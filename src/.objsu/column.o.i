# 1 "/home/jankup/SourceCpp/DatabaseExplorer/src/column.cpp"
# 1 "<built-in>"
# 1 "<command-line>"
# 1 "/home/jankup/SourceCpp/DatabaseExplorer/src/column.cpp"
# 1 "/home/jankup/SourceCpp/DatabaseExplorer/src/column.h" 1


# 1 "/usr/include/wx-2.8/wx/wx.h" 1
# 15 "/usr/include/wx-2.8/wx/wx.h"
# 1 "/usr/include/wx-2.8/wx/defs.h" 1
# 21 "/usr/include/wx-2.8/wx/defs.h"
# 1 "/usr/include/wx-2.8/wx/platform.h" 1
# 196 "/usr/include/wx-2.8/wx/platform.h"
# 1 "/usr/lib/wx/include/gtk2-unicode-release-2.8/wx/setup.h" 1
# 197 "/usr/include/wx-2.8/wx/platform.h" 2
# 293 "/usr/include/wx-2.8/wx/platform.h"
# 1 "/usr/include/wx-2.8/wx/chkconf.h" 1
# 294 "/usr/include/wx-2.8/wx/platform.h" 2
# 22 "/usr/include/wx-2.8/wx/defs.h" 2
# 63 "/usr/include/wx-2.8/wx/defs.h"
# 1 "/usr/include/wx-2.8/wx/features.h" 1
# 64 "/usr/include/wx-2.8/wx/defs.h" 2
# 134 "/usr/include/wx-2.8/wx/defs.h"
# 1 "/usr/include/wx-2.8/wx/version.h" 1
# 17 "/usr/include/wx-2.8/wx/version.h"
# 1 "/usr/include/wx-2.8/wx/cpp.h" 1
# 18 "/usr/include/wx-2.8/wx/version.h" 2
# 135 "/usr/include/wx-2.8/wx/defs.h" 2
# 237 "/usr/include/wx-2.8/wx/defs.h"
typedef short int WXTYPE;






typedef int wxWindowID;
# 490 "/usr/include/wx-2.8/wx/defs.h"
# 1 "/usr/include/wx-2.8/wx/dlimpexp.h" 1
# 491 "/usr/include/wx-2.8/wx/defs.h" 2
# 521 "/usr/include/wx-2.8/wx/defs.h"
# 1 "/usr/include/wx-2.8/wx/debug.h" 1
# 18 "/usr/include/wx-2.8/wx/debug.h"
# 1 "/usr/include/assert.h" 1 3 4
# 37 "/usr/include/assert.h" 3 4
# 1 "/usr/include/features.h" 1 3 4
# 322 "/usr/include/features.h" 3 4
# 1 "/usr/include/bits/predefs.h" 1 3 4
# 323 "/usr/include/features.h" 2 3 4
# 355 "/usr/include/features.h" 3 4
# 1 "/usr/include/sys/cdefs.h" 1 3 4
# 353 "/usr/include/sys/cdefs.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 354 "/usr/include/sys/cdefs.h" 2 3 4
# 356 "/usr/include/features.h" 2 3 4
# 387 "/usr/include/features.h" 3 4
# 1 "/usr/include/gnu/stubs.h" 1 3 4



# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 5 "/usr/include/gnu/stubs.h" 2 3 4


# 1 "/usr/include/gnu/stubs-32.h" 1 3 4
# 8 "/usr/include/gnu/stubs.h" 2 3 4
# 388 "/usr/include/features.h" 2 3 4
# 38 "/usr/include/assert.h" 2 3 4
# 19 "/usr/include/wx-2.8/wx/debug.h" 2

# 1 "/usr/lib/gcc/i686-linux-gnu/4.4.5/include-fixed/limits.h" 1 3 4
# 11 "/usr/lib/gcc/i686-linux-gnu/4.4.5/include-fixed/limits.h" 3 4
# 1 "/usr/lib/gcc/i686-linux-gnu/4.4.5/include-fixed/syslimits.h" 1 3 4






# 1 "/usr/lib/gcc/i686-linux-gnu/4.4.5/include-fixed/limits.h" 1 3 4
# 122 "/usr/lib/gcc/i686-linux-gnu/4.4.5/include-fixed/limits.h" 3 4
# 1 "/usr/include/limits.h" 1 3 4
# 145 "/usr/include/limits.h" 3 4
# 1 "/usr/include/bits/posix1_lim.h" 1 3 4
# 157 "/usr/include/bits/posix1_lim.h" 3 4
# 1 "/usr/include/bits/local_lim.h" 1 3 4
# 39 "/usr/include/bits/local_lim.h" 3 4
# 1 "/usr/include/linux/limits.h" 1 3 4
# 40 "/usr/include/bits/local_lim.h" 2 3 4
# 158 "/usr/include/bits/posix1_lim.h" 2 3 4
# 146 "/usr/include/limits.h" 2 3 4



# 1 "/usr/include/bits/posix2_lim.h" 1 3 4
# 150 "/usr/include/limits.h" 2 3 4



# 1 "/usr/include/bits/xopen_lim.h" 1 3 4
# 34 "/usr/include/bits/xopen_lim.h" 3 4
# 1 "/usr/include/bits/stdio_lim.h" 1 3 4
# 35 "/usr/include/bits/xopen_lim.h" 2 3 4
# 154 "/usr/include/limits.h" 2 3 4
# 123 "/usr/lib/gcc/i686-linux-gnu/4.4.5/include-fixed/limits.h" 2 3 4
# 8 "/usr/lib/gcc/i686-linux-gnu/4.4.5/include-fixed/syslimits.h" 2 3 4
# 12 "/usr/lib/gcc/i686-linux-gnu/4.4.5/include-fixed/limits.h" 2 3 4
# 21 "/usr/include/wx-2.8/wx/debug.h" 2

# 1 "/usr/include/wx-2.8/wx/wxchar.h" 1
# 21 "/usr/include/wx-2.8/wx/wxchar.h"
# 1 "/usr/include/stdio.h" 1 3 4
# 30 "/usr/include/stdio.h" 3 4
extern "C" {



# 1 "/usr/lib/gcc/i686-linux-gnu/4.4.5/include/stddef.h" 1 3 4
# 211 "/usr/lib/gcc/i686-linux-gnu/4.4.5/include/stddef.h" 3 4
typedef unsigned int size_t;
# 35 "/usr/include/stdio.h" 2 3 4

# 1 "/usr/include/bits/types.h" 1 3 4
# 28 "/usr/include/bits/types.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 29 "/usr/include/bits/types.h" 2 3 4


typedef unsigned char __u_char;
typedef unsigned short int __u_short;
typedef unsigned int __u_int;
typedef unsigned long int __u_long;


typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef signed short int __int16_t;
typedef unsigned short int __uint16_t;
typedef signed int __int32_t;
typedef unsigned int __uint32_t;




__extension__ typedef signed long long int __int64_t;
__extension__ typedef unsigned long long int __uint64_t;







__extension__ typedef long long int __quad_t;
__extension__ typedef unsigned long long int __u_quad_t;
# 131 "/usr/include/bits/types.h" 3 4
# 1 "/usr/include/bits/typesizes.h" 1 3 4
# 132 "/usr/include/bits/types.h" 2 3 4


__extension__ typedef __u_quad_t __dev_t;
__extension__ typedef unsigned int __uid_t;
__extension__ typedef unsigned int __gid_t;
__extension__ typedef unsigned long int __ino_t;
__extension__ typedef __u_quad_t __ino64_t;
__extension__ typedef unsigned int __mode_t;
__extension__ typedef unsigned int __nlink_t;
__extension__ typedef long int __off_t;
__extension__ typedef __quad_t __off64_t;
__extension__ typedef int __pid_t;
__extension__ typedef struct { int __val[2]; } __fsid_t;
__extension__ typedef long int __clock_t;
__extension__ typedef unsigned long int __rlim_t;
__extension__ typedef __u_quad_t __rlim64_t;
__extension__ typedef unsigned int __id_t;
__extension__ typedef long int __time_t;
__extension__ typedef unsigned int __useconds_t;
__extension__ typedef long int __suseconds_t;

__extension__ typedef int __daddr_t;
__extension__ typedef long int __swblk_t;
__extension__ typedef int __key_t;


__extension__ typedef int __clockid_t;


__extension__ typedef void * __timer_t;


__extension__ typedef long int __blksize_t;




__extension__ typedef long int __blkcnt_t;
__extension__ typedef __quad_t __blkcnt64_t;


__extension__ typedef unsigned long int __fsblkcnt_t;
__extension__ typedef __u_quad_t __fsblkcnt64_t;


__extension__ typedef unsigned long int __fsfilcnt_t;
__extension__ typedef __u_quad_t __fsfilcnt64_t;

__extension__ typedef int __ssize_t;



typedef __off64_t __loff_t;
typedef __quad_t *__qaddr_t;
typedef char *__caddr_t;


__extension__ typedef int __intptr_t;


__extension__ typedef unsigned int __socklen_t;
# 37 "/usr/include/stdio.h" 2 3 4
# 45 "/usr/include/stdio.h" 3 4
struct _IO_FILE;



typedef struct _IO_FILE FILE;





# 65 "/usr/include/stdio.h" 3 4
typedef struct _IO_FILE __FILE;
# 75 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/libio.h" 1 3 4
# 32 "/usr/include/libio.h" 3 4
# 1 "/usr/include/_G_config.h" 1 3 4
# 15 "/usr/include/_G_config.h" 3 4
# 1 "/usr/lib/gcc/i686-linux-gnu/4.4.5/include/stddef.h" 1 3 4
# 16 "/usr/include/_G_config.h" 2 3 4




# 1 "/usr/include/wchar.h" 1 3 4
# 83 "/usr/include/wchar.h" 3 4
typedef struct
{
  int __count;
  union
  {

    unsigned int __wch;



    char __wchb[4];
  } __value;
} __mbstate_t;
# 21 "/usr/include/_G_config.h" 2 3 4

typedef struct
{
  __off_t __pos;
  __mbstate_t __state;
} _G_fpos_t;
typedef struct
{
  __off64_t __pos;
  __mbstate_t __state;
} _G_fpos64_t;
# 53 "/usr/include/_G_config.h" 3 4
typedef int _G_int16_t __attribute__ ((__mode__ (__HI__)));
typedef int _G_int32_t __attribute__ ((__mode__ (__SI__)));
typedef unsigned int _G_uint16_t __attribute__ ((__mode__ (__HI__)));
typedef unsigned int _G_uint32_t __attribute__ ((__mode__ (__SI__)));
# 33 "/usr/include/libio.h" 2 3 4
# 53 "/usr/include/libio.h" 3 4
# 1 "/usr/lib/gcc/i686-linux-gnu/4.4.5/include/stdarg.h" 1 3 4
# 40 "/usr/lib/gcc/i686-linux-gnu/4.4.5/include/stdarg.h" 3 4
typedef __builtin_va_list __gnuc_va_list;
# 54 "/usr/include/libio.h" 2 3 4
# 170 "/usr/include/libio.h" 3 4
struct _IO_jump_t; struct _IO_FILE;
# 180 "/usr/include/libio.h" 3 4
typedef void _IO_lock_t;





struct _IO_marker {
  struct _IO_marker *_next;
  struct _IO_FILE *_sbuf;



  int _pos;
# 203 "/usr/include/libio.h" 3 4
};


enum __codecvt_result
{
  __codecvt_ok,
  __codecvt_partial,
  __codecvt_error,
  __codecvt_noconv
};
# 271 "/usr/include/libio.h" 3 4
struct _IO_FILE {
  int _flags;




  char* _IO_read_ptr;
  char* _IO_read_end;
  char* _IO_read_base;
  char* _IO_write_base;
  char* _IO_write_ptr;
  char* _IO_write_end;
  char* _IO_buf_base;
  char* _IO_buf_end;

  char *_IO_save_base;
  char *_IO_backup_base;
  char *_IO_save_end;

  struct _IO_marker *_markers;

  struct _IO_FILE *_chain;

  int _fileno;



  int _flags2;

  __off_t _old_offset;



  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];



  _IO_lock_t *_lock;
# 319 "/usr/include/libio.h" 3 4
  __off64_t _offset;
# 328 "/usr/include/libio.h" 3 4
  void *__pad1;
  void *__pad2;
  void *__pad3;
  void *__pad4;
  size_t __pad5;

  int _mode;

  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];

};





struct _IO_FILE_plus;

extern struct _IO_FILE_plus _IO_2_1_stdin_;
extern struct _IO_FILE_plus _IO_2_1_stdout_;
extern struct _IO_FILE_plus _IO_2_1_stderr_;
# 364 "/usr/include/libio.h" 3 4
typedef __ssize_t __io_read_fn (void *__cookie, char *__buf, size_t __nbytes);







typedef __ssize_t __io_write_fn (void *__cookie, __const char *__buf,
     size_t __n);







typedef int __io_seek_fn (void *__cookie, __off64_t *__pos, int __w);


typedef int __io_close_fn (void *__cookie);




typedef __io_read_fn cookie_read_function_t;
typedef __io_write_fn cookie_write_function_t;
typedef __io_seek_fn cookie_seek_function_t;
typedef __io_close_fn cookie_close_function_t;


typedef struct
{
  __io_read_fn *read;
  __io_write_fn *write;
  __io_seek_fn *seek;
  __io_close_fn *close;
} _IO_cookie_io_functions_t;
typedef _IO_cookie_io_functions_t cookie_io_functions_t;

struct _IO_cookie_file;


extern void _IO_cookie_init (struct _IO_cookie_file *__cfile, int __read_write,
        void *__cookie, _IO_cookie_io_functions_t __fns);




extern "C" {


extern int __underflow (_IO_FILE *);
extern int __uflow (_IO_FILE *);
extern int __overflow (_IO_FILE *, int);
# 460 "/usr/include/libio.h" 3 4
extern int _IO_getc (_IO_FILE *__fp);
extern int _IO_putc (int __c, _IO_FILE *__fp);
extern int _IO_feof (_IO_FILE *__fp) throw ();
extern int _IO_ferror (_IO_FILE *__fp) throw ();

extern int _IO_peekc_locked (_IO_FILE *__fp);





extern void _IO_flockfile (_IO_FILE *) throw ();
extern void _IO_funlockfile (_IO_FILE *) throw ();
extern int _IO_ftrylockfile (_IO_FILE *) throw ();
# 490 "/usr/include/libio.h" 3 4
extern int _IO_vfscanf (_IO_FILE * __restrict, const char * __restrict,
   __gnuc_va_list, int *__restrict);
extern int _IO_vfprintf (_IO_FILE *__restrict, const char *__restrict,
    __gnuc_va_list);
extern __ssize_t _IO_padn (_IO_FILE *, int, __ssize_t);
extern size_t _IO_sgetn (_IO_FILE *, void *, size_t);

extern __off64_t _IO_seekoff (_IO_FILE *, __off64_t, int, int);
extern __off64_t _IO_seekpos (_IO_FILE *, __off64_t, int);

extern void _IO_free_backup_area (_IO_FILE *) throw ();
# 552 "/usr/include/libio.h" 3 4
}
# 76 "/usr/include/stdio.h" 2 3 4




typedef __gnuc_va_list va_list;
# 93 "/usr/include/stdio.h" 3 4
typedef __off64_t off_t;




typedef __off64_t off64_t;




typedef __ssize_t ssize_t;









typedef _G_fpos64_t fpos_t;



typedef _G_fpos64_t fpos64_t;
# 161 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/bits/stdio_lim.h" 1 3 4
# 162 "/usr/include/stdio.h" 2 3 4



extern struct _IO_FILE *stdin;
extern struct _IO_FILE *stdout;
extern struct _IO_FILE *stderr;







extern int remove (__const char *__filename) throw ();

extern int rename (__const char *__old, __const char *__new) throw ();




extern int renameat (int __oldfd, __const char *__old, int __newfd,
       __const char *__new) throw ();



# 195 "/usr/include/stdio.h" 3 4
extern FILE *tmpfile (void) __asm__ ("" "tmpfile64") __attribute__ ((__warn_unused_result__));






extern FILE *tmpfile64 (void) __attribute__ ((__warn_unused_result__));



extern char *tmpnam (char *__s) throw () __attribute__ ((__warn_unused_result__));





extern char *tmpnam_r (char *__s) throw () __attribute__ ((__warn_unused_result__));
# 224 "/usr/include/stdio.h" 3 4
extern char *tempnam (__const char *__dir, __const char *__pfx)
     throw () __attribute__ ((__malloc__)) __attribute__ ((__warn_unused_result__));








extern int fclose (FILE *__stream);




extern int fflush (FILE *__stream);

# 249 "/usr/include/stdio.h" 3 4
extern int fflush_unlocked (FILE *__stream);
# 259 "/usr/include/stdio.h" 3 4
extern int fcloseall (void);




# 280 "/usr/include/stdio.h" 3 4
extern FILE *fopen (__const char *__restrict __filename, __const char *__restrict __modes) __asm__ ("" "fopen64")

  __attribute__ ((__warn_unused_result__));
extern FILE *freopen (__const char *__restrict __filename, __const char *__restrict __modes, FILE *__restrict __stream) __asm__ ("" "freopen64")


  __attribute__ ((__warn_unused_result__));







extern FILE *fopen64 (__const char *__restrict __filename,
        __const char *__restrict __modes) __attribute__ ((__warn_unused_result__));
extern FILE *freopen64 (__const char *__restrict __filename,
   __const char *__restrict __modes,
   FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));




extern FILE *fdopen (int __fd, __const char *__modes) throw () __attribute__ ((__warn_unused_result__));





extern FILE *fopencookie (void *__restrict __magic_cookie,
     __const char *__restrict __modes,
     _IO_cookie_io_functions_t __io_funcs) throw () __attribute__ ((__warn_unused_result__));




extern FILE *fmemopen (void *__s, size_t __len, __const char *__modes)
  throw () __attribute__ ((__warn_unused_result__));




extern FILE *open_memstream (char **__bufloc, size_t *__sizeloc) throw () __attribute__ ((__warn_unused_result__));






extern void setbuf (FILE *__restrict __stream, char *__restrict __buf) throw ();



extern int setvbuf (FILE *__restrict __stream, char *__restrict __buf,
      int __modes, size_t __n) throw ();





extern void setbuffer (FILE *__restrict __stream, char *__restrict __buf,
         size_t __size) throw ();


extern void setlinebuf (FILE *__stream) throw ();








extern int fprintf (FILE *__restrict __stream,
      __const char *__restrict __format, ...);




extern int printf (__const char *__restrict __format, ...);

extern int sprintf (char *__restrict __s,
      __const char *__restrict __format, ...) throw ();





extern int vfprintf (FILE *__restrict __s, __const char *__restrict __format,
       __gnuc_va_list __arg);




extern int vprintf (__const char *__restrict __format, __gnuc_va_list __arg);

extern int vsprintf (char *__restrict __s, __const char *__restrict __format,
       __gnuc_va_list __arg) throw ();





extern int snprintf (char *__restrict __s, size_t __maxlen,
       __const char *__restrict __format, ...)
     throw () __attribute__ ((__format__ (__printf__, 3, 4)));

extern int vsnprintf (char *__restrict __s, size_t __maxlen,
        __const char *__restrict __format, __gnuc_va_list __arg)
     throw () __attribute__ ((__format__ (__printf__, 3, 0)));






extern int vasprintf (char **__restrict __ptr, __const char *__restrict __f,
        __gnuc_va_list __arg)
     throw () __attribute__ ((__format__ (__printf__, 2, 0))) __attribute__ ((__warn_unused_result__));
extern int __asprintf (char **__restrict __ptr,
         __const char *__restrict __fmt, ...)
     throw () __attribute__ ((__format__ (__printf__, 2, 3))) __attribute__ ((__warn_unused_result__));
extern int asprintf (char **__restrict __ptr,
       __const char *__restrict __fmt, ...)
     throw () __attribute__ ((__format__ (__printf__, 2, 3))) __attribute__ ((__warn_unused_result__));
# 414 "/usr/include/stdio.h" 3 4
extern int vdprintf (int __fd, __const char *__restrict __fmt,
       __gnuc_va_list __arg)
     __attribute__ ((__format__ (__printf__, 2, 0)));
extern int dprintf (int __fd, __const char *__restrict __fmt, ...)
     __attribute__ ((__format__ (__printf__, 2, 3)));








extern int fscanf (FILE *__restrict __stream,
     __const char *__restrict __format, ...) __attribute__ ((__warn_unused_result__));




extern int scanf (__const char *__restrict __format, ...) __attribute__ ((__warn_unused_result__));

extern int sscanf (__const char *__restrict __s,
     __const char *__restrict __format, ...) throw ();
# 465 "/usr/include/stdio.h" 3 4








extern int vfscanf (FILE *__restrict __s, __const char *__restrict __format,
      __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 2, 0))) __attribute__ ((__warn_unused_result__));





extern int vscanf (__const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 1, 0))) __attribute__ ((__warn_unused_result__));


extern int vsscanf (__const char *__restrict __s,
      __const char *__restrict __format, __gnuc_va_list __arg)
     throw () __attribute__ ((__format__ (__scanf__, 2, 0)));
# 524 "/usr/include/stdio.h" 3 4









extern int fgetc (FILE *__stream);
extern int getc (FILE *__stream);





extern int getchar (void);

# 552 "/usr/include/stdio.h" 3 4
extern int getc_unlocked (FILE *__stream);
extern int getchar_unlocked (void);
# 563 "/usr/include/stdio.h" 3 4
extern int fgetc_unlocked (FILE *__stream);











extern int fputc (int __c, FILE *__stream);
extern int putc (int __c, FILE *__stream);





extern int putchar (int __c);

# 596 "/usr/include/stdio.h" 3 4
extern int fputc_unlocked (int __c, FILE *__stream);







extern int putc_unlocked (int __c, FILE *__stream);
extern int putchar_unlocked (int __c);






extern int getw (FILE *__stream);


extern int putw (int __w, FILE *__stream);








extern char *fgets (char *__restrict __s, int __n, FILE *__restrict __stream)
     __attribute__ ((__warn_unused_result__));






extern char *gets (char *__s) __attribute__ ((__warn_unused_result__));

# 642 "/usr/include/stdio.h" 3 4
extern char *fgets_unlocked (char *__restrict __s, int __n,
        FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));
# 658 "/usr/include/stdio.h" 3 4
extern __ssize_t __getdelim (char **__restrict __lineptr,
          size_t *__restrict __n, int __delimiter,
          FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));
extern __ssize_t getdelim (char **__restrict __lineptr,
        size_t *__restrict __n, int __delimiter,
        FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));







extern __ssize_t getline (char **__restrict __lineptr,
       size_t *__restrict __n,
       FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));








extern int fputs (__const char *__restrict __s, FILE *__restrict __stream);





extern int puts (__const char *__s);






extern int ungetc (int __c, FILE *__stream);






extern size_t fread (void *__restrict __ptr, size_t __size,
       size_t __n, FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));




extern size_t fwrite (__const void *__restrict __ptr, size_t __size,
        size_t __n, FILE *__restrict __s);

# 719 "/usr/include/stdio.h" 3 4
extern int fputs_unlocked (__const char *__restrict __s,
      FILE *__restrict __stream);
# 730 "/usr/include/stdio.h" 3 4
extern size_t fread_unlocked (void *__restrict __ptr, size_t __size,
         size_t __n, FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));
extern size_t fwrite_unlocked (__const void *__restrict __ptr, size_t __size,
          size_t __n, FILE *__restrict __stream);








extern int fseek (FILE *__stream, long int __off, int __whence);




extern long int ftell (FILE *__stream) __attribute__ ((__warn_unused_result__));




extern void rewind (FILE *__stream);

# 774 "/usr/include/stdio.h" 3 4
extern int fseeko (FILE *__stream, __off64_t __off, int __whence) __asm__ ("" "fseeko64");


extern __off64_t ftello (FILE *__stream) __asm__ ("" "ftello64");








# 799 "/usr/include/stdio.h" 3 4
extern int fgetpos (FILE *__restrict __stream, fpos_t *__restrict __pos) __asm__ ("" "fgetpos64");

extern int fsetpos (FILE *__stream, __const fpos_t *__pos) __asm__ ("" "fsetpos64");









extern int fseeko64 (FILE *__stream, __off64_t __off, int __whence);
extern __off64_t ftello64 (FILE *__stream) __attribute__ ((__warn_unused_result__));
extern int fgetpos64 (FILE *__restrict __stream, fpos64_t *__restrict __pos);
extern int fsetpos64 (FILE *__stream, __const fpos64_t *__pos);




extern void clearerr (FILE *__stream) throw ();

extern int feof (FILE *__stream) throw () __attribute__ ((__warn_unused_result__));

extern int ferror (FILE *__stream) throw () __attribute__ ((__warn_unused_result__));




extern void clearerr_unlocked (FILE *__stream) throw ();
extern int feof_unlocked (FILE *__stream) throw () __attribute__ ((__warn_unused_result__));
extern int ferror_unlocked (FILE *__stream) throw () __attribute__ ((__warn_unused_result__));








extern void perror (__const char *__s);






# 1 "/usr/include/bits/sys_errlist.h" 1 3 4
# 27 "/usr/include/bits/sys_errlist.h" 3 4
extern int sys_nerr;
extern __const char *__const sys_errlist[];


extern int _sys_nerr;
extern __const char *__const _sys_errlist[];
# 847 "/usr/include/stdio.h" 2 3 4




extern int fileno (FILE *__stream) throw () __attribute__ ((__warn_unused_result__));




extern int fileno_unlocked (FILE *__stream) throw () __attribute__ ((__warn_unused_result__));
# 866 "/usr/include/stdio.h" 3 4
extern FILE *popen (__const char *__command, __const char *__modes) __attribute__ ((__warn_unused_result__));





extern int pclose (FILE *__stream);





extern char *ctermid (char *__s) throw ();





extern char *cuserid (char *__s);




struct obstack;


extern int obstack_printf (struct obstack *__restrict __obstack,
      __const char *__restrict __format, ...)
     throw () __attribute__ ((__format__ (__printf__, 2, 3)));
extern int obstack_vprintf (struct obstack *__restrict __obstack,
       __const char *__restrict __format,
       __gnuc_va_list __args)
     throw () __attribute__ ((__format__ (__printf__, 2, 0)));







extern void flockfile (FILE *__stream) throw ();



extern int ftrylockfile (FILE *__stream) throw () __attribute__ ((__warn_unused_result__));


extern void funlockfile (FILE *__stream) throw ();
# 927 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/bits/stdio.h" 1 3 4
# 44 "/usr/include/bits/stdio.h" 3 4
extern __inline __attribute__ ((__gnu_inline__)) int
getchar (void)
{
  return _IO_getc (stdin);
}




extern __inline __attribute__ ((__gnu_inline__)) int
fgetc_unlocked (FILE *__fp)
{
  return (__builtin_expect (((__fp)->_IO_read_ptr >= (__fp)->_IO_read_end), 0) ? __uflow (__fp) : *(unsigned char *) (__fp)->_IO_read_ptr++);
}





extern __inline __attribute__ ((__gnu_inline__)) int
getc_unlocked (FILE *__fp)
{
  return (__builtin_expect (((__fp)->_IO_read_ptr >= (__fp)->_IO_read_end), 0) ? __uflow (__fp) : *(unsigned char *) (__fp)->_IO_read_ptr++);
}


extern __inline __attribute__ ((__gnu_inline__)) int
getchar_unlocked (void)
{
  return (__builtin_expect (((stdin)->_IO_read_ptr >= (stdin)->_IO_read_end), 0) ? __uflow (stdin) : *(unsigned char *) (stdin)->_IO_read_ptr++);
}




extern __inline __attribute__ ((__gnu_inline__)) int
putchar (int __c)
{
  return _IO_putc (__c, stdout);
}




extern __inline __attribute__ ((__gnu_inline__)) int
fputc_unlocked (int __c, FILE *__stream)
{
  return (__builtin_expect (((__stream)->_IO_write_ptr >= (__stream)->_IO_write_end), 0) ? __overflow (__stream, (unsigned char) (__c)) : (unsigned char) (*(__stream)->_IO_write_ptr++ = (__c)));
}





extern __inline __attribute__ ((__gnu_inline__)) int
putc_unlocked (int __c, FILE *__stream)
{
  return (__builtin_expect (((__stream)->_IO_write_ptr >= (__stream)->_IO_write_end), 0) ? __overflow (__stream, (unsigned char) (__c)) : (unsigned char) (*(__stream)->_IO_write_ptr++ = (__c)));
}


extern __inline __attribute__ ((__gnu_inline__)) int
putchar_unlocked (int __c)
{
  return (__builtin_expect (((stdout)->_IO_write_ptr >= (stdout)->_IO_write_end), 0) ? __overflow (stdout, (unsigned char) (__c)) : (unsigned char) (*(stdout)->_IO_write_ptr++ = (__c)));
}





extern __inline __attribute__ ((__gnu_inline__)) __ssize_t
getline (char **__lineptr, size_t *__n, FILE *__stream)
{
  return __getdelim (__lineptr, __n, '\n', __stream);
}





extern __inline __attribute__ ((__gnu_inline__)) int
feof_unlocked (FILE *__stream) throw ()
{
  return (((__stream)->_flags & 0x10) != 0);
}


extern __inline __attribute__ ((__gnu_inline__)) int
ferror_unlocked (FILE *__stream) throw ()
{
  return (((__stream)->_flags & 0x20) != 0);
}
# 928 "/usr/include/stdio.h" 2 3 4


# 1 "/usr/include/bits/stdio2.h" 1 3 4
# 24 "/usr/include/bits/stdio2.h" 3 4
extern int __sprintf_chk (char *__restrict __s, int __flag, size_t __slen,
     __const char *__restrict __format, ...) throw ();
extern int __vsprintf_chk (char *__restrict __s, int __flag, size_t __slen,
      __const char *__restrict __format,
      __gnuc_va_list __ap) throw ();


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) int
sprintf (char *__restrict __s, __const char *__restrict __fmt, ...) throw ()
{
  return __builtin___sprintf_chk (__s, 2 - 1,
      __builtin_object_size (__s, 2 > 1), __fmt, __builtin_va_arg_pack ());
}






extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) int
vsprintf (char *__restrict __s, __const char *__restrict __fmt, __gnuc_va_list __ap) throw ()

{
  return __builtin___vsprintf_chk (__s, 2 - 1,
       __builtin_object_size (__s, 2 > 1), __fmt, __ap);
}



extern int __snprintf_chk (char *__restrict __s, size_t __n, int __flag,
      size_t __slen, __const char *__restrict __format,
      ...) throw ();
extern int __vsnprintf_chk (char *__restrict __s, size_t __n, int __flag,
       size_t __slen, __const char *__restrict __format,
       __gnuc_va_list __ap) throw ();


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) int
snprintf (char *__restrict __s, size_t __n, __const char *__restrict __fmt, ...) throw ()

{
  return __builtin___snprintf_chk (__s, __n, 2 - 1,
       __builtin_object_size (__s, 2 > 1), __fmt, __builtin_va_arg_pack ());
}






extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) int
vsnprintf (char *__restrict __s, size_t __n, __const char *__restrict __fmt, __gnuc_va_list __ap) throw ()

{
  return __builtin___vsnprintf_chk (__s, __n, 2 - 1,
        __builtin_object_size (__s, 2 > 1), __fmt, __ap);
}





extern int __fprintf_chk (FILE *__restrict __stream, int __flag,
     __const char *__restrict __format, ...);
extern int __printf_chk (int __flag, __const char *__restrict __format, ...);
extern int __vfprintf_chk (FILE *__restrict __stream, int __flag,
      __const char *__restrict __format, __gnuc_va_list __ap);
extern int __vprintf_chk (int __flag, __const char *__restrict __format,
     __gnuc_va_list __ap);


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) int
fprintf (FILE *__restrict __stream, __const char *__restrict __fmt, ...)
{
  return __fprintf_chk (__stream, 2 - 1, __fmt,
   __builtin_va_arg_pack ());
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) int
printf (__const char *__restrict __fmt, ...)
{
  return __printf_chk (2 - 1, __fmt, __builtin_va_arg_pack ());
}







extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) int
vprintf (__const char *__restrict __fmt, __gnuc_va_list __ap)
{

  return __vfprintf_chk (stdout, 2 - 1, __fmt, __ap);



}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) int
vfprintf (FILE *__restrict __stream,
   __const char *__restrict __fmt, __gnuc_va_list __ap)
{
  return __vfprintf_chk (__stream, 2 - 1, __fmt, __ap);
}



extern int __asprintf_chk (char **__restrict __ptr, int __flag,
      __const char *__restrict __fmt, ...)
     throw () __attribute__ ((__format__ (__printf__, 3, 4))) __attribute__ ((__warn_unused_result__));
extern int __vasprintf_chk (char **__restrict __ptr, int __flag,
       __const char *__restrict __fmt, __gnuc_va_list __arg)
     throw () __attribute__ ((__format__ (__printf__, 3, 0))) __attribute__ ((__warn_unused_result__));
extern int __dprintf_chk (int __fd, int __flag, __const char *__restrict __fmt,
     ...) __attribute__ ((__format__ (__printf__, 3, 4)));
extern int __vdprintf_chk (int __fd, int __flag,
      __const char *__restrict __fmt, __gnuc_va_list __arg)
     __attribute__ ((__format__ (__printf__, 3, 0)));
extern int __obstack_printf_chk (struct obstack *__restrict __obstack,
     int __flag, __const char *__restrict __format,
     ...)
     throw () __attribute__ ((__format__ (__printf__, 3, 4)));
extern int __obstack_vprintf_chk (struct obstack *__restrict __obstack,
      int __flag,
      __const char *__restrict __format,
      __gnuc_va_list __args)
     throw () __attribute__ ((__format__ (__printf__, 3, 0)));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) int
asprintf (char **__restrict __ptr, __const char *__restrict __fmt, ...) throw ()
{
  return __asprintf_chk (__ptr, 2 - 1, __fmt,
    __builtin_va_arg_pack ());
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) int
__asprintf (char **__restrict __ptr, __const char *__restrict __fmt, ...) throw ()

{
  return __asprintf_chk (__ptr, 2 - 1, __fmt,
    __builtin_va_arg_pack ());
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) int
dprintf (int __fd, __const char *__restrict __fmt, ...)
{
  return __dprintf_chk (__fd, 2 - 1, __fmt,
   __builtin_va_arg_pack ());
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) int
obstack_printf (struct obstack *__restrict __obstack, __const char *__restrict __fmt, ...) throw ()

{
  return __obstack_printf_chk (__obstack, 2 - 1, __fmt,
          __builtin_va_arg_pack ());
}
# 195 "/usr/include/bits/stdio2.h" 3 4
extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) int
vasprintf (char **__restrict __ptr, __const char *__restrict __fmt, __gnuc_va_list __ap) throw ()

{
  return __vasprintf_chk (__ptr, 2 - 1, __fmt, __ap);
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) int
vdprintf (int __fd, __const char *__restrict __fmt, __gnuc_va_list __ap)
{
  return __vdprintf_chk (__fd, 2 - 1, __fmt, __ap);
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) int
obstack_vprintf (struct obstack *__restrict __obstack, __const char *__restrict __fmt, __gnuc_va_list __ap) throw ()

{
  return __obstack_vprintf_chk (__obstack, 2 - 1, __fmt,
    __ap);
}





extern char *__gets_chk (char *__str, size_t) __attribute__ ((__warn_unused_result__));
extern char *__gets_warn (char *__str) __asm__ ("" "gets")
     __attribute__ ((__warn_unused_result__)) __attribute__((__warning__ ("please use fgets or getline instead, gets can't " "specify buffer size")));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) __attribute__ ((__warn_unused_result__)) char *
gets (char *__str)
{
  if (__builtin_object_size (__str, 2 > 1) != (size_t) -1)
    return __gets_chk (__str, __builtin_object_size (__str, 2 > 1));
  return __gets_warn (__str);
}

extern char *__fgets_chk (char *__restrict __s, size_t __size, int __n,
     FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));
extern char *__fgets_alias (char *__restrict __s, int __n, FILE *__restrict __stream) __asm__ ("" "fgets") __attribute__ ((__warn_unused_result__));


extern char *__fgets_chk_warn (char *__restrict __s, size_t __size, int __n, FILE *__restrict __stream) __asm__ ("" "__fgets_chk")


     __attribute__ ((__warn_unused_result__)) __attribute__((__warning__ ("fgets called with bigger size than length " "of destination buffer")));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) __attribute__ ((__warn_unused_result__)) char *
fgets (char *__restrict __s, int __n, FILE *__restrict __stream)
{
  if (__builtin_object_size (__s, 2 > 1) != (size_t) -1)
    {
      if (!__builtin_constant_p (__n) || __n <= 0)
 return __fgets_chk (__s, __builtin_object_size (__s, 2 > 1), __n, __stream);

      if ((size_t) __n > __builtin_object_size (__s, 2 > 1))
 return __fgets_chk_warn (__s, __builtin_object_size (__s, 2 > 1), __n, __stream);
    }
  return __fgets_alias (__s, __n, __stream);
}

extern size_t __fread_chk (void *__restrict __ptr, size_t __ptrlen,
      size_t __size, size_t __n,
      FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));
extern size_t __fread_alias (void *__restrict __ptr, size_t __size, size_t __n, FILE *__restrict __stream) __asm__ ("" "fread") __attribute__ ((__warn_unused_result__));



extern size_t __fread_chk_warn (void *__restrict __ptr, size_t __ptrlen, size_t __size, size_t __n, FILE *__restrict __stream) __asm__ ("" "__fread_chk")




     __attribute__ ((__warn_unused_result__)) __attribute__((__warning__ ("fread called with bigger size * nmemb than length " "of destination buffer")));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) __attribute__ ((__warn_unused_result__)) size_t
fread (void *__restrict __ptr, size_t __size, size_t __n,
       FILE *__restrict __stream)
{
  if (__builtin_object_size (__ptr, 0) != (size_t) -1)
    {
      if (!__builtin_constant_p (__size)
   || !__builtin_constant_p (__n)
   || (__size | __n) >= (((size_t) 1) << (8 * sizeof (size_t) / 2)))
 return __fread_chk (__ptr, __builtin_object_size (__ptr, 0), __size, __n, __stream);

      if (__size * __n > __builtin_object_size (__ptr, 0))
 return __fread_chk_warn (__ptr, __builtin_object_size (__ptr, 0), __size, __n, __stream);
    }
  return __fread_alias (__ptr, __size, __n, __stream);
}


extern char *__fgets_unlocked_chk (char *__restrict __s, size_t __size,
       int __n, FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));
extern char *__fgets_unlocked_alias (char *__restrict __s, int __n, FILE *__restrict __stream) __asm__ ("" "fgets_unlocked") __attribute__ ((__warn_unused_result__));


extern char *__fgets_unlocked_chk_warn (char *__restrict __s, size_t __size, int __n, FILE *__restrict __stream) __asm__ ("" "__fgets_unlocked_chk")


     __attribute__ ((__warn_unused_result__)) __attribute__((__warning__ ("fgets_unlocked called with bigger size than length " "of destination buffer")));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) __attribute__ ((__warn_unused_result__)) char *
fgets_unlocked (char *__restrict __s, int __n, FILE *__restrict __stream)
{
  if (__builtin_object_size (__s, 2 > 1) != (size_t) -1)
    {
      if (!__builtin_constant_p (__n) || __n <= 0)
 return __fgets_unlocked_chk (__s, __builtin_object_size (__s, 2 > 1), __n, __stream);

      if ((size_t) __n > __builtin_object_size (__s, 2 > 1))
 return __fgets_unlocked_chk_warn (__s, __builtin_object_size (__s, 2 > 1), __n, __stream);
    }
  return __fgets_unlocked_alias (__s, __n, __stream);
}




extern size_t __fread_unlocked_chk (void *__restrict __ptr, size_t __ptrlen,
        size_t __size, size_t __n,
        FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));
extern size_t __fread_unlocked_alias (void *__restrict __ptr, size_t __size, size_t __n, FILE *__restrict __stream) __asm__ ("" "fread_unlocked") __attribute__ ((__warn_unused_result__));



extern size_t __fread_unlocked_chk_warn (void *__restrict __ptr, size_t __ptrlen, size_t __size, size_t __n, FILE *__restrict __stream) __asm__ ("" "__fread_unlocked_chk")




     __attribute__ ((__warn_unused_result__)) __attribute__((__warning__ ("fread_unlocked called with bigger size * nmemb than " "length of destination buffer")));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) __attribute__ ((__warn_unused_result__)) size_t
fread_unlocked (void *__restrict __ptr, size_t __size, size_t __n,
  FILE *__restrict __stream)
{
  if (__builtin_object_size (__ptr, 0) != (size_t) -1)
    {
      if (!__builtin_constant_p (__size)
   || !__builtin_constant_p (__n)
   || (__size | __n) >= (((size_t) 1) << (8 * sizeof (size_t) / 2)))
 return __fread_unlocked_chk (__ptr, __builtin_object_size (__ptr, 0), __size, __n,
         __stream);

      if (__size * __n > __builtin_object_size (__ptr, 0))
 return __fread_unlocked_chk_warn (__ptr, __builtin_object_size (__ptr, 0), __size, __n,
       __stream);
    }


  if (__builtin_constant_p (__size)
      && __builtin_constant_p (__n)
      && (__size | __n) < (((size_t) 1) << (8 * sizeof (size_t) / 2))
      && __size * __n <= 8)
    {
      size_t __cnt = __size * __n;
      char *__cptr = (char *) __ptr;
      if (__cnt == 0)
 return 0;

      for (; __cnt > 0; --__cnt)
 {
   int __c = (__builtin_expect (((__stream)->_IO_read_ptr >= (__stream)->_IO_read_end), 0) ? __uflow (__stream) : *(unsigned char *) (__stream)->_IO_read_ptr++);
   if (__c == (-1))
     break;
   *__cptr++ = __c;
 }
      return (__cptr - (char *) __ptr) / __size;
    }

  return __fread_unlocked_alias (__ptr, __size, __n, __stream);
}
# 931 "/usr/include/stdio.h" 2 3 4





}
# 22 "/usr/include/wx-2.8/wx/wxchar.h" 2
# 60 "/usr/include/wx-2.8/wx/wxchar.h"
# 1 "/usr/lib/gcc/i686-linux-gnu/4.4.5/include/stdarg.h" 1 3 4
# 61 "/usr/include/wx-2.8/wx/wxchar.h" 2
# 101 "/usr/include/wx-2.8/wx/wxchar.h"
# 1 "/usr/include/wchar.h" 1 3 4
# 42 "/usr/include/wchar.h" 3 4
# 1 "/usr/include/bits/wchar.h" 1 3 4
# 43 "/usr/include/wchar.h" 2 3 4
# 52 "/usr/include/wchar.h" 3 4
# 1 "/usr/lib/gcc/i686-linux-gnu/4.4.5/include/stddef.h" 1 3 4
# 352 "/usr/lib/gcc/i686-linux-gnu/4.4.5/include/stddef.h" 3 4
typedef unsigned int wint_t;
# 53 "/usr/include/wchar.h" 2 3 4
# 104 "/usr/include/wchar.h" 3 4


typedef __mbstate_t mbstate_t;



# 129 "/usr/include/wchar.h" 3 4
extern "C" {




struct tm;









extern wchar_t *wcscpy (wchar_t *__restrict __dest,
   __const wchar_t *__restrict __src) throw ();

extern wchar_t *wcsncpy (wchar_t *__restrict __dest,
    __const wchar_t *__restrict __src, size_t __n)
     throw ();


extern wchar_t *wcscat (wchar_t *__restrict __dest,
   __const wchar_t *__restrict __src) throw ();

extern wchar_t *wcsncat (wchar_t *__restrict __dest,
    __const wchar_t *__restrict __src, size_t __n)
     throw ();


extern int wcscmp (__const wchar_t *__s1, __const wchar_t *__s2)
     throw () __attribute__ ((__pure__));

extern int wcsncmp (__const wchar_t *__s1, __const wchar_t *__s2, size_t __n)
     throw () __attribute__ ((__pure__));




extern int wcscasecmp (__const wchar_t *__s1, __const wchar_t *__s2) throw ();


extern int wcsncasecmp (__const wchar_t *__s1, __const wchar_t *__s2,
   size_t __n) throw ();



# 1 "/usr/include/xlocale.h" 1 3 4
# 28 "/usr/include/xlocale.h" 3 4
typedef struct __locale_struct
{

  struct __locale_data *__locales[13];


  const unsigned short int *__ctype_b;
  const int *__ctype_tolower;
  const int *__ctype_toupper;


  const char *__names[13];
} *__locale_t;


typedef __locale_t locale_t;
# 178 "/usr/include/wchar.h" 2 3 4

extern int wcscasecmp_l (__const wchar_t *__s1, __const wchar_t *__s2,
    __locale_t __loc) throw ();

extern int wcsncasecmp_l (__const wchar_t *__s1, __const wchar_t *__s2,
     size_t __n, __locale_t __loc) throw ();





extern int wcscoll (__const wchar_t *__s1, __const wchar_t *__s2) throw ();



extern size_t wcsxfrm (wchar_t *__restrict __s1,
         __const wchar_t *__restrict __s2, size_t __n) throw ();








extern int wcscoll_l (__const wchar_t *__s1, __const wchar_t *__s2,
        __locale_t __loc) throw ();




extern size_t wcsxfrm_l (wchar_t *__s1, __const wchar_t *__s2,
    size_t __n, __locale_t __loc) throw ();


extern wchar_t *wcsdup (__const wchar_t *__s) throw () __attribute__ ((__malloc__));





extern "C++" wchar_t *wcschr (wchar_t *__wcs, wchar_t __wc)
     throw () __asm ("wcschr") __attribute__ ((__pure__));
extern "C++" __const wchar_t *wcschr (__const wchar_t *__wcs, wchar_t __wc)
     throw () __asm ("wcschr") __attribute__ ((__pure__));






extern "C++" wchar_t *wcsrchr (wchar_t *__wcs, wchar_t __wc)
     throw () __asm ("wcsrchr") __attribute__ ((__pure__));
extern "C++" __const wchar_t *wcsrchr (__const wchar_t *__wcs, wchar_t __wc)
     throw () __asm ("wcsrchr") __attribute__ ((__pure__));









extern wchar_t *wcschrnul (__const wchar_t *__s, wchar_t __wc)
     throw () __attribute__ ((__pure__));





extern size_t wcscspn (__const wchar_t *__wcs, __const wchar_t *__reject)
     throw () __attribute__ ((__pure__));


extern size_t wcsspn (__const wchar_t *__wcs, __const wchar_t *__accept)
     throw () __attribute__ ((__pure__));


extern "C++" wchar_t *wcspbrk (wchar_t *__wcs, __const wchar_t *__accept)
     throw () __asm ("wcspbrk") __attribute__ ((__pure__));
extern "C++" __const wchar_t *wcspbrk (__const wchar_t *__wcs,
           __const wchar_t *__accept)
     throw () __asm ("wcspbrk") __attribute__ ((__pure__));






extern "C++" wchar_t *wcsstr (wchar_t *__haystack, __const wchar_t *__needle)
     throw () __asm ("wcsstr") __attribute__ ((__pure__));
extern "C++" __const wchar_t *wcsstr (__const wchar_t *__haystack,
          __const wchar_t *__needle)
     throw () __asm ("wcsstr") __attribute__ ((__pure__));






extern wchar_t *wcstok (wchar_t *__restrict __s,
   __const wchar_t *__restrict __delim,
   wchar_t **__restrict __ptr) throw ();


extern size_t wcslen (__const wchar_t *__s) throw () __attribute__ ((__pure__));





extern "C++" wchar_t *wcswcs (wchar_t *__haystack, __const wchar_t *__needle)
     throw () __asm ("wcswcs") __attribute__ ((__pure__));
extern "C++" __const wchar_t *wcswcs (__const wchar_t *__haystack,
          __const wchar_t *__needle)
     throw () __asm ("wcswcs") __attribute__ ((__pure__));
# 303 "/usr/include/wchar.h" 3 4
extern size_t wcsnlen (__const wchar_t *__s, size_t __maxlen)
     throw () __attribute__ ((__pure__));






extern "C++" wchar_t *wmemchr (wchar_t *__s, wchar_t __c, size_t __n)
     throw () __asm ("wmemchr") __attribute__ ((__pure__));
extern "C++" __const wchar_t *wmemchr (__const wchar_t *__s, wchar_t __c,
           size_t __n)
     throw () __asm ("wmemchr") __attribute__ ((__pure__));






extern int wmemcmp (__const wchar_t *__restrict __s1,
      __const wchar_t *__restrict __s2, size_t __n)
     throw () __attribute__ ((__pure__));


extern wchar_t *wmemcpy (wchar_t *__restrict __s1,
    __const wchar_t *__restrict __s2, size_t __n) throw ();



extern wchar_t *wmemmove (wchar_t *__s1, __const wchar_t *__s2, size_t __n)
     throw ();


extern wchar_t *wmemset (wchar_t *__s, wchar_t __c, size_t __n) throw ();





extern wchar_t *wmempcpy (wchar_t *__restrict __s1,
     __const wchar_t *__restrict __s2, size_t __n)
     throw ();






extern wint_t btowc (int __c) throw ();



extern int wctob (wint_t __c) throw ();



extern int mbsinit (__const mbstate_t *__ps) throw () __attribute__ ((__pure__));



extern size_t mbrtowc (wchar_t *__restrict __pwc,
         __const char *__restrict __s, size_t __n,
         mbstate_t *__p) throw ();


extern size_t wcrtomb (char *__restrict __s, wchar_t __wc,
         mbstate_t *__restrict __ps) throw ();


extern size_t __mbrlen (__const char *__restrict __s, size_t __n,
   mbstate_t *__restrict __ps) throw ();
extern size_t mbrlen (__const char *__restrict __s, size_t __n,
        mbstate_t *__restrict __ps) throw ();








extern wint_t __btowc_alias (int __c) __asm ("btowc");
extern __inline __attribute__ ((__gnu_inline__)) wint_t
btowc (int __c) throw ()
{ return (__builtin_constant_p (__c) && __c >= '\0' && __c <= '\x7f'
   ? (wint_t) __c : __btowc_alias (__c)); }

extern int __wctob_alias (wint_t __c) __asm ("wctob");
extern __inline __attribute__ ((__gnu_inline__)) int
wctob (wint_t __wc) throw ()
{ return (__builtin_constant_p (__wc) && __wc >= L'\0' && __wc <= L'\x7f'
   ? (int) __wc : __wctob_alias (__wc)); }

extern __inline __attribute__ ((__gnu_inline__)) size_t
mbrlen (__const char *__restrict __s, size_t __n, mbstate_t *__restrict __ps) throw ()

{ return (__ps != __null
   ? mbrtowc (__null, __s, __n, __ps) : __mbrlen (__s, __n, __null)); }





extern size_t mbsrtowcs (wchar_t *__restrict __dst,
    __const char **__restrict __src, size_t __len,
    mbstate_t *__restrict __ps) throw ();



extern size_t wcsrtombs (char *__restrict __dst,
    __const wchar_t **__restrict __src, size_t __len,
    mbstate_t *__restrict __ps) throw ();






extern size_t mbsnrtowcs (wchar_t *__restrict __dst,
     __const char **__restrict __src, size_t __nmc,
     size_t __len, mbstate_t *__restrict __ps) throw ();



extern size_t wcsnrtombs (char *__restrict __dst,
     __const wchar_t **__restrict __src,
     size_t __nwc, size_t __len,
     mbstate_t *__restrict __ps) throw ();






extern int wcwidth (wchar_t __c) throw ();



extern int wcswidth (__const wchar_t *__s, size_t __n) throw ();






extern double wcstod (__const wchar_t *__restrict __nptr,
        wchar_t **__restrict __endptr) throw ();





extern float wcstof (__const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr) throw ();
extern long double wcstold (__const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr) throw ();







extern long int wcstol (__const wchar_t *__restrict __nptr,
   wchar_t **__restrict __endptr, int __base) throw ();



extern unsigned long int wcstoul (__const wchar_t *__restrict __nptr,
      wchar_t **__restrict __endptr, int __base)
     throw ();






__extension__
extern long long int wcstoll (__const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr, int __base)
     throw ();



__extension__
extern unsigned long long int wcstoull (__const wchar_t *__restrict __nptr,
     wchar_t **__restrict __endptr,
     int __base) throw ();






__extension__
extern long long int wcstoq (__const wchar_t *__restrict __nptr,
        wchar_t **__restrict __endptr, int __base)
     throw ();



__extension__
extern unsigned long long int wcstouq (__const wchar_t *__restrict __nptr,
           wchar_t **__restrict __endptr,
           int __base) throw ();
# 528 "/usr/include/wchar.h" 3 4
extern long int wcstol_l (__const wchar_t *__restrict __nptr,
     wchar_t **__restrict __endptr, int __base,
     __locale_t __loc) throw ();

extern unsigned long int wcstoul_l (__const wchar_t *__restrict __nptr,
        wchar_t **__restrict __endptr,
        int __base, __locale_t __loc) throw ();

__extension__
extern long long int wcstoll_l (__const wchar_t *__restrict __nptr,
    wchar_t **__restrict __endptr,
    int __base, __locale_t __loc) throw ();

__extension__
extern unsigned long long int wcstoull_l (__const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr,
       int __base, __locale_t __loc)
     throw ();

extern double wcstod_l (__const wchar_t *__restrict __nptr,
   wchar_t **__restrict __endptr, __locale_t __loc)
     throw ();

extern float wcstof_l (__const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr, __locale_t __loc)
     throw ();

extern long double wcstold_l (__const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr,
         __locale_t __loc) throw ();






extern wchar_t *wcpcpy (wchar_t *__dest, __const wchar_t *__src) throw ();



extern wchar_t *wcpncpy (wchar_t *__dest, __const wchar_t *__src, size_t __n)
     throw ();
# 578 "/usr/include/wchar.h" 3 4
extern __FILE *open_wmemstream (wchar_t **__bufloc, size_t *__sizeloc) throw ();






extern int fwide (__FILE *__fp, int __mode) throw ();






extern int fwprintf (__FILE *__restrict __stream,
       __const wchar_t *__restrict __format, ...)
                                                           ;




extern int wprintf (__const wchar_t *__restrict __format, ...)
                                                           ;

extern int swprintf (wchar_t *__restrict __s, size_t __n,
       __const wchar_t *__restrict __format, ...)
     throw () ;





extern int vfwprintf (__FILE *__restrict __s,
        __const wchar_t *__restrict __format,
        __gnuc_va_list __arg)
                                                           ;




extern int vwprintf (__const wchar_t *__restrict __format,
       __gnuc_va_list __arg)
                                                           ;


extern int vswprintf (wchar_t *__restrict __s, size_t __n,
        __const wchar_t *__restrict __format,
        __gnuc_va_list __arg)
     throw () ;






extern int fwscanf (__FILE *__restrict __stream,
      __const wchar_t *__restrict __format, ...)
                                                          ;




extern int wscanf (__const wchar_t *__restrict __format, ...)
                                                          ;

extern int swscanf (__const wchar_t *__restrict __s,
      __const wchar_t *__restrict __format, ...)
     throw () ;
# 678 "/usr/include/wchar.h" 3 4









extern int vfwscanf (__FILE *__restrict __s,
       __const wchar_t *__restrict __format,
       __gnuc_va_list __arg)
                                                          ;




extern int vwscanf (__const wchar_t *__restrict __format,
      __gnuc_va_list __arg)
                                                          ;

extern int vswscanf (__const wchar_t *__restrict __s,
       __const wchar_t *__restrict __format,
       __gnuc_va_list __arg)
     throw () ;
# 734 "/usr/include/wchar.h" 3 4









extern wint_t fgetwc (__FILE *__stream);
extern wint_t getwc (__FILE *__stream);





extern wint_t getwchar (void);






extern wint_t fputwc (wchar_t __wc, __FILE *__stream);
extern wint_t putwc (wchar_t __wc, __FILE *__stream);





extern wint_t putwchar (wchar_t __wc);







extern wchar_t *fgetws (wchar_t *__restrict __ws, int __n,
   __FILE *__restrict __stream);





extern int fputws (__const wchar_t *__restrict __ws,
     __FILE *__restrict __stream);






extern wint_t ungetwc (wint_t __wc, __FILE *__stream);

# 799 "/usr/include/wchar.h" 3 4
extern wint_t getwc_unlocked (__FILE *__stream);
extern wint_t getwchar_unlocked (void);







extern wint_t fgetwc_unlocked (__FILE *__stream);







extern wint_t fputwc_unlocked (wchar_t __wc, __FILE *__stream);
# 825 "/usr/include/wchar.h" 3 4
extern wint_t putwc_unlocked (wchar_t __wc, __FILE *__stream);
extern wint_t putwchar_unlocked (wchar_t __wc);
# 835 "/usr/include/wchar.h" 3 4
extern wchar_t *fgetws_unlocked (wchar_t *__restrict __ws, int __n,
     __FILE *__restrict __stream);







extern int fputws_unlocked (__const wchar_t *__restrict __ws,
       __FILE *__restrict __stream);







extern size_t wcsftime (wchar_t *__restrict __s, size_t __maxsize,
   __const wchar_t *__restrict __format,
   __const struct tm *__restrict __tp) throw ();







extern size_t wcsftime_l (wchar_t *__restrict __s, size_t __maxsize,
     __const wchar_t *__restrict __format,
     __const struct tm *__restrict __tp,
     __locale_t __loc) throw ();
# 882 "/usr/include/wchar.h" 3 4
# 1 "/usr/include/bits/wchar2.h" 1 3 4
# 25 "/usr/include/bits/wchar2.h" 3 4
extern wchar_t *__wmemcpy_chk (wchar_t *__restrict __s1,
          __const wchar_t *__restrict __s2, size_t __n,
          size_t __ns1) throw ();
extern wchar_t *__wmemcpy_alias (wchar_t *__restrict __s1, __const wchar_t *__restrict __s2, size_t __n) throw () __asm__ ("" "wmemcpy");



extern wchar_t *__wmemcpy_chk_warn (wchar_t *__restrict __s1, __const wchar_t *__restrict __s2, size_t __n, size_t __ns1) throw () __asm__ ("" "__wmemcpy_chk")



     __attribute__((__warning__ ("wmemcpy called with length bigger than size of destination " "buffer")));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) wchar_t *
wmemcpy (wchar_t *__restrict __s1, __const wchar_t *__restrict __s2, size_t __n) throw ()

{
  if (__builtin_object_size (__s1, 0) != (size_t) -1)
    {
      if (!__builtin_constant_p (__n))
 return __wmemcpy_chk (__s1, __s2, __n,
         __builtin_object_size (__s1, 0) / sizeof (wchar_t));

      if (__n > __builtin_object_size (__s1, 0) / sizeof (wchar_t))
 return __wmemcpy_chk_warn (__s1, __s2, __n,
       __builtin_object_size (__s1, 0) / sizeof (wchar_t));
    }
  return __wmemcpy_alias (__s1, __s2, __n);
}


extern wchar_t *__wmemmove_chk (wchar_t *__s1, __const wchar_t *__s2,
    size_t __n, size_t __ns1) throw ();
extern wchar_t *__wmemmove_alias (wchar_t *__s1, __const wchar_t *__s2, size_t __n) throw () __asm__ ("" "wmemmove");


extern wchar_t *__wmemmove_chk_warn (wchar_t *__restrict __s1, __const wchar_t *__restrict __s2, size_t __n, size_t __ns1) throw () __asm__ ("" "__wmemmove_chk")



     __attribute__((__warning__ ("wmemmove called with length bigger than size of destination " "buffer")));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) wchar_t *
wmemmove (wchar_t *__restrict __s1, __const wchar_t *__restrict __s2, size_t __n) throw ()

{
  if (__builtin_object_size (__s1, 0) != (size_t) -1)
    {
      if (!__builtin_constant_p (__n))
 return __wmemmove_chk (__s1, __s2, __n,
          __builtin_object_size (__s1, 0) / sizeof (wchar_t));

      if (__n > __builtin_object_size (__s1, 0) / sizeof (wchar_t))
 return __wmemmove_chk_warn (__s1, __s2, __n,
        __builtin_object_size (__s1, 0) / sizeof (wchar_t));
    }
  return __wmemmove_alias (__s1, __s2, __n);
}



extern wchar_t *__wmempcpy_chk (wchar_t *__restrict __s1,
    __const wchar_t *__restrict __s2, size_t __n,
    size_t __ns1) throw ();
extern wchar_t *__wmempcpy_alias (wchar_t *__restrict __s1, __const wchar_t *__restrict __s2, size_t __n) throw () __asm__ ("" "wmempcpy");



extern wchar_t *__wmempcpy_chk_warn (wchar_t *__restrict __s1, __const wchar_t *__restrict __s2, size_t __n, size_t __ns1) throw () __asm__ ("" "__wmempcpy_chk")



     __attribute__((__warning__ ("wmempcpy called with length bigger than size of destination " "buffer")));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) wchar_t *
wmempcpy (wchar_t *__restrict __s1, __const wchar_t *__restrict __s2, size_t __n) throw ()

{
  if (__builtin_object_size (__s1, 0) != (size_t) -1)
    {
      if (!__builtin_constant_p (__n))
 return __wmempcpy_chk (__s1, __s2, __n,
          __builtin_object_size (__s1, 0) / sizeof (wchar_t));

      if (__n > __builtin_object_size (__s1, 0) / sizeof (wchar_t))
 return __wmempcpy_chk_warn (__s1, __s2, __n,
        __builtin_object_size (__s1, 0) / sizeof (wchar_t));
    }
  return __wmempcpy_alias (__s1, __s2, __n);
}



extern wchar_t *__wmemset_chk (wchar_t *__s, wchar_t __c, size_t __n,
          size_t __ns) throw ();
extern wchar_t *__wmemset_alias (wchar_t *__s, wchar_t __c, size_t __n) throw () __asm__ ("" "wmemset");

extern wchar_t *__wmemset_chk_warn (wchar_t *__s, wchar_t __c, size_t __n, size_t __ns) throw () __asm__ ("" "__wmemset_chk")


     __attribute__((__warning__ ("wmemset called with length bigger than size of destination " "buffer")));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) wchar_t *
wmemset (wchar_t *__restrict __s, wchar_t __c, size_t __n) throw ()
{
  if (__builtin_object_size (__s, 0) != (size_t) -1)
    {
      if (!__builtin_constant_p (__n))
 return __wmemset_chk (__s, __c, __n, __builtin_object_size (__s, 0) / sizeof (wchar_t));

      if (__n > __builtin_object_size (__s, 0) / sizeof (wchar_t))
 return __wmemset_chk_warn (__s, __c, __n,
       __builtin_object_size (__s, 0) / sizeof (wchar_t));
    }
  return __wmemset_alias (__s, __c, __n);
}


extern wchar_t *__wcscpy_chk (wchar_t *__restrict __dest,
         __const wchar_t *__restrict __src,
         size_t __n) throw ();
extern wchar_t *__wcscpy_alias (wchar_t *__restrict __dest, __const wchar_t *__restrict __src) throw () __asm__ ("" "wcscpy");



extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) wchar_t *
wcscpy (wchar_t *__dest, __const wchar_t *__src) throw ()
{
  if (__builtin_object_size (__dest, 2 > 1) != (size_t) -1)
    return __wcscpy_chk (__dest, __src, __builtin_object_size (__dest, 2 > 1) / sizeof (wchar_t));
  return __wcscpy_alias (__dest, __src);
}


extern wchar_t *__wcpcpy_chk (wchar_t *__dest, __const wchar_t *__src,
         size_t __destlen) throw ();
extern wchar_t *__wcpcpy_alias (wchar_t *__dest, __const wchar_t *__src) throw () __asm__ ("" "wcpcpy");



extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) wchar_t *
wcpcpy (wchar_t *__dest, __const wchar_t *__src) throw ()
{
  if (__builtin_object_size (__dest, 2 > 1) != (size_t) -1)
    return __wcpcpy_chk (__dest, __src, __builtin_object_size (__dest, 2 > 1) / sizeof (wchar_t));
  return __wcpcpy_alias (__dest, __src);
}


extern wchar_t *__wcsncpy_chk (wchar_t *__restrict __dest,
          __const wchar_t *__restrict __src, size_t __n,
          size_t __destlen) throw ();
extern wchar_t *__wcsncpy_alias (wchar_t *__restrict __dest, __const wchar_t *__restrict __src, size_t __n) throw () __asm__ ("" "wcsncpy");



extern wchar_t *__wcsncpy_chk_warn (wchar_t *__restrict __dest, __const wchar_t *__restrict __src, size_t __n, size_t __destlen) throw () __asm__ ("" "__wcsncpy_chk")



     __attribute__((__warning__ ("wcsncpy called with length bigger than size of destination " "buffer")));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) wchar_t *
wcsncpy (wchar_t *__dest, __const wchar_t *__src, size_t __n) throw ()
{
  if (__builtin_object_size (__dest, 2 > 1) != (size_t) -1)
    {
      if (!__builtin_constant_p (__n))
 return __wcsncpy_chk (__dest, __src, __n,
         __builtin_object_size (__dest, 2 > 1) / sizeof (wchar_t));
      if (__n > __builtin_object_size (__dest, 2 > 1) / sizeof (wchar_t))
 return __wcsncpy_chk_warn (__dest, __src, __n,
       __builtin_object_size (__dest, 2 > 1) / sizeof (wchar_t));
    }
  return __wcsncpy_alias (__dest, __src, __n);
}


extern wchar_t *__wcpncpy_chk (wchar_t *__restrict __dest,
          __const wchar_t *__restrict __src, size_t __n,
          size_t __destlen) throw ();
extern wchar_t *__wcpncpy_alias (wchar_t *__restrict __dest, __const wchar_t *__restrict __src, size_t __n) throw () __asm__ ("" "wcpncpy");



extern wchar_t *__wcpncpy_chk_warn (wchar_t *__restrict __dest, __const wchar_t *__restrict __src, size_t __n, size_t __destlen) throw () __asm__ ("" "__wcpncpy_chk")



     __attribute__((__warning__ ("wcpncpy called with length bigger than size of destination " "buffer")));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) wchar_t *
wcpncpy (wchar_t *__dest, __const wchar_t *__src, size_t __n) throw ()
{
  if (__builtin_object_size (__dest, 2 > 1) != (size_t) -1)
    {
      if (!__builtin_constant_p (__n))
 return __wcpncpy_chk (__dest, __src, __n,
         __builtin_object_size (__dest, 2 > 1) / sizeof (wchar_t));
      if (__n > __builtin_object_size (__dest, 2 > 1) / sizeof (wchar_t))
 return __wcpncpy_chk_warn (__dest, __src, __n,
       __builtin_object_size (__dest, 2 > 1) / sizeof (wchar_t));
    }
  return __wcpncpy_alias (__dest, __src, __n);
}


extern wchar_t *__wcscat_chk (wchar_t *__restrict __dest,
         __const wchar_t *__restrict __src,
         size_t __destlen) throw ();
extern wchar_t *__wcscat_alias (wchar_t *__restrict __dest, __const wchar_t *__restrict __src) throw () __asm__ ("" "wcscat");



extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) wchar_t *
wcscat (wchar_t *__dest, __const wchar_t *__src) throw ()
{
  if (__builtin_object_size (__dest, 2 > 1) != (size_t) -1)
    return __wcscat_chk (__dest, __src, __builtin_object_size (__dest, 2 > 1) / sizeof (wchar_t));
  return __wcscat_alias (__dest, __src);
}


extern wchar_t *__wcsncat_chk (wchar_t *__restrict __dest,
          __const wchar_t *__restrict __src,
          size_t __n, size_t __destlen) throw ();
extern wchar_t *__wcsncat_alias (wchar_t *__restrict __dest, __const wchar_t *__restrict __src, size_t __n) throw () __asm__ ("" "wcsncat");




extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) wchar_t *
wcsncat (wchar_t *__dest, __const wchar_t *__src, size_t __n) throw ()
{
  if (__builtin_object_size (__dest, 2 > 1) != (size_t) -1)
    return __wcsncat_chk (__dest, __src, __n,
     __builtin_object_size (__dest, 2 > 1) / sizeof (wchar_t));
  return __wcsncat_alias (__dest, __src, __n);
}


extern int __swprintf_chk (wchar_t *__restrict __s, size_t __n,
      int __flag, size_t __s_len,
      __const wchar_t *__restrict __format, ...)
     throw () ;

extern int __swprintf_alias (wchar_t *__restrict __s, size_t __n, __const wchar_t *__restrict __fmt, ...) throw () __asm__ ("" "swprintf");





extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) int
swprintf (wchar_t *__restrict __s, size_t __n, __const wchar_t *__restrict __fmt, ...) throw ()

{
  if (__builtin_object_size (__s, 2 > 1) != (size_t) -1 || 2 > 1)
    return __swprintf_chk (__s, __n, 2 - 1,
      __builtin_object_size (__s, 2 > 1) / sizeof (wchar_t),
      __fmt, __builtin_va_arg_pack ());
  return __swprintf_alias (__s, __n, __fmt, __builtin_va_arg_pack ());
}
# 302 "/usr/include/bits/wchar2.h" 3 4
extern int __vswprintf_chk (wchar_t *__restrict __s, size_t __n,
       int __flag, size_t __s_len,
       __const wchar_t *__restrict __format,
       __gnuc_va_list __arg)
     throw () ;

extern int __vswprintf_alias (wchar_t *__restrict __s, size_t __n, __const wchar_t *__restrict __fmt, __gnuc_va_list __ap) throw () __asm__ ("" "vswprintf");




extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) int
vswprintf (wchar_t *__restrict __s, size_t __n, __const wchar_t *__restrict __fmt, __gnuc_va_list __ap) throw ()

{
  if (__builtin_object_size (__s, 2 > 1) != (size_t) -1 || 2 > 1)
    return __vswprintf_chk (__s, __n, 2 - 1,
       __builtin_object_size (__s, 2 > 1) / sizeof (wchar_t), __fmt, __ap);
  return __vswprintf_alias (__s, __n, __fmt, __ap);
}




extern int __fwprintf_chk (__FILE *__restrict __stream, int __flag,
      __const wchar_t *__restrict __format, ...);
extern int __wprintf_chk (int __flag, __const wchar_t *__restrict __format,
     ...);
extern int __vfwprintf_chk (__FILE *__restrict __stream, int __flag,
       __const wchar_t *__restrict __format,
       __gnuc_va_list __ap);
extern int __vwprintf_chk (int __flag, __const wchar_t *__restrict __format,
      __gnuc_va_list __ap);


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) int
wprintf (__const wchar_t *__restrict __fmt, ...)
{
  return __wprintf_chk (2 - 1, __fmt, __builtin_va_arg_pack ());
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) int
fwprintf (__FILE *__restrict __stream, __const wchar_t *__restrict __fmt, ...)
{
  return __fwprintf_chk (__stream, 2 - 1, __fmt,
    __builtin_va_arg_pack ());
}







extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) int
vwprintf (__const wchar_t *__restrict __fmt, __gnuc_va_list __ap)
{
  return __vwprintf_chk (2 - 1, __fmt, __ap);
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) int
vfwprintf (__FILE *__restrict __stream,
    __const wchar_t *__restrict __fmt, __gnuc_va_list __ap)
{
  return __vfwprintf_chk (__stream, 2 - 1, __fmt, __ap);
}



extern wchar_t *__fgetws_chk (wchar_t *__restrict __s, size_t __size, int __n,
         __FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));
extern wchar_t *__fgetws_alias (wchar_t *__restrict __s, int __n, __FILE *__restrict __stream) __asm__ ("" "fgetws") __attribute__ ((__warn_unused_result__));


extern wchar_t *__fgetws_chk_warn (wchar_t *__restrict __s, size_t __size, int __n, __FILE *__restrict __stream) __asm__ ("" "__fgetws_chk")


     __attribute__ ((__warn_unused_result__)) __attribute__((__warning__ ("fgetws called with bigger size than length " "of destination buffer")));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) __attribute__ ((__warn_unused_result__)) wchar_t *
fgetws (wchar_t *__restrict __s, int __n, __FILE *__restrict __stream)
{
  if (__builtin_object_size (__s, 2 > 1) != (size_t) -1)
    {
      if (!__builtin_constant_p (__n) || __n <= 0)
 return __fgetws_chk (__s, __builtin_object_size (__s, 2 > 1) / sizeof (wchar_t),
        __n, __stream);

      if ((size_t) __n > __builtin_object_size (__s, 2 > 1) / sizeof (wchar_t))
 return __fgetws_chk_warn (__s, __builtin_object_size (__s, 2 > 1) / sizeof (wchar_t),
      __n, __stream);
    }
  return __fgetws_alias (__s, __n, __stream);
}


extern wchar_t *__fgetws_unlocked_chk (wchar_t *__restrict __s, size_t __size,
           int __n, __FILE *__restrict __stream)
  __attribute__ ((__warn_unused_result__));
extern wchar_t *__fgetws_unlocked_alias (wchar_t *__restrict __s, int __n, __FILE *__restrict __stream) __asm__ ("" "fgetws_unlocked")


  __attribute__ ((__warn_unused_result__));
extern wchar_t *__fgetws_unlocked_chk_warn (wchar_t *__restrict __s, size_t __size, int __n, __FILE *__restrict __stream) __asm__ ("" "__fgetws_unlocked_chk")



     __attribute__ ((__warn_unused_result__)) __attribute__((__warning__ ("fgetws_unlocked called with bigger size than length " "of destination buffer")));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) __attribute__ ((__warn_unused_result__)) wchar_t *
fgetws_unlocked (wchar_t *__restrict __s, int __n, __FILE *__restrict __stream)
{
  if (__builtin_object_size (__s, 2 > 1) != (size_t) -1)
    {
      if (!__builtin_constant_p (__n) || __n <= 0)
 return __fgetws_unlocked_chk (__s, __builtin_object_size (__s, 2 > 1) / sizeof (wchar_t),
          __n, __stream);

      if ((size_t) __n > __builtin_object_size (__s, 2 > 1) / sizeof (wchar_t))
 return __fgetws_unlocked_chk_warn (__s, __builtin_object_size (__s, 2 > 1) / sizeof (wchar_t),
        __n, __stream);
    }
  return __fgetws_unlocked_alias (__s, __n, __stream);
}



extern size_t __wcrtomb_chk (char *__s, wchar_t __wchar, mbstate_t *__p,
     size_t __buflen) throw () __attribute__ ((__warn_unused_result__));
extern size_t __wcrtomb_alias (char *__restrict __s, wchar_t __wchar, mbstate_t *__restrict __ps) throw () __asm__ ("" "wcrtomb") __attribute__ ((__warn_unused_result__));



extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) __attribute__ ((__warn_unused_result__)) size_t
wcrtomb (char *__s, wchar_t __wchar, mbstate_t *__ps) throw ()
{







  if (__builtin_object_size (__s, 2 > 1) != (size_t) -1 && 16 > __builtin_object_size (__s, 2 > 1))
    return __wcrtomb_chk (__s, __wchar, __ps, __builtin_object_size (__s, 2 > 1));
  return __wcrtomb_alias (__s, __wchar, __ps);
}


extern size_t __mbsrtowcs_chk (wchar_t *__restrict __dst,
          __const char **__restrict __src,
          size_t __len, mbstate_t *__restrict __ps,
          size_t __dstlen) throw ();
extern size_t __mbsrtowcs_alias (wchar_t *__restrict __dst, __const char **__restrict __src, size_t __len, mbstate_t *__restrict __ps) throw () __asm__ ("" "mbsrtowcs");




extern size_t __mbsrtowcs_chk_warn (wchar_t *__restrict __dst, __const char **__restrict __src, size_t __len, mbstate_t *__restrict __ps, size_t __dstlen) throw () __asm__ ("" "__mbsrtowcs_chk")




     __attribute__((__warning__ ("mbsrtowcs called with dst buffer smaller than len " "* sizeof (wchar_t)")));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) size_t
mbsrtowcs (wchar_t *__restrict __dst, __const char **__restrict __src, size_t __len, mbstate_t *__restrict __ps) throw ()

{
  if (__builtin_object_size (__dst, 2 > 1) != (size_t) -1)
    {
      if (!__builtin_constant_p (__len))
 return __mbsrtowcs_chk (__dst, __src, __len, __ps,
    __builtin_object_size (__dst, 2 > 1) / sizeof (wchar_t));

      if (__len > __builtin_object_size (__dst, 2 > 1) / sizeof (wchar_t))
 return __mbsrtowcs_chk_warn (__dst, __src, __len, __ps,
         __builtin_object_size (__dst, 2 > 1) / sizeof (wchar_t));
    }
  return __mbsrtowcs_alias (__dst, __src, __len, __ps);
}


extern size_t __wcsrtombs_chk (char *__restrict __dst,
          __const wchar_t **__restrict __src,
          size_t __len, mbstate_t *__restrict __ps,
          size_t __dstlen) throw ();
extern size_t __wcsrtombs_alias (char *__restrict __dst, __const wchar_t **__restrict __src, size_t __len, mbstate_t *__restrict __ps) throw () __asm__ ("" "wcsrtombs");




extern size_t __wcsrtombs_chk_warn (char *__restrict __dst, __const wchar_t **__restrict __src, size_t __len, mbstate_t *__restrict __ps, size_t __dstlen) throw () __asm__ ("" "__wcsrtombs_chk")




    __attribute__((__warning__ ("wcsrtombs called with dst buffer smaller than len")));

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) size_t
wcsrtombs (char *__restrict __dst, __const wchar_t **__restrict __src, size_t __len, mbstate_t *__restrict __ps) throw ()

{
  if (__builtin_object_size (__dst, 2 > 1) != (size_t) -1)
    {
      if (!__builtin_constant_p (__len))
 return __wcsrtombs_chk (__dst, __src, __len, __ps, __builtin_object_size (__dst, 2 > 1));

      if (__len > __builtin_object_size (__dst, 2 > 1))
 return __wcsrtombs_chk_warn (__dst, __src, __len, __ps, __builtin_object_size (__dst, 2 > 1));
    }
  return __wcsrtombs_alias (__dst, __src, __len, __ps);
}



extern size_t __mbsnrtowcs_chk (wchar_t *__restrict __dst,
    __const char **__restrict __src, size_t __nmc,
    size_t __len, mbstate_t *__restrict __ps,
    size_t __dstlen) throw ();
extern size_t __mbsnrtowcs_alias (wchar_t *__restrict __dst, __const char **__restrict __src, size_t __nmc, size_t __len, mbstate_t *__restrict __ps) throw () __asm__ ("" "mbsnrtowcs");




extern size_t __mbsnrtowcs_chk_warn (wchar_t *__restrict __dst, __const char **__restrict __src, size_t __nmc, size_t __len, mbstate_t *__restrict __ps, size_t __dstlen) throw () __asm__ ("" "__mbsnrtowcs_chk")




     __attribute__((__warning__ ("mbsnrtowcs called with dst buffer smaller than len " "* sizeof (wchar_t)")));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) size_t
mbsnrtowcs (wchar_t *__restrict __dst, __const char **__restrict __src, size_t __nmc, size_t __len, mbstate_t *__restrict __ps) throw ()

{
  if (__builtin_object_size (__dst, 2 > 1) != (size_t) -1)
    {
      if (!__builtin_constant_p (__len))
 return __mbsnrtowcs_chk (__dst, __src, __nmc, __len, __ps,
     __builtin_object_size (__dst, 2 > 1) / sizeof (wchar_t));

      if (__len > __builtin_object_size (__dst, 2 > 1) / sizeof (wchar_t))
 return __mbsnrtowcs_chk_warn (__dst, __src, __nmc, __len, __ps,
          __builtin_object_size (__dst, 2 > 1) / sizeof (wchar_t));
    }
  return __mbsnrtowcs_alias (__dst, __src, __nmc, __len, __ps);
}


extern size_t __wcsnrtombs_chk (char *__restrict __dst,
    __const wchar_t **__restrict __src,
    size_t __nwc, size_t __len,
    mbstate_t *__restrict __ps, size_t __dstlen)
     throw ();
extern size_t __wcsnrtombs_alias (char *__restrict __dst, __const wchar_t **__restrict __src, size_t __nwc, size_t __len, mbstate_t *__restrict __ps) throw () __asm__ ("" "wcsnrtombs");




extern size_t __wcsnrtombs_chk_warn (char *__restrict __dst, __const wchar_t **__restrict __src, size_t __nwc, size_t __len, mbstate_t *__restrict __ps, size_t __dstlen) throw () __asm__ ("" "__wcsnrtombs_chk")





     __attribute__((__warning__ ("wcsnrtombs called with dst buffer smaller than len")));

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) size_t
wcsnrtombs (char *__restrict __dst, __const wchar_t **__restrict __src, size_t __nwc, size_t __len, mbstate_t *__restrict __ps) throw ()

{
  if (__builtin_object_size (__dst, 2 > 1) != (size_t) -1)
    {
      if (!__builtin_constant_p (__len))
 return __wcsnrtombs_chk (__dst, __src, __nwc, __len, __ps,
     __builtin_object_size (__dst, 2 > 1));

      if (__len > __builtin_object_size (__dst, 2 > 1))
 return __wcsnrtombs_chk_warn (__dst, __src, __nwc, __len, __ps,
          __builtin_object_size (__dst, 2 > 1));
    }
  return __wcsnrtombs_alias (__dst, __src, __nwc, __len, __ps);
}
# 883 "/usr/include/wchar.h" 2 3 4






}
# 102 "/usr/include/wx-2.8/wx/wxchar.h" 2
# 212 "/usr/include/wx-2.8/wx/wxchar.h"
        typedef wchar_t wxChar;
        typedef wchar_t wxSChar;
        typedef wchar_t wxUChar;
# 533 "/usr/include/wx-2.8/wx/wxchar.h"
# 1 "/usr/include/wctype.h" 1 3 4
# 34 "/usr/include/wctype.h" 3 4
# 1 "/usr/include/wchar.h" 1 3 4
# 35 "/usr/include/wctype.h" 2 3 4
# 50 "/usr/include/wctype.h" 3 4



typedef unsigned long int wctype_t;







# 1 "/usr/include/endian.h" 1 3 4
# 37 "/usr/include/endian.h" 3 4
# 1 "/usr/include/bits/endian.h" 1 3 4
# 38 "/usr/include/endian.h" 2 3 4
# 61 "/usr/include/endian.h" 3 4
# 1 "/usr/include/bits/byteswap.h" 1 3 4
# 28 "/usr/include/bits/byteswap.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 29 "/usr/include/bits/byteswap.h" 2 3 4
# 62 "/usr/include/endian.h" 2 3 4
# 62 "/usr/include/wctype.h" 2 3 4
# 72 "/usr/include/wctype.h" 3 4
enum
{
  __ISwupper = 0,
  __ISwlower = 1,
  __ISwalpha = 2,
  __ISwdigit = 3,
  __ISwxdigit = 4,
  __ISwspace = 5,
  __ISwprint = 6,
  __ISwgraph = 7,
  __ISwblank = 8,
  __ISwcntrl = 9,
  __ISwpunct = 10,
  __ISwalnum = 11,

  _ISwupper = ((__ISwupper) < 8 ? (int) ((1UL << (__ISwupper)) << 24) : ((__ISwupper) < 16 ? (int) ((1UL << (__ISwupper)) << 8) : ((__ISwupper) < 24 ? (int) ((1UL << (__ISwupper)) >> 8) : (int) ((1UL << (__ISwupper)) >> 24)))),
  _ISwlower = ((__ISwlower) < 8 ? (int) ((1UL << (__ISwlower)) << 24) : ((__ISwlower) < 16 ? (int) ((1UL << (__ISwlower)) << 8) : ((__ISwlower) < 24 ? (int) ((1UL << (__ISwlower)) >> 8) : (int) ((1UL << (__ISwlower)) >> 24)))),
  _ISwalpha = ((__ISwalpha) < 8 ? (int) ((1UL << (__ISwalpha)) << 24) : ((__ISwalpha) < 16 ? (int) ((1UL << (__ISwalpha)) << 8) : ((__ISwalpha) < 24 ? (int) ((1UL << (__ISwalpha)) >> 8) : (int) ((1UL << (__ISwalpha)) >> 24)))),
  _ISwdigit = ((__ISwdigit) < 8 ? (int) ((1UL << (__ISwdigit)) << 24) : ((__ISwdigit) < 16 ? (int) ((1UL << (__ISwdigit)) << 8) : ((__ISwdigit) < 24 ? (int) ((1UL << (__ISwdigit)) >> 8) : (int) ((1UL << (__ISwdigit)) >> 24)))),
  _ISwxdigit = ((__ISwxdigit) < 8 ? (int) ((1UL << (__ISwxdigit)) << 24) : ((__ISwxdigit) < 16 ? (int) ((1UL << (__ISwxdigit)) << 8) : ((__ISwxdigit) < 24 ? (int) ((1UL << (__ISwxdigit)) >> 8) : (int) ((1UL << (__ISwxdigit)) >> 24)))),
  _ISwspace = ((__ISwspace) < 8 ? (int) ((1UL << (__ISwspace)) << 24) : ((__ISwspace) < 16 ? (int) ((1UL << (__ISwspace)) << 8) : ((__ISwspace) < 24 ? (int) ((1UL << (__ISwspace)) >> 8) : (int) ((1UL << (__ISwspace)) >> 24)))),
  _ISwprint = ((__ISwprint) < 8 ? (int) ((1UL << (__ISwprint)) << 24) : ((__ISwprint) < 16 ? (int) ((1UL << (__ISwprint)) << 8) : ((__ISwprint) < 24 ? (int) ((1UL << (__ISwprint)) >> 8) : (int) ((1UL << (__ISwprint)) >> 24)))),
  _ISwgraph = ((__ISwgraph) < 8 ? (int) ((1UL << (__ISwgraph)) << 24) : ((__ISwgraph) < 16 ? (int) ((1UL << (__ISwgraph)) << 8) : ((__ISwgraph) < 24 ? (int) ((1UL << (__ISwgraph)) >> 8) : (int) ((1UL << (__ISwgraph)) >> 24)))),
  _ISwblank = ((__ISwblank) < 8 ? (int) ((1UL << (__ISwblank)) << 24) : ((__ISwblank) < 16 ? (int) ((1UL << (__ISwblank)) << 8) : ((__ISwblank) < 24 ? (int) ((1UL << (__ISwblank)) >> 8) : (int) ((1UL << (__ISwblank)) >> 24)))),
  _ISwcntrl = ((__ISwcntrl) < 8 ? (int) ((1UL << (__ISwcntrl)) << 24) : ((__ISwcntrl) < 16 ? (int) ((1UL << (__ISwcntrl)) << 8) : ((__ISwcntrl) < 24 ? (int) ((1UL << (__ISwcntrl)) >> 8) : (int) ((1UL << (__ISwcntrl)) >> 24)))),
  _ISwpunct = ((__ISwpunct) < 8 ? (int) ((1UL << (__ISwpunct)) << 24) : ((__ISwpunct) < 16 ? (int) ((1UL << (__ISwpunct)) << 8) : ((__ISwpunct) < 24 ? (int) ((1UL << (__ISwpunct)) >> 8) : (int) ((1UL << (__ISwpunct)) >> 24)))),
  _ISwalnum = ((__ISwalnum) < 8 ? (int) ((1UL << (__ISwalnum)) << 24) : ((__ISwalnum) < 16 ? (int) ((1UL << (__ISwalnum)) << 8) : ((__ISwalnum) < 24 ? (int) ((1UL << (__ISwalnum)) >> 8) : (int) ((1UL << (__ISwalnum)) >> 24))))
};



extern "C" {








extern int iswalnum (wint_t __wc) throw ();





extern int iswalpha (wint_t __wc) throw ();


extern int iswcntrl (wint_t __wc) throw ();



extern int iswdigit (wint_t __wc) throw ();



extern int iswgraph (wint_t __wc) throw ();




extern int iswlower (wint_t __wc) throw ();


extern int iswprint (wint_t __wc) throw ();




extern int iswpunct (wint_t __wc) throw ();




extern int iswspace (wint_t __wc) throw ();




extern int iswupper (wint_t __wc) throw ();




extern int iswxdigit (wint_t __wc) throw ();





extern int iswblank (wint_t __wc) throw ();
# 172 "/usr/include/wctype.h" 3 4
extern wctype_t wctype (__const char *__property) throw ();



extern int iswctype (wint_t __wc, wctype_t __desc) throw ();










typedef __const __int32_t *wctrans_t;







extern wint_t towlower (wint_t __wc) throw ();


extern wint_t towupper (wint_t __wc) throw ();


}
# 214 "/usr/include/wctype.h" 3 4
extern "C" {




extern wctrans_t wctrans (__const char *__property) throw ();


extern wint_t towctrans (wint_t __wc, wctrans_t __desc) throw ();








extern int iswalnum_l (wint_t __wc, __locale_t __locale) throw ();





extern int iswalpha_l (wint_t __wc, __locale_t __locale) throw ();


extern int iswcntrl_l (wint_t __wc, __locale_t __locale) throw ();



extern int iswdigit_l (wint_t __wc, __locale_t __locale) throw ();



extern int iswgraph_l (wint_t __wc, __locale_t __locale) throw ();




extern int iswlower_l (wint_t __wc, __locale_t __locale) throw ();


extern int iswprint_l (wint_t __wc, __locale_t __locale) throw ();




extern int iswpunct_l (wint_t __wc, __locale_t __locale) throw ();




extern int iswspace_l (wint_t __wc, __locale_t __locale) throw ();




extern int iswupper_l (wint_t __wc, __locale_t __locale) throw ();




extern int iswxdigit_l (wint_t __wc, __locale_t __locale) throw ();




extern int iswblank_l (wint_t __wc, __locale_t __locale) throw ();



extern wctype_t wctype_l (__const char *__property, __locale_t __locale)
     throw ();



extern int iswctype_l (wint_t __wc, wctype_t __desc, __locale_t __locale)
     throw ();







extern wint_t towlower_l (wint_t __wc, __locale_t __locale) throw ();


extern wint_t towupper_l (wint_t __wc, __locale_t __locale) throw ();



extern wctrans_t wctrans_l (__const char *__property, __locale_t __locale)
     throw ();


extern wint_t towctrans_l (wint_t __wc, wctrans_t __desc,
      __locale_t __locale) throw ();



}
# 534 "/usr/include/wx-2.8/wx/wxchar.h" 2
# 609 "/usr/include/wx-2.8/wx/wxchar.h"
                int wxPutc(wxChar ch, FILE *stream);
# 622 "/usr/include/wx-2.8/wx/wxchar.h"
                int wxPuts(const wxChar *ws);
# 854 "/usr/include/wx-2.8/wx/wxchar.h"
inline bool wxIsEmpty(const wxChar *p) { return !p || !*p; }


inline size_t wxStrlen(const wxChar *psz) { return psz ? wcslen(psz) : 0; }
# 874 "/usr/include/wx-2.8/wx/wxchar.h"
 bool wxOKlibc();
# 1011 "/usr/include/wx-2.8/wx/wxchar.h"
    int
    wxSnprintf_(wxChar *buf, size_t len, const wxChar *format, ...) ;
# 1052 "/usr/include/wx-2.8/wx/wxchar.h"
    int wxScanf( const wxChar *format, ... ) ;
    int wxSscanf( const wxChar *str, const wxChar *format, ... ) ;
    int wxFscanf( FILE *stream, const wxChar *format, ... ) ;
    int wxVsscanf( const wxChar *str, const wxChar *format, va_list ap );
    int wxPrintf( const wxChar *format, ... ) ;
    int wxSprintf( wxChar *str, const wxChar *format, ... ) ;
    int wxFprintf( FILE *stream, const wxChar *format, ... ) ;
    int wxVfprintf( FILE *stream, const wxChar *format, va_list ap );
    int wxVprintf( const wxChar *format, va_list ap );
    int wxVsprintf( wxChar *str, const wxChar *format, va_list ap );
# 1071 "/usr/include/wx-2.8/wx/wxchar.h"
    int wxSnprintf( wxChar *str, size_t size, const wxChar *format, ... ) ;
    int wxVsnprintf( wxChar *str, size_t size, const wxChar *format, va_list ap );
# 1206 "/usr/include/wx-2.8/wx/wxchar.h"
 wchar_t *wxStrdupW(const wchar_t *pwz);



 int wxStricmp(const wxChar *psz1, const wxChar *psz2);



 int wxStrnicmp(const wxChar *psz1, const wxChar *psz2, size_t len);



 wxChar * wxStrtok(wxChar *psz, const wxChar *delim, wxChar **save_ptr);




class wxWCharBuffer;
 wxWCharBuffer wxSetlocale(int category, const wxChar *locale);






    FILE * wxFopen(const wxChar *path, const wxChar *mode);
    FILE * wxFreopen(const wxChar *path, const wxChar *mode, FILE *stream);
    int wxRemove(const wxChar *path);
    int wxRename(const wxChar *oldpath, const wxChar *newpath);







 double wxAtof(const wxChar *psz);
# 1254 "/usr/include/wx-2.8/wx/wxchar.h"
 int wxAtoi(const wxChar *psz);
 long wxAtol(const wxChar *psz);
 wxChar * wxGetenv(const wxChar *name);




 int wxSystem(const wxChar *psz);
# 1271 "/usr/include/wx-2.8/wx/wxchar.h"
    struct tm;
    size_t wxStrftime(wxChar *s, size_t max,
                                  const wxChar *fmt, const struct tm *tm);



# 1 "/usr/include/time.h" 1 3 4
# 30 "/usr/include/time.h" 3 4
extern "C" {







# 1 "/usr/lib/gcc/i686-linux-gnu/4.4.5/include/stddef.h" 1 3 4
# 39 "/usr/include/time.h" 2 3 4



# 1 "/usr/include/bits/time.h" 1 3 4
# 43 "/usr/include/time.h" 2 3 4
# 58 "/usr/include/time.h" 3 4


typedef __clock_t clock_t;



# 74 "/usr/include/time.h" 3 4


typedef __time_t time_t;



# 92 "/usr/include/time.h" 3 4
typedef __clockid_t clockid_t;
# 104 "/usr/include/time.h" 3 4
typedef __timer_t timer_t;
# 120 "/usr/include/time.h" 3 4
struct timespec
  {
    __time_t tv_sec;
    long int tv_nsec;
  };








struct tm
{
  int tm_sec;
  int tm_min;
  int tm_hour;
  int tm_mday;
  int tm_mon;
  int tm_year;
  int tm_wday;
  int tm_yday;
  int tm_isdst;


  long int tm_gmtoff;
  __const char *tm_zone;




};








struct itimerspec
  {
    struct timespec it_interval;
    struct timespec it_value;
  };


struct sigevent;





typedef __pid_t pid_t;








extern clock_t clock (void) throw ();


extern time_t time (time_t *__timer) throw ();


extern double difftime (time_t __time1, time_t __time0)
     throw () __attribute__ ((__const__));


extern time_t mktime (struct tm *__tp) throw ();





extern size_t strftime (char *__restrict __s, size_t __maxsize,
   __const char *__restrict __format,
   __const struct tm *__restrict __tp) throw ();





extern char *strptime (__const char *__restrict __s,
         __const char *__restrict __fmt, struct tm *__tp)
     throw ();







extern size_t strftime_l (char *__restrict __s, size_t __maxsize,
     __const char *__restrict __format,
     __const struct tm *__restrict __tp,
     __locale_t __loc) throw ();



extern char *strptime_l (__const char *__restrict __s,
    __const char *__restrict __fmt, struct tm *__tp,
    __locale_t __loc) throw ();






extern struct tm *gmtime (__const time_t *__timer) throw ();



extern struct tm *localtime (__const time_t *__timer) throw ();





extern struct tm *gmtime_r (__const time_t *__restrict __timer,
       struct tm *__restrict __tp) throw ();



extern struct tm *localtime_r (__const time_t *__restrict __timer,
          struct tm *__restrict __tp) throw ();





extern char *asctime (__const struct tm *__tp) throw ();


extern char *ctime (__const time_t *__timer) throw ();







extern char *asctime_r (__const struct tm *__restrict __tp,
   char *__restrict __buf) throw ();


extern char *ctime_r (__const time_t *__restrict __timer,
        char *__restrict __buf) throw ();




extern char *__tzname[2];
extern int __daylight;
extern long int __timezone;




extern char *tzname[2];



extern void tzset (void) throw ();



extern int daylight;
extern long int timezone;





extern int stime (__const time_t *__when) throw ();
# 313 "/usr/include/time.h" 3 4
extern time_t timegm (struct tm *__tp) throw ();


extern time_t timelocal (struct tm *__tp) throw ();


extern int dysize (int __year) throw () __attribute__ ((__const__));
# 328 "/usr/include/time.h" 3 4
extern int nanosleep (__const struct timespec *__requested_time,
        struct timespec *__remaining);



extern int clock_getres (clockid_t __clock_id, struct timespec *__res) throw ();


extern int clock_gettime (clockid_t __clock_id, struct timespec *__tp) throw ();


extern int clock_settime (clockid_t __clock_id, __const struct timespec *__tp)
     throw ();






extern int clock_nanosleep (clockid_t __clock_id, int __flags,
       __const struct timespec *__req,
       struct timespec *__rem);


extern int clock_getcpuclockid (pid_t __pid, clockid_t *__clock_id) throw ();




extern int timer_create (clockid_t __clock_id,
    struct sigevent *__restrict __evp,
    timer_t *__restrict __timerid) throw ();


extern int timer_delete (timer_t __timerid) throw ();


extern int timer_settime (timer_t __timerid, int __flags,
     __const struct itimerspec *__restrict __value,
     struct itimerspec *__restrict __ovalue) throw ();


extern int timer_gettime (timer_t __timerid, struct itimerspec *__value)
     throw ();


extern int timer_getoverrun (timer_t __timerid) throw ();
# 390 "/usr/include/time.h" 3 4
extern int getdate_err;
# 399 "/usr/include/time.h" 3 4
extern struct tm *getdate (__const char *__string);
# 413 "/usr/include/time.h" 3 4
extern int getdate_r (__const char *__restrict __string,
        struct tm *__restrict __resbufp);


}
# 1278 "/usr/include/wx-2.8/wx/wxchar.h" 2
 wxChar *wxCtime(const time_t *timep);
# 1293 "/usr/include/wx-2.8/wx/wxchar.h"
    size_t wxMB2WC(wchar_t *buf, const char *psz, size_t n);
    size_t wxWC2MB(char *buf, const wchar_t *psz, size_t n);
# 1335 "/usr/include/wx-2.8/wx/wxchar.h"
# 1 "/usr/include/string.h" 1 3 4
# 29 "/usr/include/string.h" 3 4
extern "C" {




# 1 "/usr/lib/gcc/i686-linux-gnu/4.4.5/include/stddef.h" 1 3 4
# 35 "/usr/include/string.h" 2 3 4









extern void *memcpy (void *__restrict __dest,
       __const void *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern void *memmove (void *__dest, __const void *__src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));






extern void *memccpy (void *__restrict __dest, __const void *__restrict __src,
        int __c, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));





extern void *memset (void *__s, int __c, size_t __n) throw () __attribute__ ((__nonnull__ (1)));


extern int memcmp (__const void *__s1, __const void *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));



extern "C++"
{
extern void *memchr (void *__s, int __c, size_t __n)
      throw () __asm ("memchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern __const void *memchr (__const void *__s, int __c, size_t __n)
      throw () __asm ("memchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) void *
memchr (void *__s, int __c, size_t __n) throw ()
{
  return __builtin_memchr (__s, __c, __n);
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) __const void *
memchr (__const void *__s, int __c, size_t __n) throw ()
{
  return __builtin_memchr (__s, __c, __n);
}

}










extern "C++" void *rawmemchr (void *__s, int __c)
     throw () __asm ("rawmemchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern "C++" __const void *rawmemchr (__const void *__s, int __c)
     throw () __asm ("rawmemchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));







extern "C++" void *memrchr (void *__s, int __c, size_t __n)
      throw () __asm ("memrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern "C++" __const void *memrchr (__const void *__s, int __c, size_t __n)
      throw () __asm ("memrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));









extern char *strcpy (char *__restrict __dest, __const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));

extern char *strncpy (char *__restrict __dest,
        __const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern char *strcat (char *__restrict __dest, __const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));

extern char *strncat (char *__restrict __dest, __const char *__restrict __src,
        size_t __n) throw () __attribute__ ((__nonnull__ (1, 2)));


extern int strcmp (__const char *__s1, __const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern int strncmp (__const char *__s1, __const char *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strcoll (__const char *__s1, __const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern size_t strxfrm (char *__restrict __dest,
         __const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (2)));

# 165 "/usr/include/string.h" 3 4
extern int strcoll_l (__const char *__s1, __const char *__s2, __locale_t __l)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));

extern size_t strxfrm_l (char *__dest, __const char *__src, size_t __n,
    __locale_t __l) throw () __attribute__ ((__nonnull__ (2, 4)));





extern char *strdup (__const char *__s)
     throw () __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));






extern char *strndup (__const char *__string, size_t __n)
     throw () __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));
# 210 "/usr/include/string.h" 3 4



extern "C++"
{
extern char *strchr (char *__s, int __c)
     throw () __asm ("strchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern __const char *strchr (__const char *__s, int __c)
     throw () __asm ("strchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) char *
strchr (char *__s, int __c) throw ()
{
  return __builtin_strchr (__s, __c);
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) __const char *
strchr (__const char *__s, int __c) throw ()
{
  return __builtin_strchr (__s, __c);
}

}






extern "C++"
{
extern char *strrchr (char *__s, int __c)
     throw () __asm ("strrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern __const char *strrchr (__const char *__s, int __c)
     throw () __asm ("strrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) char *
strrchr (char *__s, int __c) throw ()
{
  return __builtin_strrchr (__s, __c);
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) __const char *
strrchr (__const char *__s, int __c) throw ()
{
  return __builtin_strrchr (__s, __c);
}

}










extern "C++" char *strchrnul (char *__s, int __c)
     throw () __asm ("strchrnul") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern "C++" __const char *strchrnul (__const char *__s, int __c)
     throw () __asm ("strchrnul") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));









extern size_t strcspn (__const char *__s, __const char *__reject)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern size_t strspn (__const char *__s, __const char *__accept)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern "C++"
{
extern char *strpbrk (char *__s, __const char *__accept)
     throw () __asm ("strpbrk") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
extern __const char *strpbrk (__const char *__s, __const char *__accept)
     throw () __asm ("strpbrk") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) char *
strpbrk (char *__s, __const char *__accept) throw ()
{
  return __builtin_strpbrk (__s, __accept);
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) __const char *
strpbrk (__const char *__s, __const char *__accept) throw ()
{
  return __builtin_strpbrk (__s, __accept);
}

}






extern "C++"
{
extern char *strstr (char *__haystack, __const char *__needle)
     throw () __asm ("strstr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
extern __const char *strstr (__const char *__haystack,
        __const char *__needle)
     throw () __asm ("strstr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) char *
strstr (char *__haystack, __const char *__needle) throw ()
{
  return __builtin_strstr (__haystack, __needle);
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) __const char *
strstr (__const char *__haystack, __const char *__needle) throw ()
{
  return __builtin_strstr (__haystack, __needle);
}

}







extern char *strtok (char *__restrict __s, __const char *__restrict __delim)
     throw () __attribute__ ((__nonnull__ (2)));




extern char *__strtok_r (char *__restrict __s,
    __const char *__restrict __delim,
    char **__restrict __save_ptr)
     throw () __attribute__ ((__nonnull__ (2, 3)));

extern char *strtok_r (char *__restrict __s, __const char *__restrict __delim,
         char **__restrict __save_ptr)
     throw () __attribute__ ((__nonnull__ (2, 3)));





extern "C++" char *strcasestr (char *__haystack, __const char *__needle)
     throw () __asm ("strcasestr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
extern "C++" __const char *strcasestr (__const char *__haystack,
           __const char *__needle)
     throw () __asm ("strcasestr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 382 "/usr/include/string.h" 3 4
extern void *memmem (__const void *__haystack, size_t __haystacklen,
       __const void *__needle, size_t __needlelen)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 3)));



extern void *__mempcpy (void *__restrict __dest,
   __const void *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern void *mempcpy (void *__restrict __dest,
        __const void *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));





extern size_t strlen (__const char *__s)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern size_t strnlen (__const char *__string, size_t __maxlen)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern char *strerror (int __errnum) throw ();

# 438 "/usr/include/string.h" 3 4
extern char *strerror_r (int __errnum, char *__buf, size_t __buflen)
     throw () __attribute__ ((__nonnull__ (2)));





extern char *strerror_l (int __errnum, __locale_t __l) throw ();





extern void __bzero (void *__s, size_t __n) throw () __attribute__ ((__nonnull__ (1)));



extern void bcopy (__const void *__src, void *__dest, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern void bzero (void *__s, size_t __n) throw () __attribute__ ((__nonnull__ (1)));


extern int bcmp (__const void *__s1, __const void *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));



extern "C++"
{
extern char *index (char *__s, int __c)
     throw () __asm ("index") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern __const char *index (__const char *__s, int __c)
     throw () __asm ("index") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) char *
index (char *__s, int __c) throw ()
{
  return __builtin_index (__s, __c);
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) __const char *
index (__const char *__s, int __c) throw ()
{
  return __builtin_index (__s, __c);
}

}







extern "C++"
{
extern char *rindex (char *__s, int __c)
     throw () __asm ("rindex") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern __const char *rindex (__const char *__s, int __c)
     throw () __asm ("rindex") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) char *
rindex (char *__s, int __c) throw ()
{
  return __builtin_rindex (__s, __c);
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) __const char *
rindex (__const char *__s, int __c) throw ()
{
  return __builtin_rindex (__s, __c);
}

}







extern int ffs (int __i) throw () __attribute__ ((__const__));




extern int ffsl (long int __l) throw () __attribute__ ((__const__));

__extension__ extern int ffsll (long long int __ll)
     throw () __attribute__ ((__const__));




extern int strcasecmp (__const char *__s1, __const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strncasecmp (__const char *__s1, __const char *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));





extern int strcasecmp_l (__const char *__s1, __const char *__s2,
    __locale_t __loc)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));

extern int strncasecmp_l (__const char *__s1, __const char *__s2,
     size_t __n, __locale_t __loc)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 4)));





extern char *strsep (char **__restrict __stringp,
       __const char *__restrict __delim)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern char *strsignal (int __sig) throw ();


extern char *__stpcpy (char *__restrict __dest, __const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern char *stpcpy (char *__restrict __dest, __const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern char *__stpncpy (char *__restrict __dest,
   __const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern char *stpncpy (char *__restrict __dest,
        __const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern int strverscmp (__const char *__s1, __const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern char *strfry (char *__string) throw () __attribute__ ((__nonnull__ (1)));


extern void *memfrob (void *__s, size_t __n) throw () __attribute__ ((__nonnull__ (1)));







extern "C++" char *basename (char *__filename)
     throw () __asm ("basename") __attribute__ ((__nonnull__ (1)));
extern "C++" __const char *basename (__const char *__filename)
     throw () __asm ("basename") __attribute__ ((__nonnull__ (1)));
# 642 "/usr/include/string.h" 3 4
# 1 "/usr/include/bits/string3.h" 1 3 4
# 23 "/usr/include/bits/string3.h" 3 4
extern void __warn_memset_zero_len (void) __attribute__((__warning__ ("memset used with constant zero length parameter; this could be due to transposed parameters")));
# 48 "/usr/include/bits/string3.h" 3 4
extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) void *
memcpy (void *__restrict __dest, __const void *__restrict __src, size_t __len) throw ()

{
  return __builtin___memcpy_chk (__dest, __src, __len, __builtin_object_size (__dest, 0));
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) void *
memmove (void *__restrict __dest, __const void *__restrict __src, size_t __len) throw ()

{
  return __builtin___memmove_chk (__dest, __src, __len, __builtin_object_size (__dest, 0));
}


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) void *
mempcpy (void *__restrict __dest, __const void *__restrict __src, size_t __len) throw ()

{
  return __builtin___mempcpy_chk (__dest, __src, __len, __builtin_object_size (__dest, 0));
}
# 77 "/usr/include/bits/string3.h" 3 4
extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) void *
memset (void *__dest, int __ch, size_t __len) throw ()
{
  if (__builtin_constant_p (__len) && __len == 0
      && (!__builtin_constant_p (__ch) || __ch != 0))
    {
      __warn_memset_zero_len ();
      return __dest;
    }
  return __builtin___memset_chk (__dest, __ch, __len, __builtin_object_size (__dest, 0));
}


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) void
bcopy (__const void *__restrict __src, void *__restrict __dest, size_t __len) throw ()

{
  (void) __builtin___memmove_chk (__dest, __src, __len, __builtin_object_size (__dest, 0));
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) void
bzero (void *__dest, size_t __len) throw ()
{
  (void) __builtin___memset_chk (__dest, '\0', __len, __builtin_object_size (__dest, 0));
}


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) char *
strcpy (char *__restrict __dest, __const char *__restrict __src) throw ()
{
  return __builtin___strcpy_chk (__dest, __src, __builtin_object_size (__dest, 2 > 1));
}


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) char *
stpcpy (char *__restrict __dest, __const char *__restrict __src) throw ()
{
  return __builtin___stpcpy_chk (__dest, __src, __builtin_object_size (__dest, 2 > 1));
}



extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) char *
strncpy (char *__restrict __dest, __const char *__restrict __src, size_t __len) throw ()

{
  return __builtin___strncpy_chk (__dest, __src, __len, __builtin_object_size (__dest, 2 > 1));
}


extern char *__stpncpy_chk (char *__dest, __const char *__src, size_t __n,
       size_t __destlen) throw ();
extern char *__stpncpy_alias (char *__dest, __const char *__src, size_t __n) throw () __asm__ ("" "stpncpy");



extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) char *
stpncpy (char *__dest, __const char *__src, size_t __n) throw ()
{
  if (__builtin_object_size (__dest, 2 > 1) != (size_t) -1
      && (!__builtin_constant_p (__n) || __n <= __builtin_object_size (__dest, 2 > 1)))
    return __stpncpy_chk (__dest, __src, __n, __builtin_object_size (__dest, 2 > 1));
  return __stpncpy_alias (__dest, __src, __n);
}


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) char *
strcat (char *__restrict __dest, __const char *__restrict __src) throw ()
{
  return __builtin___strcat_chk (__dest, __src, __builtin_object_size (__dest, 2 > 1));
}


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) char *
strncat (char *__restrict __dest, __const char *__restrict __src, size_t __len) throw ()

{
  return __builtin___strncat_chk (__dest, __src, __len, __builtin_object_size (__dest, 2 > 1));
}
# 643 "/usr/include/string.h" 2 3 4



}
# 1336 "/usr/include/wx-2.8/wx/wxchar.h" 2


        inline wxChar* wxTmemchr(const wxChar* s, wxChar c, size_t l)
        {
            for(;l && *s != c;--l, ++s) {}

            if(l)
                return (wxChar*)s;
            return __null;
        }

        inline int wxTmemcmp(const wxChar* sz1, const wxChar* sz2, size_t len)
        {
            for(; *sz1 == *sz2 && len; --len, ++sz1, ++sz2) {}

            if(len)
                return *sz1 < *sz2 ? -1 : *sz1 > *sz2;
            else
                return 0;
        }

        inline wxChar* wxTmemcpy(wxChar* szOut, const wxChar* szIn, size_t len)
        {
            return (wxChar*) memcpy(szOut, szIn, len * sizeof(wxChar));
        }

        inline wxChar* wxTmemmove(wxChar* szOut, const wxChar* szIn, size_t len)
        {
            return (wxChar*) memmove(szOut, szIn, len * sizeof(wxChar));
        }

        inline wxChar* wxTmemset(wxChar* szOut, const wxChar cIn, size_t len)
        {
            wxChar* szRet = szOut;

            while (len--)
                *szOut++ = cIn;

            return szRet;
        }
# 23 "/usr/include/wx-2.8/wx/debug.h" 2
# 168 "/usr/include/wx-2.8/wx/debug.h"
    extern const bool wxFalse;
# 312 "/usr/include/wx-2.8/wx/debug.h"
        inline bool wxIsDebuggerRunning() { return false; }
# 522 "/usr/include/wx-2.8/wx/defs.h" 2





# 1 "/usr/lib/gcc/i686-linux-gnu/4.4.5/include/stddef.h" 1 3 4
# 149 "/usr/lib/gcc/i686-linux-gnu/4.4.5/include/stddef.h" 3 4
typedef int ptrdiff_t;
# 528 "/usr/include/wx-2.8/wx/defs.h" 2
# 602 "/usr/include/wx-2.8/wx/defs.h"
        template <class T>
            inline void wxUnusedVar(const T& ) { }
# 651 "/usr/include/wx-2.8/wx/defs.h"
typedef int wxCoord;

enum { wxDefaultCoord = -1 };
# 670 "/usr/include/wx-2.8/wx/defs.h"
typedef signed char wxInt8;
typedef unsigned char wxUint8;
typedef wxUint8 wxByte;
# 684 "/usr/include/wx-2.8/wx/defs.h"
typedef signed short wxInt16;
typedef unsigned short wxUint16;

typedef wxUint16 wxWord;
# 781 "/usr/include/wx-2.8/wx/defs.h"
            typedef int wxInt32;
            typedef unsigned int wxUint32;
# 824 "/usr/include/wx-2.8/wx/defs.h"
typedef wxUint32 wxDword;






    typedef unsigned long wxUIntPtr;
# 845 "/usr/include/wx-2.8/wx/defs.h"
inline wxUIntPtr wxPtrToUInt(const void *p)
{
# 864 "/usr/include/wx-2.8/wx/defs.h"
    return reinterpret_cast<wxUIntPtr>(p);




}

inline void *wxUIntToPtr(wxUIntPtr p)
{
# 885 "/usr/include/wx-2.8/wx/defs.h"
    return reinterpret_cast<void *>(p);




}
# 978 "/usr/include/wx-2.8/wx/defs.h"
    typedef long long wxInt64;
    typedef unsigned long long wxUint64;
# 1034 "/usr/include/wx-2.8/wx/defs.h"
typedef float wxFloat32;



    typedef double wxFloat64;


typedef double wxDouble;
# 1213 "/usr/include/wx-2.8/wx/defs.h"
enum wxGeometryCentre
{
    wxCENTRE = 0x0001,
    wxCENTER = wxCENTRE
};







enum wxOrientation
{

    wxHORIZONTAL = 0x0004,
    wxVERTICAL = 0x0008,

    wxBOTH = wxVERTICAL | wxHORIZONTAL
};

enum wxDirection
{
    wxLEFT = 0x0010,
    wxRIGHT = 0x0020,
    wxUP = 0x0040,
    wxDOWN = 0x0080,

    wxTOP = wxUP,
    wxBOTTOM = wxDOWN,

    wxNORTH = wxUP,
    wxSOUTH = wxDOWN,
    wxWEST = wxLEFT,
    wxEAST = wxRIGHT,

    wxALL = (wxUP | wxDOWN | wxRIGHT | wxLEFT)
};

enum wxAlignment
{
    wxALIGN_NOT = 0x0000,
    wxALIGN_CENTER_HORIZONTAL = 0x0100,
    wxALIGN_CENTRE_HORIZONTAL = wxALIGN_CENTER_HORIZONTAL,
    wxALIGN_LEFT = wxALIGN_NOT,
    wxALIGN_TOP = wxALIGN_NOT,
    wxALIGN_RIGHT = 0x0200,
    wxALIGN_BOTTOM = 0x0400,
    wxALIGN_CENTER_VERTICAL = 0x0800,
    wxALIGN_CENTRE_VERTICAL = wxALIGN_CENTER_VERTICAL,

    wxALIGN_CENTER = (wxALIGN_CENTER_HORIZONTAL | wxALIGN_CENTER_VERTICAL),
    wxALIGN_CENTRE = wxALIGN_CENTER,


    wxALIGN_MASK = 0x0f00
};

enum wxStretch
{
    wxSTRETCH_NOT = 0x0000,
    wxSHRINK = 0x1000,
    wxGROW = 0x2000,
    wxEXPAND = wxGROW,
    wxSHAPED = 0x4000,
    wxFIXED_MINSIZE = 0x8000,

    wxRESERVE_SPACE_EVEN_IF_HIDDEN = 0x0002,

    wxTILE = 0xc000,





    wxADJUST_MINSIZE = 0

};


enum wxBorder
{


    wxBORDER_DEFAULT = 0,

    wxBORDER_NONE = 0x00200000,
    wxBORDER_STATIC = 0x01000000,
    wxBORDER_SIMPLE = 0x02000000,
    wxBORDER_RAISED = 0x04000000,
    wxBORDER_SUNKEN = 0x08000000,
    wxBORDER_DOUBLE = 0x10000000,
    wxBORDER_THEME = 0x10000000,


    wxBORDER_MASK = 0x1f200000
};
# 1627 "/usr/include/wx-2.8/wx/defs.h"
enum wxBackgroundStyle
{
  wxBG_STYLE_SYSTEM,
  wxBG_STYLE_COLOUR,
  wxBG_STYLE_CUSTOM
};






enum
{

    wxID_NONE = -3,


    wxID_SEPARATOR = -2,



    wxID_ANY = -1,



    wxID_LOWEST = 4999,

    wxID_OPEN,
    wxID_CLOSE,
    wxID_NEW,
    wxID_SAVE,
    wxID_SAVEAS,
    wxID_REVERT,
    wxID_EXIT,
    wxID_UNDO,
    wxID_REDO,
    wxID_HELP,
    wxID_PRINT,
    wxID_PRINT_SETUP,
    wxID_PAGE_SETUP,
    wxID_PREVIEW,
    wxID_ABOUT,
    wxID_HELP_CONTENTS,
    wxID_HELP_INDEX,
    wxID_HELP_SEARCH,
    wxID_HELP_COMMANDS,
    wxID_HELP_PROCEDURES,
    wxID_HELP_CONTEXT,
    wxID_CLOSE_ALL,
    wxID_PREFERENCES,

    wxID_EDIT = 5030,
    wxID_CUT,
    wxID_COPY,
    wxID_PASTE,
    wxID_CLEAR,
    wxID_FIND,
    wxID_DUPLICATE,
    wxID_SELECTALL,
    wxID_DELETE,
    wxID_REPLACE,
    wxID_REPLACE_ALL,
    wxID_PROPERTIES,

    wxID_VIEW_DETAILS,
    wxID_VIEW_LARGEICONS,
    wxID_VIEW_SMALLICONS,
    wxID_VIEW_LIST,
    wxID_VIEW_SORTDATE,
    wxID_VIEW_SORTNAME,
    wxID_VIEW_SORTSIZE,
    wxID_VIEW_SORTTYPE,

    wxID_FILE = 5050,
    wxID_FILE1,
    wxID_FILE2,
    wxID_FILE3,
    wxID_FILE4,
    wxID_FILE5,
    wxID_FILE6,
    wxID_FILE7,
    wxID_FILE8,
    wxID_FILE9,


    wxID_OK = 5100,
    wxID_CANCEL,
    wxID_APPLY,
    wxID_YES,
    wxID_NO,
    wxID_STATIC,
    wxID_FORWARD,
    wxID_BACKWARD,
    wxID_DEFAULT,
    wxID_MORE,
    wxID_SETUP,
    wxID_RESET,
    wxID_CONTEXT_HELP,
    wxID_YESTOALL,
    wxID_NOTOALL,
    wxID_ABORT,
    wxID_RETRY,
    wxID_IGNORE,
    wxID_ADD,
    wxID_REMOVE,

    wxID_UP,
    wxID_DOWN,
    wxID_HOME,
    wxID_REFRESH,
    wxID_STOP,
    wxID_INDEX,

    wxID_BOLD,
    wxID_ITALIC,
    wxID_JUSTIFY_CENTER,
    wxID_JUSTIFY_FILL,
    wxID_JUSTIFY_RIGHT,
    wxID_JUSTIFY_LEFT,
    wxID_UNDERLINE,
    wxID_INDENT,
    wxID_UNINDENT,
    wxID_ZOOM_100,
    wxID_ZOOM_FIT,
    wxID_ZOOM_IN,
    wxID_ZOOM_OUT,
    wxID_UNDELETE,
    wxID_REVERT_TO_SAVED,


    wxID_SYSTEM_MENU = 5200,
    wxID_CLOSE_FRAME,
    wxID_MOVE_FRAME,
    wxID_RESIZE_FRAME,
    wxID_MAXIMIZE_FRAME,
    wxID_ICONIZE_FRAME,
    wxID_RESTORE_FRAME,


    wxID_FILEDLGG = 5900,

    wxID_HIGHEST = 5999
};






enum wxItemKind
{
    wxITEM_SEPARATOR = -1,
    wxITEM_NORMAL,
    wxITEM_CHECK,
    wxITEM_RADIO,
    wxITEM_MAX
};


enum wxHitTest
{
    wxHT_NOWHERE,


    wxHT_SCROLLBAR_FIRST = wxHT_NOWHERE,
    wxHT_SCROLLBAR_ARROW_LINE_1,
    wxHT_SCROLLBAR_ARROW_LINE_2,
    wxHT_SCROLLBAR_ARROW_PAGE_1,
    wxHT_SCROLLBAR_ARROW_PAGE_2,
    wxHT_SCROLLBAR_THUMB,
    wxHT_SCROLLBAR_BAR_1,
    wxHT_SCROLLBAR_BAR_2,
    wxHT_SCROLLBAR_LAST,


    wxHT_WINDOW_OUTSIDE,
    wxHT_WINDOW_INSIDE,
    wxHT_WINDOW_VERT_SCROLLBAR,
    wxHT_WINDOW_HORZ_SCROLLBAR,
    wxHT_WINDOW_CORNER,

    wxHT_MAX
};
# 1836 "/usr/include/wx-2.8/wx/defs.h"
enum
{

    wxDEFAULT = 70,
    wxDECORATIVE,
    wxROMAN,
    wxSCRIPT,
    wxSWISS,
    wxMODERN,
    wxTELETYPE,


    wxVARIABLE = 80,
    wxFIXED,

    wxNORMAL = 90,
    wxLIGHT,
    wxBOLD,

    wxITALIC,
    wxSLANT,


    wxSOLID = 100,
    wxDOT,
    wxLONG_DASH,
    wxSHORT_DASH,
    wxDOT_DASH,
    wxUSER_DASH,

    wxTRANSPARENT,



    wxSTIPPLE_MASK_OPAQUE,
    wxSTIPPLE_MASK,

    wxSTIPPLE = 110,

    wxBDIAGONAL_HATCH,
    wxCROSSDIAG_HATCH,
    wxFDIAGONAL_HATCH,
    wxCROSS_HATCH,
    wxHORIZONTAL_HATCH,
    wxVERTICAL_HATCH,
    wxFIRST_HATCH = wxBDIAGONAL_HATCH,
    wxLAST_HATCH = wxVERTICAL_HATCH,

    wxJOIN_BEVEL = 120,
    wxJOIN_MITER,
    wxJOIN_ROUND,

    wxCAP_ROUND = 130,
    wxCAP_PROJECTING,
    wxCAP_BUTT
};
# 1900 "/usr/include/wx-2.8/wx/defs.h"
typedef enum
{
    wxCLEAR, wxROP_BLACK = wxCLEAR, wxBLIT_BLACKNESS = wxCLEAR,
    wxXOR, wxROP_XORPEN = wxXOR, wxBLIT_SRCINVERT = wxXOR,
    wxINVERT, wxROP_NOT = wxINVERT, wxBLIT_DSTINVERT = wxINVERT,
    wxOR_REVERSE, wxROP_MERGEPENNOT = wxOR_REVERSE, wxBLIT_00DD0228 = wxOR_REVERSE,
    wxAND_REVERSE, wxROP_MASKPENNOT = wxAND_REVERSE, wxBLIT_SRCERASE = wxAND_REVERSE,
    wxCOPY, wxROP_COPYPEN = wxCOPY, wxBLIT_SRCCOPY = wxCOPY,
    wxAND, wxROP_MASKPEN = wxAND, wxBLIT_SRCAND = wxAND,
    wxAND_INVERT, wxROP_MASKNOTPEN = wxAND_INVERT, wxBLIT_00220326 = wxAND_INVERT,
    wxNO_OP, wxROP_NOP = wxNO_OP, wxBLIT_00AA0029 = wxNO_OP,
    wxNOR, wxROP_NOTMERGEPEN = wxNOR, wxBLIT_NOTSRCERASE = wxNOR,
    wxEQUIV, wxROP_NOTXORPEN = wxEQUIV, wxBLIT_00990066 = wxEQUIV,
    wxSRC_INVERT, wxROP_NOTCOPYPEN = wxSRC_INVERT, wxBLIT_NOTSCRCOPY = wxSRC_INVERT,
    wxOR_INVERT, wxROP_MERGENOTPEN = wxOR_INVERT, wxBLIT_MERGEPAINT = wxOR_INVERT,
    wxNAND, wxROP_NOTMASKPEN = wxNAND, wxBLIT_007700E6 = wxNAND,
    wxOR, wxROP_MERGEPEN = wxOR, wxBLIT_SRCPAINT = wxOR,
    wxSET, wxROP_WHITE = wxSET, wxBLIT_WHITENESS = wxSET
} form_ops_t;


enum
{
    wxFLOOD_SURFACE = 1,
    wxFLOOD_BORDER
};


enum
{
    wxODDEVEN_RULE = 1,
    wxWINDING_RULE
};


enum
{
    wxTOOL_TOP = 1,
    wxTOOL_BOTTOM,
    wxTOOL_LEFT,
    wxTOOL_RIGHT
};



enum wxDataFormatId
{
    wxDF_INVALID = 0,
    wxDF_TEXT = 1,
    wxDF_BITMAP = 2,
    wxDF_METAFILE = 3,
    wxDF_SYLK = 4,
    wxDF_DIF = 5,
    wxDF_TIFF = 6,
    wxDF_OEMTEXT = 7,
    wxDF_DIB = 8,
    wxDF_PALETTE = 9,
    wxDF_PENDATA = 10,
    wxDF_RIFF = 11,
    wxDF_WAVE = 12,
    wxDF_UNICODETEXT = 13,
    wxDF_ENHMETAFILE = 14,
    wxDF_FILENAME = 15,
    wxDF_LOCALE = 16,
    wxDF_PRIVATE = 20,
    wxDF_HTML = 30,
    wxDF_MAX
};


enum wxKeyCode
{
    WXK_BACK = 8,
    WXK_TAB = 9,
    WXK_RETURN = 13,
    WXK_ESCAPE = 27,
    WXK_SPACE = 32,
    WXK_DELETE = 127,




    WXK_START = 300,
    WXK_LBUTTON,
    WXK_RBUTTON,
    WXK_CANCEL,
    WXK_MBUTTON,
    WXK_CLEAR,
    WXK_SHIFT,
    WXK_ALT,
    WXK_CONTROL,
    WXK_MENU,
    WXK_PAUSE,
    WXK_CAPITAL,
    WXK_END,
    WXK_HOME,
    WXK_LEFT,
    WXK_UP,
    WXK_RIGHT,
    WXK_DOWN,
    WXK_SELECT,
    WXK_PRINT,
    WXK_EXECUTE,
    WXK_SNAPSHOT,
    WXK_INSERT,
    WXK_HELP,
    WXK_NUMPAD0,
    WXK_NUMPAD1,
    WXK_NUMPAD2,
    WXK_NUMPAD3,
    WXK_NUMPAD4,
    WXK_NUMPAD5,
    WXK_NUMPAD6,
    WXK_NUMPAD7,
    WXK_NUMPAD8,
    WXK_NUMPAD9,
    WXK_MULTIPLY,
    WXK_ADD,
    WXK_SEPARATOR,
    WXK_SUBTRACT,
    WXK_DECIMAL,
    WXK_DIVIDE,
    WXK_F1,
    WXK_F2,
    WXK_F3,
    WXK_F4,
    WXK_F5,
    WXK_F6,
    WXK_F7,
    WXK_F8,
    WXK_F9,
    WXK_F10,
    WXK_F11,
    WXK_F12,
    WXK_F13,
    WXK_F14,
    WXK_F15,
    WXK_F16,
    WXK_F17,
    WXK_F18,
    WXK_F19,
    WXK_F20,
    WXK_F21,
    WXK_F22,
    WXK_F23,
    WXK_F24,
    WXK_NUMLOCK,
    WXK_SCROLL,
    WXK_PAGEUP,
    WXK_PAGEDOWN,

    WXK_PRIOR = WXK_PAGEUP,
    WXK_NEXT = WXK_PAGEDOWN,


    WXK_NUMPAD_SPACE,
    WXK_NUMPAD_TAB,
    WXK_NUMPAD_ENTER,
    WXK_NUMPAD_F1,
    WXK_NUMPAD_F2,
    WXK_NUMPAD_F3,
    WXK_NUMPAD_F4,
    WXK_NUMPAD_HOME,
    WXK_NUMPAD_LEFT,
    WXK_NUMPAD_UP,
    WXK_NUMPAD_RIGHT,
    WXK_NUMPAD_DOWN,
    WXK_NUMPAD_PAGEUP,
    WXK_NUMPAD_PAGEDOWN,

    WXK_NUMPAD_PRIOR = WXK_NUMPAD_PAGEUP,
    WXK_NUMPAD_NEXT = WXK_NUMPAD_PAGEDOWN,

    WXK_NUMPAD_END,
    WXK_NUMPAD_BEGIN,
    WXK_NUMPAD_INSERT,
    WXK_NUMPAD_DELETE,
    WXK_NUMPAD_EQUAL,
    WXK_NUMPAD_MULTIPLY,
    WXK_NUMPAD_ADD,
    WXK_NUMPAD_SEPARATOR,
    WXK_NUMPAD_SUBTRACT,
    WXK_NUMPAD_DECIMAL,
    WXK_NUMPAD_DIVIDE,

    WXK_WINDOWS_LEFT,
    WXK_WINDOWS_RIGHT,
    WXK_WINDOWS_MENU ,
    WXK_COMMAND,


    WXK_SPECIAL1 = 193,
    WXK_SPECIAL2,
    WXK_SPECIAL3,
    WXK_SPECIAL4,
    WXK_SPECIAL5,
    WXK_SPECIAL6,
    WXK_SPECIAL7,
    WXK_SPECIAL8,
    WXK_SPECIAL9,
    WXK_SPECIAL10,
    WXK_SPECIAL11,
    WXK_SPECIAL12,
    WXK_SPECIAL13,
    WXK_SPECIAL14,
    WXK_SPECIAL15,
    WXK_SPECIAL16,
    WXK_SPECIAL17,
    WXK_SPECIAL18,
    WXK_SPECIAL19,
    WXK_SPECIAL20
};


enum wxKeyModifier
{
    wxMOD_NONE = 0x0000,
    wxMOD_ALT = 0x0001,
    wxMOD_CONTROL = 0x0002,
    wxMOD_ALTGR = wxMOD_ALT | wxMOD_CONTROL,
    wxMOD_SHIFT = 0x0004,
    wxMOD_META = 0x0008,
    wxMOD_WIN = wxMOD_META,



    wxMOD_CMD = wxMOD_CONTROL,

    wxMOD_ALL = 0xffff
};


enum
{
    wxMM_TEXT = 1,
    wxMM_LOMETRIC,
    wxMM_HIMETRIC,
    wxMM_LOENGLISH,
    wxMM_HIENGLISH,
    wxMM_TWIPS,
    wxMM_ISOTROPIC,
    wxMM_ANISOTROPIC,
    wxMM_POINTS,
    wxMM_METRIC
};





typedef enum
{
    wxPAPER_NONE,
    wxPAPER_LETTER,
    wxPAPER_LEGAL,
    wxPAPER_A4,
    wxPAPER_CSHEET,
    wxPAPER_DSHEET,
    wxPAPER_ESHEET,
    wxPAPER_LETTERSMALL,
    wxPAPER_TABLOID,
    wxPAPER_LEDGER,
    wxPAPER_STATEMENT,
    wxPAPER_EXECUTIVE,
    wxPAPER_A3,
    wxPAPER_A4SMALL,
    wxPAPER_A5,
    wxPAPER_B4,
    wxPAPER_B5,
    wxPAPER_FOLIO,
    wxPAPER_QUARTO,
    wxPAPER_10X14,
    wxPAPER_11X17,
    wxPAPER_NOTE,
    wxPAPER_ENV_9,
    wxPAPER_ENV_10,
    wxPAPER_ENV_11,
    wxPAPER_ENV_12,
    wxPAPER_ENV_14,
    wxPAPER_ENV_DL,
    wxPAPER_ENV_C5,
    wxPAPER_ENV_C3,
    wxPAPER_ENV_C4,
    wxPAPER_ENV_C6,
    wxPAPER_ENV_C65,
    wxPAPER_ENV_B4,
    wxPAPER_ENV_B5,
    wxPAPER_ENV_B6,
    wxPAPER_ENV_ITALY,
    wxPAPER_ENV_MONARCH,
    wxPAPER_ENV_PERSONAL,
    wxPAPER_FANFOLD_US,
    wxPAPER_FANFOLD_STD_GERMAN,
    wxPAPER_FANFOLD_LGL_GERMAN,

    wxPAPER_ISO_B4,
    wxPAPER_JAPANESE_POSTCARD,
    wxPAPER_9X11,
    wxPAPER_10X11,
    wxPAPER_15X11,
    wxPAPER_ENV_INVITE,
    wxPAPER_LETTER_EXTRA,
    wxPAPER_LEGAL_EXTRA,
    wxPAPER_TABLOID_EXTRA,
    wxPAPER_A4_EXTRA,
    wxPAPER_LETTER_TRANSVERSE,
    wxPAPER_A4_TRANSVERSE,
    wxPAPER_LETTER_EXTRA_TRANSVERSE,
    wxPAPER_A_PLUS,
    wxPAPER_B_PLUS,
    wxPAPER_LETTER_PLUS,
    wxPAPER_A4_PLUS,
    wxPAPER_A5_TRANSVERSE,
    wxPAPER_B5_TRANSVERSE,
    wxPAPER_A3_EXTRA,
    wxPAPER_A5_EXTRA,
    wxPAPER_B5_EXTRA,
    wxPAPER_A2,
    wxPAPER_A3_TRANSVERSE,
    wxPAPER_A3_EXTRA_TRANSVERSE,

    wxPAPER_DBL_JAPANESE_POSTCARD,
    wxPAPER_A6,
    wxPAPER_JENV_KAKU2,
    wxPAPER_JENV_KAKU3,
    wxPAPER_JENV_CHOU3,
    wxPAPER_JENV_CHOU4,
    wxPAPER_LETTER_ROTATED,
    wxPAPER_A3_ROTATED,
    wxPAPER_A4_ROTATED,
    wxPAPER_A5_ROTATED,
    wxPAPER_B4_JIS_ROTATED,
    wxPAPER_B5_JIS_ROTATED,
    wxPAPER_JAPANESE_POSTCARD_ROTATED,
    wxPAPER_DBL_JAPANESE_POSTCARD_ROTATED,
    wxPAPER_A6_ROTATED,
    wxPAPER_JENV_KAKU2_ROTATED,
    wxPAPER_JENV_KAKU3_ROTATED,
    wxPAPER_JENV_CHOU3_ROTATED,
    wxPAPER_JENV_CHOU4_ROTATED,
    wxPAPER_B6_JIS,
    wxPAPER_B6_JIS_ROTATED,
    wxPAPER_12X11,
    wxPAPER_JENV_YOU4,
    wxPAPER_JENV_YOU4_ROTATED,
    wxPAPER_P16K,
    wxPAPER_P32K,
    wxPAPER_P32KBIG,
    wxPAPER_PENV_1,
    wxPAPER_PENV_2,
    wxPAPER_PENV_3,
    wxPAPER_PENV_4,
    wxPAPER_PENV_5,
    wxPAPER_PENV_6,
    wxPAPER_PENV_7,
    wxPAPER_PENV_8,
    wxPAPER_PENV_9,
    wxPAPER_PENV_10,
    wxPAPER_P16K_ROTATED,
    wxPAPER_P32K_ROTATED,
    wxPAPER_P32KBIG_ROTATED,
    wxPAPER_PENV_1_ROTATED,
    wxPAPER_PENV_2_ROTATED,
    wxPAPER_PENV_3_ROTATED,
    wxPAPER_PENV_4_ROTATED,
    wxPAPER_PENV_5_ROTATED,
    wxPAPER_PENV_6_ROTATED,
    wxPAPER_PENV_7_ROTATED,
    wxPAPER_PENV_8_ROTATED,
    wxPAPER_PENV_9_ROTATED,
    wxPAPER_PENV_10_ROTATED
} wxPaperSize;
# 2282 "/usr/include/wx-2.8/wx/defs.h"
enum wxDuplexMode
{
    wxDUPLEX_SIMPLEX,
    wxDUPLEX_HORIZONTAL,
    wxDUPLEX_VERTICAL
};
# 2297 "/usr/include/wx-2.8/wx/defs.h"
typedef int wxPrintQuality;




enum wxPrintMode
{
    wxPRINT_MODE_NONE = 0,
    wxPRINT_MODE_PREVIEW = 1,
    wxPRINT_MODE_FILE = 2,
    wxPRINT_MODE_PRINTER = 3,
    wxPRINT_MODE_STREAM = 4
};





enum wxUpdateUI
{
    wxUPDATE_UI_NONE = 0x0000,
    wxUPDATE_UI_RECURSE = 0x0001,
    wxUPDATE_UI_FROMIDLE = 0x0002
};





enum wxNotificationOptions
{
    wxNOTIFY_NONE = 0x0000,
    wxNOTIFY_ONCE = 0x0001,
    wxNOTIFY_REPEAT = 0x0002
};
# 2772 "/usr/include/wx-2.8/wx/defs.h"
typedef char gchar;
typedef signed char gint8;
typedef int gint;
typedef unsigned guint;
typedef unsigned long gulong;
typedef void* gpointer;
typedef struct _GSList GSList;


typedef struct _GdkColor GdkColor;
typedef struct _GdkColormap GdkColormap;
typedef struct _GdkFont GdkFont;
typedef struct _GdkGC GdkGC;
typedef struct _GdkVisual GdkVisual;


typedef struct _GdkAtom *GdkAtom;
typedef struct _GdkDrawable GdkWindow;
typedef struct _GdkDrawable GdkBitmap;
typedef struct _GdkDrawable GdkPixmap;







typedef struct _GdkCursor GdkCursor;
typedef struct _GdkRegion GdkRegion;
typedef struct _GdkDragContext GdkDragContext;







typedef struct _GtkWidget GtkWidget;
typedef struct _GtkRcStyle GtkRcStyle;
typedef struct _GtkAdjustment GtkAdjustment;
typedef struct _GtkList GtkList;
typedef struct _GtkToolbar GtkToolbar;
typedef struct _GtkTooltips GtkTooltips;
typedef struct _GtkNotebook GtkNotebook;
typedef struct _GtkNotebookPage GtkNotebookPage;
typedef struct _GtkAccelGroup GtkAccelGroup;
typedef struct _GtkItemFactory GtkItemFactory;
typedef struct _GtkSelectionData GtkSelectionData;
typedef struct _GtkTextBuffer GtkTextBuffer;
typedef struct _GtkRange GtkRange;

typedef GtkWidget *WXWidget;
# 2840 "/usr/include/wx-2.8/wx/defs.h"
typedef struct _PangoContext PangoContext;
typedef struct _PangoLayout PangoLayout;
typedef struct _PangoFontDescription PangoFontDescription;
# 16 "/usr/include/wx-2.8/wx/wx.h" 2
# 1 "/usr/include/wx-2.8/wx/object.h" 1
# 20 "/usr/include/wx-2.8/wx/object.h"
# 1 "/usr/include/wx-2.8/wx/memory.h" 1
# 16 "/usr/include/wx-2.8/wx/memory.h"
# 1 "/usr/include/wx-2.8/wx/string.h" 1
# 42 "/usr/include/wx-2.8/wx/string.h"
# 1 "/usr/lib/gcc/i686-linux-gnu/4.4.5/include-fixed/limits.h" 1 3 4
# 43 "/usr/include/wx-2.8/wx/string.h" 2
# 1 "/usr/include/stdlib.h" 1 3 4
# 33 "/usr/include/stdlib.h" 3 4
# 1 "/usr/lib/gcc/i686-linux-gnu/4.4.5/include/stddef.h" 1 3 4
# 34 "/usr/include/stdlib.h" 2 3 4

extern "C" {






# 1 "/usr/include/bits/waitflags.h" 1 3 4
# 43 "/usr/include/stdlib.h" 2 3 4
# 1 "/usr/include/bits/waitstatus.h" 1 3 4
# 67 "/usr/include/bits/waitstatus.h" 3 4
union wait
  {
    int w_status;
    struct
      {

 unsigned int __w_termsig:7;
 unsigned int __w_coredump:1;
 unsigned int __w_retcode:8;
 unsigned int:16;







      } __wait_terminated;
    struct
      {

 unsigned int __w_stopval:8;
 unsigned int __w_stopsig:8;
 unsigned int:16;






      } __wait_stopped;
  };
# 44 "/usr/include/stdlib.h" 2 3 4
# 96 "/usr/include/stdlib.h" 3 4


typedef struct
  {
    int quot;
    int rem;
  } div_t;



typedef struct
  {
    long int quot;
    long int rem;
  } ldiv_t;







__extension__ typedef struct
  {
    long long int quot;
    long long int rem;
  } lldiv_t;


# 140 "/usr/include/stdlib.h" 3 4
extern size_t __ctype_get_mb_cur_max (void) throw () __attribute__ ((__warn_unused_result__));




extern double atof (__const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));

extern int atoi (__const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));

extern long int atol (__const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));





__extension__ extern long long int atoll (__const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));





extern double strtod (__const char *__restrict __nptr,
        char **__restrict __endptr)
     throw () __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));





extern float strtof (__const char *__restrict __nptr,
       char **__restrict __endptr) throw () __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));

extern long double strtold (__const char *__restrict __nptr,
       char **__restrict __endptr)
     throw () __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));





extern long int strtol (__const char *__restrict __nptr,
   char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));

extern unsigned long int strtoul (__const char *__restrict __nptr,
      char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));




__extension__
extern long long int strtoq (__const char *__restrict __nptr,
        char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));

__extension__
extern unsigned long long int strtouq (__const char *__restrict __nptr,
           char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));





__extension__
extern long long int strtoll (__const char *__restrict __nptr,
         char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));

__extension__
extern unsigned long long int strtoull (__const char *__restrict __nptr,
     char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));

# 240 "/usr/include/stdlib.h" 3 4
extern long int strtol_l (__const char *__restrict __nptr,
     char **__restrict __endptr, int __base,
     __locale_t __loc) throw () __attribute__ ((__nonnull__ (1, 4))) __attribute__ ((__warn_unused_result__));

extern unsigned long int strtoul_l (__const char *__restrict __nptr,
        char **__restrict __endptr,
        int __base, __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 4))) __attribute__ ((__warn_unused_result__));

__extension__
extern long long int strtoll_l (__const char *__restrict __nptr,
    char **__restrict __endptr, int __base,
    __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 4))) __attribute__ ((__warn_unused_result__));

__extension__
extern unsigned long long int strtoull_l (__const char *__restrict __nptr,
       char **__restrict __endptr,
       int __base, __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 4))) __attribute__ ((__warn_unused_result__));

extern double strtod_l (__const char *__restrict __nptr,
   char **__restrict __endptr, __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3))) __attribute__ ((__warn_unused_result__));

extern float strtof_l (__const char *__restrict __nptr,
         char **__restrict __endptr, __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3))) __attribute__ ((__warn_unused_result__));

extern long double strtold_l (__const char *__restrict __nptr,
         char **__restrict __endptr,
         __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3))) __attribute__ ((__warn_unused_result__));





extern __inline __attribute__ ((__gnu_inline__)) double
atof (__const char *__nptr) throw ()
{
  return strtod (__nptr, (char **) __null);
}
extern __inline __attribute__ ((__gnu_inline__)) int
atoi (__const char *__nptr) throw ()
{
  return (int) strtol (__nptr, (char **) __null, 10);
}
extern __inline __attribute__ ((__gnu_inline__)) long int
atol (__const char *__nptr) throw ()
{
  return strtol (__nptr, (char **) __null, 10);
}




__extension__ extern __inline __attribute__ ((__gnu_inline__)) long long int
atoll (__const char *__nptr) throw ()
{
  return strtoll (__nptr, (char **) __null, 10);
}

# 311 "/usr/include/stdlib.h" 3 4
extern char *l64a (long int __n) throw () __attribute__ ((__warn_unused_result__));


extern long int a64l (__const char *__s)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));




# 1 "/usr/include/sys/types.h" 1 3 4
# 28 "/usr/include/sys/types.h" 3 4
extern "C" {





typedef __u_char u_char;
typedef __u_short u_short;
typedef __u_int u_int;
typedef __u_long u_long;
typedef __quad_t quad_t;
typedef __u_quad_t u_quad_t;
typedef __fsid_t fsid_t;




typedef __loff_t loff_t;





typedef __ino64_t ino_t;




typedef __ino64_t ino64_t;




typedef __dev_t dev_t;




typedef __gid_t gid_t;




typedef __mode_t mode_t;




typedef __nlink_t nlink_t;




typedef __uid_t uid_t;
# 105 "/usr/include/sys/types.h" 3 4
typedef __id_t id_t;
# 116 "/usr/include/sys/types.h" 3 4
typedef __daddr_t daddr_t;
typedef __caddr_t caddr_t;





typedef __key_t key_t;
# 137 "/usr/include/sys/types.h" 3 4
typedef __useconds_t useconds_t;



typedef __suseconds_t suseconds_t;





# 1 "/usr/lib/gcc/i686-linux-gnu/4.4.5/include/stddef.h" 1 3 4
# 148 "/usr/include/sys/types.h" 2 3 4



typedef unsigned long int ulong;
typedef unsigned short int ushort;
typedef unsigned int uint;
# 195 "/usr/include/sys/types.h" 3 4
typedef int int8_t __attribute__ ((__mode__ (__QI__)));
typedef int int16_t __attribute__ ((__mode__ (__HI__)));
typedef int int32_t __attribute__ ((__mode__ (__SI__)));
typedef int int64_t __attribute__ ((__mode__ (__DI__)));


typedef unsigned int u_int8_t __attribute__ ((__mode__ (__QI__)));
typedef unsigned int u_int16_t __attribute__ ((__mode__ (__HI__)));
typedef unsigned int u_int32_t __attribute__ ((__mode__ (__SI__)));
typedef unsigned int u_int64_t __attribute__ ((__mode__ (__DI__)));

typedef int register_t __attribute__ ((__mode__ (__word__)));
# 220 "/usr/include/sys/types.h" 3 4
# 1 "/usr/include/sys/select.h" 1 3 4
# 31 "/usr/include/sys/select.h" 3 4
# 1 "/usr/include/bits/select.h" 1 3 4
# 23 "/usr/include/bits/select.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 24 "/usr/include/bits/select.h" 2 3 4
# 32 "/usr/include/sys/select.h" 2 3 4


# 1 "/usr/include/bits/sigset.h" 1 3 4
# 24 "/usr/include/bits/sigset.h" 3 4
typedef int __sig_atomic_t;




typedef struct
  {
    unsigned long int __val[(1024 / (8 * sizeof (unsigned long int)))];
  } __sigset_t;
# 35 "/usr/include/sys/select.h" 2 3 4



typedef __sigset_t sigset_t;







# 1 "/usr/include/bits/time.h" 1 3 4
# 75 "/usr/include/bits/time.h" 3 4
struct timeval
  {
    __time_t tv_sec;
    __suseconds_t tv_usec;
  };
# 47 "/usr/include/sys/select.h" 2 3 4
# 55 "/usr/include/sys/select.h" 3 4
typedef long int __fd_mask;
# 67 "/usr/include/sys/select.h" 3 4
typedef struct
  {



    __fd_mask fds_bits[1024 / (8 * (int) sizeof (__fd_mask))];





  } fd_set;






typedef __fd_mask fd_mask;
# 99 "/usr/include/sys/select.h" 3 4
extern "C" {
# 109 "/usr/include/sys/select.h" 3 4
extern int select (int __nfds, fd_set *__restrict __readfds,
     fd_set *__restrict __writefds,
     fd_set *__restrict __exceptfds,
     struct timeval *__restrict __timeout);
# 121 "/usr/include/sys/select.h" 3 4
extern int pselect (int __nfds, fd_set *__restrict __readfds,
      fd_set *__restrict __writefds,
      fd_set *__restrict __exceptfds,
      const struct timespec *__restrict __timeout,
      const __sigset_t *__restrict __sigmask);


}
# 221 "/usr/include/sys/types.h" 2 3 4


# 1 "/usr/include/sys/sysmacros.h" 1 3 4
# 30 "/usr/include/sys/sysmacros.h" 3 4
__extension__
extern unsigned int gnu_dev_major (unsigned long long int __dev)
     throw ();
__extension__
extern unsigned int gnu_dev_minor (unsigned long long int __dev)
     throw ();
__extension__
extern unsigned long long int gnu_dev_makedev (unsigned int __major,
            unsigned int __minor)
     throw ();


__extension__ extern __inline __attribute__ ((__gnu_inline__)) unsigned int
gnu_dev_major (unsigned long long int __dev) throw ()
{
  return ((__dev >> 8) & 0xfff) | ((unsigned int) (__dev >> 32) & ~0xfff);
}

__extension__ extern __inline __attribute__ ((__gnu_inline__)) unsigned int
gnu_dev_minor (unsigned long long int __dev) throw ()
{
  return (__dev & 0xff) | ((unsigned int) (__dev >> 12) & ~0xff);
}

__extension__ extern __inline __attribute__ ((__gnu_inline__)) unsigned long long int
gnu_dev_makedev (unsigned int __major, unsigned int __minor) throw ()
{
  return ((__minor & 0xff) | ((__major & 0xfff) << 8)
   | (((unsigned long long int) (__minor & ~0xff)) << 12)
   | (((unsigned long long int) (__major & ~0xfff)) << 32));
}
# 224 "/usr/include/sys/types.h" 2 3 4





typedef __blksize_t blksize_t;
# 249 "/usr/include/sys/types.h" 3 4
typedef __blkcnt64_t blkcnt_t;



typedef __fsblkcnt64_t fsblkcnt_t;



typedef __fsfilcnt64_t fsfilcnt_t;





typedef __blkcnt64_t blkcnt64_t;
typedef __fsblkcnt64_t fsblkcnt64_t;
typedef __fsfilcnt64_t fsfilcnt64_t;





# 1 "/usr/include/bits/pthreadtypes.h" 1 3 4
# 23 "/usr/include/bits/pthreadtypes.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 24 "/usr/include/bits/pthreadtypes.h" 2 3 4
# 50 "/usr/include/bits/pthreadtypes.h" 3 4
typedef unsigned long int pthread_t;


typedef union
{
  char __size[36];
  long int __align;
} pthread_attr_t;
# 67 "/usr/include/bits/pthreadtypes.h" 3 4
typedef struct __pthread_internal_slist
{
  struct __pthread_internal_slist *__next;
} __pthread_slist_t;





typedef union
{
  struct __pthread_mutex_s
  {
    int __lock;
    unsigned int __count;
    int __owner;





    int __kind;





    unsigned int __nusers;
    __extension__ union
    {
      int __spins;
      __pthread_slist_t __list;
    };

  } __data;
  char __size[24];
  long int __align;
} pthread_mutex_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_mutexattr_t;




typedef union
{
  struct
  {
    int __lock;
    unsigned int __futex;
    __extension__ unsigned long long int __total_seq;
    __extension__ unsigned long long int __wakeup_seq;
    __extension__ unsigned long long int __woken_seq;
    void *__mutex;
    unsigned int __nwaiters;
    unsigned int __broadcast_seq;
  } __data;
  char __size[48];
  __extension__ long long int __align;
} pthread_cond_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_condattr_t;



typedef unsigned int pthread_key_t;



typedef int pthread_once_t;





typedef union
{
# 170 "/usr/include/bits/pthreadtypes.h" 3 4
  struct
  {
    int __lock;
    unsigned int __nr_readers;
    unsigned int __readers_wakeup;
    unsigned int __writer_wakeup;
    unsigned int __nr_readers_queued;
    unsigned int __nr_writers_queued;


    unsigned char __flags;
    unsigned char __shared;
    unsigned char __pad1;
    unsigned char __pad2;
    int __writer;
  } __data;

  char __size[32];
  long int __align;
} pthread_rwlock_t;

typedef union
{
  char __size[8];
  long int __align;
} pthread_rwlockattr_t;





typedef volatile int pthread_spinlock_t;




typedef union
{
  char __size[20];
  long int __align;
} pthread_barrier_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_barrierattr_t;
# 272 "/usr/include/sys/types.h" 2 3 4


}
# 321 "/usr/include/stdlib.h" 2 3 4






extern long int random (void) throw ();


extern void srandom (unsigned int __seed) throw ();





extern char *initstate (unsigned int __seed, char *__statebuf,
   size_t __statelen) throw () __attribute__ ((__nonnull__ (2)));



extern char *setstate (char *__statebuf) throw () __attribute__ ((__nonnull__ (1)));







struct random_data
  {
    int32_t *fptr;
    int32_t *rptr;
    int32_t *state;
    int rand_type;
    int rand_deg;
    int rand_sep;
    int32_t *end_ptr;
  };

extern int random_r (struct random_data *__restrict __buf,
       int32_t *__restrict __result) throw () __attribute__ ((__nonnull__ (1, 2)));

extern int srandom_r (unsigned int __seed, struct random_data *__buf)
     throw () __attribute__ ((__nonnull__ (2)));

extern int initstate_r (unsigned int __seed, char *__restrict __statebuf,
   size_t __statelen,
   struct random_data *__restrict __buf)
     throw () __attribute__ ((__nonnull__ (2, 4)));

extern int setstate_r (char *__restrict __statebuf,
         struct random_data *__restrict __buf)
     throw () __attribute__ ((__nonnull__ (1, 2)));






extern int rand (void) throw ();

extern void srand (unsigned int __seed) throw ();




extern int rand_r (unsigned int *__seed) throw ();







extern double drand48 (void) throw ();
extern double erand48 (unsigned short int __xsubi[3]) throw () __attribute__ ((__nonnull__ (1)));


extern long int lrand48 (void) throw ();
extern long int nrand48 (unsigned short int __xsubi[3])
     throw () __attribute__ ((__nonnull__ (1)));


extern long int mrand48 (void) throw ();
extern long int jrand48 (unsigned short int __xsubi[3])
     throw () __attribute__ ((__nonnull__ (1)));


extern void srand48 (long int __seedval) throw ();
extern unsigned short int *seed48 (unsigned short int __seed16v[3])
     throw () __attribute__ ((__nonnull__ (1)));
extern void lcong48 (unsigned short int __param[7]) throw () __attribute__ ((__nonnull__ (1)));





struct drand48_data
  {
    unsigned short int __x[3];
    unsigned short int __old_x[3];
    unsigned short int __c;
    unsigned short int __init;
    unsigned long long int __a;
  };


extern int drand48_r (struct drand48_data *__restrict __buffer,
        double *__restrict __result) throw () __attribute__ ((__nonnull__ (1, 2)));
extern int erand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        double *__restrict __result) throw () __attribute__ ((__nonnull__ (1, 2)));


extern int lrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern int nrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int mrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern int jrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int srand48_r (long int __seedval, struct drand48_data *__buffer)
     throw () __attribute__ ((__nonnull__ (2)));

extern int seed48_r (unsigned short int __seed16v[3],
       struct drand48_data *__buffer) throw () __attribute__ ((__nonnull__ (1, 2)));

extern int lcong48_r (unsigned short int __param[7],
        struct drand48_data *__buffer)
     throw () __attribute__ ((__nonnull__ (1, 2)));









extern void *malloc (size_t __size) throw () __attribute__ ((__malloc__)) __attribute__ ((__warn_unused_result__));

extern void *calloc (size_t __nmemb, size_t __size)
     throw () __attribute__ ((__malloc__)) __attribute__ ((__warn_unused_result__));










extern void *realloc (void *__ptr, size_t __size)
     throw () __attribute__ ((__warn_unused_result__));

extern void free (void *__ptr) throw ();




extern void cfree (void *__ptr) throw ();



# 1 "/usr/include/alloca.h" 1 3 4
# 25 "/usr/include/alloca.h" 3 4
# 1 "/usr/lib/gcc/i686-linux-gnu/4.4.5/include/stddef.h" 1 3 4
# 26 "/usr/include/alloca.h" 2 3 4

extern "C" {





extern void *alloca (size_t __size) throw ();





}
# 498 "/usr/include/stdlib.h" 2 3 4





extern void *valloc (size_t __size) throw () __attribute__ ((__malloc__)) __attribute__ ((__warn_unused_result__));




extern int posix_memalign (void **__memptr, size_t __alignment, size_t __size)
     throw () __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));




extern void abort (void) throw () __attribute__ ((__noreturn__));



extern int atexit (void (*__func) (void)) throw () __attribute__ ((__nonnull__ (1)));






extern "C++" int at_quick_exit (void (*__func) (void))
     throw () __asm ("at_quick_exit") __attribute__ ((__nonnull__ (1)));









extern int on_exit (void (*__func) (int __status, void *__arg), void *__arg)
     throw () __attribute__ ((__nonnull__ (1)));






extern void exit (int __status) throw () __attribute__ ((__noreturn__));







extern void quick_exit (int __status) throw () __attribute__ ((__noreturn__));







extern void _Exit (int __status) throw () __attribute__ ((__noreturn__));






extern char *getenv (__const char *__name) throw () __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));




extern char *__secure_getenv (__const char *__name)
     throw () __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));





extern int putenv (char *__string) throw () __attribute__ ((__nonnull__ (1)));





extern int setenv (__const char *__name, __const char *__value, int __replace)
     throw () __attribute__ ((__nonnull__ (2)));


extern int unsetenv (__const char *__name) throw () __attribute__ ((__nonnull__ (1)));






extern int clearenv (void) throw ();
# 606 "/usr/include/stdlib.h" 3 4
extern char *mktemp (char *__template) throw () __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
# 623 "/usr/include/stdlib.h" 3 4
extern int mkstemp (char *__template) __asm__ ("" "mkstemp64")
     __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));





extern int mkstemp64 (char *__template) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
# 645 "/usr/include/stdlib.h" 3 4
extern int mkstemps (char *__template, int __suffixlen) __asm__ ("" "mkstemps64") __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));






extern int mkstemps64 (char *__template, int __suffixlen)
     __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
# 663 "/usr/include/stdlib.h" 3 4
extern char *mkdtemp (char *__template) throw () __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
# 677 "/usr/include/stdlib.h" 3 4
extern int mkostemp (char *__template, int __flags) __asm__ ("" "mkostemp64")
     __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));





extern int mkostemp64 (char *__template, int __flags) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
# 698 "/usr/include/stdlib.h" 3 4
extern int mkostemps (char *__template, int __suffixlen, int __flags) __asm__ ("" "mkostemps64")

     __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));





extern int mkostemps64 (char *__template, int __suffixlen, int __flags)
     __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));









extern int system (__const char *__command) __attribute__ ((__warn_unused_result__));






extern char *canonicalize_file_name (__const char *__name)
     throw () __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
# 734 "/usr/include/stdlib.h" 3 4
extern char *realpath (__const char *__restrict __name,
         char *__restrict __resolved) throw () __attribute__ ((__warn_unused_result__));






typedef int (*__compar_fn_t) (__const void *, __const void *);


typedef __compar_fn_t comparison_fn_t;



typedef int (*__compar_d_fn_t) (__const void *, __const void *, void *);





extern void *bsearch (__const void *__key, __const void *__base,
        size_t __nmemb, size_t __size, __compar_fn_t __compar)
     __attribute__ ((__nonnull__ (1, 2, 5))) __attribute__ ((__warn_unused_result__));



extern void qsort (void *__base, size_t __nmemb, size_t __size,
     __compar_fn_t __compar) __attribute__ ((__nonnull__ (1, 4)));

extern void qsort_r (void *__base, size_t __nmemb, size_t __size,
       __compar_d_fn_t __compar, void *__arg)
  __attribute__ ((__nonnull__ (1, 4)));




extern int abs (int __x) throw () __attribute__ ((__const__)) __attribute__ ((__warn_unused_result__));
extern long int labs (long int __x) throw () __attribute__ ((__const__)) __attribute__ ((__warn_unused_result__));



__extension__ extern long long int llabs (long long int __x)
     throw () __attribute__ ((__const__)) __attribute__ ((__warn_unused_result__));







extern div_t div (int __numer, int __denom)
     throw () __attribute__ ((__const__)) __attribute__ ((__warn_unused_result__));
extern ldiv_t ldiv (long int __numer, long int __denom)
     throw () __attribute__ ((__const__)) __attribute__ ((__warn_unused_result__));




__extension__ extern lldiv_t lldiv (long long int __numer,
        long long int __denom)
     throw () __attribute__ ((__const__)) __attribute__ ((__warn_unused_result__));

# 808 "/usr/include/stdlib.h" 3 4
extern char *ecvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) throw () __attribute__ ((__nonnull__ (3, 4))) __attribute__ ((__warn_unused_result__));




extern char *fcvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) throw () __attribute__ ((__nonnull__ (3, 4))) __attribute__ ((__warn_unused_result__));




extern char *gcvt (double __value, int __ndigit, char *__buf)
     throw () __attribute__ ((__nonnull__ (3))) __attribute__ ((__warn_unused_result__));




extern char *qecvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     throw () __attribute__ ((__nonnull__ (3, 4))) __attribute__ ((__warn_unused_result__));
extern char *qfcvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     throw () __attribute__ ((__nonnull__ (3, 4))) __attribute__ ((__warn_unused_result__));
extern char *qgcvt (long double __value, int __ndigit, char *__buf)
     throw () __attribute__ ((__nonnull__ (3))) __attribute__ ((__warn_unused_result__));




extern int ecvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) throw () __attribute__ ((__nonnull__ (3, 4, 5)));
extern int fcvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) throw () __attribute__ ((__nonnull__ (3, 4, 5)));

extern int qecvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     throw () __attribute__ ((__nonnull__ (3, 4, 5)));
extern int qfcvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     throw () __attribute__ ((__nonnull__ (3, 4, 5)));







extern int mblen (__const char *__s, size_t __n) throw () __attribute__ ((__warn_unused_result__));


extern int mbtowc (wchar_t *__restrict __pwc,
     __const char *__restrict __s, size_t __n) throw () __attribute__ ((__warn_unused_result__));


extern int wctomb (char *__s, wchar_t __wchar) throw () __attribute__ ((__warn_unused_result__));



extern size_t mbstowcs (wchar_t *__restrict __pwcs,
   __const char *__restrict __s, size_t __n) throw ();

extern size_t wcstombs (char *__restrict __s,
   __const wchar_t *__restrict __pwcs, size_t __n)
     throw ();








extern int rpmatch (__const char *__response) throw () __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
# 896 "/usr/include/stdlib.h" 3 4
extern int getsubopt (char **__restrict __optionp,
        char *__const *__restrict __tokens,
        char **__restrict __valuep)
     throw () __attribute__ ((__nonnull__ (1, 2, 3))) __attribute__ ((__warn_unused_result__));





extern void setkey (__const char *__key) throw () __attribute__ ((__nonnull__ (1)));







extern int posix_openpt (int __oflag) __attribute__ ((__warn_unused_result__));







extern int grantpt (int __fd) throw ();



extern int unlockpt (int __fd) throw ();




extern char *ptsname (int __fd) throw () __attribute__ ((__warn_unused_result__));






extern int ptsname_r (int __fd, char *__buf, size_t __buflen)
     throw () __attribute__ ((__nonnull__ (2)));


extern int getpt (void);






extern int getloadavg (double __loadavg[], int __nelem)
     throw () __attribute__ ((__nonnull__ (1)));





# 1 "/usr/include/bits/stdlib.h" 1 3 4
# 24 "/usr/include/bits/stdlib.h" 3 4
extern char *__realpath_chk (__const char *__restrict __name,
        char *__restrict __resolved,
        size_t __resolvedlen) throw () __attribute__ ((__warn_unused_result__));
extern char *__realpath_alias (__const char *__restrict __name, char *__restrict __resolved) throw () __asm__ ("" "realpath") __attribute__ ((__warn_unused_result__));


extern char *__realpath_chk_warn (__const char *__restrict __name, char *__restrict __resolved, size_t __resolvedlen) throw () __asm__ ("" "__realpath_chk") __attribute__ ((__warn_unused_result__))



     __attribute__((__warning__ ("second argument of realpath must be either NULL or at " "least PATH_MAX bytes long buffer")));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) __attribute__ ((__warn_unused_result__)) char *
realpath (__const char *__restrict __name, char *__restrict __resolved) throw ()
{
  if (__builtin_object_size (__resolved, 2 > 1) != (size_t) -1)
    {

      if (__builtin_object_size (__resolved, 2 > 1) < 4096)
 return __realpath_chk_warn (__name, __resolved, __builtin_object_size (__resolved, 2 > 1));

      return __realpath_chk (__name, __resolved, __builtin_object_size (__resolved, 2 > 1));
    }

  return __realpath_alias (__name, __resolved);
}


extern int __ptsname_r_chk (int __fd, char *__buf, size_t __buflen,
       size_t __nreal) throw () __attribute__ ((__nonnull__ (2)));
extern int __ptsname_r_alias (int __fd, char *__buf, size_t __buflen) throw () __asm__ ("" "ptsname_r")

     __attribute__ ((__nonnull__ (2)));
extern int __ptsname_r_chk_warn (int __fd, char *__buf, size_t __buflen, size_t __nreal) throw () __asm__ ("" "__ptsname_r_chk")


     __attribute__ ((__nonnull__ (2))) __attribute__((__warning__ ("ptsname_r called with buflen bigger than " "size of buf")));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) int
ptsname_r (int __fd, char *__buf, size_t __buflen) throw ()
{
  if (__builtin_object_size (__buf, 2 > 1) != (size_t) -1)
    {
      if (!__builtin_constant_p (__buflen))
 return __ptsname_r_chk (__fd, __buf, __buflen, __builtin_object_size (__buf, 2 > 1));
      if (__buflen > __builtin_object_size (__buf, 2 > 1))
 return __ptsname_r_chk_warn (__fd, __buf, __buflen, __builtin_object_size (__buf, 2 > 1));
    }
  return __ptsname_r_alias (__fd, __buf, __buflen);
}


extern int __wctomb_chk (char *__s, wchar_t __wchar, size_t __buflen)
  throw () __attribute__ ((__warn_unused_result__));
extern int __wctomb_alias (char *__s, wchar_t __wchar) throw () __asm__ ("" "wctomb") __attribute__ ((__warn_unused_result__));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) __attribute__ ((__warn_unused_result__)) int
wctomb (char *__s, wchar_t __wchar) throw ()
{







  if (__builtin_object_size (__s, 2 > 1) != (size_t) -1 && 16 > __builtin_object_size (__s, 2 > 1))
    return __wctomb_chk (__s, __wchar, __builtin_object_size (__s, 2 > 1));
  return __wctomb_alias (__s, __wchar);
}


extern size_t __mbstowcs_chk (wchar_t *__restrict __dst,
         __const char *__restrict __src,
         size_t __len, size_t __dstlen) throw ();
extern size_t __mbstowcs_alias (wchar_t *__restrict __dst, __const char *__restrict __src, size_t __len) throw () __asm__ ("" "mbstowcs");



extern size_t __mbstowcs_chk_warn (wchar_t *__restrict __dst, __const char *__restrict __src, size_t __len, size_t __dstlen) throw () __asm__ ("" "__mbstowcs_chk")



     __attribute__((__warning__ ("mbstowcs called with dst buffer smaller than len " "* sizeof (wchar_t)")));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) size_t
mbstowcs (wchar_t *__restrict __dst, __const char *__restrict __src, size_t __len) throw ()

{
  if (__builtin_object_size (__dst, 2 > 1) != (size_t) -1)
    {
      if (!__builtin_constant_p (__len))
 return __mbstowcs_chk (__dst, __src, __len,
          __builtin_object_size (__dst, 2 > 1) / sizeof (wchar_t));

      if (__len > __builtin_object_size (__dst, 2 > 1) / sizeof (wchar_t))
 return __mbstowcs_chk_warn (__dst, __src, __len,
         __builtin_object_size (__dst, 2 > 1) / sizeof (wchar_t));
    }
  return __mbstowcs_alias (__dst, __src, __len);
}


extern size_t __wcstombs_chk (char *__restrict __dst,
         __const wchar_t *__restrict __src,
         size_t __len, size_t __dstlen) throw ();
extern size_t __wcstombs_alias (char *__restrict __dst, __const wchar_t *__restrict __src, size_t __len) throw () __asm__ ("" "wcstombs");



extern size_t __wcstombs_chk_warn (char *__restrict __dst, __const wchar_t *__restrict __src, size_t __len, size_t __dstlen) throw () __asm__ ("" "__wcstombs_chk")



     __attribute__((__warning__ ("wcstombs called with dst buffer smaller than len")));

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) size_t
wcstombs (char *__restrict __dst, __const wchar_t *__restrict __src, size_t __len) throw ()

{
  if (__builtin_object_size (__dst, 2 > 1) != (size_t) -1)
    {
      if (!__builtin_constant_p (__len))
 return __wcstombs_chk (__dst, __src, __len, __builtin_object_size (__dst, 2 > 1));
      if (__len > __builtin_object_size (__dst, 2 > 1))
 return __wcstombs_chk_warn (__dst, __src, __len, __builtin_object_size (__dst, 2 > 1));
    }
  return __wcstombs_alias (__dst, __src, __len);
}
# 956 "/usr/include/stdlib.h" 2 3 4
# 964 "/usr/include/stdlib.h" 3 4
}
# 44 "/usr/include/wx-2.8/wx/string.h" 2
# 55 "/usr/include/wx-2.8/wx/string.h"
# 1 "/usr/include/wx-2.8/wx/buffer.h" 1
# 127 "/usr/include/wx-2.8/wx/buffer.h"
class wxCharBuffer { public: wxCharBuffer(const char *str = __null) : m_str(str ? strdup(str) : __null) { } wxCharBuffer(size_t len) : m_str((char *)malloc((len + 1)*sizeof(char))) { m_str[len] = (char)0; } ~wxCharBuffer() { free(m_str); } char *release() const { char *p = m_str; ((wxCharBuffer *)this)->m_str = __null; return p; } void reset() { free(m_str); m_str = __null; } wxCharBuffer(const wxCharBuffer& src) : m_str(src.release()) { } wxCharBuffer& operator=(const char *str) { free(m_str); m_str = str ? strdup(str) : __null; return *this; } wxCharBuffer& operator=(const wxCharBuffer& src) { free(m_str); m_str = src.release(); return *this; } bool extend(size_t len) { char * str = (char *)realloc(m_str, (len + 1)*sizeof(char)); if ( !str ) return false; m_str = str; return true; } char *data() { return m_str; } const char *data() const { return m_str; } operator const char *() const { return m_str; } char operator[](size_t n) const { return m_str[n]; } private: char *m_str; };

class wxWritableCharBuffer : public wxCharBuffer { public: wxWritableCharBuffer(const wxCharBuffer& src) : wxCharBuffer(src) {} wxWritableCharBuffer(const char *str = __null) : wxCharBuffer(str) {} operator char*() { return this->data(); } };




class wxWCharBuffer { public: wxWCharBuffer(const wchar_t *str = __null) : m_str(str ? wxStrdupW(str) : __null) { } wxWCharBuffer(size_t len) : m_str((wchar_t *)malloc((len + 1)*sizeof(wchar_t))) { m_str[len] = (wchar_t)0; } ~wxWCharBuffer() { free(m_str); } wchar_t *release() const { wchar_t *p = m_str; ((wxWCharBuffer *)this)->m_str = __null; return p; } void reset() { free(m_str); m_str = __null; } wxWCharBuffer(const wxWCharBuffer& src) : m_str(src.release()) { } wxWCharBuffer& operator=(const wchar_t *str) { free(m_str); m_str = str ? wxStrdupW(str) : __null; return *this; } wxWCharBuffer& operator=(const wxWCharBuffer& src) { free(m_str); m_str = src.release(); return *this; } bool extend(size_t len) { wchar_t * str = (wchar_t *)realloc(m_str, (len + 1)*sizeof(wchar_t)); if ( !str ) return false; m_str = str; return true; } wchar_t *data() { return m_str; } const wchar_t *data() const { return m_str; } operator const wchar_t *() const { return m_str; } wchar_t operator[](size_t n) const { return m_str[n]; } private: wchar_t *m_str; };

class wxWritableWCharBuffer : public wxWCharBuffer { public: wxWritableWCharBuffer(const wxWCharBuffer& src) : wxWCharBuffer(src) {} wxWritableWCharBuffer(const wchar_t *str = __null) : wxWCharBuffer(str) {} operator wchar_t*() { return this->data(); } };
# 145 "/usr/include/wx-2.8/wx/buffer.h"
    typedef wxWCharBuffer wxWxCharBuffer;
# 165 "/usr/include/wx-2.8/wx/buffer.h"
class wxMemoryBufferData
{
public:

    enum { DefBufSize = 1024 };

    friend class wxMemoryBuffer;


private:
    wxMemoryBufferData(size_t size = wxMemoryBufferData::DefBufSize)
        : m_data(size ? malloc(size) : __null), m_size(size), m_len(0), m_ref(0)
    {
    }
    ~wxMemoryBufferData() { free(m_data); }


    void ResizeIfNeeded(size_t newSize)
    {
        if (newSize > m_size)
        {
            void *dataOld = m_data;
            m_data = realloc(m_data, newSize + wxMemoryBufferData::DefBufSize);
            if ( !m_data )
            {
                free(dataOld);
            }

            m_size = newSize + wxMemoryBufferData::DefBufSize;
        }
    }

    void IncRef() { m_ref += 1; }
    void DecRef()
    {
        m_ref -= 1;
        if (m_ref == 0)
            delete this;
    }



    void *m_data;


    size_t m_size;


    size_t m_len;


    size_t m_ref;

    private: wxMemoryBufferData(const wxMemoryBufferData&); wxMemoryBufferData& operator=(const wxMemoryBufferData&);
};


class wxMemoryBuffer
{
public:

    wxMemoryBuffer(size_t size = wxMemoryBufferData::DefBufSize)
    {
        m_bufdata = new wxMemoryBufferData(size);
        m_bufdata->IncRef();
    }

    ~wxMemoryBuffer() { m_bufdata->DecRef(); }



    wxMemoryBuffer(const wxMemoryBuffer& src)
        : m_bufdata(src.m_bufdata)
    {
        m_bufdata->IncRef();
    }

    wxMemoryBuffer& operator=(const wxMemoryBuffer& src)
    {
        m_bufdata->DecRef();
        m_bufdata = src.m_bufdata;
        m_bufdata->IncRef();
        return *this;
    }



    void *GetData() const { return m_bufdata->m_data; }
    size_t GetBufSize() const { return m_bufdata->m_size; }
    size_t GetDataLen() const { return m_bufdata->m_len; }

    void SetBufSize(size_t size) { m_bufdata->ResizeIfNeeded(size); }
    void SetDataLen(size_t len)
    {
        ;
        m_bufdata->m_len = len;
    }


    void *GetWriteBuf(size_t sizeNeeded)
    {
        m_bufdata->ResizeIfNeeded(sizeNeeded);
        return m_bufdata->m_data;
    }


    void UngetWriteBuf(size_t sizeUsed) { SetDataLen(sizeUsed); }


    void *GetAppendBuf(size_t sizeNeeded)
    {
        m_bufdata->ResizeIfNeeded(m_bufdata->m_len + sizeNeeded);
        return (char*)m_bufdata->m_data + m_bufdata->m_len;
    }


    void UngetAppendBuf(size_t sizeUsed)
    {
        SetDataLen(m_bufdata->m_len + sizeUsed);
    }


    void AppendByte(char data)
    {
        if ( m_bufdata->m_data ) ; else { ; return; } typedef int wxDummyCheckInt;

        m_bufdata->ResizeIfNeeded(m_bufdata->m_len + 1);
        *(((char*)m_bufdata->m_data) + m_bufdata->m_len) = data;
        m_bufdata->m_len += 1;
    }

    void AppendData(const void *data, size_t len)
    {
        memcpy(GetAppendBuf(len), data, len);
        UngetAppendBuf(len);
    }

    operator const char *() const { return (const char*)GetData(); }

private:
    wxMemoryBufferData* m_bufdata;
};
# 56 "/usr/include/wx-2.8/wx/string.h" 2
# 1 "/usr/include/wx-2.8/wx/strconv.h" 1
# 52 "/usr/include/wx-2.8/wx/strconv.h"
class wxMBConv
{
public:
# 78 "/usr/include/wx-2.8/wx/strconv.h"
    virtual size_t ToWChar(wchar_t *dst, size_t dstLen,
                           const char *src, size_t srcLen = ((size_t)-1)) const;

    virtual size_t FromWChar(char *dst, size_t dstLen,
                             const wchar_t *src, size_t srcLen = ((size_t)-1)) const;





    const wxWCharBuffer cMB2WC(const char *in) const;
    const wxCharBuffer cWC2MB(const wchar_t *in) const;
# 103 "/usr/include/wx-2.8/wx/strconv.h"
    const wxWCharBuffer
        cMB2WC(const char *in, size_t inLen, size_t *outLen) const;
    const wxCharBuffer
        cWC2MB(const wchar_t *in, size_t inLen, size_t *outLen) const;



    const wxWCharBuffer cMB2WX(const char *psz) const { return cMB2WC(psz); }
    const wxCharBuffer cWX2MB(const wchar_t *psz) const { return cWC2MB(psz); }
    const wchar_t* cWC2WX(const wchar_t *psz) const { return psz; }
    const wchar_t* cWX2WC(const wchar_t *psz) const { return psz; }
# 132 "/usr/include/wx-2.8/wx/strconv.h"
    virtual size_t GetMBNulLen() const { return 1; }



    static size_t GetMaxMBNulLen() { return 4 ; }
# 155 "/usr/include/wx-2.8/wx/strconv.h"
    virtual size_t MB2WC(wchar_t *out, const char *in, size_t outLen) const;
    virtual size_t WC2MB(char *out, const wchar_t *in, size_t outLen) const;



    virtual wxMBConv *Clone() const = 0;


    virtual ~wxMBConv();
};






class wxMBConvLibc : public wxMBConv
{
public:
    virtual size_t MB2WC(wchar_t *outputBuf, const char *psz, size_t outputSize) const;
    virtual size_t WC2MB(char *outputBuf, const wchar_t *psz, size_t outputSize) const;

    virtual wxMBConv *Clone() const { return new wxMBConvLibc; }
};
# 189 "/usr/include/wx-2.8/wx/strconv.h"
class wxConvBrokenFileNames : public wxMBConv
{
public:
    wxConvBrokenFileNames(const wxChar *charset);
    wxConvBrokenFileNames(const wxConvBrokenFileNames& conv)
        : wxMBConv(),
          m_conv(conv.m_conv ? conv.m_conv->Clone() : __null)
    {
    }
    virtual ~wxConvBrokenFileNames() { delete m_conv; }

    virtual size_t MB2WC(wchar_t *out, const char *in, size_t outLen) const
    {
        return m_conv->MB2WC(out, in, outLen);
    }

    virtual size_t WC2MB(char *out, const wchar_t *in, size_t outLen) const
    {
        return m_conv->WC2MB(out, in, outLen);
    }

    virtual size_t GetMBNulLen() const
    {

        return m_conv->GetMBNulLen();
    }

    virtual wxMBConv *Clone() const { return new wxConvBrokenFileNames(*this); }

private:

    wxMBConv *m_conv;

    private: wxConvBrokenFileNames& operator=(const wxConvBrokenFileNames&);
};







class wxMBConvUTF7 : public wxMBConv
{
public:
    virtual size_t MB2WC(wchar_t *outputBuf, const char *psz, size_t outputSize) const;
    virtual size_t WC2MB(char *outputBuf, const wchar_t *psz, size_t outputSize) const;

    virtual wxMBConv *Clone() const { return new wxMBConvUTF7; }
};





class wxMBConvUTF8 : public wxMBConv
{
public:
    enum
    {
        MAP_INVALID_UTF8_NOT = 0,
        MAP_INVALID_UTF8_TO_PUA = 1,
        MAP_INVALID_UTF8_TO_OCTAL = 2
    };

    wxMBConvUTF8(int options = MAP_INVALID_UTF8_NOT) : m_options(options) { }
    virtual size_t MB2WC(wchar_t *outputBuf, const char *psz, size_t outputSize) const;
    virtual size_t WC2MB(char *outputBuf, const wchar_t *psz, size_t outputSize) const;

    virtual wxMBConv *Clone() const { return new wxMBConvUTF8(m_options); }

private:
    int m_options;
};





class wxMBConvUTF16Base : public wxMBConv
{
public:
    enum { BYTES_PER_CHAR = 2 };

    virtual size_t GetMBNulLen() const { return BYTES_PER_CHAR; }

protected:




    static size_t GetLength(const char *src, size_t srcLen);
};





class wxMBConvUTF16LE : public wxMBConvUTF16Base
{
public:
    virtual size_t ToWChar(wchar_t *dst, size_t dstLen,
                           const char *src, size_t srcLen = ((size_t)-1)) const;
    virtual size_t FromWChar(char *dst, size_t dstLen,
                             const wchar_t *src, size_t srcLen = ((size_t)-1)) const;
    virtual wxMBConv *Clone() const { return new wxMBConvUTF16LE; }
};





class wxMBConvUTF16BE : public wxMBConvUTF16Base
{
public:
    virtual size_t ToWChar(wchar_t *dst, size_t dstLen,
                           const char *src, size_t srcLen = ((size_t)-1)) const;
    virtual size_t FromWChar(char *dst, size_t dstLen,
                             const wchar_t *src, size_t srcLen = ((size_t)-1)) const;
    virtual wxMBConv *Clone() const { return new wxMBConvUTF16BE; }
};





class wxMBConvUTF32Base : public wxMBConv
{
public:
    enum { BYTES_PER_CHAR = 4 };

    virtual size_t GetMBNulLen() const { return BYTES_PER_CHAR; }

protected:



    static size_t GetLength(const char *src, size_t srcLen);
};





class wxMBConvUTF32LE : public wxMBConvUTF32Base
{
public:
    virtual size_t ToWChar(wchar_t *dst, size_t dstLen,
                           const char *src, size_t srcLen = ((size_t)-1)) const;
    virtual size_t FromWChar(char *dst, size_t dstLen,
                             const wchar_t *src, size_t srcLen = ((size_t)-1)) const;
    virtual wxMBConv *Clone() const { return new wxMBConvUTF32LE; }
};





class wxMBConvUTF32BE : public wxMBConvUTF32Base
{
public:
    virtual size_t ToWChar(wchar_t *dst, size_t dstLen,
                           const char *src, size_t srcLen = ((size_t)-1)) const;
    virtual size_t FromWChar(char *dst, size_t dstLen,
                             const wchar_t *src, size_t srcLen = ((size_t)-1)) const;
    virtual wxMBConv *Clone() const { return new wxMBConvUTF32BE; }
};





# 1 "/usr/include/wx-2.8/wx/fontenc.h" 1
# 16 "/usr/include/wx-2.8/wx/fontenc.h"
enum wxFontEncoding
{
    wxFONTENCODING_SYSTEM = -1,
    wxFONTENCODING_DEFAULT,


    wxFONTENCODING_ISO8859_1,
    wxFONTENCODING_ISO8859_2,
    wxFONTENCODING_ISO8859_3,
    wxFONTENCODING_ISO8859_4,
    wxFONTENCODING_ISO8859_5,
    wxFONTENCODING_ISO8859_6,
    wxFONTENCODING_ISO8859_7,
    wxFONTENCODING_ISO8859_8,
    wxFONTENCODING_ISO8859_9,
    wxFONTENCODING_ISO8859_10,
    wxFONTENCODING_ISO8859_11,
    wxFONTENCODING_ISO8859_12,


    wxFONTENCODING_ISO8859_13,
    wxFONTENCODING_ISO8859_14,
    wxFONTENCODING_ISO8859_15,
    wxFONTENCODING_ISO8859_MAX,


    wxFONTENCODING_KOI8,
    wxFONTENCODING_KOI8_U,
    wxFONTENCODING_ALTERNATIVE,
    wxFONTENCODING_BULGARIAN,



    wxFONTENCODING_CP437,
    wxFONTENCODING_CP850,
    wxFONTENCODING_CP852,
    wxFONTENCODING_CP855,
    wxFONTENCODING_CP866,

    wxFONTENCODING_CP874,
    wxFONTENCODING_CP932,
    wxFONTENCODING_CP936,
    wxFONTENCODING_CP949,
    wxFONTENCODING_CP950,
    wxFONTENCODING_CP1250,
    wxFONTENCODING_CP1251,
    wxFONTENCODING_CP1252,
    wxFONTENCODING_CP1253,
    wxFONTENCODING_CP1254,
    wxFONTENCODING_CP1255,
    wxFONTENCODING_CP1256,
    wxFONTENCODING_CP1257,
    wxFONTENCODING_CP12_MAX,

    wxFONTENCODING_UTF7,
    wxFONTENCODING_UTF8,
    wxFONTENCODING_EUC_JP,
    wxFONTENCODING_UTF16BE,
    wxFONTENCODING_UTF16LE,
    wxFONTENCODING_UTF32BE,
    wxFONTENCODING_UTF32LE,

    wxFONTENCODING_MACROMAN,
    wxFONTENCODING_MACJAPANESE,
    wxFONTENCODING_MACCHINESETRAD,
    wxFONTENCODING_MACKOREAN,
    wxFONTENCODING_MACARABIC,
    wxFONTENCODING_MACHEBREW,
    wxFONTENCODING_MACGREEK,
    wxFONTENCODING_MACCYRILLIC,
    wxFONTENCODING_MACDEVANAGARI,
    wxFONTENCODING_MACGURMUKHI,
    wxFONTENCODING_MACGUJARATI,
    wxFONTENCODING_MACORIYA,
    wxFONTENCODING_MACBENGALI,
    wxFONTENCODING_MACTAMIL,
    wxFONTENCODING_MACTELUGU,
    wxFONTENCODING_MACKANNADA,
    wxFONTENCODING_MACMALAJALAM,
    wxFONTENCODING_MACSINHALESE,
    wxFONTENCODING_MACBURMESE,
    wxFONTENCODING_MACKHMER,
    wxFONTENCODING_MACTHAI,
    wxFONTENCODING_MACLAOTIAN,
    wxFONTENCODING_MACGEORGIAN,
    wxFONTENCODING_MACARMENIAN,
    wxFONTENCODING_MACCHINESESIMP,
    wxFONTENCODING_MACTIBETAN,
    wxFONTENCODING_MACMONGOLIAN,
    wxFONTENCODING_MACETHIOPIC,
    wxFONTENCODING_MACCENTRALEUR,
    wxFONTENCODING_MACVIATNAMESE,
    wxFONTENCODING_MACARABICEXT,
    wxFONTENCODING_MACSYMBOL,
    wxFONTENCODING_MACDINGBATS,
    wxFONTENCODING_MACTURKISH,
    wxFONTENCODING_MACCROATIAN,
    wxFONTENCODING_MACICELANDIC,
    wxFONTENCODING_MACROMANIAN,
    wxFONTENCODING_MACCELTIC,
    wxFONTENCODING_MACGAELIC,
    wxFONTENCODING_MACKEYBOARD,

    wxFONTENCODING_MAX,

    wxFONTENCODING_MACMIN = wxFONTENCODING_MACROMAN ,
    wxFONTENCODING_MACMAX = wxFONTENCODING_MACKEYBOARD ,






    wxFONTENCODING_UTF16 = wxFONTENCODING_UTF16LE,
    wxFONTENCODING_UTF32 = wxFONTENCODING_UTF32LE,







    wxFONTENCODING_UNICODE = wxFONTENCODING_UTF32,




    wxFONTENCODING_GB2312 = wxFONTENCODING_CP936,
    wxFONTENCODING_BIG5 = wxFONTENCODING_CP950,


    wxFONTENCODING_SHIFT_JIS = wxFONTENCODING_CP932
};
# 362 "/usr/include/wx-2.8/wx/strconv.h" 2

class wxCSConv : public wxMBConv
{
public:


    wxCSConv(const wxChar *charset);
    wxCSConv(wxFontEncoding encoding);

    wxCSConv(const wxCSConv& conv);
    virtual ~wxCSConv();

    wxCSConv& operator=(const wxCSConv& conv);

    virtual size_t ToWChar(wchar_t *dst, size_t dstLen,
                           const char *src, size_t srcLen = ((size_t)-1)) const;
    virtual size_t FromWChar(char *dst, size_t dstLen,
                             const wchar_t *src, size_t srcLen = ((size_t)-1)) const;
    virtual size_t MB2WC(wchar_t *outputBuf, const char *psz, size_t outputSize) const;
    virtual size_t WC2MB(char *outputBuf, const wchar_t *psz, size_t outputSize) const;
    virtual size_t GetMBNulLen() const;

    virtual wxMBConv *Clone() const { return new wxCSConv(*this); }

    void Clear();



    bool IsOk() const;


private:

    void Init();


    void CreateConvIfNeeded() const;


    wxMBConv *DoCreate() const;



    void SetName(const wxChar *charset);




    wxChar *m_name;
    wxFontEncoding m_encoding;


    wxMBConv *m_convReal;
    bool m_deferred;
};
# 425 "/usr/include/wx-2.8/wx/strconv.h"
extern wxMBConv& wxConvLibc;


extern wxCSConv& wxConvISO8859_1;
extern wxMBConvUTF7& wxConvUTF7;
extern wxMBConvUTF8& wxConvUTF8;
# 439 "/usr/include/wx-2.8/wx/strconv.h"
extern wxMBConv * wxConvFileName;






extern wxMBConv * wxConvCurrent;


extern wxCSConv& wxConvLocal;





extern wxMBConv * wxConvUI;
# 465 "/usr/include/wx-2.8/wx/strconv.h"
    typedef wxMBConvUTF16LE wxMBConvUTF16;
    typedef wxMBConvUTF32LE wxMBConvUTF32;
# 538 "/usr/include/wx-2.8/wx/strconv.h"
    extern wxWCharBuffer wxSafeConvertMB2WX(const char *s);



    extern wxCharBuffer wxSafeConvertWX2MB(const wchar_t *ws);
# 57 "/usr/include/wx-2.8/wx/string.h" 2

class wxString;
# 93 "/usr/include/wx-2.8/wx/string.h"
extern const wxChar* wxEmptyString;
# 104 "/usr/include/wx-2.8/wx/string.h"
inline bool IsEmpty(const char *p) { return (!p || !*p); }


inline size_t Strlen(const char *psz)
  { return psz ? strlen(psz) : 0; }


inline int Stricmp(const char *psz1, const char *psz2)
{
# 141 "/usr/include/wx-2.8/wx/string.h"
  return strcasecmp(psz1, psz2);
# 166 "/usr/include/wx-2.8/wx/string.h"
}
# 175 "/usr/include/wx-2.8/wx/string.h"
# 1 "/usr/include/wx-2.8/wx/beforestd.h" 1
# 176 "/usr/include/wx-2.8/wx/string.h" 2
# 1 "/usr/include/c++/4.4/string" 1 3
# 38 "/usr/include/c++/4.4/string" 3
       
# 39 "/usr/include/c++/4.4/string" 3

# 1 "/usr/include/c++/4.4/i686-linux-gnu/bits/c++config.h" 1 3
# 243 "/usr/include/c++/4.4/i686-linux-gnu/bits/c++config.h" 3
# 1 "/usr/include/c++/4.4/i686-linux-gnu/bits/os_defines.h" 1 3
# 244 "/usr/include/c++/4.4/i686-linux-gnu/bits/c++config.h" 2 3


# 1 "/usr/include/c++/4.4/i686-linux-gnu/bits/cpu_defines.h" 1 3
# 247 "/usr/include/c++/4.4/i686-linux-gnu/bits/c++config.h" 2 3
# 41 "/usr/include/c++/4.4/string" 2 3
# 1 "/usr/include/c++/4.4/bits/stringfwd.h" 1 3
# 38 "/usr/include/c++/4.4/bits/stringfwd.h" 3
       
# 39 "/usr/include/c++/4.4/bits/stringfwd.h" 3



namespace std __attribute__ ((__visibility__ ("default"))) {

  template<typename _Alloc>
    class allocator;

  template<class _CharT>
    struct char_traits;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
           typename _Alloc = allocator<_CharT> >
    class basic_string;

  template<> struct char_traits<char>;

  typedef basic_string<char> string;


  template<> struct char_traits<wchar_t>;

  typedef basic_string<wchar_t> wstring;
# 75 "/usr/include/c++/4.4/bits/stringfwd.h" 3
}
# 42 "/usr/include/c++/4.4/string" 2 3
# 1 "/usr/include/c++/4.4/bits/char_traits.h" 1 3
# 39 "/usr/include/c++/4.4/bits/char_traits.h" 3
       
# 40 "/usr/include/c++/4.4/bits/char_traits.h" 3

# 1 "/usr/include/c++/4.4/bits/stl_algobase.h" 1 3
# 61 "/usr/include/c++/4.4/bits/stl_algobase.h" 3
# 1 "/usr/include/c++/4.4/cstddef" 1 3
# 41 "/usr/include/c++/4.4/cstddef" 3
       
# 42 "/usr/include/c++/4.4/cstddef" 3


# 1 "/usr/lib/gcc/i686-linux-gnu/4.4.5/include/stddef.h" 1 3 4
# 45 "/usr/include/c++/4.4/cstddef" 2 3




namespace std __attribute__ ((__visibility__ ("default"))) {

  using ::ptrdiff_t;
  using ::size_t;

}
# 62 "/usr/include/c++/4.4/bits/stl_algobase.h" 2 3
# 1 "/usr/include/c++/4.4/bits/functexcept.h" 1 3
# 37 "/usr/include/c++/4.4/bits/functexcept.h" 3
# 1 "/usr/include/c++/4.4/exception_defines.h" 1 3
# 38 "/usr/include/c++/4.4/bits/functexcept.h" 2 3

namespace std __attribute__ ((__visibility__ ("default"))) {


  void
  __throw_bad_exception(void) __attribute__((__noreturn__));


  void
  __throw_bad_alloc(void) __attribute__((__noreturn__));


  void
  __throw_bad_cast(void) __attribute__((__noreturn__));

  void
  __throw_bad_typeid(void) __attribute__((__noreturn__));


  void
  __throw_logic_error(const char*) __attribute__((__noreturn__));

  void
  __throw_domain_error(const char*) __attribute__((__noreturn__));

  void
  __throw_invalid_argument(const char*) __attribute__((__noreturn__));

  void
  __throw_length_error(const char*) __attribute__((__noreturn__));

  void
  __throw_out_of_range(const char*) __attribute__((__noreturn__));

  void
  __throw_runtime_error(const char*) __attribute__((__noreturn__));

  void
  __throw_range_error(const char*) __attribute__((__noreturn__));

  void
  __throw_overflow_error(const char*) __attribute__((__noreturn__));

  void
  __throw_underflow_error(const char*) __attribute__((__noreturn__));


  void
  __throw_ios_failure(const char*) __attribute__((__noreturn__));

  void
  __throw_system_error(int) __attribute__((__noreturn__));

}
# 63 "/usr/include/c++/4.4/bits/stl_algobase.h" 2 3
# 1 "/usr/include/c++/4.4/bits/cpp_type_traits.h" 1 3
# 36 "/usr/include/c++/4.4/bits/cpp_type_traits.h" 3
       
# 37 "/usr/include/c++/4.4/bits/cpp_type_traits.h" 3
# 69 "/usr/include/c++/4.4/bits/cpp_type_traits.h" 3
namespace __gnu_cxx __attribute__ ((__visibility__ ("default"))) {

  template<typename _Iterator, typename _Container>
    class __normal_iterator;

}

namespace std __attribute__ ((__visibility__ ("default"))) {

  struct __true_type { };
  struct __false_type { };

  template<bool>
    struct __truth_type
    { typedef __false_type __type; };

  template<>
    struct __truth_type<true>
    { typedef __true_type __type; };



  template<class _Sp, class _Tp>
    struct __traitor
    {
      enum { __value = bool(_Sp::__value) || bool(_Tp::__value) };
      typedef typename __truth_type<__value>::__type __type;
    };


  template<typename, typename>
    struct __are_same
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Tp>
    struct __are_same<_Tp, _Tp>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<typename _Tp>
    struct __is_void
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_void<void>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_integer
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };




  template<>
    struct __is_integer<bool>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<signed char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_integer<wchar_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
# 194 "/usr/include/c++/4.4/bits/cpp_type_traits.h" 3
  template<>
    struct __is_integer<short>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned short>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<int>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned int>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<long long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned long long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_floating
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };


  template<>
    struct __is_floating<float>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_floating<double>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_floating<long double>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_pointer
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Tp>
    struct __is_pointer<_Tp*>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_normal_iterator
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Iterator, typename _Container>
    struct __is_normal_iterator< __gnu_cxx::__normal_iterator<_Iterator,
             _Container> >
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_arithmetic
    : public __traitor<__is_integer<_Tp>, __is_floating<_Tp> >
    { };




  template<typename _Tp>
    struct __is_fundamental
    : public __traitor<__is_void<_Tp>, __is_arithmetic<_Tp> >
    { };




  template<typename _Tp>
    struct __is_scalar
    : public __traitor<__is_arithmetic<_Tp>, __is_pointer<_Tp> >
    { };




  template<typename _Tp>
    struct __is_char
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_char<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_char<wchar_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<typename _Tp>
    struct __is_byte
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_byte<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_byte<signed char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_byte<unsigned char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_move_iterator
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };
# 417 "/usr/include/c++/4.4/bits/cpp_type_traits.h" 3
}
# 64 "/usr/include/c++/4.4/bits/stl_algobase.h" 2 3
# 1 "/usr/include/c++/4.4/ext/type_traits.h" 1 3
# 32 "/usr/include/c++/4.4/ext/type_traits.h" 3
       
# 33 "/usr/include/c++/4.4/ext/type_traits.h" 3




namespace __gnu_cxx __attribute__ ((__visibility__ ("default"))) {


  template<bool, typename>
    struct __enable_if
    { };

  template<typename _Tp>
    struct __enable_if<true, _Tp>
    { typedef _Tp __type; };



  template<bool _Cond, typename _Iftrue, typename _Iffalse>
    struct __conditional_type
    { typedef _Iftrue __type; };

  template<typename _Iftrue, typename _Iffalse>
    struct __conditional_type<false, _Iftrue, _Iffalse>
    { typedef _Iffalse __type; };



  template<typename _Tp>
    struct __add_unsigned
    {
    private:
      typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;

    public:
      typedef typename __if_type::__type __type;
    };

  template<>
    struct __add_unsigned<char>
    { typedef unsigned char __type; };

  template<>
    struct __add_unsigned<signed char>
    { typedef unsigned char __type; };

  template<>
    struct __add_unsigned<short>
    { typedef unsigned short __type; };

  template<>
    struct __add_unsigned<int>
    { typedef unsigned int __type; };

  template<>
    struct __add_unsigned<long>
    { typedef unsigned long __type; };

  template<>
    struct __add_unsigned<long long>
    { typedef unsigned long long __type; };


  template<>
    struct __add_unsigned<bool>;

  template<>
    struct __add_unsigned<wchar_t>;



  template<typename _Tp>
    struct __remove_unsigned
    {
    private:
      typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;

    public:
      typedef typename __if_type::__type __type;
    };

  template<>
    struct __remove_unsigned<char>
    { typedef signed char __type; };

  template<>
    struct __remove_unsigned<unsigned char>
    { typedef signed char __type; };

  template<>
    struct __remove_unsigned<unsigned short>
    { typedef short __type; };

  template<>
    struct __remove_unsigned<unsigned int>
    { typedef int __type; };

  template<>
    struct __remove_unsigned<unsigned long>
    { typedef long __type; };

  template<>
    struct __remove_unsigned<unsigned long long>
    { typedef long long __type; };


  template<>
    struct __remove_unsigned<bool>;

  template<>
    struct __remove_unsigned<wchar_t>;



  template<typename _Type>
    inline bool
    __is_null_pointer(_Type* __ptr)
    { return __ptr == 0; }

  template<typename _Type>
    inline bool
    __is_null_pointer(_Type)
    { return false; }



  template<typename _Tp, bool = std::__is_integer<_Tp>::__value>
    struct __promote
    { typedef double __type; };

  template<typename _Tp>
    struct __promote<_Tp, false>
    { typedef _Tp __type; };

  template<typename _Tp, typename _Up>
    struct __promote_2
    {
    private:
      typedef typename __promote<_Tp>::__type __type1;
      typedef typename __promote<_Up>::__type __type2;

    public:
      typedef __typeof__(__type1() + __type2()) __type;
    };

  template<typename _Tp, typename _Up, typename _Vp>
    struct __promote_3
    {
    private:
      typedef typename __promote<_Tp>::__type __type1;
      typedef typename __promote<_Up>::__type __type2;
      typedef typename __promote<_Vp>::__type __type3;

    public:
      typedef __typeof__(__type1() + __type2() + __type3()) __type;
    };

  template<typename _Tp, typename _Up, typename _Vp, typename _Wp>
    struct __promote_4
    {
    private:
      typedef typename __promote<_Tp>::__type __type1;
      typedef typename __promote<_Up>::__type __type2;
      typedef typename __promote<_Vp>::__type __type3;
      typedef typename __promote<_Wp>::__type __type4;

    public:
      typedef __typeof__(__type1() + __type2() + __type3() + __type4()) __type;
    };

}
# 65 "/usr/include/c++/4.4/bits/stl_algobase.h" 2 3
# 1 "/usr/include/c++/4.4/ext/numeric_traits.h" 1 3
# 32 "/usr/include/c++/4.4/ext/numeric_traits.h" 3
       
# 33 "/usr/include/c++/4.4/ext/numeric_traits.h" 3




namespace __gnu_cxx __attribute__ ((__visibility__ ("default"))) {
# 52 "/usr/include/c++/4.4/ext/numeric_traits.h" 3
  template<typename _Value>
    struct __numeric_traits_integer
    {

      static const _Value __min = (((_Value)(-1) < 0) ? (_Value)1 << (sizeof(_Value) * 8 - ((_Value)(-1) < 0)) : (_Value)0);
      static const _Value __max = (((_Value)(-1) < 0) ? (((((_Value)1 << ((sizeof(_Value) * 8 - ((_Value)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(_Value)0);



      static const bool __is_signed = ((_Value)(-1) < 0);
      static const int __digits = (sizeof(_Value) * 8 - ((_Value)(-1) < 0));
    };

  template<typename _Value>
    const _Value __numeric_traits_integer<_Value>::__min;

  template<typename _Value>
    const _Value __numeric_traits_integer<_Value>::__max;

  template<typename _Value>
    const bool __numeric_traits_integer<_Value>::__is_signed;

  template<typename _Value>
    const int __numeric_traits_integer<_Value>::__digits;
# 97 "/usr/include/c++/4.4/ext/numeric_traits.h" 3
  template<typename _Value>
    struct __numeric_traits_floating
    {

      static const int __max_digits10 = (2 + (std::__are_same<_Value, float>::__value ? 24 : std::__are_same<_Value, double>::__value ? 53 : 64) * 3010 / 10000);


      static const bool __is_signed = true;
      static const int __digits10 = (std::__are_same<_Value, float>::__value ? 6 : std::__are_same<_Value, double>::__value ? 15 : 18);
      static const int __max_exponent10 = (std::__are_same<_Value, float>::__value ? 38 : std::__are_same<_Value, double>::__value ? 308 : 4932);
    };

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__max_digits10;

  template<typename _Value>
    const bool __numeric_traits_floating<_Value>::__is_signed;

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__digits10;

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__max_exponent10;

  template<typename _Value>
    struct __numeric_traits
    : public __conditional_type<std::__is_integer<_Value>::__value,
    __numeric_traits_integer<_Value>,
    __numeric_traits_floating<_Value> >::__type
    { };

}
# 66 "/usr/include/c++/4.4/bits/stl_algobase.h" 2 3
# 1 "/usr/include/c++/4.4/bits/stl_pair.h" 1 3
# 60 "/usr/include/c++/4.4/bits/stl_pair.h" 3
# 1 "/usr/include/c++/4.4/bits/move.h" 1 3
# 34 "/usr/include/c++/4.4/bits/move.h" 3
# 1 "/usr/include/c++/4.4/cstddef" 1 3
# 41 "/usr/include/c++/4.4/cstddef" 3
       
# 42 "/usr/include/c++/4.4/cstddef" 3


# 1 "/usr/lib/gcc/i686-linux-gnu/4.4.5/include/stddef.h" 1 3 4
# 45 "/usr/include/c++/4.4/cstddef" 2 3
# 35 "/usr/include/c++/4.4/bits/move.h" 2 3
# 1 "/usr/include/c++/4.4/bits/concept_check.h" 1 3
# 33 "/usr/include/c++/4.4/bits/concept_check.h" 3
       
# 34 "/usr/include/c++/4.4/bits/concept_check.h" 3
# 36 "/usr/include/c++/4.4/bits/move.h" 2 3
# 66 "/usr/include/c++/4.4/bits/move.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {







  template<typename _Tp>
    inline void
    swap(_Tp& __a, _Tp& __b)
    {

     

      _Tp __tmp = (__a);
      __a = (__b);
      __b = (__tmp);
    }



  template<typename _Tp, size_t _Nm>
    inline void
    swap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm])
    {
      for (size_t __n = 0; __n < _Nm; ++__n)
 swap(__a[__n], __b[__n]);
    }

}
# 61 "/usr/include/c++/4.4/bits/stl_pair.h" 2 3


namespace std __attribute__ ((__visibility__ ("default"))) {


  template<class _T1, class _T2>
    struct pair
    {
      typedef _T1 first_type;
      typedef _T2 second_type;

      _T1 first;
      _T2 second;





      pair()
      : first(), second() { }


      pair(const _T1& __a, const _T2& __b)
      : first(__a), second(__b) { }
# 98 "/usr/include/c++/4.4/bits/stl_pair.h" 3
      template<class _U1, class _U2>
        pair(const pair<_U1, _U2>& __p)
 : first(__p.first),
   second(__p.second) { }
# 141 "/usr/include/c++/4.4/bits/stl_pair.h" 3
    };


  template<class _T1, class _T2>
    inline bool
    operator==(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __x.first == __y.first && __x.second == __y.second; }


  template<class _T1, class _T2>
    inline bool
    operator<(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __x.first < __y.first
      || (!(__y.first < __x.first) && __x.second < __y.second); }


  template<class _T1, class _T2>
    inline bool
    operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__x == __y); }


  template<class _T1, class _T2>
    inline bool
    operator>(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __y < __x; }


  template<class _T1, class _T2>
    inline bool
    operator<=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__y < __x); }


  template<class _T1, class _T2>
    inline bool
    operator>=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__x < __y); }
# 213 "/usr/include/c++/4.4/bits/stl_pair.h" 3
  template<class _T1, class _T2>
    inline pair<_T1, _T2>
    make_pair(_T1 __x, _T2 __y)
    { return pair<_T1, _T2>(__x, __y); }
# 259 "/usr/include/c++/4.4/bits/stl_pair.h" 3
}
# 67 "/usr/include/c++/4.4/bits/stl_algobase.h" 2 3
# 1 "/usr/include/c++/4.4/bits/stl_iterator_base_types.h" 1 3
# 63 "/usr/include/c++/4.4/bits/stl_iterator_base_types.h" 3
       
# 64 "/usr/include/c++/4.4/bits/stl_iterator_base_types.h" 3


# 1 "/usr/include/c++/4.4/cstddef" 1 3
# 41 "/usr/include/c++/4.4/cstddef" 3
       
# 42 "/usr/include/c++/4.4/cstddef" 3


# 1 "/usr/lib/gcc/i686-linux-gnu/4.4.5/include/stddef.h" 1 3 4
# 45 "/usr/include/c++/4.4/cstddef" 2 3
# 67 "/usr/include/c++/4.4/bits/stl_iterator_base_types.h" 2 3

namespace std __attribute__ ((__visibility__ ("default"))) {
# 79 "/usr/include/c++/4.4/bits/stl_iterator_base_types.h" 3
  struct input_iterator_tag { };

  struct output_iterator_tag { };

  struct forward_iterator_tag : public input_iterator_tag { };


  struct bidirectional_iterator_tag : public forward_iterator_tag { };


  struct random_access_iterator_tag : public bidirectional_iterator_tag { };
# 102 "/usr/include/c++/4.4/bits/stl_iterator_base_types.h" 3
  template<typename _Category, typename _Tp, typename _Distance = ptrdiff_t,
           typename _Pointer = _Tp*, typename _Reference = _Tp&>
    struct iterator
    {

      typedef _Category iterator_category;

      typedef _Tp value_type;

      typedef _Distance difference_type;

      typedef _Pointer pointer;

      typedef _Reference reference;
    };







  template<typename _Iterator>
    struct iterator_traits
    {
      typedef typename _Iterator::iterator_category iterator_category;
      typedef typename _Iterator::value_type value_type;
      typedef typename _Iterator::difference_type difference_type;
      typedef typename _Iterator::pointer pointer;
      typedef typename _Iterator::reference reference;
    };

  template<typename _Tp>
    struct iterator_traits<_Tp*>
    {
      typedef random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef _Tp& reference;
    };

  template<typename _Tp>
    struct iterator_traits<const _Tp*>
    {
      typedef random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef ptrdiff_t difference_type;
      typedef const _Tp* pointer;
      typedef const _Tp& reference;
    };





  template<typename _Iter>
    inline typename iterator_traits<_Iter>::iterator_category
    __iterator_category(const _Iter&)
    { return typename iterator_traits<_Iter>::iterator_category(); }



}
# 68 "/usr/include/c++/4.4/bits/stl_algobase.h" 2 3
# 1 "/usr/include/c++/4.4/bits/stl_iterator_base_funcs.h" 1 3
# 63 "/usr/include/c++/4.4/bits/stl_iterator_base_funcs.h" 3
       
# 64 "/usr/include/c++/4.4/bits/stl_iterator_base_funcs.h" 3


namespace std __attribute__ ((__visibility__ ("default"))) {

  template<typename _InputIterator>
    inline typename iterator_traits<_InputIterator>::difference_type
    __distance(_InputIterator __first, _InputIterator __last,
               input_iterator_tag)
    {

     

      typename iterator_traits<_InputIterator>::difference_type __n = 0;
      while (__first != __last)
 {
   ++__first;
   ++__n;
 }
      return __n;
    }

  template<typename _RandomAccessIterator>
    inline typename iterator_traits<_RandomAccessIterator>::difference_type
    __distance(_RandomAccessIterator __first, _RandomAccessIterator __last,
               random_access_iterator_tag)
    {

     

      return __last - __first;
    }
# 108 "/usr/include/c++/4.4/bits/stl_iterator_base_funcs.h" 3
  template<typename _InputIterator>
    inline typename iterator_traits<_InputIterator>::difference_type
    distance(_InputIterator __first, _InputIterator __last)
    {

      return std::__distance(__first, __last,
        std::__iterator_category(__first));
    }

  template<typename _InputIterator, typename _Distance>
    inline void
    __advance(_InputIterator& __i, _Distance __n, input_iterator_tag)
    {

     
      while (__n--)
 ++__i;
    }

  template<typename _BidirectionalIterator, typename _Distance>
    inline void
    __advance(_BidirectionalIterator& __i, _Distance __n,
       bidirectional_iterator_tag)
    {

     

      if (__n > 0)
        while (__n--)
   ++__i;
      else
        while (__n++)
   --__i;
    }

  template<typename _RandomAccessIterator, typename _Distance>
    inline void
    __advance(_RandomAccessIterator& __i, _Distance __n,
              random_access_iterator_tag)
    {

     

      __i += __n;
    }
# 166 "/usr/include/c++/4.4/bits/stl_iterator_base_funcs.h" 3
  template<typename _InputIterator, typename _Distance>
    inline void
    advance(_InputIterator& __i, _Distance __n)
    {

      typename iterator_traits<_InputIterator>::difference_type __d = __n;
      std::__advance(__i, __d, std::__iterator_category(__i));
    }
# 195 "/usr/include/c++/4.4/bits/stl_iterator_base_funcs.h" 3
}
# 69 "/usr/include/c++/4.4/bits/stl_algobase.h" 2 3
# 1 "/usr/include/c++/4.4/bits/stl_iterator.h" 1 3
# 68 "/usr/include/c++/4.4/bits/stl_iterator.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {
# 89 "/usr/include/c++/4.4/bits/stl_iterator.h" 3
  template<typename _Iterator>
    class reverse_iterator
    : public iterator<typename iterator_traits<_Iterator>::iterator_category,
        typename iterator_traits<_Iterator>::value_type,
        typename iterator_traits<_Iterator>::difference_type,
        typename iterator_traits<_Iterator>::pointer,
                      typename iterator_traits<_Iterator>::reference>
    {
    protected:
      _Iterator current;

    public:
      typedef _Iterator iterator_type;
      typedef typename iterator_traits<_Iterator>::difference_type
              difference_type;
      typedef typename iterator_traits<_Iterator>::reference reference;
      typedef typename iterator_traits<_Iterator>::pointer pointer;

    public:






      reverse_iterator() : current() { }




      explicit
      reverse_iterator(iterator_type __x) : current(__x) { }




      reverse_iterator(const reverse_iterator& __x)
      : current(__x.current) { }





      template<typename _Iter>
        reverse_iterator(const reverse_iterator<_Iter>& __x)
 : current(__x.base()) { }




      iterator_type
      base() const
      { return current; }






      reference
      operator*() const
      {
 _Iterator __tmp = current;
 return *--__tmp;
      }






      pointer
      operator->() const
      { return &(operator*()); }






      reverse_iterator&
      operator++()
      {
 --current;
 return *this;
      }






      reverse_iterator
      operator++(int)
      {
 reverse_iterator __tmp = *this;
 --current;
 return __tmp;
      }






      reverse_iterator&
      operator--()
      {
 ++current;
 return *this;
      }






      reverse_iterator
      operator--(int)
      {
 reverse_iterator __tmp = *this;
 ++current;
 return __tmp;
      }






      reverse_iterator
      operator+(difference_type __n) const
      { return reverse_iterator(current - __n); }






      reverse_iterator&
      operator+=(difference_type __n)
      {
 current -= __n;
 return *this;
      }






      reverse_iterator
      operator-(difference_type __n) const
      { return reverse_iterator(current + __n); }






      reverse_iterator&
      operator-=(difference_type __n)
      {
 current += __n;
 return *this;
      }






      reference
      operator[](difference_type __n) const
      { return *(*this + __n); }
    };
# 276 "/usr/include/c++/4.4/bits/stl_iterator.h" 3
  template<typename _Iterator>
    inline bool
    operator==(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return __x.base() == __y.base(); }

  template<typename _Iterator>
    inline bool
    operator<(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y.base() < __x.base(); }

  template<typename _Iterator>
    inline bool
    operator!=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__x == __y); }

  template<typename _Iterator>
    inline bool
    operator>(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y < __x; }

  template<typename _Iterator>
    inline bool
    operator<=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__y < __x); }

  template<typename _Iterator>
    inline bool
    operator>=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__x < __y); }

  template<typename _Iterator>
    inline typename reverse_iterator<_Iterator>::difference_type
    operator-(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y.base() - __x.base(); }

  template<typename _Iterator>
    inline reverse_iterator<_Iterator>
    operator+(typename reverse_iterator<_Iterator>::difference_type __n,
       const reverse_iterator<_Iterator>& __x)
    { return reverse_iterator<_Iterator>(__x.base() - __n); }



  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator==(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return __x.base() == __y.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator<(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    { return __y.base() < __x.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator!=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__x == __y); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator>(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    { return __y < __x; }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator<=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__y < __x); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator>=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__x < __y); }

  template<typename _IteratorL, typename _IteratorR>







    inline typename reverse_iterator<_IteratorL>::difference_type
    operator-(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)

    { return __y.base() - __x.base(); }
# 388 "/usr/include/c++/4.4/bits/stl_iterator.h" 3
  template<typename _Container>
    class back_insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;

    public:

      typedef _Container container_type;


      explicit
      back_insert_iterator(_Container& __x) : container(&__x) { }
# 414 "/usr/include/c++/4.4/bits/stl_iterator.h" 3
      back_insert_iterator&
      operator=(typename _Container::const_reference __value)
      {
 container->push_back(__value);
 return *this;
      }
# 431 "/usr/include/c++/4.4/bits/stl_iterator.h" 3
      back_insert_iterator&
      operator*()
      { return *this; }


      back_insert_iterator&
      operator++()
      { return *this; }


      back_insert_iterator
      operator++(int)
      { return *this; }
    };
# 457 "/usr/include/c++/4.4/bits/stl_iterator.h" 3
  template<typename _Container>
    inline back_insert_iterator<_Container>
    back_inserter(_Container& __x)
    { return back_insert_iterator<_Container>(__x); }
# 472 "/usr/include/c++/4.4/bits/stl_iterator.h" 3
  template<typename _Container>
    class front_insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;

    public:

      typedef _Container container_type;


      explicit front_insert_iterator(_Container& __x) : container(&__x) { }
# 497 "/usr/include/c++/4.4/bits/stl_iterator.h" 3
      front_insert_iterator&
      operator=(typename _Container::const_reference __value)
      {
 container->push_front(__value);
 return *this;
      }
# 514 "/usr/include/c++/4.4/bits/stl_iterator.h" 3
      front_insert_iterator&
      operator*()
      { return *this; }


      front_insert_iterator&
      operator++()
      { return *this; }


      front_insert_iterator
      operator++(int)
      { return *this; }
    };
# 540 "/usr/include/c++/4.4/bits/stl_iterator.h" 3
  template<typename _Container>
    inline front_insert_iterator<_Container>
    front_inserter(_Container& __x)
    { return front_insert_iterator<_Container>(__x); }
# 559 "/usr/include/c++/4.4/bits/stl_iterator.h" 3
  template<typename _Container>
    class insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;
      typename _Container::iterator iter;

    public:

      typedef _Container container_type;





      insert_iterator(_Container& __x, typename _Container::iterator __i)
      : container(&__x), iter(__i) {}
# 601 "/usr/include/c++/4.4/bits/stl_iterator.h" 3
      insert_iterator&
      operator=(typename _Container::const_reference __value)
      {
 iter = container->insert(iter, __value);
 ++iter;
 return *this;
      }
# 620 "/usr/include/c++/4.4/bits/stl_iterator.h" 3
      insert_iterator&
      operator*()
      { return *this; }


      insert_iterator&
      operator++()
      { return *this; }


      insert_iterator&
      operator++(int)
      { return *this; }
    };
# 646 "/usr/include/c++/4.4/bits/stl_iterator.h" 3
  template<typename _Container, typename _Iterator>
    inline insert_iterator<_Container>
    inserter(_Container& __x, _Iterator __i)
    {
      return insert_iterator<_Container>(__x,
      typename _Container::iterator(__i));
    }

}

namespace __gnu_cxx __attribute__ ((__visibility__ ("default"))) {
# 665 "/usr/include/c++/4.4/bits/stl_iterator.h" 3
  using std::iterator_traits;
  using std::iterator;
  template<typename _Iterator, typename _Container>
    class __normal_iterator
    {
    protected:
      _Iterator _M_current;

    public:
      typedef _Iterator iterator_type;
      typedef typename iterator_traits<_Iterator>::iterator_category
                                                             iterator_category;
      typedef typename iterator_traits<_Iterator>::value_type value_type;
      typedef typename iterator_traits<_Iterator>::difference_type
                                                             difference_type;
      typedef typename iterator_traits<_Iterator>::reference reference;
      typedef typename iterator_traits<_Iterator>::pointer pointer;

      __normal_iterator() : _M_current(_Iterator()) { }

      explicit
      __normal_iterator(const _Iterator& __i) : _M_current(__i) { }


      template<typename _Iter>
        __normal_iterator(const __normal_iterator<_Iter,
     typename __enable_if<
              (std::__are_same<_Iter, typename _Container::pointer>::__value),
        _Container>::__type>& __i)
        : _M_current(__i.base()) { }


      reference
      operator*() const
      { return *_M_current; }

      pointer
      operator->() const
      { return _M_current; }

      __normal_iterator&
      operator++()
      {
 ++_M_current;
 return *this;
      }

      __normal_iterator
      operator++(int)
      { return __normal_iterator(_M_current++); }


      __normal_iterator&
      operator--()
      {
 --_M_current;
 return *this;
      }

      __normal_iterator
      operator--(int)
      { return __normal_iterator(_M_current--); }


      reference
      operator[](const difference_type& __n) const
      { return _M_current[__n]; }

      __normal_iterator&
      operator+=(const difference_type& __n)
      { _M_current += __n; return *this; }

      __normal_iterator
      operator+(const difference_type& __n) const
      { return __normal_iterator(_M_current + __n); }

      __normal_iterator&
      operator-=(const difference_type& __n)
      { _M_current -= __n; return *this; }

      __normal_iterator
      operator-(const difference_type& __n) const
      { return __normal_iterator(_M_current - __n); }

      const _Iterator&
      base() const
      { return _M_current; }
    };
# 763 "/usr/include/c++/4.4/bits/stl_iterator.h" 3
  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() == __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator==(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() == __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator!=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() != __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator!=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() != __rhs.base(); }


  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator<(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() < __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator<(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() < __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator>(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() > __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator>(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() > __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator<=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() <= __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator<=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() <= __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator>=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() >= __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator>=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() >= __rhs.base(); }





  template<typename _IteratorL, typename _IteratorR, typename _Container>







    inline typename __normal_iterator<_IteratorL, _Container>::difference_type
    operator-(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)

    { return __lhs.base() - __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline typename __normal_iterator<_Iterator, _Container>::difference_type
    operator-(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() - __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline __normal_iterator<_Iterator, _Container>
    operator+(typename __normal_iterator<_Iterator, _Container>::difference_type
       __n, const __normal_iterator<_Iterator, _Container>& __i)
    { return __normal_iterator<_Iterator, _Container>(__i.base() + __n); }

}
# 70 "/usr/include/c++/4.4/bits/stl_algobase.h" 2 3

# 1 "/usr/include/c++/4.4/debug/debug.h" 1 3
# 47 "/usr/include/c++/4.4/debug/debug.h" 3
namespace std
{
  namespace __debug { }
}




namespace __gnu_debug
{
  using namespace std::__debug;
}
# 72 "/usr/include/c++/4.4/bits/stl_algobase.h" 2 3


namespace std __attribute__ ((__visibility__ ("default"))) {




  template<bool _BoolType>
    struct __iter_swap
    {
      template<typename _ForwardIterator1, typename _ForwardIterator2>
        static void
        iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
        {
          typedef typename iterator_traits<_ForwardIterator1>::value_type
            _ValueType1;
          _ValueType1 __tmp = (*__a);
          *__a = (*__b);
          *__b = (__tmp);
 }
    };

  template<>
    struct __iter_swap<true>
    {
      template<typename _ForwardIterator1, typename _ForwardIterator2>
        static void
        iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
        {
          swap(*__a, *__b);
        }
    };
# 115 "/usr/include/c++/4.4/bits/stl_algobase.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    inline void
    iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
    {
      typedef typename iterator_traits<_ForwardIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_ForwardIterator2>::value_type
 _ValueType2;


     

     

     

     


      typedef typename iterator_traits<_ForwardIterator1>::reference
 _ReferenceType1;
      typedef typename iterator_traits<_ForwardIterator2>::reference
 _ReferenceType2;
      std::__iter_swap<__are_same<_ValueType1, _ValueType2>::__value
 && __are_same<_ValueType1&, _ReferenceType1>::__value
 && __are_same<_ValueType2&, _ReferenceType2>::__value>::
 iter_swap(__a, __b);
    }
# 156 "/usr/include/c++/4.4/bits/stl_algobase.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    _ForwardIterator2
    swap_ranges(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
  _ForwardIterator2 __first2)
    {

     

     

      ;

      for (; __first1 != __last1; ++__first1, ++__first2)
 std::iter_swap(__first1, __first2);
      return __first2;
    }
# 184 "/usr/include/c++/4.4/bits/stl_algobase.h" 3
  template<typename _Tp>
    inline const _Tp&
    min(const _Tp& __a, const _Tp& __b)
    {

     

      if (__b < __a)
 return __b;
      return __a;
    }
# 207 "/usr/include/c++/4.4/bits/stl_algobase.h" 3
  template<typename _Tp>
    inline const _Tp&
    max(const _Tp& __a, const _Tp& __b)
    {

     

      if (__a < __b)
 return __b;
      return __a;
    }
# 230 "/usr/include/c++/4.4/bits/stl_algobase.h" 3
  template<typename _Tp, typename _Compare>
    inline const _Tp&
    min(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {

      if (__comp(__b, __a))
 return __b;
      return __a;
    }
# 251 "/usr/include/c++/4.4/bits/stl_algobase.h" 3
  template<typename _Tp, typename _Compare>
    inline const _Tp&
    max(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {

      if (__comp(__a, __b))
 return __b;
      return __a;
    }




  template<typename _Iterator,
    bool _IsNormal = __is_normal_iterator<_Iterator>::__value>
    struct __niter_base
    {
      static _Iterator
      __b(_Iterator __it)
      { return __it; }
    };

  template<typename _Iterator>
    struct __niter_base<_Iterator, true>
    {
      static typename _Iterator::iterator_type
      __b(_Iterator __it)
      { return __it.base(); }
    };


  template<typename _Iterator,
    bool _IsMove = __is_move_iterator<_Iterator>::__value>
    struct __miter_base
    {
      static _Iterator
      __b(_Iterator __it)
      { return __it; }
    };

  template<typename _Iterator>
    struct __miter_base<_Iterator, true>
    {
      static typename _Iterator::iterator_type
      __b(_Iterator __it)
      { return __it.base(); }
    };







  template<bool, bool, typename>
    struct __copy_move
    {
      template<typename _II, typename _OI>
        static _OI
        __copy_m(_II __first, _II __last, _OI __result)
        {
   for (; __first != __last; ++__result, ++__first)
     *__result = *__first;
   return __result;
 }
    };
# 333 "/usr/include/c++/4.4/bits/stl_algobase.h" 3
  template<>
    struct __copy_move<false, false, random_access_iterator_tag>
    {
      template<typename _II, typename _OI>
        static _OI
        __copy_m(_II __first, _II __last, _OI __result)
        {
   typedef typename iterator_traits<_II>::difference_type _Distance;
   for(_Distance __n = __last - __first; __n > 0; --__n)
     {
       *__result = *__first;
       ++__first;
       ++__result;
     }
   return __result;
 }
    };
# 371 "/usr/include/c++/4.4/bits/stl_algobase.h" 3
  template<bool _IsMove>
    struct __copy_move<_IsMove, true, random_access_iterator_tag>
    {
      template<typename _Tp>
        static _Tp*
        __copy_m(const _Tp* __first, const _Tp* __last, _Tp* __result)
        {
   __builtin_memmove(__result, __first,
       sizeof(_Tp) * (__last - __first));
   return __result + (__last - __first);
 }
    };

  template<bool _IsMove, typename _II, typename _OI>
    inline _OI
    __copy_move_a(_II __first, _II __last, _OI __result)
    {
      typedef typename iterator_traits<_II>::value_type _ValueTypeI;
      typedef typename iterator_traits<_OI>::value_type _ValueTypeO;
      typedef typename iterator_traits<_II>::iterator_category _Category;
      const bool __simple = (__is_pod(_ValueTypeI)
                      && __is_pointer<_II>::__value
                      && __is_pointer<_OI>::__value
        && __are_same<_ValueTypeI, _ValueTypeO>::__value);

      return std::__copy_move<_IsMove, __simple,
                       _Category>::__copy_m(__first, __last, __result);
    }



  template<typename _CharT>
    struct char_traits;

  template<typename _CharT, typename _Traits>
    class istreambuf_iterator;

  template<typename _CharT, typename _Traits>
    class ostreambuf_iterator;

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
      ostreambuf_iterator<_CharT, char_traits<_CharT> > >::__type
    __copy_move_a2(_CharT*, _CharT*,
     ostreambuf_iterator<_CharT, char_traits<_CharT> >);

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
      ostreambuf_iterator<_CharT, char_traits<_CharT> > >::__type
    __copy_move_a2(const _CharT*, const _CharT*,
     ostreambuf_iterator<_CharT, char_traits<_CharT> >);

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
        _CharT*>::__type
    __copy_move_a2(istreambuf_iterator<_CharT, char_traits<_CharT> >,
     istreambuf_iterator<_CharT, char_traits<_CharT> >, _CharT*);

  template<bool _IsMove, typename _II, typename _OI>
    inline _OI
    __copy_move_a2(_II __first, _II __last, _OI __result)
    {
      return _OI(std::__copy_move_a<_IsMove>
   (std::__niter_base<_II>::__b(__first),
    std::__niter_base<_II>::__b(__last),
    std::__niter_base<_OI>::__b(__result)));
    }
# 456 "/usr/include/c++/4.4/bits/stl_algobase.h" 3
  template<typename _II, typename _OI>
    inline _OI
    copy(_II __first, _II __last, _OI __result)
    {

     
     

      ;

      return (std::__copy_move_a2<__is_move_iterator<_II>::__value>
       (std::__miter_base<_II>::__b(__first),
        std::__miter_base<_II>::__b(__last), __result));
    }
# 509 "/usr/include/c++/4.4/bits/stl_algobase.h" 3
  template<bool, bool, typename>
    struct __copy_move_backward
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
        {
   while (__first != __last)
     *--__result = *--__last;
   return __result;
 }
    };
# 537 "/usr/include/c++/4.4/bits/stl_algobase.h" 3
  template<>
    struct __copy_move_backward<false, false, random_access_iterator_tag>
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
        {
   typename iterator_traits<_BI1>::difference_type __n;
   for (__n = __last - __first; __n > 0; --__n)
     *--__result = *--__last;
   return __result;
 }
    };
# 567 "/usr/include/c++/4.4/bits/stl_algobase.h" 3
  template<bool _IsMove>
    struct __copy_move_backward<_IsMove, true, random_access_iterator_tag>
    {
      template<typename _Tp>
        static _Tp*
        __copy_move_b(const _Tp* __first, const _Tp* __last, _Tp* __result)
        {
   const ptrdiff_t _Num = __last - __first;
   __builtin_memmove(__result - _Num, __first, sizeof(_Tp) * _Num);
   return __result - _Num;
 }
    };

  template<bool _IsMove, typename _BI1, typename _BI2>
    inline _BI2
    __copy_move_backward_a(_BI1 __first, _BI1 __last, _BI2 __result)
    {
      typedef typename iterator_traits<_BI1>::value_type _ValueType1;
      typedef typename iterator_traits<_BI2>::value_type _ValueType2;
      typedef typename iterator_traits<_BI1>::iterator_category _Category;
      const bool __simple = (__is_pod(_ValueType1)
                      && __is_pointer<_BI1>::__value
                      && __is_pointer<_BI2>::__value
        && __are_same<_ValueType1, _ValueType2>::__value);

      return std::__copy_move_backward<_IsMove, __simple,
                                _Category>::__copy_move_b(__first,
         __last,
         __result);
    }

  template<bool _IsMove, typename _BI1, typename _BI2>
    inline _BI2
    __copy_move_backward_a2(_BI1 __first, _BI1 __last, _BI2 __result)
    {
      return _BI2(std::__copy_move_backward_a<_IsMove>
    (std::__niter_base<_BI1>::__b(__first),
     std::__niter_base<_BI1>::__b(__last),
     std::__niter_base<_BI2>::__b(__result)));
    }
# 626 "/usr/include/c++/4.4/bits/stl_algobase.h" 3
  template<typename _BI1, typename _BI2>
    inline _BI2
    copy_backward(_BI1 __first, _BI1 __last, _BI2 __result)
    {

     
     
     


      ;

      return (std::__copy_move_backward_a2<__is_move_iterator<_BI1>::__value>
       (std::__miter_base<_BI1>::__b(__first),
        std::__miter_base<_BI1>::__b(__last), __result));
    }
# 684 "/usr/include/c++/4.4/bits/stl_algobase.h" 3
  template<typename _ForwardIterator, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, void>::__type
    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
       const _Tp& __value)
    {
      for (; __first != __last; ++__first)
 *__first = __value;
    }

  template<typename _ForwardIterator, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, void>::__type
    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
      const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (; __first != __last; ++__first)
 *__first = __tmp;
    }


  template<typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_byte<_Tp>::__value, void>::__type
    __fill_a(_Tp* __first, _Tp* __last, const _Tp& __c)
    {
      const _Tp __tmp = __c;
      __builtin_memset(__first, static_cast<unsigned char>(__tmp),
         __last - __first);
    }
# 728 "/usr/include/c++/4.4/bits/stl_algobase.h" 3
  template<typename _ForwardIterator, typename _Tp>
    inline void
    fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value)
    {

     

      ;

      std::__fill_a(std::__niter_base<_ForwardIterator>::__b(__first),
      std::__niter_base<_ForwardIterator>::__b(__last), __value);
    }

  template<typename _OutputIterator, typename _Size, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, _OutputIterator>::__type
    __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value)
    {
      for (; __n > 0; --__n, ++__first)
 *__first = __value;
      return __first;
    }

  template<typename _OutputIterator, typename _Size, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, _OutputIterator>::__type
    __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (; __n > 0; --__n, ++__first)
 *__first = __tmp;
      return __first;
    }

  template<typename _Size, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_byte<_Tp>::__value, _Tp*>::__type
    __fill_n_a(_Tp* __first, _Size __n, const _Tp& __c)
    {
      std::__fill_a(__first, __first + __n, __c);
      return __first + __n;
    }
# 783 "/usr/include/c++/4.4/bits/stl_algobase.h" 3
  template<typename _OI, typename _Size, typename _Tp>
    inline _OI
    fill_n(_OI __first, _Size __n, const _Tp& __value)
    {

     

      return _OI(std::__fill_n_a(std::__niter_base<_OI>::__b(__first),
     __n, __value));
    }

  template<bool _BoolType>
    struct __equal
    {
      template<typename _II1, typename _II2>
        static bool
        equal(_II1 __first1, _II1 __last1, _II2 __first2)
        {
   for (; __first1 != __last1; ++__first1, ++__first2)
     if (!(*__first1 == *__first2))
       return false;
   return true;
 }
    };

  template<>
    struct __equal<true>
    {
      template<typename _Tp>
        static bool
        equal(const _Tp* __first1, const _Tp* __last1, const _Tp* __first2)
        {
   return !__builtin_memcmp(__first1, __first2, sizeof(_Tp)
       * (__last1 - __first1));
 }
    };

  template<typename _II1, typename _II2>
    inline bool
    __equal_aux(_II1 __first1, _II1 __last1, _II2 __first2)
    {
      typedef typename iterator_traits<_II1>::value_type _ValueType1;
      typedef typename iterator_traits<_II2>::value_type _ValueType2;
      const bool __simple = (__is_integer<_ValueType1>::__value
                      && __is_pointer<_II1>::__value
                      && __is_pointer<_II2>::__value
        && __are_same<_ValueType1, _ValueType2>::__value);

      return std::__equal<__simple>::equal(__first1, __last1, __first2);
    }


  template<typename, typename>
    struct __lc_rai
    {
      template<typename _II1, typename _II2>
        static _II1
        __newlast1(_II1, _II1 __last1, _II2, _II2)
        { return __last1; }

      template<typename _II>
        static bool
        __cnd2(_II __first, _II __last)
        { return __first != __last; }
    };

  template<>
    struct __lc_rai<random_access_iterator_tag, random_access_iterator_tag>
    {
      template<typename _RAI1, typename _RAI2>
        static _RAI1
        __newlast1(_RAI1 __first1, _RAI1 __last1,
     _RAI2 __first2, _RAI2 __last2)
        {
   const typename iterator_traits<_RAI1>::difference_type
     __diff1 = __last1 - __first1;
   const typename iterator_traits<_RAI2>::difference_type
     __diff2 = __last2 - __first2;
   return __diff2 < __diff1 ? __first1 + __diff2 : __last1;
 }

      template<typename _RAI>
        static bool
        __cnd2(_RAI, _RAI)
        { return true; }
    };

  template<bool _BoolType>
    struct __lexicographical_compare
    {
      template<typename _II1, typename _II2>
        static bool __lc(_II1, _II1, _II2, _II2);
    };

  template<bool _BoolType>
    template<typename _II1, typename _II2>
      bool
      __lexicographical_compare<_BoolType>::
      __lc(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)
      {
 typedef typename iterator_traits<_II1>::iterator_category _Category1;
 typedef typename iterator_traits<_II2>::iterator_category _Category2;
 typedef std::__lc_rai<_Category1, _Category2> __rai_type;

 __last1 = __rai_type::__newlast1(__first1, __last1,
      __first2, __last2);
 for (; __first1 != __last1 && __rai_type::__cnd2(__first2, __last2);
      ++__first1, ++__first2)
   {
     if (*__first1 < *__first2)
       return true;
     if (*__first2 < *__first1)
       return false;
   }
 return __first1 == __last1 && __first2 != __last2;
      }

  template<>
    struct __lexicographical_compare<true>
    {
      template<typename _Tp, typename _Up>
        static bool
        __lc(const _Tp* __first1, const _Tp* __last1,
      const _Up* __first2, const _Up* __last2)
 {
   const size_t __len1 = __last1 - __first1;
   const size_t __len2 = __last2 - __first2;
   const int __result = __builtin_memcmp(__first1, __first2,
      std::min(__len1, __len2));
   return __result != 0 ? __result < 0 : __len1 < __len2;
 }
    };

  template<typename _II1, typename _II2>
    inline bool
    __lexicographical_compare_aux(_II1 __first1, _II1 __last1,
      _II2 __first2, _II2 __last2)
    {
      typedef typename iterator_traits<_II1>::value_type _ValueType1;
      typedef typename iterator_traits<_II2>::value_type _ValueType2;
      const bool __simple =
 (__is_byte<_ValueType1>::__value && __is_byte<_ValueType2>::__value
  && !__gnu_cxx::__numeric_traits<_ValueType1>::__is_signed
  && !__gnu_cxx::__numeric_traits<_ValueType2>::__is_signed
  && __is_pointer<_II1>::__value
  && __is_pointer<_II2>::__value);

      return std::__lexicographical_compare<__simple>::__lc(__first1, __last1,
           __first2, __last2);
    }

}

namespace std __attribute__ ((__visibility__ ("default"))) {
# 950 "/usr/include/c++/4.4/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2>
    inline bool
    equal(_II1 __first1, _II1 __last1, _II2 __first2)
    {

     
     
     


      ;

      return std::__equal_aux(std::__niter_base<_II1>::__b(__first1),
         std::__niter_base<_II1>::__b(__last1),
         std::__niter_base<_II2>::__b(__first2));
    }
# 982 "/usr/include/c++/4.4/bits/stl_algobase.h" 3
  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>
    inline bool
    equal(_IIter1 __first1, _IIter1 __last1,
   _IIter2 __first2, _BinaryPredicate __binary_pred)
    {

     
     
      ;

      for (; __first1 != __last1; ++__first1, ++__first2)
 if (!bool(__binary_pred(*__first1, *__first2)))
   return false;
      return true;
    }
# 1013 "/usr/include/c++/4.4/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2>
    inline bool
    lexicographical_compare(_II1 __first1, _II1 __last1,
       _II2 __first2, _II2 __last2)
    {

      typedef typename iterator_traits<_II1>::value_type _ValueType1;
      typedef typename iterator_traits<_II2>::value_type _ValueType2;
     
     
     
     
      ;
      ;

      return std::__lexicographical_compare_aux
 (std::__niter_base<_II1>::__b(__first1),
  std::__niter_base<_II1>::__b(__last1),
  std::__niter_base<_II2>::__b(__first2),
  std::__niter_base<_II2>::__b(__last2));
    }
# 1048 "/usr/include/c++/4.4/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2, typename _Compare>
    bool
    lexicographical_compare(_II1 __first1, _II1 __last1,
       _II2 __first2, _II2 __last2, _Compare __comp)
    {
      typedef typename iterator_traits<_II1>::iterator_category _Category1;
      typedef typename iterator_traits<_II2>::iterator_category _Category2;
      typedef std::__lc_rai<_Category1, _Category2> __rai_type;


     
     
      ;
      ;

      __last1 = __rai_type::__newlast1(__first1, __last1, __first2, __last2);
      for (; __first1 != __last1 && __rai_type::__cnd2(__first2, __last2);
    ++__first1, ++__first2)
 {
   if (__comp(*__first1, *__first2))
     return true;
   if (__comp(*__first2, *__first1))
     return false;
 }
      return __first1 == __last1 && __first2 != __last2;
    }
# 1088 "/usr/include/c++/4.4/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2>
    pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2)
    {

     
     
     


      ;

      while (__first1 != __last1 && *__first1 == *__first2)
        {
   ++__first1;
   ++__first2;
        }
      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
    }
# 1125 "/usr/include/c++/4.4/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _BinaryPredicate>
    pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _BinaryPredicate __binary_pred)
    {

     
     
      ;

      while (__first1 != __last1 && bool(__binary_pred(*__first1, *__first2)))
        {
   ++__first1;
   ++__first2;
        }
      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
    }

}
# 42 "/usr/include/c++/4.4/bits/char_traits.h" 2 3
# 1 "/usr/include/c++/4.4/bits/postypes.h" 1 3
# 40 "/usr/include/c++/4.4/bits/postypes.h" 3
       
# 41 "/usr/include/c++/4.4/bits/postypes.h" 3

# 1 "/usr/include/c++/4.4/cwchar" 1 3
# 41 "/usr/include/c++/4.4/cwchar" 3
       
# 42 "/usr/include/c++/4.4/cwchar" 3


# 1 "/usr/include/c++/4.4/cstddef" 1 3
# 41 "/usr/include/c++/4.4/cstddef" 3
       
# 42 "/usr/include/c++/4.4/cstddef" 3


# 1 "/usr/lib/gcc/i686-linux-gnu/4.4.5/include/stddef.h" 1 3 4
# 45 "/usr/include/c++/4.4/cstddef" 2 3
# 45 "/usr/include/c++/4.4/cwchar" 2 3


# 1 "/usr/include/wchar.h" 1 3 4
# 48 "/usr/include/c++/4.4/cwchar" 2 3
# 65 "/usr/include/c++/4.4/cwchar" 3
namespace std __attribute__ ((__visibility__ ("default"))) {

  using ::mbstate_t;

}
# 139 "/usr/include/c++/4.4/cwchar" 3
namespace std __attribute__ ((__visibility__ ("default"))) {

  using ::wint_t;

  using ::btowc;
  using ::fgetwc;
  using ::fgetws;
  using ::fputwc;
  using ::fputws;
  using ::fwide;
  using ::fwprintf;
  using ::fwscanf;
  using ::getwc;
  using ::getwchar;
  using ::mbrlen;
  using ::mbrtowc;
  using ::mbsinit;
  using ::mbsrtowcs;
  using ::putwc;
  using ::putwchar;

  using ::swprintf;

  using ::swscanf;
  using ::ungetwc;
  using ::vfwprintf;

  using ::vfwscanf;


  using ::vswprintf;


  using ::vswscanf;

  using ::vwprintf;

  using ::vwscanf;

  using ::wcrtomb;
  using ::wcscat;
  using ::wcscmp;
  using ::wcscoll;
  using ::wcscpy;
  using ::wcscspn;
  using ::wcsftime;
  using ::wcslen;
  using ::wcsncat;
  using ::wcsncmp;
  using ::wcsncpy;
  using ::wcsrtombs;
  using ::wcsspn;
  using ::wcstod;

  using ::wcstof;

  using ::wcstok;
  using ::wcstol;
  using ::wcstoul;
  using ::wcsxfrm;
  using ::wctob;
  using ::wmemcmp;
  using ::wmemcpy;
  using ::wmemmove;
  using ::wmemset;
  using ::wprintf;
  using ::wscanf;
  using ::wcschr;
  using ::wcspbrk;
  using ::wcsrchr;
  using ::wcsstr;
  using ::wmemchr;
# 234 "/usr/include/c++/4.4/cwchar" 3
}







namespace __gnu_cxx __attribute__ ((__visibility__ ("default"))) {






  using ::wcstold;
# 258 "/usr/include/c++/4.4/cwchar" 3
  using ::wcstoll;
  using ::wcstoull;


}

namespace std __attribute__ ((__visibility__ ("default"))) {

  using ::__gnu_cxx::wcstold;
  using ::__gnu_cxx::wcstoll;
  using ::__gnu_cxx::wcstoull;

}
# 43 "/usr/include/c++/4.4/bits/postypes.h" 2 3
# 70 "/usr/include/c++/4.4/bits/postypes.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {
# 90 "/usr/include/c++/4.4/bits/postypes.h" 3
  typedef long long streamoff;







  typedef ptrdiff_t streamsize;
# 111 "/usr/include/c++/4.4/bits/postypes.h" 3
  template<typename _StateT>
    class fpos
    {
    private:
      streamoff _M_off;
      _StateT _M_state;

    public:




      fpos()
      : _M_off(0), _M_state() { }
# 133 "/usr/include/c++/4.4/bits/postypes.h" 3
      fpos(streamoff __off)
      : _M_off(__off), _M_state() { }


      operator streamoff() const { return _M_off; }


      void
      state(_StateT __st)
      { _M_state = __st; }


      _StateT
      state() const
      { return _M_state; }





      fpos&
      operator+=(streamoff __off)
      {
 _M_off += __off;
 return *this;
      }





      fpos&
      operator-=(streamoff __off)
      {
 _M_off -= __off;
 return *this;
      }







      fpos
      operator+(streamoff __off) const
      {
 fpos __pos(*this);
 __pos += __off;
 return __pos;
      }







      fpos
      operator-(streamoff __off) const
      {
 fpos __pos(*this);
 __pos -= __off;
 return __pos;
      }






      streamoff
      operator-(const fpos& __other) const
      { return _M_off - __other._M_off; }
    };






  template<typename _StateT>
    inline bool
    operator==(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
    { return streamoff(__lhs) == streamoff(__rhs); }

  template<typename _StateT>
    inline bool
    operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
    { return streamoff(__lhs) != streamoff(__rhs); }





  typedef fpos<mbstate_t> streampos;

  typedef fpos<mbstate_t> wstreampos;
# 239 "/usr/include/c++/4.4/bits/postypes.h" 3
}
# 43 "/usr/include/c++/4.4/bits/char_traits.h" 2 3
# 1 "/usr/include/c++/4.4/cwchar" 1 3
# 41 "/usr/include/c++/4.4/cwchar" 3
       
# 42 "/usr/include/c++/4.4/cwchar" 3


# 1 "/usr/include/c++/4.4/cstddef" 1 3
# 41 "/usr/include/c++/4.4/cstddef" 3
       
# 42 "/usr/include/c++/4.4/cstddef" 3


# 1 "/usr/lib/gcc/i686-linux-gnu/4.4.5/include/stddef.h" 1 3 4
# 45 "/usr/include/c++/4.4/cstddef" 2 3
# 45 "/usr/include/c++/4.4/cwchar" 2 3


# 1 "/usr/include/wchar.h" 1 3 4
# 48 "/usr/include/c++/4.4/cwchar" 2 3
# 44 "/usr/include/c++/4.4/bits/char_traits.h" 2 3
# 52 "/usr/include/c++/4.4/bits/char_traits.h" 3
namespace __gnu_cxx __attribute__ ((__visibility__ ("default"))) {
# 64 "/usr/include/c++/4.4/bits/char_traits.h" 3
  template<typename _CharT>
    struct _Char_types
    {
      typedef unsigned long int_type;
      typedef std::streampos pos_type;
      typedef std::streamoff off_type;
      typedef std::mbstate_t state_type;
    };
# 89 "/usr/include/c++/4.4/bits/char_traits.h" 3
  template<typename _CharT>
    struct char_traits
    {
      typedef _CharT char_type;
      typedef typename _Char_types<_CharT>::int_type int_type;
      typedef typename _Char_types<_CharT>::pos_type pos_type;
      typedef typename _Char_types<_CharT>::off_type off_type;
      typedef typename _Char_types<_CharT>::state_type state_type;

      static void
      assign(char_type& __c1, const char_type& __c2)
      { __c1 = __c2; }

      static bool
      eq(const char_type& __c1, const char_type& __c2)
      { return __c1 == __c2; }

      static bool
      lt(const char_type& __c1, const char_type& __c2)
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, std::size_t __n);

      static std::size_t
      length(const char_type* __s);

      static const char_type*
      find(const char_type* __s, std::size_t __n, const char_type& __a);

      static char_type*
      move(char_type* __s1, const char_type* __s2, std::size_t __n);

      static char_type*
      copy(char_type* __s1, const char_type* __s2, std::size_t __n);

      static char_type*
      assign(char_type* __s, std::size_t __n, char_type __a);

      static char_type
      to_char_type(const int_type& __c)
      { return static_cast<char_type>(__c); }

      static int_type
      to_int_type(const char_type& __c)
      { return static_cast<int_type>(__c); }

      static bool
      eq_int_type(const int_type& __c1, const int_type& __c2)
      { return __c1 == __c2; }

      static int_type
      eof()
      { return static_cast<int_type>((-1)); }

      static int_type
      not_eof(const int_type& __c)
      { return !eq_int_type(__c, eof()) ? __c : to_int_type(char_type()); }
    };

  template<typename _CharT>
    int
    char_traits<_CharT>::
    compare(const char_type* __s1, const char_type* __s2, std::size_t __n)
    {
      for (std::size_t __i = 0; __i < __n; ++__i)
 if (lt(__s1[__i], __s2[__i]))
   return -1;
 else if (lt(__s2[__i], __s1[__i]))
   return 1;
      return 0;
    }

  template<typename _CharT>
    std::size_t
    char_traits<_CharT>::
    length(const char_type* __p)
    {
      std::size_t __i = 0;
      while (!eq(__p[__i], char_type()))
        ++__i;
      return __i;
    }

  template<typename _CharT>
    const typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    find(const char_type* __s, std::size_t __n, const char_type& __a)
    {
      for (std::size_t __i = 0; __i < __n; ++__i)
        if (eq(__s[__i], __a))
          return __s + __i;
      return 0;
    }

  template<typename _CharT>
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    move(char_type* __s1, const char_type* __s2, std::size_t __n)
    {
      return static_cast<_CharT*>(__builtin_memmove(__s1, __s2,
          __n * sizeof(char_type)));
    }

  template<typename _CharT>
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    copy(char_type* __s1, const char_type* __s2, std::size_t __n)
    {

      std::copy(__s2, __s2 + __n, __s1);
      return __s1;
    }

  template<typename _CharT>
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    assign(char_type* __s, std::size_t __n, char_type __a)
    {

      std::fill_n(__s, __n, __a);
      return __s;
    }

}

namespace std __attribute__ ((__visibility__ ("default"))) {
# 230 "/usr/include/c++/4.4/bits/char_traits.h" 3
  template<class _CharT>
    struct char_traits : public __gnu_cxx::char_traits<_CharT>
    { };



  template<>
    struct char_traits<char>
    {
      typedef char char_type;
      typedef int int_type;
      typedef streampos pos_type;
      typedef streamoff off_type;
      typedef mbstate_t state_type;

      static void
      assign(char_type& __c1, const char_type& __c2)
      { __c1 = __c2; }

      static bool
      eq(const char_type& __c1, const char_type& __c2)
      { return __c1 == __c2; }

      static bool
      lt(const char_type& __c1, const char_type& __c2)
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      { return __builtin_memcmp(__s1, __s2, __n); }

      static size_t
      length(const char_type* __s)
      { return __builtin_strlen(__s); }

      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      { return static_cast<const char_type*>(__builtin_memchr(__s, __a, __n)); }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      { return static_cast<char_type*>(__builtin_memmove(__s1, __s2, __n)); }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      { return static_cast<char_type*>(__builtin_memcpy(__s1, __s2, __n)); }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      { return static_cast<char_type*>(__builtin_memset(__s, __a, __n)); }

      static char_type
      to_char_type(const int_type& __c)
      { return static_cast<char_type>(__c); }



      static int_type
      to_int_type(const char_type& __c)
      { return static_cast<int_type>(static_cast<unsigned char>(__c)); }

      static bool
      eq_int_type(const int_type& __c1, const int_type& __c2)
      { return __c1 == __c2; }

      static int_type
      eof()
      { return static_cast<int_type>((-1)); }

      static int_type
      not_eof(const int_type& __c)
      { return (__c == eof()) ? 0 : __c; }
  };




  template<>
    struct char_traits<wchar_t>
    {
      typedef wchar_t char_type;
      typedef wint_t int_type;
      typedef streamoff off_type;
      typedef wstreampos pos_type;
      typedef mbstate_t state_type;

      static void
      assign(char_type& __c1, const char_type& __c2)
      { __c1 = __c2; }

      static bool
      eq(const char_type& __c1, const char_type& __c2)
      { return __c1 == __c2; }

      static bool
      lt(const char_type& __c1, const char_type& __c2)
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      { return wmemcmp(__s1, __s2, __n); }

      static size_t
      length(const char_type* __s)
      { return wcslen(__s); }

      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      { return wmemchr(__s, __a, __n); }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      { return wmemmove(__s1, __s2, __n); }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      { return wmemcpy(__s1, __s2, __n); }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      { return wmemset(__s, __a, __n); }

      static char_type
      to_char_type(const int_type& __c)
      { return char_type(__c); }

      static int_type
      to_int_type(const char_type& __c)
      { return int_type(__c); }

      static bool
      eq_int_type(const int_type& __c1, const int_type& __c2)
      { return __c1 == __c2; }

      static int_type
      eof()
      { return static_cast<int_type>((0xffffffffu)); }

      static int_type
      not_eof(const int_type& __c)
      { return eq_int_type(__c, eof()) ? 0 : __c; }
  };


}
# 43 "/usr/include/c++/4.4/string" 2 3
# 1 "/usr/include/c++/4.4/bits/allocator.h" 1 3
# 48 "/usr/include/c++/4.4/bits/allocator.h" 3
# 1 "/usr/include/c++/4.4/i686-linux-gnu/bits/c++allocator.h" 1 3
# 34 "/usr/include/c++/4.4/i686-linux-gnu/bits/c++allocator.h" 3
# 1 "/usr/include/c++/4.4/ext/new_allocator.h" 1 3
# 33 "/usr/include/c++/4.4/ext/new_allocator.h" 3
# 1 "/usr/include/c++/4.4/new" 1 3
# 39 "/usr/include/c++/4.4/new" 3
# 1 "/usr/include/c++/4.4/cstddef" 1 3
# 41 "/usr/include/c++/4.4/cstddef" 3
       
# 42 "/usr/include/c++/4.4/cstddef" 3


# 1 "/usr/lib/gcc/i686-linux-gnu/4.4.5/include/stddef.h" 1 3 4
# 45 "/usr/include/c++/4.4/cstddef" 2 3
# 40 "/usr/include/c++/4.4/new" 2 3
# 1 "/usr/include/c++/4.4/exception" 1 3
# 35 "/usr/include/c++/4.4/exception" 3
#pragma GCC visibility push(default)



extern "C++" {

namespace std
{
# 59 "/usr/include/c++/4.4/exception" 3
  class exception
  {
  public:
    exception() throw() { }
    virtual ~exception() throw();



    virtual const char* what() const throw();
  };



  class bad_exception : public exception
  {
  public:
    bad_exception() throw() { }



    virtual ~bad_exception() throw();


    virtual const char* what() const throw();
  };


  typedef void (*terminate_handler) ();


  typedef void (*unexpected_handler) ();


  terminate_handler set_terminate(terminate_handler) throw();



  void terminate() __attribute__ ((__noreturn__));


  unexpected_handler set_unexpected(unexpected_handler) throw();



  void unexpected() __attribute__ ((__noreturn__));
# 115 "/usr/include/c++/4.4/exception" 3
  bool uncaught_exception() throw();


}

namespace __gnu_cxx __attribute__ ((__visibility__ ("default"))) {
# 138 "/usr/include/c++/4.4/exception" 3
  void __verbose_terminate_handler();

}

}

#pragma GCC visibility pop
# 41 "/usr/include/c++/4.4/new" 2 3

#pragma GCC visibility push(default)

extern "C++" {

namespace std
{






  class bad_alloc : public exception
  {
  public:
    bad_alloc() throw() { }



    virtual ~bad_alloc() throw();


    virtual const char* what() const throw();
  };

  struct nothrow_t { };

  extern const nothrow_t nothrow;



  typedef void (*new_handler)();



  new_handler set_new_handler(new_handler) throw();
}
# 91 "/usr/include/c++/4.4/new" 3
void* operator new(std::size_t) throw (std::bad_alloc);
void* operator new[](std::size_t) throw (std::bad_alloc);
void operator delete(void*) throw();
void operator delete[](void*) throw();
void* operator new(std::size_t, const std::nothrow_t&) throw();
void* operator new[](std::size_t, const std::nothrow_t&) throw();
void operator delete(void*, const std::nothrow_t&) throw();
void operator delete[](void*, const std::nothrow_t&) throw();


inline void* operator new(std::size_t, void* __p) throw() { return __p; }
inline void* operator new[](std::size_t, void* __p) throw() { return __p; }


inline void operator delete (void*, void*) throw() { }
inline void operator delete[](void*, void*) throw() { }

}

#pragma GCC visibility pop
# 34 "/usr/include/c++/4.4/ext/new_allocator.h" 2 3



namespace __gnu_cxx __attribute__ ((__visibility__ ("default"))) {

  using std::size_t;
  using std::ptrdiff_t;
# 50 "/usr/include/c++/4.4/ext/new_allocator.h" 3
  template<typename _Tp>
    class new_allocator
    {
    public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef const _Tp* const_pointer;
      typedef _Tp& reference;
      typedef const _Tp& const_reference;
      typedef _Tp value_type;

      template<typename _Tp1>
        struct rebind
        { typedef new_allocator<_Tp1> other; };

      new_allocator() throw() { }

      new_allocator(const new_allocator&) throw() { }

      template<typename _Tp1>
        new_allocator(const new_allocator<_Tp1>&) throw() { }

      ~new_allocator() throw() { }

      pointer
      address(reference __x) const { return &__x; }

      const_pointer
      address(const_reference __x) const { return &__x; }



      pointer
      allocate(size_type __n, const void* = 0)
      {
 if (__builtin_expect(__n > this->max_size(), false))
   std::__throw_bad_alloc();

 return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
      }


      void
      deallocate(pointer __p, size_type)
      { ::operator delete(__p); }

      size_type
      max_size() const throw()
      { return size_t(-1) / sizeof(_Tp); }



      void
      construct(pointer __p, const _Tp& __val)
      { ::new((void *)__p) _Tp(__val); }
# 114 "/usr/include/c++/4.4/ext/new_allocator.h" 3
      void
      destroy(pointer __p) { __p->~_Tp(); }
    };

  template<typename _Tp>
    inline bool
    operator==(const new_allocator<_Tp>&, const new_allocator<_Tp>&)
    { return true; }

  template<typename _Tp>
    inline bool
    operator!=(const new_allocator<_Tp>&, const new_allocator<_Tp>&)
    { return false; }

}
# 35 "/usr/include/c++/4.4/i686-linux-gnu/bits/c++allocator.h" 2 3
# 49 "/usr/include/c++/4.4/bits/allocator.h" 2 3

namespace std __attribute__ ((__visibility__ ("default"))) {
# 59 "/usr/include/c++/4.4/bits/allocator.h" 3
  template<typename _Tp>
    class allocator;


  template<>
    class allocator<void>
    {
    public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef void* pointer;
      typedef const void* const_pointer;
      typedef void value_type;

      template<typename _Tp1>
        struct rebind
        { typedef allocator<_Tp1> other; };
    };
# 85 "/usr/include/c++/4.4/bits/allocator.h" 3
  template<typename _Tp>
    class allocator: public __gnu_cxx::new_allocator<_Tp>
    {
   public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef const _Tp* const_pointer;
      typedef _Tp& reference;
      typedef const _Tp& const_reference;
      typedef _Tp value_type;

      template<typename _Tp1>
        struct rebind
        { typedef allocator<_Tp1> other; };

      allocator() throw() { }

      allocator(const allocator& __a) throw()
      : __gnu_cxx::new_allocator<_Tp>(__a) { }

      template<typename _Tp1>
        allocator(const allocator<_Tp1>&) throw() { }

      ~allocator() throw() { }


    };

  template<typename _T1, typename _T2>
    inline bool
    operator==(const allocator<_T1>&, const allocator<_T2>&)
    { return true; }

  template<typename _Tp>
    inline bool
    operator==(const allocator<_Tp>&, const allocator<_Tp>&)
    { return true; }

  template<typename _T1, typename _T2>
    inline bool
    operator!=(const allocator<_T1>&, const allocator<_T2>&)
    { return false; }

  template<typename _Tp>
    inline bool
    operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
    { return false; }





  extern template class allocator<char>;
  extern template class allocator<wchar_t>;






  template<typename _Alloc, bool = __is_empty(_Alloc)>
    struct __alloc_swap
    { static void _S_do_it(_Alloc&, _Alloc&) { } };

  template<typename _Alloc>
    struct __alloc_swap<_Alloc, false>
    {
      static void
      _S_do_it(_Alloc& __one, _Alloc& __two)
      {

 if (__one != __two)
   swap(__one, __two);
      }
    };


  template<typename _Alloc, bool = __is_empty(_Alloc)>
    struct __alloc_neq
    {
      static bool
      _S_do_it(const _Alloc&, const _Alloc&)
      { return false; }
    };

  template<typename _Alloc>
    struct __alloc_neq<_Alloc, false>
    {
      static bool
      _S_do_it(const _Alloc& __one, const _Alloc& __two)
      { return __one != __two; }
    };

}
# 44 "/usr/include/c++/4.4/string" 2 3

# 1 "/usr/include/c++/4.4/bits/localefwd.h" 1 3
# 39 "/usr/include/c++/4.4/bits/localefwd.h" 3
       
# 40 "/usr/include/c++/4.4/bits/localefwd.h" 3


# 1 "/usr/include/c++/4.4/i686-linux-gnu/bits/c++locale.h" 1 3
# 40 "/usr/include/c++/4.4/i686-linux-gnu/bits/c++locale.h" 3
       
# 41 "/usr/include/c++/4.4/i686-linux-gnu/bits/c++locale.h" 3

# 1 "/usr/include/c++/4.4/clocale" 1 3
# 41 "/usr/include/c++/4.4/clocale" 3
       
# 42 "/usr/include/c++/4.4/clocale" 3


# 1 "/usr/include/locale.h" 1 3 4
# 29 "/usr/include/locale.h" 3 4
# 1 "/usr/lib/gcc/i686-linux-gnu/4.4.5/include/stddef.h" 1 3 4
# 30 "/usr/include/locale.h" 2 3 4
# 1 "/usr/include/bits/locale.h" 1 3 4
# 27 "/usr/include/bits/locale.h" 3 4
enum
{
  __LC_CTYPE = 0,
  __LC_NUMERIC = 1,
  __LC_TIME = 2,
  __LC_COLLATE = 3,
  __LC_MONETARY = 4,
  __LC_MESSAGES = 5,
  __LC_ALL = 6,
  __LC_PAPER = 7,
  __LC_NAME = 8,
  __LC_ADDRESS = 9,
  __LC_TELEPHONE = 10,
  __LC_MEASUREMENT = 11,
  __LC_IDENTIFICATION = 12
};
# 31 "/usr/include/locale.h" 2 3 4

extern "C" {
# 51 "/usr/include/locale.h" 3 4



struct lconv
{


  char *decimal_point;
  char *thousands_sep;





  char *grouping;





  char *int_curr_symbol;
  char *currency_symbol;
  char *mon_decimal_point;
  char *mon_thousands_sep;
  char *mon_grouping;
  char *positive_sign;
  char *negative_sign;
  char int_frac_digits;
  char frac_digits;

  char p_cs_precedes;

  char p_sep_by_space;

  char n_cs_precedes;

  char n_sep_by_space;






  char p_sign_posn;
  char n_sign_posn;


  char int_p_cs_precedes;

  char int_p_sep_by_space;

  char int_n_cs_precedes;

  char int_n_sep_by_space;






  char int_p_sign_posn;
  char int_n_sign_posn;
# 121 "/usr/include/locale.h" 3 4
};



extern char *setlocale (int __category, __const char *__locale) throw ();


extern struct lconv *localeconv (void) throw ();


# 152 "/usr/include/locale.h" 3 4
extern __locale_t newlocale (int __category_mask, __const char *__locale,
        __locale_t __base) throw ();
# 187 "/usr/include/locale.h" 3 4
extern __locale_t duplocale (__locale_t __dataset) throw ();



extern void freelocale (__locale_t __dataset) throw ();






extern __locale_t uselocale (__locale_t __dataset) throw ();







}
# 45 "/usr/include/c++/4.4/clocale" 2 3
# 53 "/usr/include/c++/4.4/clocale" 3
namespace std __attribute__ ((__visibility__ ("default"))) {

  using ::lconv;
  using ::setlocale;
  using ::localeconv;

}
# 43 "/usr/include/c++/4.4/i686-linux-gnu/bits/c++locale.h" 2 3
# 1 "/usr/include/c++/4.4/cstddef" 1 3
# 41 "/usr/include/c++/4.4/cstddef" 3
       
# 42 "/usr/include/c++/4.4/cstddef" 3


# 1 "/usr/lib/gcc/i686-linux-gnu/4.4.5/include/stddef.h" 1 3 4
# 45 "/usr/include/c++/4.4/cstddef" 2 3
# 44 "/usr/include/c++/4.4/i686-linux-gnu/bits/c++locale.h" 2 3






namespace __gnu_cxx __attribute__ ((__visibility__ ("default"))) {

  extern "C" __typeof(uselocale) __uselocale;

}


namespace std __attribute__ ((__visibility__ ("default"))) {

  typedef __locale_t __c_locale;





  inline int
  __convert_from_v(const __c_locale& __cloc __attribute__ ((__unused__)),
     char* __out,
     const int __size __attribute__ ((__unused__)),
     const char* __fmt, ...)
  {

    __c_locale __old = __gnu_cxx::__uselocale(__cloc);
# 85 "/usr/include/c++/4.4/i686-linux-gnu/bits/c++locale.h" 3
    __builtin_va_list __args;
    __builtin_va_start(__args, __fmt);


    const int __ret = __builtin_vsnprintf(__out, __size, __fmt, __args);




    __builtin_va_end(__args);


    __gnu_cxx::__uselocale(__old);







    return __ret;
  }

}
# 43 "/usr/include/c++/4.4/bits/localefwd.h" 2 3
# 1 "/usr/include/c++/4.4/iosfwd" 1 3
# 38 "/usr/include/c++/4.4/iosfwd" 3
       
# 39 "/usr/include/c++/4.4/iosfwd" 3





namespace std __attribute__ ((__visibility__ ("default"))) {

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ios;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_streambuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_istream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ostream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_iostream;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
     typename _Alloc = allocator<_CharT> >
    class basic_stringbuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_istringstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_ostringstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_stringstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_filebuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ifstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ofstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_fstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class istreambuf_iterator;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class ostreambuf_iterator;



  class ios_base;
# 127 "/usr/include/c++/4.4/iosfwd" 3
  typedef basic_ios<char> ios;
  typedef basic_streambuf<char> streambuf;
  typedef basic_istream<char> istream;
  typedef basic_ostream<char> ostream;
  typedef basic_iostream<char> iostream;
  typedef basic_stringbuf<char> stringbuf;
  typedef basic_istringstream<char> istringstream;
  typedef basic_ostringstream<char> ostringstream;
  typedef basic_stringstream<char> stringstream;
  typedef basic_filebuf<char> filebuf;
  typedef basic_ifstream<char> ifstream;
  typedef basic_ofstream<char> ofstream;
  typedef basic_fstream<char> fstream;


  typedef basic_ios<wchar_t> wios;
  typedef basic_streambuf<wchar_t> wstreambuf;
  typedef basic_istream<wchar_t> wistream;
  typedef basic_ostream<wchar_t> wostream;
  typedef basic_iostream<wchar_t> wiostream;
  typedef basic_stringbuf<wchar_t> wstringbuf;
  typedef basic_istringstream<wchar_t> wistringstream;
  typedef basic_ostringstream<wchar_t> wostringstream;
  typedef basic_stringstream<wchar_t> wstringstream;
  typedef basic_filebuf<wchar_t> wfilebuf;
  typedef basic_ifstream<wchar_t> wifstream;
  typedef basic_ofstream<wchar_t> wofstream;
  typedef basic_fstream<wchar_t> wfstream;



}
# 44 "/usr/include/c++/4.4/bits/localefwd.h" 2 3
# 1 "/usr/include/c++/4.4/cctype" 1 3
# 41 "/usr/include/c++/4.4/cctype" 3
       
# 42 "/usr/include/c++/4.4/cctype" 3


# 1 "/usr/include/ctype.h" 1 3 4
# 30 "/usr/include/ctype.h" 3 4
extern "C" {
# 48 "/usr/include/ctype.h" 3 4
enum
{
  _ISupper = ((0) < 8 ? ((1 << (0)) << 8) : ((1 << (0)) >> 8)),
  _ISlower = ((1) < 8 ? ((1 << (1)) << 8) : ((1 << (1)) >> 8)),
  _ISalpha = ((2) < 8 ? ((1 << (2)) << 8) : ((1 << (2)) >> 8)),
  _ISdigit = ((3) < 8 ? ((1 << (3)) << 8) : ((1 << (3)) >> 8)),
  _ISxdigit = ((4) < 8 ? ((1 << (4)) << 8) : ((1 << (4)) >> 8)),
  _ISspace = ((5) < 8 ? ((1 << (5)) << 8) : ((1 << (5)) >> 8)),
  _ISprint = ((6) < 8 ? ((1 << (6)) << 8) : ((1 << (6)) >> 8)),
  _ISgraph = ((7) < 8 ? ((1 << (7)) << 8) : ((1 << (7)) >> 8)),
  _ISblank = ((8) < 8 ? ((1 << (8)) << 8) : ((1 << (8)) >> 8)),
  _IScntrl = ((9) < 8 ? ((1 << (9)) << 8) : ((1 << (9)) >> 8)),
  _ISpunct = ((10) < 8 ? ((1 << (10)) << 8) : ((1 << (10)) >> 8)),
  _ISalnum = ((11) < 8 ? ((1 << (11)) << 8) : ((1 << (11)) >> 8))
};
# 81 "/usr/include/ctype.h" 3 4
extern __const unsigned short int **__ctype_b_loc (void)
     throw () __attribute__ ((__const));
extern __const __int32_t **__ctype_tolower_loc (void)
     throw () __attribute__ ((__const));
extern __const __int32_t **__ctype_toupper_loc (void)
     throw () __attribute__ ((__const));
# 96 "/usr/include/ctype.h" 3 4






extern int isalnum (int) throw ();
extern int isalpha (int) throw ();
extern int iscntrl (int) throw ();
extern int isdigit (int) throw ();
extern int islower (int) throw ();
extern int isgraph (int) throw ();
extern int isprint (int) throw ();
extern int ispunct (int) throw ();
extern int isspace (int) throw ();
extern int isupper (int) throw ();
extern int isxdigit (int) throw ();



extern int tolower (int __c) throw ();


extern int toupper (int __c) throw ();








extern int isblank (int) throw ();






extern int isctype (int __c, int __mask) throw ();






extern int isascii (int __c) throw ();



extern int toascii (int __c) throw ();



extern int _toupper (int) throw ();
extern int _tolower (int) throw ();
# 247 "/usr/include/ctype.h" 3 4
extern int isalnum_l (int, __locale_t) throw ();
extern int isalpha_l (int, __locale_t) throw ();
extern int iscntrl_l (int, __locale_t) throw ();
extern int isdigit_l (int, __locale_t) throw ();
extern int islower_l (int, __locale_t) throw ();
extern int isgraph_l (int, __locale_t) throw ();
extern int isprint_l (int, __locale_t) throw ();
extern int ispunct_l (int, __locale_t) throw ();
extern int isspace_l (int, __locale_t) throw ();
extern int isupper_l (int, __locale_t) throw ();
extern int isxdigit_l (int, __locale_t) throw ();

extern int isblank_l (int, __locale_t) throw ();



extern int __tolower_l (int __c, __locale_t __l) throw ();
extern int tolower_l (int __c, __locale_t __l) throw ();


extern int __toupper_l (int __c, __locale_t __l) throw ();
extern int toupper_l (int __c, __locale_t __l) throw ();
# 323 "/usr/include/ctype.h" 3 4
}
# 45 "/usr/include/c++/4.4/cctype" 2 3
# 64 "/usr/include/c++/4.4/cctype" 3
namespace std __attribute__ ((__visibility__ ("default"))) {

  using ::isalnum;
  using ::isalpha;
  using ::iscntrl;
  using ::isdigit;
  using ::isgraph;
  using ::islower;
  using ::isprint;
  using ::ispunct;
  using ::isspace;
  using ::isupper;
  using ::isxdigit;
  using ::tolower;
  using ::toupper;

}
# 45 "/usr/include/c++/4.4/bits/localefwd.h" 2 3

namespace std __attribute__ ((__visibility__ ("default"))) {


  class locale;

  template<typename _Facet>
    bool
    has_facet(const locale&) throw();

  template<typename _Facet>
    const _Facet&
    use_facet(const locale&);


  template<typename _CharT>
    bool
    isspace(_CharT, const locale&);

  template<typename _CharT>
    bool
    isprint(_CharT, const locale&);

  template<typename _CharT>
    bool
    iscntrl(_CharT, const locale&);

  template<typename _CharT>
    bool
    isupper(_CharT, const locale&);

  template<typename _CharT>
    bool
    islower(_CharT, const locale&);

  template<typename _CharT>
    bool
    isalpha(_CharT, const locale&);

  template<typename _CharT>
    bool
    isdigit(_CharT, const locale&);

  template<typename _CharT>
    bool
    ispunct(_CharT, const locale&);

  template<typename _CharT>
    bool
    isxdigit(_CharT, const locale&);

  template<typename _CharT>
    bool
    isalnum(_CharT, const locale&);

  template<typename _CharT>
    bool
    isgraph(_CharT, const locale&);

  template<typename _CharT>
    _CharT
    toupper(_CharT, const locale&);

  template<typename _CharT>
    _CharT
    tolower(_CharT, const locale&);


  class ctype_base;
  template<typename _CharT>
    class ctype;
  template<> class ctype<char>;

  template<> class ctype<wchar_t>;

  template<typename _CharT>
    class ctype_byname;


  class codecvt_base;
  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt;
  template<> class codecvt<char, char, mbstate_t>;

  template<> class codecvt<wchar_t, char, mbstate_t>;

  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt_byname;



  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class num_get;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class num_put;

  template<typename _CharT> class numpunct;
  template<typename _CharT> class numpunct_byname;


  template<typename _CharT>
    class collate;
  template<typename _CharT> class
    collate_byname;


  class time_base;
  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class time_get;
  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class time_get_byname;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class time_put;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class time_put_byname;


  class money_base;

  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class money_get;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class money_put;

  template<typename _CharT, bool _Intl = false>
    class moneypunct;
  template<typename _CharT, bool _Intl = false>
    class moneypunct_byname;


  class messages_base;
  template<typename _CharT>
    class messages;
  template<typename _CharT>
    class messages_byname;

}
# 46 "/usr/include/c++/4.4/string" 2 3
# 1 "/usr/include/c++/4.4/bits/ostream_insert.h" 1 3
# 33 "/usr/include/c++/4.4/bits/ostream_insert.h" 3
       
# 34 "/usr/include/c++/4.4/bits/ostream_insert.h" 3


# 1 "/usr/include/c++/4.4/cxxabi-forced.h" 1 3
# 29 "/usr/include/c++/4.4/cxxabi-forced.h" 3
#pragma GCC visibility push(default)


namespace __cxxabiv1
{







  class __forced_unwind
  {
    virtual ~__forced_unwind() throw();
    virtual void __pure_dummy() = 0;
  };
}


#pragma GCC visibility pop
# 37 "/usr/include/c++/4.4/bits/ostream_insert.h" 2 3

namespace std __attribute__ ((__visibility__ ("default"))) {

  template<typename _CharT, typename _Traits>
    inline void
    __ostream_write(basic_ostream<_CharT, _Traits>& __out,
      const _CharT* __s, streamsize __n)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const streamsize __put = __out.rdbuf()->sputn(__s, __n);
      if (__put != __n)
 __out.setstate(__ios_base::badbit);
    }

  template<typename _CharT, typename _Traits>
    inline void
    __ostream_fill(basic_ostream<_CharT, _Traits>& __out, streamsize __n)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const _CharT __c = __out.fill();
      for (; __n > 0; --__n)
 {
   const typename _Traits::int_type __put = __out.rdbuf()->sputc(__c);
   if (_Traits::eq_int_type(__put, _Traits::eof()))
     {
       __out.setstate(__ios_base::badbit);
       break;
     }
 }
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    __ostream_insert(basic_ostream<_CharT, _Traits>& __out,
       const _CharT* __s, streamsize __n)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      typename __ostream_type::sentry __cerb(__out);
      if (__cerb)
 {
   try
     {
       const streamsize __w = __out.width();
       if (__w > __n)
  {
    const bool __left = ((__out.flags()
     & __ios_base::adjustfield)
           == __ios_base::left);
    if (!__left)
      __ostream_fill(__out, __w - __n);
    if (__out.good())
      __ostream_write(__out, __s, __n);
    if (__left && __out.good())
      __ostream_fill(__out, __w - __n);
  }
       else
  __ostream_write(__out, __s, __n);
       __out.width(0);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __out._M_setstate(__ios_base::badbit);
       throw;
     }
   catch(...)
     { __out._M_setstate(__ios_base::badbit); }
 }
      return __out;
    }





  extern template ostream& __ostream_insert(ostream&, const char*, streamsize);


  extern template wostream& __ostream_insert(wostream&, const wchar_t*,
          streamsize);



}
# 47 "/usr/include/c++/4.4/string" 2 3



# 1 "/usr/include/c++/4.4/bits/stl_function.h" 1 3
# 60 "/usr/include/c++/4.4/bits/stl_function.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {
# 99 "/usr/include/c++/4.4/bits/stl_function.h" 3
  template<typename _Arg, typename _Result>
    struct unary_function
    {
      typedef _Arg argument_type;


      typedef _Result result_type;
    };




  template<typename _Arg1, typename _Arg2, typename _Result>
    struct binary_function
    {
      typedef _Arg1 first_argument_type;


      typedef _Arg2 second_argument_type;
      typedef _Result result_type;
    };
# 134 "/usr/include/c++/4.4/bits/stl_function.h" 3
  template<typename _Tp>
    struct plus : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x + __y; }
    };


  template<typename _Tp>
    struct minus : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x - __y; }
    };


  template<typename _Tp>
    struct multiplies : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x * __y; }
    };


  template<typename _Tp>
    struct divides : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x / __y; }
    };


  template<typename _Tp>
    struct modulus : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x % __y; }
    };


  template<typename _Tp>
    struct negate : public unary_function<_Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x) const
      { return -__x; }
    };
# 198 "/usr/include/c++/4.4/bits/stl_function.h" 3
  template<typename _Tp>
    struct equal_to : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x == __y; }
    };


  template<typename _Tp>
    struct not_equal_to : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x != __y; }
    };


  template<typename _Tp>
    struct greater : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x > __y; }
    };


  template<typename _Tp>
    struct less : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x < __y; }
    };


  template<typename _Tp>
    struct greater_equal : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x >= __y; }
    };


  template<typename _Tp>
    struct less_equal : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x <= __y; }
    };
# 262 "/usr/include/c++/4.4/bits/stl_function.h" 3
  template<typename _Tp>
    struct logical_and : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x && __y; }
    };


  template<typename _Tp>
    struct logical_or : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x || __y; }
    };


  template<typename _Tp>
    struct logical_not : public unary_function<_Tp, bool>
    {
      bool
      operator()(const _Tp& __x) const
      { return !__x; }
    };




  template<typename _Tp>
    struct bit_and : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x & __y; }
    };

  template<typename _Tp>
    struct bit_or : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x | __y; }
    };

  template<typename _Tp>
    struct bit_xor : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x ^ __y; }
    };
# 345 "/usr/include/c++/4.4/bits/stl_function.h" 3
  template<typename _Predicate>
    class unary_negate
    : public unary_function<typename _Predicate::argument_type, bool>
    {
    protected:
      _Predicate _M_pred;

    public:
      explicit
      unary_negate(const _Predicate& __x) : _M_pred(__x) { }

      bool
      operator()(const typename _Predicate::argument_type& __x) const
      { return !_M_pred(__x); }
    };


  template<typename _Predicate>
    inline unary_negate<_Predicate>
    not1(const _Predicate& __pred)
    { return unary_negate<_Predicate>(__pred); }


  template<typename _Predicate>
    class binary_negate
    : public binary_function<typename _Predicate::first_argument_type,
        typename _Predicate::second_argument_type, bool>
    {
    protected:
      _Predicate _M_pred;

    public:
      explicit
      binary_negate(const _Predicate& __x) : _M_pred(__x) { }

      bool
      operator()(const typename _Predicate::first_argument_type& __x,
   const typename _Predicate::second_argument_type& __y) const
      { return !_M_pred(__x, __y); }
    };


  template<typename _Predicate>
    inline binary_negate<_Predicate>
    not2(const _Predicate& __pred)
    { return binary_negate<_Predicate>(__pred); }
# 416 "/usr/include/c++/4.4/bits/stl_function.h" 3
  template<typename _Arg, typename _Result>
    class pointer_to_unary_function : public unary_function<_Arg, _Result>
    {
    protected:
      _Result (*_M_ptr)(_Arg);

    public:
      pointer_to_unary_function() { }

      explicit
      pointer_to_unary_function(_Result (*__x)(_Arg))
      : _M_ptr(__x) { }

      _Result
      operator()(_Arg __x) const
      { return _M_ptr(__x); }
    };


  template<typename _Arg, typename _Result>
    inline pointer_to_unary_function<_Arg, _Result>
    ptr_fun(_Result (*__x)(_Arg))
    { return pointer_to_unary_function<_Arg, _Result>(__x); }


  template<typename _Arg1, typename _Arg2, typename _Result>
    class pointer_to_binary_function
    : public binary_function<_Arg1, _Arg2, _Result>
    {
    protected:
      _Result (*_M_ptr)(_Arg1, _Arg2);

    public:
      pointer_to_binary_function() { }

      explicit
      pointer_to_binary_function(_Result (*__x)(_Arg1, _Arg2))
      : _M_ptr(__x) { }

      _Result
      operator()(_Arg1 __x, _Arg2 __y) const
      { return _M_ptr(__x, __y); }
    };


  template<typename _Arg1, typename _Arg2, typename _Result>
    inline pointer_to_binary_function<_Arg1, _Arg2, _Result>
    ptr_fun(_Result (*__x)(_Arg1, _Arg2))
    { return pointer_to_binary_function<_Arg1, _Arg2, _Result>(__x); }


  template<typename _Tp>
    struct _Identity : public unary_function<_Tp,_Tp>
    {
      _Tp&
      operator()(_Tp& __x) const
      { return __x; }

      const _Tp&
      operator()(const _Tp& __x) const
      { return __x; }
    };

  template<typename _Pair>
    struct _Select1st : public unary_function<_Pair,
           typename _Pair::first_type>
    {
      typename _Pair::first_type&
      operator()(_Pair& __x) const
      { return __x.first; }

      const typename _Pair::first_type&
      operator()(const _Pair& __x) const
      { return __x.first; }
    };

  template<typename _Pair>
    struct _Select2nd : public unary_function<_Pair,
           typename _Pair::second_type>
    {
      typename _Pair::second_type&
      operator()(_Pair& __x) const
      { return __x.second; }

      const typename _Pair::second_type&
      operator()(const _Pair& __x) const
      { return __x.second; }
    };
# 523 "/usr/include/c++/4.4/bits/stl_function.h" 3
  template<typename _Ret, typename _Tp>
    class mem_fun_t : public unary_function<_Tp*, _Ret>
    {
    public:
      explicit
      mem_fun_t(_Ret (_Tp::*__pf)())
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp* __p) const
      { return (__p->*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)();
    };



  template<typename _Ret, typename _Tp>
    class const_mem_fun_t : public unary_function<const _Tp*, _Ret>
    {
    public:
      explicit
      const_mem_fun_t(_Ret (_Tp::*__pf)() const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp* __p) const
      { return (__p->*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)() const;
    };



  template<typename _Ret, typename _Tp>
    class mem_fun_ref_t : public unary_function<_Tp, _Ret>
    {
    public:
      explicit
      mem_fun_ref_t(_Ret (_Tp::*__pf)())
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp& __r) const
      { return (__r.*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)();
  };



  template<typename _Ret, typename _Tp>
    class const_mem_fun_ref_t : public unary_function<_Tp, _Ret>
    {
    public:
      explicit
      const_mem_fun_ref_t(_Ret (_Tp::*__pf)() const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp& __r) const
      { return (__r.*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)() const;
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class mem_fun1_t : public binary_function<_Tp*, _Arg, _Ret>
    {
    public:
      explicit
      mem_fun1_t(_Ret (_Tp::*__pf)(_Arg))
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp* __p, _Arg __x) const
      { return (__p->*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg);
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class const_mem_fun1_t : public binary_function<const _Tp*, _Arg, _Ret>
    {
    public:
      explicit
      const_mem_fun1_t(_Ret (_Tp::*__pf)(_Arg) const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp* __p, _Arg __x) const
      { return (__p->*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg) const;
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret>
    {
    public:
      explicit
      mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg))
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp& __r, _Arg __x) const
      { return (__r.*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg);
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class const_mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret>
    {
    public:
      explicit
      const_mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg) const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp& __r, _Arg __x) const
      { return (__r.*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg) const;
    };



  template<typename _Ret, typename _Tp>
    inline mem_fun_t<_Ret, _Tp>
    mem_fun(_Ret (_Tp::*__f)())
    { return mem_fun_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp>
    inline const_mem_fun_t<_Ret, _Tp>
    mem_fun(_Ret (_Tp::*__f)() const)
    { return const_mem_fun_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp>
    inline mem_fun_ref_t<_Ret, _Tp>
    mem_fun_ref(_Ret (_Tp::*__f)())
    { return mem_fun_ref_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp>
    inline const_mem_fun_ref_t<_Ret, _Tp>
    mem_fun_ref(_Ret (_Tp::*__f)() const)
    { return const_mem_fun_ref_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline mem_fun1_t<_Ret, _Tp, _Arg>
    mem_fun(_Ret (_Tp::*__f)(_Arg))
    { return mem_fun1_t<_Ret, _Tp, _Arg>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline const_mem_fun1_t<_Ret, _Tp, _Arg>
    mem_fun(_Ret (_Tp::*__f)(_Arg) const)
    { return const_mem_fun1_t<_Ret, _Tp, _Arg>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline mem_fun1_ref_t<_Ret, _Tp, _Arg>
    mem_fun_ref(_Ret (_Tp::*__f)(_Arg))
    { return mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline const_mem_fun1_ref_t<_Ret, _Tp, _Arg>
    mem_fun_ref(_Ret (_Tp::*__f)(_Arg) const)
    { return const_mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f); }



}


# 1 "/usr/include/c++/4.4/backward/binders.h" 1 3
# 60 "/usr/include/c++/4.4/backward/binders.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {
# 96 "/usr/include/c++/4.4/backward/binders.h" 3
  template<typename _Operation>
    class binder1st
    : public unary_function<typename _Operation::second_argument_type,
       typename _Operation::result_type>
    {
    protected:
      _Operation op;
      typename _Operation::first_argument_type value;

    public:
      binder1st(const _Operation& __x,
  const typename _Operation::first_argument_type& __y)
      : op(__x), value(__y) { }

      typename _Operation::result_type
      operator()(const typename _Operation::second_argument_type& __x) const
      { return op(value, __x); }



      typename _Operation::result_type
      operator()(typename _Operation::second_argument_type& __x) const
      { return op(value, __x); }
    } ;


  template<typename _Operation, typename _Tp>
    inline binder1st<_Operation>
    bind1st(const _Operation& __fn, const _Tp& __x)
    {
      typedef typename _Operation::first_argument_type _Arg1_type;
      return binder1st<_Operation>(__fn, _Arg1_type(__x));
    }


  template<typename _Operation>
    class binder2nd
    : public unary_function<typename _Operation::first_argument_type,
       typename _Operation::result_type>
    {
    protected:
      _Operation op;
      typename _Operation::second_argument_type value;

    public:
      binder2nd(const _Operation& __x,
  const typename _Operation::second_argument_type& __y)
      : op(__x), value(__y) { }

      typename _Operation::result_type
      operator()(const typename _Operation::first_argument_type& __x) const
      { return op(__x, value); }



      typename _Operation::result_type
      operator()(typename _Operation::first_argument_type& __x) const
      { return op(__x, value); }
    } ;


  template<typename _Operation, typename _Tp>
    inline binder2nd<_Operation>
    bind2nd(const _Operation& __fn, const _Tp& __x)
    {
      typedef typename _Operation::second_argument_type _Arg2_type;
      return binder2nd<_Operation>(__fn, _Arg2_type(__x));
    }


}
# 713 "/usr/include/c++/4.4/bits/stl_function.h" 2 3
# 51 "/usr/include/c++/4.4/string" 2 3


# 1 "/usr/include/c++/4.4/bits/basic_string.h" 1 3
# 39 "/usr/include/c++/4.4/bits/basic_string.h" 3
       
# 40 "/usr/include/c++/4.4/bits/basic_string.h" 3

# 1 "/usr/include/c++/4.4/ext/atomicity.h" 1 3
# 34 "/usr/include/c++/4.4/ext/atomicity.h" 3
# 1 "/usr/include/c++/4.4/i686-linux-gnu/bits/gthr.h" 1 3
# 30 "/usr/include/c++/4.4/i686-linux-gnu/bits/gthr.h" 3
#pragma GCC visibility push(default)
# 162 "/usr/include/c++/4.4/i686-linux-gnu/bits/gthr.h" 3
# 1 "/usr/include/c++/4.4/i686-linux-gnu/bits/gthr-default.h" 1 3
# 41 "/usr/include/c++/4.4/i686-linux-gnu/bits/gthr-default.h" 3
# 1 "/usr/include/pthread.h" 1 3 4
# 25 "/usr/include/pthread.h" 3 4
# 1 "/usr/include/sched.h" 1 3 4
# 30 "/usr/include/sched.h" 3 4
# 1 "/usr/lib/gcc/i686-linux-gnu/4.4.5/include/stddef.h" 1 3 4
# 31 "/usr/include/sched.h" 2 3 4
# 43 "/usr/include/sched.h" 3 4
# 1 "/usr/include/bits/sched.h" 1 3 4
# 74 "/usr/include/bits/sched.h" 3 4
struct sched_param
  {
    int __sched_priority;
  };

extern "C" {



extern int clone (int (*__fn) (void *__arg), void *__child_stack,
    int __flags, void *__arg, ...) throw ();


extern int unshare (int __flags) throw ();


extern int sched_getcpu (void) throw ();


}







struct __sched_param
  {
    int __sched_priority;
  };
# 116 "/usr/include/bits/sched.h" 3 4
typedef unsigned long int __cpu_mask;






typedef struct
{
  __cpu_mask __bits[1024 / (8 * sizeof (__cpu_mask))];
} cpu_set_t;
# 199 "/usr/include/bits/sched.h" 3 4
extern "C" {

extern int __sched_cpucount (size_t __setsize, const cpu_set_t *__setp)
  throw ();
extern cpu_set_t *__sched_cpualloc (size_t __count) throw () __attribute__ ((__warn_unused_result__));
extern void __sched_cpufree (cpu_set_t *__set) throw ();

}
# 44 "/usr/include/sched.h" 2 3 4




extern "C" {


extern int sched_setparam (__pid_t __pid, __const struct sched_param *__param)
     throw ();


extern int sched_getparam (__pid_t __pid, struct sched_param *__param) throw ();


extern int sched_setscheduler (__pid_t __pid, int __policy,
          __const struct sched_param *__param) throw ();


extern int sched_getscheduler (__pid_t __pid) throw ();


extern int sched_yield (void) throw ();


extern int sched_get_priority_max (int __algorithm) throw ();


extern int sched_get_priority_min (int __algorithm) throw ();


extern int sched_rr_get_interval (__pid_t __pid, struct timespec *__t) throw ();
# 118 "/usr/include/sched.h" 3 4
extern int sched_setaffinity (__pid_t __pid, size_t __cpusetsize,
         __const cpu_set_t *__cpuset) throw ();


extern int sched_getaffinity (__pid_t __pid, size_t __cpusetsize,
         cpu_set_t *__cpuset) throw ();


}
# 26 "/usr/include/pthread.h" 2 3 4



# 1 "/usr/include/bits/setjmp.h" 1 3 4
# 27 "/usr/include/bits/setjmp.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 28 "/usr/include/bits/setjmp.h" 2 3 4






typedef int __jmp_buf[6];
# 30 "/usr/include/pthread.h" 2 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 31 "/usr/include/pthread.h" 2 3 4



enum
{
  PTHREAD_CREATE_JOINABLE,

  PTHREAD_CREATE_DETACHED

};



enum
{
  PTHREAD_MUTEX_TIMED_NP,
  PTHREAD_MUTEX_RECURSIVE_NP,
  PTHREAD_MUTEX_ERRORCHECK_NP,
  PTHREAD_MUTEX_ADAPTIVE_NP

  ,
  PTHREAD_MUTEX_NORMAL = PTHREAD_MUTEX_TIMED_NP,
  PTHREAD_MUTEX_RECURSIVE = PTHREAD_MUTEX_RECURSIVE_NP,
  PTHREAD_MUTEX_ERRORCHECK = PTHREAD_MUTEX_ERRORCHECK_NP,
  PTHREAD_MUTEX_DEFAULT = PTHREAD_MUTEX_NORMAL



  , PTHREAD_MUTEX_FAST_NP = PTHREAD_MUTEX_TIMED_NP

};




enum
{
  PTHREAD_MUTEX_STALLED,
  PTHREAD_MUTEX_STALLED_NP = PTHREAD_MUTEX_STALLED,
  PTHREAD_MUTEX_ROBUST,
  PTHREAD_MUTEX_ROBUST_NP = PTHREAD_MUTEX_ROBUST
};





enum
{
  PTHREAD_PRIO_NONE,
  PTHREAD_PRIO_INHERIT,
  PTHREAD_PRIO_PROTECT
};
# 115 "/usr/include/pthread.h" 3 4
enum
{
  PTHREAD_RWLOCK_PREFER_READER_NP,
  PTHREAD_RWLOCK_PREFER_WRITER_NP,
  PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP,
  PTHREAD_RWLOCK_DEFAULT_NP = PTHREAD_RWLOCK_PREFER_READER_NP
};
# 147 "/usr/include/pthread.h" 3 4
enum
{
  PTHREAD_INHERIT_SCHED,

  PTHREAD_EXPLICIT_SCHED

};



enum
{
  PTHREAD_SCOPE_SYSTEM,

  PTHREAD_SCOPE_PROCESS

};



enum
{
  PTHREAD_PROCESS_PRIVATE,

  PTHREAD_PROCESS_SHARED

};
# 182 "/usr/include/pthread.h" 3 4
struct _pthread_cleanup_buffer
{
  void (*__routine) (void *);
  void *__arg;
  int __canceltype;
  struct _pthread_cleanup_buffer *__prev;
};


enum
{
  PTHREAD_CANCEL_ENABLE,

  PTHREAD_CANCEL_DISABLE

};
enum
{
  PTHREAD_CANCEL_DEFERRED,

  PTHREAD_CANCEL_ASYNCHRONOUS

};
# 220 "/usr/include/pthread.h" 3 4
extern "C" {




extern int pthread_create (pthread_t *__restrict __newthread,
      __const pthread_attr_t *__restrict __attr,
      void *(*__start_routine) (void *),
      void *__restrict __arg) throw () __attribute__ ((__nonnull__ (1, 3)));





extern void pthread_exit (void *__retval) __attribute__ ((__noreturn__));







extern int pthread_join (pthread_t __th, void **__thread_return);




extern int pthread_tryjoin_np (pthread_t __th, void **__thread_return) throw ();







extern int pthread_timedjoin_np (pthread_t __th, void **__thread_return,
     __const struct timespec *__abstime);






extern int pthread_detach (pthread_t __th) throw ();



extern pthread_t pthread_self (void) throw () __attribute__ ((__const__));


extern int pthread_equal (pthread_t __thread1, pthread_t __thread2) throw ();







extern int pthread_attr_init (pthread_attr_t *__attr) throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_destroy (pthread_attr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_getdetachstate (__const pthread_attr_t *__attr,
     int *__detachstate)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setdetachstate (pthread_attr_t *__attr,
     int __detachstate)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getguardsize (__const pthread_attr_t *__attr,
          size_t *__guardsize)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setguardsize (pthread_attr_t *__attr,
          size_t __guardsize)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getschedparam (__const pthread_attr_t *__restrict
           __attr,
           struct sched_param *__restrict __param)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setschedparam (pthread_attr_t *__restrict __attr,
           __const struct sched_param *__restrict
           __param) throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_getschedpolicy (__const pthread_attr_t *__restrict
     __attr, int *__restrict __policy)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setschedpolicy (pthread_attr_t *__attr, int __policy)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_getinheritsched (__const pthread_attr_t *__restrict
      __attr, int *__restrict __inherit)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setinheritsched (pthread_attr_t *__attr,
      int __inherit)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getscope (__const pthread_attr_t *__restrict __attr,
      int *__restrict __scope)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setscope (pthread_attr_t *__attr, int __scope)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_getstackaddr (__const pthread_attr_t *__restrict
          __attr, void **__restrict __stackaddr)
     throw () __attribute__ ((__nonnull__ (1, 2))) __attribute__ ((__deprecated__));





extern int pthread_attr_setstackaddr (pthread_attr_t *__attr,
          void *__stackaddr)
     throw () __attribute__ ((__nonnull__ (1))) __attribute__ ((__deprecated__));


extern int pthread_attr_getstacksize (__const pthread_attr_t *__restrict
          __attr, size_t *__restrict __stacksize)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern int pthread_attr_setstacksize (pthread_attr_t *__attr,
          size_t __stacksize)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getstack (__const pthread_attr_t *__restrict __attr,
      void **__restrict __stackaddr,
      size_t *__restrict __stacksize)
     throw () __attribute__ ((__nonnull__ (1, 2, 3)));




extern int pthread_attr_setstack (pthread_attr_t *__attr, void *__stackaddr,
      size_t __stacksize) throw () __attribute__ ((__nonnull__ (1)));





extern int pthread_attr_setaffinity_np (pthread_attr_t *__attr,
     size_t __cpusetsize,
     __const cpu_set_t *__cpuset)
     throw () __attribute__ ((__nonnull__ (1, 3)));



extern int pthread_attr_getaffinity_np (__const pthread_attr_t *__attr,
     size_t __cpusetsize,
     cpu_set_t *__cpuset)
     throw () __attribute__ ((__nonnull__ (1, 3)));





extern int pthread_getattr_np (pthread_t __th, pthread_attr_t *__attr)
     throw () __attribute__ ((__nonnull__ (2)));







extern int pthread_setschedparam (pthread_t __target_thread, int __policy,
      __const struct sched_param *__param)
     throw () __attribute__ ((__nonnull__ (3)));


extern int pthread_getschedparam (pthread_t __target_thread,
      int *__restrict __policy,
      struct sched_param *__restrict __param)
     throw () __attribute__ ((__nonnull__ (2, 3)));


extern int pthread_setschedprio (pthread_t __target_thread, int __prio)
     throw ();




extern int pthread_getname_np (pthread_t __target_thread, char *__buf,
          size_t __buflen)
     throw () __attribute__ ((__nonnull__ (2)));


extern int pthread_setname_np (pthread_t __target_thread, __const char *__name)
     throw () __attribute__ ((__nonnull__ (2)));





extern int pthread_getconcurrency (void) throw ();


extern int pthread_setconcurrency (int __level) throw ();







extern int pthread_yield (void) throw ();




extern int pthread_setaffinity_np (pthread_t __th, size_t __cpusetsize,
       __const cpu_set_t *__cpuset)
     throw () __attribute__ ((__nonnull__ (3)));


extern int pthread_getaffinity_np (pthread_t __th, size_t __cpusetsize,
       cpu_set_t *__cpuset)
     throw () __attribute__ ((__nonnull__ (3)));
# 478 "/usr/include/pthread.h" 3 4
extern int pthread_once (pthread_once_t *__once_control,
    void (*__init_routine) (void)) __attribute__ ((__nonnull__ (1, 2)));
# 490 "/usr/include/pthread.h" 3 4
extern int pthread_setcancelstate (int __state, int *__oldstate);



extern int pthread_setcanceltype (int __type, int *__oldtype);


extern int pthread_cancel (pthread_t __th);




extern void pthread_testcancel (void);




typedef struct
{
  struct
  {
    __jmp_buf __cancel_jmp_buf;
    int __mask_was_saved;
  } __cancel_jmp_buf[1];
  void *__pad[4];
} __pthread_unwind_buf_t __attribute__ ((__aligned__));
# 524 "/usr/include/pthread.h" 3 4
struct __pthread_cleanup_frame
{
  void (*__cancel_routine) (void *);
  void *__cancel_arg;
  int __do_it;
  int __cancel_type;
};




class __pthread_cleanup_class
{
  void (*__cancel_routine) (void *);
  void *__cancel_arg;
  int __do_it;
  int __cancel_type;

 public:
  __pthread_cleanup_class (void (*__fct) (void *), void *__arg)
    : __cancel_routine (__fct), __cancel_arg (__arg), __do_it (1) { }
  ~__pthread_cleanup_class () { if (__do_it) __cancel_routine (__cancel_arg); }
  void __setdoit (int __newval) { __do_it = __newval; }
  void __defer () { pthread_setcanceltype (PTHREAD_CANCEL_DEFERRED,
        &__cancel_type); }
  void __restore () const { pthread_setcanceltype (__cancel_type, 0); }
};
# 726 "/usr/include/pthread.h" 3 4
struct __jmp_buf_tag;
extern int __sigsetjmp (struct __jmp_buf_tag *__env, int __savemask) throw ();





extern int pthread_mutex_init (pthread_mutex_t *__mutex,
          __const pthread_mutexattr_t *__mutexattr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutex_destroy (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutex_trylock (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutex_lock (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_mutex_timedlock (pthread_mutex_t *__restrict __mutex,
        __const struct timespec *__restrict
        __abstime) throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutex_unlock (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_mutex_getprioceiling (__const pthread_mutex_t *
      __restrict __mutex,
      int *__restrict __prioceiling)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutex_setprioceiling (pthread_mutex_t *__restrict __mutex,
      int __prioceiling,
      int *__restrict __old_ceiling)
     throw () __attribute__ ((__nonnull__ (1, 3)));




extern int pthread_mutex_consistent (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));

extern int pthread_mutex_consistent_np (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));
# 790 "/usr/include/pthread.h" 3 4
extern int pthread_mutexattr_init (pthread_mutexattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_destroy (pthread_mutexattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_getpshared (__const pthread_mutexattr_t *
      __restrict __attr,
      int *__restrict __pshared)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_mutexattr_setpshared (pthread_mutexattr_t *__attr,
      int __pshared)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_mutexattr_gettype (__const pthread_mutexattr_t *__restrict
          __attr, int *__restrict __kind)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern int pthread_mutexattr_settype (pthread_mutexattr_t *__attr, int __kind)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_mutexattr_getprotocol (__const pthread_mutexattr_t *
       __restrict __attr,
       int *__restrict __protocol)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutexattr_setprotocol (pthread_mutexattr_t *__attr,
       int __protocol)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_getprioceiling (__const pthread_mutexattr_t *
          __restrict __attr,
          int *__restrict __prioceiling)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_mutexattr_setprioceiling (pthread_mutexattr_t *__attr,
          int __prioceiling)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_mutexattr_getrobust (__const pthread_mutexattr_t *__attr,
     int *__robustness)
     throw () __attribute__ ((__nonnull__ (1, 2)));

extern int pthread_mutexattr_getrobust_np (__const pthread_mutexattr_t *__attr,
        int *__robustness)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutexattr_setrobust (pthread_mutexattr_t *__attr,
     int __robustness)
     throw () __attribute__ ((__nonnull__ (1)));

extern int pthread_mutexattr_setrobust_np (pthread_mutexattr_t *__attr,
        int __robustness)
     throw () __attribute__ ((__nonnull__ (1)));
# 872 "/usr/include/pthread.h" 3 4
extern int pthread_rwlock_init (pthread_rwlock_t *__restrict __rwlock,
    __const pthread_rwlockattr_t *__restrict
    __attr) throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_destroy (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_rdlock (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_tryrdlock (pthread_rwlock_t *__rwlock)
  throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_rwlock_timedrdlock (pthread_rwlock_t *__restrict __rwlock,
           __const struct timespec *__restrict
           __abstime) throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_rwlock_wrlock (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_trywrlock (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_rwlock_timedwrlock (pthread_rwlock_t *__restrict __rwlock,
           __const struct timespec *__restrict
           __abstime) throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_rwlock_unlock (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));





extern int pthread_rwlockattr_init (pthread_rwlockattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlockattr_destroy (pthread_rwlockattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlockattr_getpshared (__const pthread_rwlockattr_t *
       __restrict __attr,
       int *__restrict __pshared)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_rwlockattr_setpshared (pthread_rwlockattr_t *__attr,
       int __pshared)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlockattr_getkind_np (__const pthread_rwlockattr_t *
       __restrict __attr,
       int *__restrict __pref)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_rwlockattr_setkind_np (pthread_rwlockattr_t *__attr,
       int __pref) throw () __attribute__ ((__nonnull__ (1)));







extern int pthread_cond_init (pthread_cond_t *__restrict __cond,
         __const pthread_condattr_t *__restrict
         __cond_attr) throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_cond_destroy (pthread_cond_t *__cond)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_cond_signal (pthread_cond_t *__cond)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_cond_broadcast (pthread_cond_t *__cond)
     throw () __attribute__ ((__nonnull__ (1)));






extern int pthread_cond_wait (pthread_cond_t *__restrict __cond,
         pthread_mutex_t *__restrict __mutex)
     __attribute__ ((__nonnull__ (1, 2)));
# 984 "/usr/include/pthread.h" 3 4
extern int pthread_cond_timedwait (pthread_cond_t *__restrict __cond,
       pthread_mutex_t *__restrict __mutex,
       __const struct timespec *__restrict
       __abstime) __attribute__ ((__nonnull__ (1, 2, 3)));




extern int pthread_condattr_init (pthread_condattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_condattr_destroy (pthread_condattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_condattr_getpshared (__const pthread_condattr_t *
     __restrict __attr,
     int *__restrict __pshared)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_condattr_setpshared (pthread_condattr_t *__attr,
     int __pshared) throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_condattr_getclock (__const pthread_condattr_t *
          __restrict __attr,
          __clockid_t *__restrict __clock_id)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_condattr_setclock (pthread_condattr_t *__attr,
          __clockid_t __clock_id)
     throw () __attribute__ ((__nonnull__ (1)));
# 1028 "/usr/include/pthread.h" 3 4
extern int pthread_spin_init (pthread_spinlock_t *__lock, int __pshared)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_destroy (pthread_spinlock_t *__lock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_lock (pthread_spinlock_t *__lock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_trylock (pthread_spinlock_t *__lock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_unlock (pthread_spinlock_t *__lock)
     throw () __attribute__ ((__nonnull__ (1)));






extern int pthread_barrier_init (pthread_barrier_t *__restrict __barrier,
     __const pthread_barrierattr_t *__restrict
     __attr, unsigned int __count)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_barrier_destroy (pthread_barrier_t *__barrier)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_barrier_wait (pthread_barrier_t *__barrier)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_barrierattr_init (pthread_barrierattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_barrierattr_destroy (pthread_barrierattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_barrierattr_getpshared (__const pthread_barrierattr_t *
        __restrict __attr,
        int *__restrict __pshared)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_barrierattr_setpshared (pthread_barrierattr_t *__attr,
        int __pshared)
     throw () __attribute__ ((__nonnull__ (1)));
# 1095 "/usr/include/pthread.h" 3 4
extern int pthread_key_create (pthread_key_t *__key,
          void (*__destr_function) (void *))
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_key_delete (pthread_key_t __key) throw ();


extern void *pthread_getspecific (pthread_key_t __key) throw ();


extern int pthread_setspecific (pthread_key_t __key,
    __const void *__pointer) throw () ;




extern int pthread_getcpuclockid (pthread_t __thread_id,
      __clockid_t *__clock_id)
     throw () __attribute__ ((__nonnull__ (2)));
# 1129 "/usr/include/pthread.h" 3 4
extern int pthread_atfork (void (*__prepare) (void),
      void (*__parent) (void),
      void (*__child) (void)) throw ();




extern __inline __attribute__ ((__gnu_inline__)) int
pthread_equal (pthread_t __thread1, pthread_t __thread2) throw ()
{
  return __thread1 == __thread2;
}


}
# 42 "/usr/include/c++/4.4/i686-linux-gnu/bits/gthr-default.h" 2 3
# 1 "/usr/include/unistd.h" 1 3 4
# 28 "/usr/include/unistd.h" 3 4
extern "C" {
# 203 "/usr/include/unistd.h" 3 4
# 1 "/usr/include/bits/posix_opt.h" 1 3 4
# 204 "/usr/include/unistd.h" 2 3 4



# 1 "/usr/include/bits/environments.h" 1 3 4
# 23 "/usr/include/bits/environments.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 24 "/usr/include/bits/environments.h" 2 3 4
# 208 "/usr/include/unistd.h" 2 3 4
# 227 "/usr/include/unistd.h" 3 4
# 1 "/usr/lib/gcc/i686-linux-gnu/4.4.5/include/stddef.h" 1 3 4
# 228 "/usr/include/unistd.h" 2 3 4
# 268 "/usr/include/unistd.h" 3 4
typedef __intptr_t intptr_t;






typedef __socklen_t socklen_t;
# 288 "/usr/include/unistd.h" 3 4
extern int access (__const char *__name, int __type) throw () __attribute__ ((__nonnull__ (1)));




extern int euidaccess (__const char *__name, int __type)
     throw () __attribute__ ((__nonnull__ (1)));


extern int eaccess (__const char *__name, int __type)
     throw () __attribute__ ((__nonnull__ (1)));






extern int faccessat (int __fd, __const char *__file, int __type, int __flag)
     throw () __attribute__ ((__nonnull__ (2))) __attribute__ ((__warn_unused_result__));
# 334 "/usr/include/unistd.h" 3 4
extern __off64_t lseek (int __fd, __off64_t __offset, int __whence) throw () __asm__ ("" "lseek64");







extern __off64_t lseek64 (int __fd, __off64_t __offset, int __whence)
     throw ();






extern int close (int __fd);






extern ssize_t read (int __fd, void *__buf, size_t __nbytes) __attribute__ ((__warn_unused_result__));





extern ssize_t write (int __fd, __const void *__buf, size_t __n) __attribute__ ((__warn_unused_result__));
# 385 "/usr/include/unistd.h" 3 4
extern ssize_t pread (int __fd, void *__buf, size_t __nbytes, __off64_t __offset) __asm__ ("" "pread64") __attribute__ ((__warn_unused_result__));


extern ssize_t pwrite (int __fd, __const void *__buf, size_t __nbytes, __off64_t __offset) __asm__ ("" "pwrite64") __attribute__ ((__warn_unused_result__));
# 401 "/usr/include/unistd.h" 3 4
extern ssize_t pread64 (int __fd, void *__buf, size_t __nbytes,
   __off64_t __offset) __attribute__ ((__warn_unused_result__));


extern ssize_t pwrite64 (int __fd, __const void *__buf, size_t __n,
    __off64_t __offset) __attribute__ ((__warn_unused_result__));







extern int pipe (int __pipedes[2]) throw () __attribute__ ((__warn_unused_result__));




extern int pipe2 (int __pipedes[2], int __flags) throw () __attribute__ ((__warn_unused_result__));
# 429 "/usr/include/unistd.h" 3 4
extern unsigned int alarm (unsigned int __seconds) throw ();
# 441 "/usr/include/unistd.h" 3 4
extern unsigned int sleep (unsigned int __seconds);







extern __useconds_t ualarm (__useconds_t __value, __useconds_t __interval)
     throw ();






extern int usleep (__useconds_t __useconds);
# 466 "/usr/include/unistd.h" 3 4
extern int pause (void);



extern int chown (__const char *__file, __uid_t __owner, __gid_t __group)
     throw () __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));



extern int fchown (int __fd, __uid_t __owner, __gid_t __group) throw () __attribute__ ((__warn_unused_result__));




extern int lchown (__const char *__file, __uid_t __owner, __gid_t __group)
     throw () __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));






extern int fchownat (int __fd, __const char *__file, __uid_t __owner,
       __gid_t __group, int __flag)
     throw () __attribute__ ((__nonnull__ (2))) __attribute__ ((__warn_unused_result__));



extern int chdir (__const char *__path) throw () __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));



extern int fchdir (int __fd) throw () __attribute__ ((__warn_unused_result__));
# 508 "/usr/include/unistd.h" 3 4
extern char *getcwd (char *__buf, size_t __size) throw () __attribute__ ((__warn_unused_result__));





extern char *get_current_dir_name (void) throw ();







extern char *getwd (char *__buf)
     throw () __attribute__ ((__nonnull__ (1))) __attribute__ ((__deprecated__)) __attribute__ ((__warn_unused_result__));




extern int dup (int __fd) throw () __attribute__ ((__warn_unused_result__));


extern int dup2 (int __fd, int __fd2) throw ();




extern int dup3 (int __fd, int __fd2, int __flags) throw ();



extern char **__environ;

extern char **environ;





extern int execve (__const char *__path, char *__const __argv[],
     char *__const __envp[]) throw () __attribute__ ((__nonnull__ (1, 2)));




extern int fexecve (int __fd, char *__const __argv[], char *__const __envp[])
     throw () __attribute__ ((__nonnull__ (2)));




extern int execv (__const char *__path, char *__const __argv[])
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int execle (__const char *__path, __const char *__arg, ...)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int execl (__const char *__path, __const char *__arg, ...)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int execvp (__const char *__file, char *__const __argv[])
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern int execlp (__const char *__file, __const char *__arg, ...)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern int execvpe (__const char *__file, char *__const __argv[],
      char *__const __envp[])
     throw () __attribute__ ((__nonnull__ (1, 2)));





extern int nice (int __inc) throw () __attribute__ ((__warn_unused_result__));




extern void _exit (int __status) __attribute__ ((__noreturn__));





# 1 "/usr/include/bits/confname.h" 1 3 4
# 26 "/usr/include/bits/confname.h" 3 4
enum
  {
    _PC_LINK_MAX,

    _PC_MAX_CANON,

    _PC_MAX_INPUT,

    _PC_NAME_MAX,

    _PC_PATH_MAX,

    _PC_PIPE_BUF,

    _PC_CHOWN_RESTRICTED,

    _PC_NO_TRUNC,

    _PC_VDISABLE,

    _PC_SYNC_IO,

    _PC_ASYNC_IO,

    _PC_PRIO_IO,

    _PC_SOCK_MAXBUF,

    _PC_FILESIZEBITS,

    _PC_REC_INCR_XFER_SIZE,

    _PC_REC_MAX_XFER_SIZE,

    _PC_REC_MIN_XFER_SIZE,

    _PC_REC_XFER_ALIGN,

    _PC_ALLOC_SIZE_MIN,

    _PC_SYMLINK_MAX,

    _PC_2_SYMLINKS

  };


enum
  {
    _SC_ARG_MAX,

    _SC_CHILD_MAX,

    _SC_CLK_TCK,

    _SC_NGROUPS_MAX,

    _SC_OPEN_MAX,

    _SC_STREAM_MAX,

    _SC_TZNAME_MAX,

    _SC_JOB_CONTROL,

    _SC_SAVED_IDS,

    _SC_REALTIME_SIGNALS,

    _SC_PRIORITY_SCHEDULING,

    _SC_TIMERS,

    _SC_ASYNCHRONOUS_IO,

    _SC_PRIORITIZED_IO,

    _SC_SYNCHRONIZED_IO,

    _SC_FSYNC,

    _SC_MAPPED_FILES,

    _SC_MEMLOCK,

    _SC_MEMLOCK_RANGE,

    _SC_MEMORY_PROTECTION,

    _SC_MESSAGE_PASSING,

    _SC_SEMAPHORES,

    _SC_SHARED_MEMORY_OBJECTS,

    _SC_AIO_LISTIO_MAX,

    _SC_AIO_MAX,

    _SC_AIO_PRIO_DELTA_MAX,

    _SC_DELAYTIMER_MAX,

    _SC_MQ_OPEN_MAX,

    _SC_MQ_PRIO_MAX,

    _SC_VERSION,

    _SC_PAGESIZE,


    _SC_RTSIG_MAX,

    _SC_SEM_NSEMS_MAX,

    _SC_SEM_VALUE_MAX,

    _SC_SIGQUEUE_MAX,

    _SC_TIMER_MAX,




    _SC_BC_BASE_MAX,

    _SC_BC_DIM_MAX,

    _SC_BC_SCALE_MAX,

    _SC_BC_STRING_MAX,

    _SC_COLL_WEIGHTS_MAX,

    _SC_EQUIV_CLASS_MAX,

    _SC_EXPR_NEST_MAX,

    _SC_LINE_MAX,

    _SC_RE_DUP_MAX,

    _SC_CHARCLASS_NAME_MAX,


    _SC_2_VERSION,

    _SC_2_C_BIND,

    _SC_2_C_DEV,

    _SC_2_FORT_DEV,

    _SC_2_FORT_RUN,

    _SC_2_SW_DEV,

    _SC_2_LOCALEDEF,


    _SC_PII,

    _SC_PII_XTI,

    _SC_PII_SOCKET,

    _SC_PII_INTERNET,

    _SC_PII_OSI,

    _SC_POLL,

    _SC_SELECT,

    _SC_UIO_MAXIOV,

    _SC_IOV_MAX = _SC_UIO_MAXIOV,

    _SC_PII_INTERNET_STREAM,

    _SC_PII_INTERNET_DGRAM,

    _SC_PII_OSI_COTS,

    _SC_PII_OSI_CLTS,

    _SC_PII_OSI_M,

    _SC_T_IOV_MAX,



    _SC_THREADS,

    _SC_THREAD_SAFE_FUNCTIONS,

    _SC_GETGR_R_SIZE_MAX,

    _SC_GETPW_R_SIZE_MAX,

    _SC_LOGIN_NAME_MAX,

    _SC_TTY_NAME_MAX,

    _SC_THREAD_DESTRUCTOR_ITERATIONS,

    _SC_THREAD_KEYS_MAX,

    _SC_THREAD_STACK_MIN,

    _SC_THREAD_THREADS_MAX,

    _SC_THREAD_ATTR_STACKADDR,

    _SC_THREAD_ATTR_STACKSIZE,

    _SC_THREAD_PRIORITY_SCHEDULING,

    _SC_THREAD_PRIO_INHERIT,

    _SC_THREAD_PRIO_PROTECT,

    _SC_THREAD_PROCESS_SHARED,


    _SC_NPROCESSORS_CONF,

    _SC_NPROCESSORS_ONLN,

    _SC_PHYS_PAGES,

    _SC_AVPHYS_PAGES,

    _SC_ATEXIT_MAX,

    _SC_PASS_MAX,


    _SC_XOPEN_VERSION,

    _SC_XOPEN_XCU_VERSION,

    _SC_XOPEN_UNIX,

    _SC_XOPEN_CRYPT,

    _SC_XOPEN_ENH_I18N,

    _SC_XOPEN_SHM,


    _SC_2_CHAR_TERM,

    _SC_2_C_VERSION,

    _SC_2_UPE,


    _SC_XOPEN_XPG2,

    _SC_XOPEN_XPG3,

    _SC_XOPEN_XPG4,


    _SC_CHAR_BIT,

    _SC_CHAR_MAX,

    _SC_CHAR_MIN,

    _SC_INT_MAX,

    _SC_INT_MIN,

    _SC_LONG_BIT,

    _SC_WORD_BIT,

    _SC_MB_LEN_MAX,

    _SC_NZERO,

    _SC_SSIZE_MAX,

    _SC_SCHAR_MAX,

    _SC_SCHAR_MIN,

    _SC_SHRT_MAX,

    _SC_SHRT_MIN,

    _SC_UCHAR_MAX,

    _SC_UINT_MAX,

    _SC_ULONG_MAX,

    _SC_USHRT_MAX,


    _SC_NL_ARGMAX,

    _SC_NL_LANGMAX,

    _SC_NL_MSGMAX,

    _SC_NL_NMAX,

    _SC_NL_SETMAX,

    _SC_NL_TEXTMAX,


    _SC_XBS5_ILP32_OFF32,

    _SC_XBS5_ILP32_OFFBIG,

    _SC_XBS5_LP64_OFF64,

    _SC_XBS5_LPBIG_OFFBIG,


    _SC_XOPEN_LEGACY,

    _SC_XOPEN_REALTIME,

    _SC_XOPEN_REALTIME_THREADS,


    _SC_ADVISORY_INFO,

    _SC_BARRIERS,

    _SC_BASE,

    _SC_C_LANG_SUPPORT,

    _SC_C_LANG_SUPPORT_R,

    _SC_CLOCK_SELECTION,

    _SC_CPUTIME,

    _SC_THREAD_CPUTIME,

    _SC_DEVICE_IO,

    _SC_DEVICE_SPECIFIC,

    _SC_DEVICE_SPECIFIC_R,

    _SC_FD_MGMT,

    _SC_FIFO,

    _SC_PIPE,

    _SC_FILE_ATTRIBUTES,

    _SC_FILE_LOCKING,

    _SC_FILE_SYSTEM,

    _SC_MONOTONIC_CLOCK,

    _SC_MULTI_PROCESS,

    _SC_SINGLE_PROCESS,

    _SC_NETWORKING,

    _SC_READER_WRITER_LOCKS,

    _SC_SPIN_LOCKS,

    _SC_REGEXP,

    _SC_REGEX_VERSION,

    _SC_SHELL,

    _SC_SIGNALS,

    _SC_SPAWN,

    _SC_SPORADIC_SERVER,

    _SC_THREAD_SPORADIC_SERVER,

    _SC_SYSTEM_DATABASE,

    _SC_SYSTEM_DATABASE_R,

    _SC_TIMEOUTS,

    _SC_TYPED_MEMORY_OBJECTS,

    _SC_USER_GROUPS,

    _SC_USER_GROUPS_R,

    _SC_2_PBS,

    _SC_2_PBS_ACCOUNTING,

    _SC_2_PBS_LOCATE,

    _SC_2_PBS_MESSAGE,

    _SC_2_PBS_TRACK,

    _SC_SYMLOOP_MAX,

    _SC_STREAMS,

    _SC_2_PBS_CHECKPOINT,


    _SC_V6_ILP32_OFF32,

    _SC_V6_ILP32_OFFBIG,

    _SC_V6_LP64_OFF64,

    _SC_V6_LPBIG_OFFBIG,


    _SC_HOST_NAME_MAX,

    _SC_TRACE,

    _SC_TRACE_EVENT_FILTER,

    _SC_TRACE_INHERIT,

    _SC_TRACE_LOG,


    _SC_LEVEL1_ICACHE_SIZE,

    _SC_LEVEL1_ICACHE_ASSOC,

    _SC_LEVEL1_ICACHE_LINESIZE,

    _SC_LEVEL1_DCACHE_SIZE,

    _SC_LEVEL1_DCACHE_ASSOC,

    _SC_LEVEL1_DCACHE_LINESIZE,

    _SC_LEVEL2_CACHE_SIZE,

    _SC_LEVEL2_CACHE_ASSOC,

    _SC_LEVEL2_CACHE_LINESIZE,

    _SC_LEVEL3_CACHE_SIZE,

    _SC_LEVEL3_CACHE_ASSOC,

    _SC_LEVEL3_CACHE_LINESIZE,

    _SC_LEVEL4_CACHE_SIZE,

    _SC_LEVEL4_CACHE_ASSOC,

    _SC_LEVEL4_CACHE_LINESIZE,



    _SC_IPV6 = _SC_LEVEL1_ICACHE_SIZE + 50,

    _SC_RAW_SOCKETS,


    _SC_V7_ILP32_OFF32,

    _SC_V7_ILP32_OFFBIG,

    _SC_V7_LP64_OFF64,

    _SC_V7_LPBIG_OFFBIG,


    _SC_SS_REPL_MAX,


    _SC_TRACE_EVENT_NAME_MAX,

    _SC_TRACE_NAME_MAX,

    _SC_TRACE_SYS_MAX,

    _SC_TRACE_USER_EVENT_MAX,


    _SC_XOPEN_STREAMS,


    _SC_THREAD_ROBUST_PRIO_INHERIT,

    _SC_THREAD_ROBUST_PRIO_PROTECT

  };


enum
  {
    _CS_PATH,


    _CS_V6_WIDTH_RESTRICTED_ENVS,



    _CS_GNU_LIBC_VERSION,

    _CS_GNU_LIBPTHREAD_VERSION,


    _CS_V5_WIDTH_RESTRICTED_ENVS,



    _CS_V7_WIDTH_RESTRICTED_ENVS,



    _CS_LFS_CFLAGS = 1000,

    _CS_LFS_LDFLAGS,

    _CS_LFS_LIBS,

    _CS_LFS_LINTFLAGS,

    _CS_LFS64_CFLAGS,

    _CS_LFS64_LDFLAGS,

    _CS_LFS64_LIBS,

    _CS_LFS64_LINTFLAGS,


    _CS_XBS5_ILP32_OFF32_CFLAGS = 1100,

    _CS_XBS5_ILP32_OFF32_LDFLAGS,

    _CS_XBS5_ILP32_OFF32_LIBS,

    _CS_XBS5_ILP32_OFF32_LINTFLAGS,

    _CS_XBS5_ILP32_OFFBIG_CFLAGS,

    _CS_XBS5_ILP32_OFFBIG_LDFLAGS,

    _CS_XBS5_ILP32_OFFBIG_LIBS,

    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS,

    _CS_XBS5_LP64_OFF64_CFLAGS,

    _CS_XBS5_LP64_OFF64_LDFLAGS,

    _CS_XBS5_LP64_OFF64_LIBS,

    _CS_XBS5_LP64_OFF64_LINTFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_CFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_LIBS,

    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS,


    _CS_POSIX_V6_ILP32_OFF32_CFLAGS,

    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS,

    _CS_POSIX_V6_ILP32_OFF32_LIBS,

    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_LIBS,

    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS,

    _CS_POSIX_V6_LP64_OFF64_CFLAGS,

    _CS_POSIX_V6_LP64_OFF64_LDFLAGS,

    _CS_POSIX_V6_LP64_OFF64_LIBS,

    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS,


    _CS_POSIX_V7_ILP32_OFF32_CFLAGS,

    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS,

    _CS_POSIX_V7_ILP32_OFF32_LIBS,

    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_LIBS,

    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS,

    _CS_POSIX_V7_LP64_OFF64_CFLAGS,

    _CS_POSIX_V7_LP64_OFF64_LDFLAGS,

    _CS_POSIX_V7_LP64_OFF64_LIBS,

    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS,


    _CS_V6_ENV,

    _CS_V7_ENV

  };
# 607 "/usr/include/unistd.h" 2 3 4


extern long int pathconf (__const char *__path, int __name)
     throw () __attribute__ ((__nonnull__ (1)));


extern long int fpathconf (int __fd, int __name) throw ();


extern long int sysconf (int __name) throw ();



extern size_t confstr (int __name, char *__buf, size_t __len) throw ();




extern __pid_t getpid (void) throw ();


extern __pid_t getppid (void) throw ();




extern __pid_t getpgrp (void) throw ();
# 643 "/usr/include/unistd.h" 3 4
extern __pid_t __getpgid (__pid_t __pid) throw ();

extern __pid_t getpgid (__pid_t __pid) throw ();






extern int setpgid (__pid_t __pid, __pid_t __pgid) throw ();
# 669 "/usr/include/unistd.h" 3 4
extern int setpgrp (void) throw ();
# 686 "/usr/include/unistd.h" 3 4
extern __pid_t setsid (void) throw ();



extern __pid_t getsid (__pid_t __pid) throw ();



extern __uid_t getuid (void) throw ();


extern __uid_t geteuid (void) throw ();


extern __gid_t getgid (void) throw ();


extern __gid_t getegid (void) throw ();




extern int getgroups (int __size, __gid_t __list[]) throw () __attribute__ ((__warn_unused_result__));



extern int group_member (__gid_t __gid) throw ();






extern int setuid (__uid_t __uid) throw ();




extern int setreuid (__uid_t __ruid, __uid_t __euid) throw ();




extern int seteuid (__uid_t __uid) throw ();






extern int setgid (__gid_t __gid) throw ();




extern int setregid (__gid_t __rgid, __gid_t __egid) throw ();




extern int setegid (__gid_t __gid) throw ();





extern int getresuid (__uid_t *__ruid, __uid_t *__euid, __uid_t *__suid)
     throw ();



extern int getresgid (__gid_t *__rgid, __gid_t *__egid, __gid_t *__sgid)
     throw ();



extern int setresuid (__uid_t __ruid, __uid_t __euid, __uid_t __suid)
     throw ();



extern int setresgid (__gid_t __rgid, __gid_t __egid, __gid_t __sgid)
     throw ();






extern __pid_t fork (void) throw ();







extern __pid_t vfork (void) throw ();





extern char *ttyname (int __fd) throw ();



extern int ttyname_r (int __fd, char *__buf, size_t __buflen)
     throw () __attribute__ ((__nonnull__ (2))) __attribute__ ((__warn_unused_result__));



extern int isatty (int __fd) throw ();





extern int ttyslot (void) throw ();




extern int link (__const char *__from, __const char *__to)
     throw () __attribute__ ((__nonnull__ (1, 2))) __attribute__ ((__warn_unused_result__));




extern int linkat (int __fromfd, __const char *__from, int __tofd,
     __const char *__to, int __flags)
     throw () __attribute__ ((__nonnull__ (2, 4))) __attribute__ ((__warn_unused_result__));




extern int symlink (__const char *__from, __const char *__to)
     throw () __attribute__ ((__nonnull__ (1, 2))) __attribute__ ((__warn_unused_result__));




extern ssize_t readlink (__const char *__restrict __path,
    char *__restrict __buf, size_t __len)
     throw () __attribute__ ((__nonnull__ (1, 2))) __attribute__ ((__warn_unused_result__));




extern int symlinkat (__const char *__from, int __tofd,
        __const char *__to) throw () __attribute__ ((__nonnull__ (1, 3))) __attribute__ ((__warn_unused_result__));


extern ssize_t readlinkat (int __fd, __const char *__restrict __path,
      char *__restrict __buf, size_t __len)
     throw () __attribute__ ((__nonnull__ (2, 3))) __attribute__ ((__warn_unused_result__));



extern int unlink (__const char *__name) throw () __attribute__ ((__nonnull__ (1)));



extern int unlinkat (int __fd, __const char *__name, int __flag)
     throw () __attribute__ ((__nonnull__ (2)));



extern int rmdir (__const char *__path) throw () __attribute__ ((__nonnull__ (1)));



extern __pid_t tcgetpgrp (int __fd) throw ();


extern int tcsetpgrp (int __fd, __pid_t __pgrp_id) throw ();






extern char *getlogin (void);







extern int getlogin_r (char *__name, size_t __name_len) __attribute__ ((__nonnull__ (1)));




extern int setlogin (__const char *__name) throw () __attribute__ ((__nonnull__ (1)));
# 890 "/usr/include/unistd.h" 3 4
# 1 "/usr/include/getopt.h" 1 3 4
# 50 "/usr/include/getopt.h" 3 4
extern "C" {
# 59 "/usr/include/getopt.h" 3 4
extern char *optarg;
# 73 "/usr/include/getopt.h" 3 4
extern int optind;




extern int opterr;



extern int optopt;
# 152 "/usr/include/getopt.h" 3 4
extern int getopt (int ___argc, char *const *___argv, const char *__shortopts)
       throw ();
# 187 "/usr/include/getopt.h" 3 4
}
# 891 "/usr/include/unistd.h" 2 3 4







extern int gethostname (char *__name, size_t __len) throw () __attribute__ ((__nonnull__ (1)));






extern int sethostname (__const char *__name, size_t __len)
     throw () __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));



extern int sethostid (long int __id) throw () __attribute__ ((__warn_unused_result__));





extern int getdomainname (char *__name, size_t __len)
     throw () __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
extern int setdomainname (__const char *__name, size_t __len)
     throw () __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));





extern int vhangup (void) throw ();


extern int revoke (__const char *__file) throw () __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));







extern int profil (unsigned short int *__sample_buffer, size_t __size,
     size_t __offset, unsigned int __scale)
     throw () __attribute__ ((__nonnull__ (1)));





extern int acct (__const char *__name) throw ();



extern char *getusershell (void) throw ();
extern void endusershell (void) throw ();
extern void setusershell (void) throw ();





extern int daemon (int __nochdir, int __noclose) throw () __attribute__ ((__warn_unused_result__));






extern int chroot (__const char *__path) throw () __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));



extern char *getpass (__const char *__prompt) __attribute__ ((__nonnull__ (1)));
# 976 "/usr/include/unistd.h" 3 4
extern int fsync (int __fd);






extern long int gethostid (void);


extern void sync (void) throw ();





extern int getpagesize (void) throw () __attribute__ ((__const__));




extern int getdtablesize (void) throw ();
# 1011 "/usr/include/unistd.h" 3 4
extern int truncate (__const char *__file, __off64_t __length) throw () __asm__ ("" "truncate64") __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));







extern int truncate64 (__const char *__file, __off64_t __length)
     throw () __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
# 1029 "/usr/include/unistd.h" 3 4
extern int ftruncate (int __fd, __off64_t __length) throw () __asm__ ("" "ftruncate64") __attribute__ ((__warn_unused_result__));






extern int ftruncate64 (int __fd, __off64_t __length) throw () __attribute__ ((__warn_unused_result__));
# 1047 "/usr/include/unistd.h" 3 4
extern int brk (void *__addr) throw () __attribute__ ((__warn_unused_result__));





extern void *sbrk (intptr_t __delta) throw ();
# 1068 "/usr/include/unistd.h" 3 4
extern long int syscall (long int __sysno, ...) throw ();
# 1094 "/usr/include/unistd.h" 3 4
extern int lockf (int __fd, int __cmd, __off64_t __len) __asm__ ("" "lockf64") __attribute__ ((__warn_unused_result__));






extern int lockf64 (int __fd, int __cmd, __off64_t __len) __attribute__ ((__warn_unused_result__));
# 1122 "/usr/include/unistd.h" 3 4
extern int fdatasync (int __fildes);







extern char *crypt (__const char *__key, __const char *__salt)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern void encrypt (char *__libc_block, int __edflag) throw () __attribute__ ((__nonnull__ (1)));






extern void swab (__const void *__restrict __from, void *__restrict __to,
    ssize_t __n) throw () __attribute__ ((__nonnull__ (1, 2)));







extern char *ctermid (char *__s) throw ();





# 1 "/usr/include/bits/unistd.h" 1 3 4
# 24 "/usr/include/bits/unistd.h" 3 4
extern ssize_t __read_chk (int __fd, void *__buf, size_t __nbytes,
      size_t __buflen) __attribute__ ((__warn_unused_result__));
extern ssize_t __read_alias (int __fd, void *__buf, size_t __nbytes) __asm__ ("" "read") __attribute__ ((__warn_unused_result__));

extern ssize_t __read_chk_warn (int __fd, void *__buf, size_t __nbytes, size_t __buflen) __asm__ ("" "__read_chk")


     __attribute__ ((__warn_unused_result__)) __attribute__((__warning__ ("read called with bigger length than size of " "the destination buffer")));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) __attribute__ ((__warn_unused_result__)) ssize_t
read (int __fd, void *__buf, size_t __nbytes)
{
  if (__builtin_object_size (__buf, 0) != (size_t) -1)
    {
      if (!__builtin_constant_p (__nbytes))
 return __read_chk (__fd, __buf, __nbytes, __builtin_object_size (__buf, 0));

      if (__nbytes > __builtin_object_size (__buf, 0))
 return __read_chk_warn (__fd, __buf, __nbytes, __builtin_object_size (__buf, 0));
    }
  return __read_alias (__fd, __buf, __nbytes);
}


extern ssize_t __pread_chk (int __fd, void *__buf, size_t __nbytes,
       __off_t __offset, size_t __bufsize) __attribute__ ((__warn_unused_result__));
extern ssize_t __pread64_chk (int __fd, void *__buf, size_t __nbytes,
         __off64_t __offset, size_t __bufsize) __attribute__ ((__warn_unused_result__));
extern ssize_t __pread_alias (int __fd, void *__buf, size_t __nbytes, __off_t __offset) __asm__ ("" "pread") __attribute__ ((__warn_unused_result__));


extern ssize_t __pread64_alias (int __fd, void *__buf, size_t __nbytes, __off64_t __offset) __asm__ ("" "pread64") __attribute__ ((__warn_unused_result__));


extern ssize_t __pread_chk_warn (int __fd, void *__buf, size_t __nbytes, __off_t __offset, size_t __bufsize) __asm__ ("" "__pread_chk")


     __attribute__ ((__warn_unused_result__)) __attribute__((__warning__ ("pread called with bigger length than size of " "the destination buffer")));

extern ssize_t __pread64_chk_warn (int __fd, void *__buf, size_t __nbytes, __off64_t __offset, size_t __bufsize) __asm__ ("" "__pread64_chk")



     __attribute__ ((__warn_unused_result__)) __attribute__((__warning__ ("pread64 called with bigger length than size of " "the destination buffer")));
# 87 "/usr/include/bits/unistd.h" 3 4
extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) __attribute__ ((__warn_unused_result__)) ssize_t
pread (int __fd, void *__buf, size_t __nbytes, __off64_t __offset)
{
  if (__builtin_object_size (__buf, 0) != (size_t) -1)
    {
      if (!__builtin_constant_p (__nbytes))
 return __pread64_chk (__fd, __buf, __nbytes, __offset, __builtin_object_size (__buf, 0));

      if ( __nbytes > __builtin_object_size (__buf, 0))
 return __pread64_chk_warn (__fd, __buf, __nbytes, __offset,
       __builtin_object_size (__buf, 0));
    }

  return __pread64_alias (__fd, __buf, __nbytes, __offset);
}



extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) __attribute__ ((__warn_unused_result__)) ssize_t
pread64 (int __fd, void *__buf, size_t __nbytes, __off64_t __offset)
{
  if (__builtin_object_size (__buf, 0) != (size_t) -1)
    {
      if (!__builtin_constant_p (__nbytes))
 return __pread64_chk (__fd, __buf, __nbytes, __offset, __builtin_object_size (__buf, 0));

      if ( __nbytes > __builtin_object_size (__buf, 0))
 return __pread64_chk_warn (__fd, __buf, __nbytes, __offset,
       __builtin_object_size (__buf, 0));
    }

  return __pread64_alias (__fd, __buf, __nbytes, __offset);
}




extern ssize_t __readlink_chk (__const char *__restrict __path,
          char *__restrict __buf, size_t __len,
          size_t __buflen)
     throw () __attribute__ ((__nonnull__ (1, 2))) __attribute__ ((__warn_unused_result__));
extern ssize_t __readlink_alias (__const char *__restrict __path, char *__restrict __buf, size_t __len) throw () __asm__ ("" "readlink")


     __attribute__ ((__nonnull__ (1, 2))) __attribute__ ((__warn_unused_result__));
extern ssize_t __readlink_chk_warn (__const char *__restrict __path, char *__restrict __buf, size_t __len, size_t __buflen) throw () __asm__ ("" "__readlink_chk")



     __attribute__ ((__nonnull__ (1, 2))) __attribute__ ((__warn_unused_result__)) __attribute__((__warning__ ("readlink called with bigger length " "than size of destination buffer")));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) __attribute__ ((__nonnull__ (1, 2))) __attribute__ ((__warn_unused_result__)) ssize_t
readlink (__const char *__restrict __path, char *__restrict __buf, size_t __len) throw ()

{
  if (__builtin_object_size (__buf, 2 > 1) != (size_t) -1)
    {
      if (!__builtin_constant_p (__len))
 return __readlink_chk (__path, __buf, __len, __builtin_object_size (__buf, 2 > 1));

      if ( __len > __builtin_object_size (__buf, 2 > 1))
 return __readlink_chk_warn (__path, __buf, __len, __builtin_object_size (__buf, 2 > 1));
    }
  return __readlink_alias (__path, __buf, __len);
}



extern ssize_t __readlinkat_chk (int __fd, __const char *__restrict __path,
     char *__restrict __buf, size_t __len,
     size_t __buflen)
     throw () __attribute__ ((__nonnull__ (2, 3))) __attribute__ ((__warn_unused_result__));
extern ssize_t __readlinkat_alias (int __fd, __const char *__restrict __path, char *__restrict __buf, size_t __len) throw () __asm__ ("" "readlinkat")



     __attribute__ ((__nonnull__ (2, 3))) __attribute__ ((__warn_unused_result__));
extern ssize_t __readlinkat_chk_warn (int __fd, __const char *__restrict __path, char *__restrict __buf, size_t __len, size_t __buflen) throw () __asm__ ("" "__readlinkat_chk")



     __attribute__ ((__nonnull__ (2, 3))) __attribute__ ((__warn_unused_result__)) __attribute__((__warning__ ("readlinkat called with bigger " "length than size of destination " "buffer")));



extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) __attribute__ ((__nonnull__ (2, 3))) __attribute__ ((__warn_unused_result__)) ssize_t
readlinkat (int __fd, __const char *__restrict __path, char *__restrict __buf, size_t __len) throw ()

{
  if (__builtin_object_size (__buf, 2 > 1) != (size_t) -1)
    {
      if (!__builtin_constant_p (__len))
 return __readlinkat_chk (__fd, __path, __buf, __len, __builtin_object_size (__buf, 2 > 1));

      if (__len > __builtin_object_size (__buf, 2 > 1))
 return __readlinkat_chk_warn (__fd, __path, __buf, __len,
          __builtin_object_size (__buf, 2 > 1));
    }
  return __readlinkat_alias (__fd, __path, __buf, __len);
}


extern char *__getcwd_chk (char *__buf, size_t __size, size_t __buflen)
     throw () __attribute__ ((__warn_unused_result__));
extern char *__getcwd_alias (char *__buf, size_t __size) throw () __asm__ ("" "getcwd") __attribute__ ((__warn_unused_result__));

extern char *__getcwd_chk_warn (char *__buf, size_t __size, size_t __buflen) throw () __asm__ ("" "__getcwd_chk")


     __attribute__ ((__warn_unused_result__)) __attribute__((__warning__ ("getcwd caller with bigger length than size of " "destination buffer")));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) __attribute__ ((__warn_unused_result__)) char *
getcwd (char *__buf, size_t __size) throw ()
{
  if (__builtin_object_size (__buf, 2 > 1) != (size_t) -1)
    {
      if (!__builtin_constant_p (__size))
 return __getcwd_chk (__buf, __size, __builtin_object_size (__buf, 2 > 1));

      if (__size > __builtin_object_size (__buf, 2 > 1))
 return __getcwd_chk_warn (__buf, __size, __builtin_object_size (__buf, 2 > 1));
    }
  return __getcwd_alias (__buf, __size);
}


extern char *__getwd_chk (char *__buf, size_t buflen)
     throw () __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
extern char *__getwd_warn (char *__buf) throw () __asm__ ("" "getwd")
     __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__)) __attribute__((__warning__ ("please use getcwd instead, as getwd " "doesn't specify buffer size")));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__deprecated__)) __attribute__ ((__warn_unused_result__)) char *
getwd (char *__buf) throw ()
{
  if (__builtin_object_size (__buf, 2 > 1) != (size_t) -1)
    return __getwd_chk (__buf, __builtin_object_size (__buf, 2 > 1));
  return __getwd_warn (__buf);
}


extern size_t __confstr_chk (int __name, char *__buf, size_t __len,
        size_t __buflen) throw ();
extern size_t __confstr_alias (int __name, char *__buf, size_t __len) throw () __asm__ ("" "confstr");

extern size_t __confstr_chk_warn (int __name, char *__buf, size_t __len, size_t __buflen) throw () __asm__ ("" "__confstr_chk")


     __attribute__((__warning__ ("confstr called with bigger length than size of destination " "buffer")));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) size_t
confstr (int __name, char *__buf, size_t __len) throw ()
{
  if (__builtin_object_size (__buf, 2 > 1) != (size_t) -1)
    {
      if (!__builtin_constant_p (__len))
 return __confstr_chk (__name, __buf, __len, __builtin_object_size (__buf, 2 > 1));

      if (__builtin_object_size (__buf, 2 > 1) < __len)
 return __confstr_chk_warn (__name, __buf, __len, __builtin_object_size (__buf, 2 > 1));
    }
  return __confstr_alias (__name, __buf, __len);
}


extern int __getgroups_chk (int __size, __gid_t __list[], size_t __listlen)
     throw () __attribute__ ((__warn_unused_result__));
extern int __getgroups_alias (int __size, __gid_t __list[]) throw () __asm__ ("" "getgroups") __attribute__ ((__warn_unused_result__));

extern int __getgroups_chk_warn (int __size, __gid_t __list[], size_t __listlen) throw () __asm__ ("" "__getgroups_chk")


     __attribute__ ((__warn_unused_result__)) __attribute__((__warning__ ("getgroups called with bigger group count than what " "can fit into destination buffer")));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) int
getgroups (int __size, __gid_t __list[]) throw ()
{
  if (__builtin_object_size (__list, 2 > 1) != (size_t) -1)
    {
      if (!__builtin_constant_p (__size) || __size < 0)
 return __getgroups_chk (__size, __list, __builtin_object_size (__list, 2 > 1));

      if (__size * sizeof (__gid_t) > __builtin_object_size (__list, 2 > 1))
 return __getgroups_chk_warn (__size, __list, __builtin_object_size (__list, 2 > 1));
    }
  return __getgroups_alias (__size, __list);
}


extern int __ttyname_r_chk (int __fd, char *__buf, size_t __buflen,
       size_t __nreal) throw () __attribute__ ((__nonnull__ (2)));
extern int __ttyname_r_alias (int __fd, char *__buf, size_t __buflen) throw () __asm__ ("" "ttyname_r")

     __attribute__ ((__nonnull__ (2)));
extern int __ttyname_r_chk_warn (int __fd, char *__buf, size_t __buflen, size_t __nreal) throw () __asm__ ("" "__ttyname_r_chk")


     __attribute__ ((__nonnull__ (2))) __attribute__((__warning__ ("ttyname_r called with bigger buflen than " "size of destination buffer")));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) int
ttyname_r (int __fd, char *__buf, size_t __buflen) throw ()
{
  if (__builtin_object_size (__buf, 2 > 1) != (size_t) -1)
    {
      if (!__builtin_constant_p (__buflen))
 return __ttyname_r_chk (__fd, __buf, __buflen, __builtin_object_size (__buf, 2 > 1));

      if (__buflen > __builtin_object_size (__buf, 2 > 1))
 return __ttyname_r_chk_warn (__fd, __buf, __buflen, __builtin_object_size (__buf, 2 > 1));
    }
  return __ttyname_r_alias (__fd, __buf, __buflen);
}



extern int __getlogin_r_chk (char *__buf, size_t __buflen, size_t __nreal)
     __attribute__ ((__nonnull__ (1)));
extern int __getlogin_r_alias (char *__buf, size_t __buflen) __asm__ ("" "getlogin_r") __attribute__ ((__nonnull__ (1)));

extern int __getlogin_r_chk_warn (char *__buf, size_t __buflen, size_t __nreal) __asm__ ("" "__getlogin_r_chk")


     __attribute__ ((__nonnull__ (1))) __attribute__((__warning__ ("getlogin_r called with bigger buflen than " "size of destination buffer")));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) int
getlogin_r (char *__buf, size_t __buflen)
{
  if (__builtin_object_size (__buf, 2 > 1) != (size_t) -1)
    {
      if (!__builtin_constant_p (__buflen))
 return __getlogin_r_chk (__buf, __buflen, __builtin_object_size (__buf, 2 > 1));

      if (__buflen > __builtin_object_size (__buf, 2 > 1))
 return __getlogin_r_chk_warn (__buf, __buflen, __builtin_object_size (__buf, 2 > 1));
    }
  return __getlogin_r_alias (__buf, __buflen);
}




extern int __gethostname_chk (char *__buf, size_t __buflen, size_t __nreal)
     throw () __attribute__ ((__nonnull__ (1)));
extern int __gethostname_alias (char *__buf, size_t __buflen) throw () __asm__ ("" "gethostname") __attribute__ ((__nonnull__ (1)));

extern int __gethostname_chk_warn (char *__buf, size_t __buflen, size_t __nreal) throw () __asm__ ("" "__gethostname_chk")


     __attribute__ ((__nonnull__ (1))) __attribute__((__warning__ ("gethostname called with bigger buflen than " "size of destination buffer")));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) int
gethostname (char *__buf, size_t __buflen) throw ()
{
  if (__builtin_object_size (__buf, 2 > 1) != (size_t) -1)
    {
      if (!__builtin_constant_p (__buflen))
 return __gethostname_chk (__buf, __buflen, __builtin_object_size (__buf, 2 > 1));

      if (__buflen > __builtin_object_size (__buf, 2 > 1))
 return __gethostname_chk_warn (__buf, __buflen, __builtin_object_size (__buf, 2 > 1));
    }
  return __gethostname_alias (__buf, __buflen);
}




extern int __getdomainname_chk (char *__buf, size_t __buflen, size_t __nreal)
     throw () __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
extern int __getdomainname_alias (char *__buf, size_t __buflen) throw () __asm__ ("" "getdomainname") __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));


extern int __getdomainname_chk_warn (char *__buf, size_t __buflen, size_t __nreal) throw () __asm__ ("" "__getdomainname_chk")


     __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__)) __attribute__((__warning__ ("getdomainname called with bigger " "buflen than size of destination " "buffer")));



extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) int
getdomainname (char *__buf, size_t __buflen) throw ()
{
  if (__builtin_object_size (__buf, 2 > 1) != (size_t) -1)
    {
      if (!__builtin_constant_p (__buflen))
 return __getdomainname_chk (__buf, __buflen, __builtin_object_size (__buf, 2 > 1));

      if (__buflen > __builtin_object_size (__buf, 2 > 1))
 return __getdomainname_chk_warn (__buf, __buflen, __builtin_object_size (__buf, 2 > 1));
    }
  return __getdomainname_alias (__buf, __buflen);
}
# 1158 "/usr/include/unistd.h" 2 3 4


}
# 43 "/usr/include/c++/4.4/i686-linux-gnu/bits/gthr-default.h" 2 3

typedef pthread_t __gthread_t;
typedef pthread_key_t __gthread_key_t;
typedef pthread_once_t __gthread_once_t;
typedef pthread_mutex_t __gthread_mutex_t;
typedef pthread_mutex_t __gthread_recursive_mutex_t;
typedef pthread_cond_t __gthread_cond_t;
typedef struct timespec __gthread_time_t;
# 118 "/usr/include/c++/4.4/i686-linux-gnu/bits/gthr-default.h" 3
static __typeof(pthread_once) __gthrw_pthread_once __attribute__ ((__weakref__("pthread_once")));
static __typeof(pthread_getspecific) __gthrw_pthread_getspecific __attribute__ ((__weakref__("pthread_getspecific")));
static __typeof(pthread_setspecific) __gthrw_pthread_setspecific __attribute__ ((__weakref__("pthread_setspecific")));

static __typeof(pthread_create) __gthrw_pthread_create __attribute__ ((__weakref__("pthread_create")));
static __typeof(pthread_join) __gthrw_pthread_join __attribute__ ((__weakref__("pthread_join")));
static __typeof(pthread_equal) __gthrw_pthread_equal __attribute__ ((__weakref__("pthread_equal")));
static __typeof(pthread_self) __gthrw_pthread_self __attribute__ ((__weakref__("pthread_self")));
static __typeof(pthread_detach) __gthrw_pthread_detach __attribute__ ((__weakref__("pthread_detach")));
static __typeof(pthread_cancel) __gthrw_pthread_cancel __attribute__ ((__weakref__("pthread_cancel")));
static __typeof(sched_yield) __gthrw_sched_yield __attribute__ ((__weakref__("sched_yield")));

static __typeof(pthread_mutex_lock) __gthrw_pthread_mutex_lock __attribute__ ((__weakref__("pthread_mutex_lock")));
static __typeof(pthread_mutex_trylock) __gthrw_pthread_mutex_trylock __attribute__ ((__weakref__("pthread_mutex_trylock")));


static __typeof(pthread_mutex_timedlock) __gthrw_pthread_mutex_timedlock __attribute__ ((__weakref__("pthread_mutex_timedlock")));


static __typeof(pthread_mutex_unlock) __gthrw_pthread_mutex_unlock __attribute__ ((__weakref__("pthread_mutex_unlock")));
static __typeof(pthread_mutex_init) __gthrw_pthread_mutex_init __attribute__ ((__weakref__("pthread_mutex_init")));
static __typeof(pthread_mutex_destroy) __gthrw_pthread_mutex_destroy __attribute__ ((__weakref__("pthread_mutex_destroy")));

static __typeof(pthread_cond_broadcast) __gthrw_pthread_cond_broadcast __attribute__ ((__weakref__("pthread_cond_broadcast")));
static __typeof(pthread_cond_signal) __gthrw_pthread_cond_signal __attribute__ ((__weakref__("pthread_cond_signal")));
static __typeof(pthread_cond_wait) __gthrw_pthread_cond_wait __attribute__ ((__weakref__("pthread_cond_wait")));
static __typeof(pthread_cond_timedwait) __gthrw_pthread_cond_timedwait __attribute__ ((__weakref__("pthread_cond_timedwait")));
static __typeof(pthread_cond_destroy) __gthrw_pthread_cond_destroy __attribute__ ((__weakref__("pthread_cond_destroy")));


static __typeof(pthread_key_create) __gthrw_pthread_key_create __attribute__ ((__weakref__("pthread_key_create")));
static __typeof(pthread_key_delete) __gthrw_pthread_key_delete __attribute__ ((__weakref__("pthread_key_delete")));
static __typeof(pthread_mutexattr_init) __gthrw_pthread_mutexattr_init __attribute__ ((__weakref__("pthread_mutexattr_init")));
static __typeof(pthread_mutexattr_settype) __gthrw_pthread_mutexattr_settype __attribute__ ((__weakref__("pthread_mutexattr_settype")));
static __typeof(pthread_mutexattr_destroy) __gthrw_pthread_mutexattr_destroy __attribute__ ((__weakref__("pthread_mutexattr_destroy")));
# 237 "/usr/include/c++/4.4/i686-linux-gnu/bits/gthr-default.h" 3
static inline int
__gthread_active_p (void)
{
  static void *const __gthread_active_ptr
    = __extension__ (void *) &__gthrw_pthread_cancel;
  return __gthread_active_ptr != 0;
}
# 675 "/usr/include/c++/4.4/i686-linux-gnu/bits/gthr-default.h" 3
static inline int
__gthread_create (__gthread_t *__threadid, void *(*__func) (void*),
    void *__args)
{
  return __gthrw_pthread_create (__threadid, __null, __func, __args);
}

static inline int
__gthread_join (__gthread_t __threadid, void **__value_ptr)
{
  return __gthrw_pthread_join (__threadid, __value_ptr);
}

static inline int
__gthread_detach (__gthread_t __threadid)
{
  return __gthrw_pthread_detach (__threadid);
}

static inline int
__gthread_equal (__gthread_t __t1, __gthread_t __t2)
{
  return __gthrw_pthread_equal (__t1, __t2);
}

static inline __gthread_t
__gthread_self (void)
{
  return __gthrw_pthread_self ();
}

static inline int
__gthread_yield (void)
{
  return __gthrw_sched_yield ();
}

static inline int
__gthread_once (__gthread_once_t *__once, void (*__func) (void))
{
  if (__gthread_active_p ())
    return __gthrw_pthread_once (__once, __func);
  else
    return -1;
}

static inline int
__gthread_key_create (__gthread_key_t *__key, void (*__dtor) (void *))
{
  return __gthrw_pthread_key_create (__key, __dtor);
}

static inline int
__gthread_key_delete (__gthread_key_t __key)
{
  return __gthrw_pthread_key_delete (__key);
}

static inline void *
__gthread_getspecific (__gthread_key_t __key)
{
  return __gthrw_pthread_getspecific (__key);
}

static inline int
__gthread_setspecific (__gthread_key_t __key, const void *__ptr)
{
  return __gthrw_pthread_setspecific (__key, __ptr);
}

static inline int
__gthread_mutex_destroy (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_destroy (__mutex);
  else
    return 0;
}

static inline int
__gthread_mutex_lock (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_lock (__mutex);
  else
    return 0;
}

static inline int
__gthread_mutex_trylock (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_trylock (__mutex);
  else
    return 0;
}



static inline int
__gthread_mutex_timedlock (__gthread_mutex_t *__mutex,
      const __gthread_time_t *__abs_timeout)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_timedlock (__mutex, __abs_timeout);
  else
    return 0;
}



static inline int
__gthread_mutex_unlock (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_unlock (__mutex);
  else
    return 0;
}
# 818 "/usr/include/c++/4.4/i686-linux-gnu/bits/gthr-default.h" 3
static inline int
__gthread_recursive_mutex_lock (__gthread_recursive_mutex_t *__mutex)
{
  return __gthread_mutex_lock (__mutex);
}

static inline int
__gthread_recursive_mutex_trylock (__gthread_recursive_mutex_t *__mutex)
{
  return __gthread_mutex_trylock (__mutex);
}



static inline int
__gthread_recursive_mutex_timedlock (__gthread_recursive_mutex_t *__mutex,
         const __gthread_time_t *__abs_timeout)
{
  return __gthread_mutex_timedlock (__mutex, __abs_timeout);
}



static inline int
__gthread_recursive_mutex_unlock (__gthread_recursive_mutex_t *__mutex)
{
  return __gthread_mutex_unlock (__mutex);
}

static inline int
__gthread_cond_broadcast (__gthread_cond_t *__cond)
{
  return __gthrw_pthread_cond_broadcast (__cond);
}

static inline int
__gthread_cond_signal (__gthread_cond_t *__cond)
{
  return __gthrw_pthread_cond_signal (__cond);
}

static inline int
__gthread_cond_wait (__gthread_cond_t *__cond, __gthread_mutex_t *__mutex)
{
  return __gthrw_pthread_cond_wait (__cond, __mutex);
}

static inline int
__gthread_cond_timedwait (__gthread_cond_t *__cond, __gthread_mutex_t *__mutex,
     const __gthread_time_t *__abs_timeout)
{
  return __gthrw_pthread_cond_timedwait (__cond, __mutex, __abs_timeout);
}

static inline int
__gthread_cond_wait_recursive (__gthread_cond_t *__cond,
          __gthread_recursive_mutex_t *__mutex)
{
  return __gthread_cond_wait (__cond, __mutex);
}

static inline int
__gthread_cond_timedwait_recursive (__gthread_cond_t *__cond,
        __gthread_recursive_mutex_t *__mutex,
        const __gthread_time_t *__abs_timeout)
{
  return __gthread_cond_timedwait (__cond, __mutex, __abs_timeout);
}

static inline int
__gthread_cond_destroy (__gthread_cond_t* __cond)
{
  return __gthrw_pthread_cond_destroy (__cond);
}
# 163 "/usr/include/c++/4.4/i686-linux-gnu/bits/gthr.h" 2 3







#pragma GCC visibility pop
# 35 "/usr/include/c++/4.4/ext/atomicity.h" 2 3
# 1 "/usr/include/c++/4.4/i686-linux-gnu/bits/atomic_word.h" 1 3
# 32 "/usr/include/c++/4.4/i686-linux-gnu/bits/atomic_word.h" 3
typedef int _Atomic_word;
# 36 "/usr/include/c++/4.4/ext/atomicity.h" 2 3

namespace __gnu_cxx __attribute__ ((__visibility__ ("default"))) {






  static inline _Atomic_word
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __sync_fetch_and_add(__mem, __val); }

  static inline void
  __atomic_add(volatile _Atomic_word* __mem, int __val)
  { __sync_fetch_and_add(__mem, __val); }
# 61 "/usr/include/c++/4.4/ext/atomicity.h" 3
  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
    *__mem += __val;
    return __result;
  }

  static inline void
  __atomic_add_single(_Atomic_word* __mem, int __val)
  { *__mem += __val; }

  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {

    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);



  }

  static inline void
  __attribute__ ((__unused__))
  __atomic_add_dispatch(_Atomic_word* __mem, int __val)
  {

    if (__gthread_active_p())
      __atomic_add(__mem, __val);
    else
      __atomic_add_single(__mem, __val);



  }

}
# 42 "/usr/include/c++/4.4/bits/basic_string.h" 2 3

# 1 "/usr/include/c++/4.4/initializer_list" 1 3
# 44 "/usr/include/c++/4.4/bits/basic_string.h" 2 3

namespace std __attribute__ ((__visibility__ ("default"))) {
# 103 "/usr/include/c++/4.4/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    class basic_string
    {
      typedef typename _Alloc::template rebind<_CharT>::other _CharT_alloc_type;


    public:
      typedef _Traits traits_type;
      typedef typename _Traits::char_type value_type;
      typedef _Alloc allocator_type;
      typedef typename _CharT_alloc_type::size_type size_type;
      typedef typename _CharT_alloc_type::difference_type difference_type;
      typedef typename _CharT_alloc_type::reference reference;
      typedef typename _CharT_alloc_type::const_reference const_reference;
      typedef typename _CharT_alloc_type::pointer pointer;
      typedef typename _CharT_alloc_type::const_pointer const_pointer;
      typedef __gnu_cxx::__normal_iterator<pointer, basic_string> iterator;
      typedef __gnu_cxx::__normal_iterator<const_pointer, basic_string>
                                                            const_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      typedef std::reverse_iterator<iterator> reverse_iterator;

    private:
# 140 "/usr/include/c++/4.4/bits/basic_string.h" 3
      struct _Rep_base
      {
 size_type _M_length;
 size_type _M_capacity;
 _Atomic_word _M_refcount;
      };

      struct _Rep : _Rep_base
      {

 typedef typename _Alloc::template rebind<char>::other _Raw_bytes_alloc;
# 165 "/usr/include/c++/4.4/bits/basic_string.h" 3
 static const size_type _S_max_size;
 static const _CharT _S_terminal;



        static size_type _S_empty_rep_storage[];

        static _Rep&
        _S_empty_rep()
        {



   void* __p = reinterpret_cast<void*>(&_S_empty_rep_storage);
   return *reinterpret_cast<_Rep*>(__p);
 }

        bool
 _M_is_leaked() const
        { return this->_M_refcount < 0; }

        bool
 _M_is_shared() const
        { return this->_M_refcount > 0; }

        void
 _M_set_leaked()
        { this->_M_refcount = -1; }

        void
 _M_set_sharable()
        { this->_M_refcount = 0; }

 void
 _M_set_length_and_sharable(size_type __n)
 {

   if (__builtin_expect(this != &_S_empty_rep(), false))

     {
       this->_M_set_sharable();
       this->_M_length = __n;
       traits_type::assign(this->_M_refdata()[__n], _S_terminal);


     }
 }

 _CharT*
 _M_refdata() throw()
 { return reinterpret_cast<_CharT*>(this + 1); }

 _CharT*
 _M_grab(const _Alloc& __alloc1, const _Alloc& __alloc2)
 {
   return (!_M_is_leaked() && __alloc1 == __alloc2)
           ? _M_refcopy() : _M_clone(__alloc1);
 }


 static _Rep*
 _S_create(size_type, size_type, const _Alloc&);

 void
 _M_dispose(const _Alloc& __a)
 {

   if (__builtin_expect(this != &_S_empty_rep(), false))

     if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
             -1) <= 0)
       _M_destroy(__a);
 }

 void
 _M_destroy(const _Alloc&) throw();

 _CharT*
 _M_refcopy() throw()
 {

   if (__builtin_expect(this != &_S_empty_rep(), false))

            __gnu_cxx::__atomic_add_dispatch(&this->_M_refcount, 1);
   return _M_refdata();
 }

 _CharT*
 _M_clone(const _Alloc&, size_type __res = 0);
      };


      struct _Alloc_hider : _Alloc
      {
 _Alloc_hider(_CharT* __dat, const _Alloc& __a)
 : _Alloc(__a), _M_p(__dat) { }

 _CharT* _M_p;
      };

    public:




      static const size_type npos = static_cast<size_type>(-1);

    private:

      mutable _Alloc_hider _M_dataplus;

      _CharT*
      _M_data() const
      { return _M_dataplus._M_p; }

      _CharT*
      _M_data(_CharT* __p)
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }



      iterator
      _M_ibegin() const
      { return iterator(_M_data()); }

      iterator
      _M_iend() const
      { return iterator(_M_data() + this->size()); }

      void
      _M_leak()
      {
 if (!_M_rep()->_M_is_leaked())
   _M_leak_hard();
      }

      size_type
      _M_check(size_type __pos, const char* __s) const
      {
 if (__pos > this->size())
   __throw_out_of_range((__s));
 return __pos;
      }

      void
      _M_check_length(size_type __n1, size_type __n2, const char* __s) const
      {
 if (this->max_size() - (this->size() - __n1) < __n2)
   __throw_length_error((__s));
      }


      size_type
      _M_limit(size_type __pos, size_type __off) const
      {
 const bool __testoff = __off < this->size() - __pos;
 return __testoff ? __off : this->size() - __pos;
      }


      bool
      _M_disjunct(const _CharT* __s) const
      {
 return (less<const _CharT*>()(__s, _M_data())
  || less<const _CharT*>()(_M_data() + this->size(), __s));
      }



      static void
      _M_copy(_CharT* __d, const _CharT* __s, size_type __n)
      {
 if (__n == 1)
   traits_type::assign(*__d, *__s);
 else
   traits_type::copy(__d, __s, __n);
      }

      static void
      _M_move(_CharT* __d, const _CharT* __s, size_type __n)
      {
 if (__n == 1)
   traits_type::assign(*__d, *__s);
 else
   traits_type::move(__d, __s, __n);
      }

      static void
      _M_assign(_CharT* __d, size_type __n, _CharT __c)
      {
 if (__n == 1)
   traits_type::assign(*__d, __c);
 else
   traits_type::assign(__d, __n, __c);
      }



      template<class _Iterator>
        static void
        _S_copy_chars(_CharT* __p, _Iterator __k1, _Iterator __k2)
        {
   for (; __k1 != __k2; ++__k1, ++__p)
     traits_type::assign(*__p, *__k1);
 }

      static void
      _S_copy_chars(_CharT* __p, iterator __k1, iterator __k2)
      { _S_copy_chars(__p, __k1.base(), __k2.base()); }

      static void
      _S_copy_chars(_CharT* __p, const_iterator __k1, const_iterator __k2)
      { _S_copy_chars(__p, __k1.base(), __k2.base()); }

      static void
      _S_copy_chars(_CharT* __p, _CharT* __k1, _CharT* __k2)
      { _M_copy(__p, __k1, __k2 - __k1); }

      static void
      _S_copy_chars(_CharT* __p, const _CharT* __k1, const _CharT* __k2)
      { _M_copy(__p, __k1, __k2 - __k1); }

      static int
      _S_compare(size_type __n1, size_type __n2)
      {
 const difference_type __d = difference_type(__n1 - __n2);

 if (__d > __gnu_cxx::__numeric_traits<int>::__max)
   return __gnu_cxx::__numeric_traits<int>::__max;
 else if (__d < __gnu_cxx::__numeric_traits<int>::__min)
   return __gnu_cxx::__numeric_traits<int>::__min;
 else
   return int(__d);
      }

      void
      _M_mutate(size_type __pos, size_type __len1, size_type __len2);

      void
      _M_leak_hard();

      static _Rep&
      _S_empty_rep()
      { return _Rep::_S_empty_rep(); }

    public:







      inline
      basic_string();




      explicit
      basic_string(const _Alloc& __a);






      basic_string(const basic_string& __str);






      basic_string(const basic_string& __str, size_type __pos,
     size_type __n = npos);







      basic_string(const basic_string& __str, size_type __pos,
     size_type __n, const _Alloc& __a);
# 464 "/usr/include/c++/4.4/bits/basic_string.h" 3
      basic_string(const _CharT* __s, size_type __n,
     const _Alloc& __a = _Alloc());





      basic_string(const _CharT* __s, const _Alloc& __a = _Alloc());






      basic_string(size_type __n, _CharT __c, const _Alloc& __a = _Alloc());
# 495 "/usr/include/c++/4.4/bits/basic_string.h" 3
      template<class _InputIterator>
        basic_string(_InputIterator __beg, _InputIterator __end,
       const _Alloc& __a = _Alloc());




      ~basic_string()
      { _M_rep()->_M_dispose(this->get_allocator()); }





      basic_string&
      operator=(const basic_string& __str)
      { return this->assign(__str); }





      basic_string&
      operator=(const _CharT* __s)
      { return this->assign(__s); }
# 528 "/usr/include/c++/4.4/bits/basic_string.h" 3
      basic_string&
      operator=(_CharT __c)
      {
 this->assign(1, __c);
 return *this;
      }
# 553 "/usr/include/c++/4.4/bits/basic_string.h" 3
      iterator
      begin()
      {
 _M_leak();
 return iterator(_M_data());
      }





      const_iterator
      begin() const
      { return const_iterator(_M_data()); }





      iterator
      end()
      {
 _M_leak();
 return iterator(_M_data() + this->size());
      }





      const_iterator
      end() const
      { return const_iterator(_M_data() + this->size()); }






      reverse_iterator
      rbegin()
      { return reverse_iterator(this->end()); }






      const_reverse_iterator
      rbegin() const
      { return const_reverse_iterator(this->end()); }






      reverse_iterator
      rend()
      { return reverse_iterator(this->begin()); }






      const_reverse_iterator
      rend() const
      { return const_reverse_iterator(this->begin()); }

    public:



      size_type
      size() const
      { return _M_rep()->_M_length; }



      size_type
      length() const
      { return _M_rep()->_M_length; }


      size_type
      max_size() const
      { return _Rep::_S_max_size; }
# 652 "/usr/include/c++/4.4/bits/basic_string.h" 3
      void
      resize(size_type __n, _CharT __c);
# 665 "/usr/include/c++/4.4/bits/basic_string.h" 3
      void
      resize(size_type __n)
      { this->resize(__n, _CharT()); }





      size_type
      capacity() const
      { return _M_rep()->_M_capacity; }
# 694 "/usr/include/c++/4.4/bits/basic_string.h" 3
      void
      reserve(size_type __res_arg = 0);




      void
      clear()
      { _M_mutate(0, this->size(), 0); }




      bool
      empty() const
      { return this->size() == 0; }
# 722 "/usr/include/c++/4.4/bits/basic_string.h" 3
      const_reference
      operator[] (size_type __pos) const
      {
 ;
 return _M_data()[__pos];
      }
# 739 "/usr/include/c++/4.4/bits/basic_string.h" 3
      reference
      operator[](size_type __pos)
      {

 ;

 ;
 _M_leak();
 return _M_data()[__pos];
      }
# 760 "/usr/include/c++/4.4/bits/basic_string.h" 3
      const_reference
      at(size_type __n) const
      {
 if (__n >= this->size())
   __throw_out_of_range(("basic_string::at"));
 return _M_data()[__n];
      }
# 779 "/usr/include/c++/4.4/bits/basic_string.h" 3
      reference
      at(size_type __n)
      {
 if (__n >= size())
   __throw_out_of_range(("basic_string::at"));
 _M_leak();
 return _M_data()[__n];
      }







      basic_string&
      operator+=(const basic_string& __str)
      { return this->append(__str); }






      basic_string&
      operator+=(const _CharT* __s)
      { return this->append(__s); }






      basic_string&
      operator+=(_CharT __c)
      {
 this->push_back(__c);
 return *this;
      }
# 835 "/usr/include/c++/4.4/bits/basic_string.h" 3
      basic_string&
      append(const basic_string& __str);
# 850 "/usr/include/c++/4.4/bits/basic_string.h" 3
      basic_string&
      append(const basic_string& __str, size_type __pos, size_type __n);







      basic_string&
      append(const _CharT* __s, size_type __n);






      basic_string&
      append(const _CharT* __s)
      {
 ;
 return this->append(__s, traits_type::length(__s));
      }
# 882 "/usr/include/c++/4.4/bits/basic_string.h" 3
      basic_string&
      append(size_type __n, _CharT __c);
# 904 "/usr/include/c++/4.4/bits/basic_string.h" 3
      template<class _InputIterator>
        basic_string&
        append(_InputIterator __first, _InputIterator __last)
        { return this->replace(_M_iend(), _M_iend(), __first, __last); }





      void
      push_back(_CharT __c)
      {
 const size_type __len = 1 + this->size();
 if (__len > this->capacity() || _M_rep()->_M_is_shared())
   this->reserve(__len);
 traits_type::assign(_M_data()[this->size()], __c);
 _M_rep()->_M_set_length_and_sharable(__len);
      }






      basic_string&
      assign(const basic_string& __str);
# 943 "/usr/include/c++/4.4/bits/basic_string.h" 3
      basic_string&
      assign(const basic_string& __str, size_type __pos, size_type __n)
      { return this->assign(__str._M_data()
       + __str._M_check(__pos, "basic_string::assign"),
       __str._M_limit(__pos, __n)); }
# 959 "/usr/include/c++/4.4/bits/basic_string.h" 3
      basic_string&
      assign(const _CharT* __s, size_type __n);
# 971 "/usr/include/c++/4.4/bits/basic_string.h" 3
      basic_string&
      assign(const _CharT* __s)
      {
 ;
 return this->assign(__s, traits_type::length(__s));
      }
# 987 "/usr/include/c++/4.4/bits/basic_string.h" 3
      basic_string&
      assign(size_type __n, _CharT __c)
      { return _M_replace_aux(size_type(0), this->size(), __n, __c); }
# 999 "/usr/include/c++/4.4/bits/basic_string.h" 3
      template<class _InputIterator>
        basic_string&
        assign(_InputIterator __first, _InputIterator __last)
        { return this->replace(_M_ibegin(), _M_iend(), __first, __last); }
# 1027 "/usr/include/c++/4.4/bits/basic_string.h" 3
      void
      insert(iterator __p, size_type __n, _CharT __c)
      { this->replace(__p, __p, __n, __c); }
# 1042 "/usr/include/c++/4.4/bits/basic_string.h" 3
      template<class _InputIterator>
        void
        insert(iterator __p, _InputIterator __beg, _InputIterator __end)
        { this->replace(__p, __p, __beg, __end); }
# 1070 "/usr/include/c++/4.4/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos1, const basic_string& __str)
      { return this->insert(__pos1, __str, size_type(0), __str.size()); }
# 1092 "/usr/include/c++/4.4/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos1, const basic_string& __str,
      size_type __pos2, size_type __n)
      { return this->insert(__pos1, __str._M_data()
       + __str._M_check(__pos2, "basic_string::insert"),
       __str._M_limit(__pos2, __n)); }
# 1115 "/usr/include/c++/4.4/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos, const _CharT* __s, size_type __n);
# 1133 "/usr/include/c++/4.4/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos, const _CharT* __s)
      {
 ;
 return this->insert(__pos, __s, traits_type::length(__s));
      }
# 1156 "/usr/include/c++/4.4/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos, size_type __n, _CharT __c)
      { return _M_replace_aux(_M_check(__pos, "basic_string::insert"),
         size_type(0), __n, __c); }
# 1173 "/usr/include/c++/4.4/bits/basic_string.h" 3
      iterator
      insert(iterator __p, _CharT __c)
      {
 ;
 const size_type __pos = __p - _M_ibegin();
 _M_replace_aux(__pos, size_type(0), size_type(1), __c);
 _M_rep()->_M_set_leaked();
 return iterator(_M_data() + __pos);
      }
# 1197 "/usr/include/c++/4.4/bits/basic_string.h" 3
      basic_string&
      erase(size_type __pos = 0, size_type __n = npos)
      {
 _M_mutate(_M_check(__pos, "basic_string::erase"),
    _M_limit(__pos, __n), size_type(0));
 return *this;
      }
# 1213 "/usr/include/c++/4.4/bits/basic_string.h" 3
      iterator
      erase(iterator __position)
      {
 ;

 const size_type __pos = __position - _M_ibegin();
 _M_mutate(__pos, size_type(1), size_type(0));
 _M_rep()->_M_set_leaked();
 return iterator(_M_data() + __pos);
      }
# 1233 "/usr/include/c++/4.4/bits/basic_string.h" 3
      iterator
      erase(iterator __first, iterator __last);
# 1252 "/usr/include/c++/4.4/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n, const basic_string& __str)
      { return this->replace(__pos, __n, __str._M_data(), __str.size()); }
# 1274 "/usr/include/c++/4.4/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos1, size_type __n1, const basic_string& __str,
       size_type __pos2, size_type __n2)
      { return this->replace(__pos1, __n1, __str._M_data()
        + __str._M_check(__pos2, "basic_string::replace"),
        __str._M_limit(__pos2, __n2)); }
# 1298 "/usr/include/c++/4.4/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n1, const _CharT* __s,
       size_type __n2);
# 1317 "/usr/include/c++/4.4/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n1, const _CharT* __s)
      {
 ;
 return this->replace(__pos, __n1, __s, traits_type::length(__s));
      }
# 1340 "/usr/include/c++/4.4/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n1, size_type __n2, _CharT __c)
      { return _M_replace_aux(_M_check(__pos, "basic_string::replace"),
         _M_limit(__pos, __n1), __n2, __c); }
# 1358 "/usr/include/c++/4.4/bits/basic_string.h" 3
      basic_string&
      replace(iterator __i1, iterator __i2, const basic_string& __str)
      { return this->replace(__i1, __i2, __str._M_data(), __str.size()); }
# 1376 "/usr/include/c++/4.4/bits/basic_string.h" 3
      basic_string&
      replace(iterator __i1, iterator __i2, const _CharT* __s, size_type __n)
      {
 ;

 return this->replace(__i1 - _M_ibegin(), __i2 - __i1, __s, __n);
      }
# 1397 "/usr/include/c++/4.4/bits/basic_string.h" 3
      basic_string&
      replace(iterator __i1, iterator __i2, const _CharT* __s)
      {
 ;
 return this->replace(__i1, __i2, __s, traits_type::length(__s));
      }
# 1418 "/usr/include/c++/4.4/bits/basic_string.h" 3
      basic_string&
      replace(iterator __i1, iterator __i2, size_type __n, _CharT __c)
      {
 ;

 return _M_replace_aux(__i1 - _M_ibegin(), __i2 - __i1, __n, __c);
      }
# 1440 "/usr/include/c++/4.4/bits/basic_string.h" 3
      template<class _InputIterator>
        basic_string&
        replace(iterator __i1, iterator __i2,
  _InputIterator __k1, _InputIterator __k2)
        {
   ;

   ;
   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   return _M_replace_dispatch(__i1, __i2, __k1, __k2, _Integral());
 }



      basic_string&
      replace(iterator __i1, iterator __i2, _CharT* __k1, _CharT* __k2)
      {
 ;

 ;
 return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
        __k1, __k2 - __k1);
      }

      basic_string&
      replace(iterator __i1, iterator __i2,
       const _CharT* __k1, const _CharT* __k2)
      {
 ;

 ;
 return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
        __k1, __k2 - __k1);
      }

      basic_string&
      replace(iterator __i1, iterator __i2, iterator __k1, iterator __k2)
      {
 ;

 ;
 return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
        __k1.base(), __k2 - __k1);
      }

      basic_string&
      replace(iterator __i1, iterator __i2,
       const_iterator __k1, const_iterator __k2)
      {
 ;

 ;
 return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
        __k1.base(), __k2 - __k1);
      }
# 1515 "/usr/include/c++/4.4/bits/basic_string.h" 3
    private:
      template<class _Integer>
 basic_string&
 _M_replace_dispatch(iterator __i1, iterator __i2, _Integer __n,
       _Integer __val, __true_type)
        { return _M_replace_aux(__i1 - _M_ibegin(), __i2 - __i1, __n, __val); }

      template<class _InputIterator>
 basic_string&
 _M_replace_dispatch(iterator __i1, iterator __i2, _InputIterator __k1,
       _InputIterator __k2, __false_type);

      basic_string&
      _M_replace_aux(size_type __pos1, size_type __n1, size_type __n2,
       _CharT __c);

      basic_string&
      _M_replace_safe(size_type __pos1, size_type __n1, const _CharT* __s,
        size_type __n2);



      template<class _InIterator>
        static _CharT*
        _S_construct_aux(_InIterator __beg, _InIterator __end,
    const _Alloc& __a, __false_type)
 {
          typedef typename iterator_traits<_InIterator>::iterator_category _Tag;
          return _S_construct(__beg, __end, __a, _Tag());
 }



      template<class _Integer>
        static _CharT*
        _S_construct_aux(_Integer __beg, _Integer __end,
    const _Alloc& __a, __true_type)
        { return _S_construct(static_cast<size_type>(__beg), __end, __a); }

      template<class _InIterator>
        static _CharT*
        _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a)
 {
   typedef typename std::__is_integer<_InIterator>::__type _Integral;
   return _S_construct_aux(__beg, __end, __a, _Integral());
        }


      template<class _InIterator>
        static _CharT*
         _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a,
        input_iterator_tag);



      template<class _FwdIterator>
        static _CharT*
        _S_construct(_FwdIterator __beg, _FwdIterator __end, const _Alloc& __a,
       forward_iterator_tag);

      static _CharT*
      _S_construct(size_type __req, _CharT __c, const _Alloc& __a);

    public:
# 1591 "/usr/include/c++/4.4/bits/basic_string.h" 3
      size_type
      copy(_CharT* __s, size_type __n, size_type __pos = 0) const;
# 1601 "/usr/include/c++/4.4/bits/basic_string.h" 3
      void
      swap(basic_string& __s);
# 1611 "/usr/include/c++/4.4/bits/basic_string.h" 3
      const _CharT*
      c_str() const
      { return _M_data(); }







      const _CharT*
      data() const
      { return _M_data(); }




      allocator_type
      get_allocator() const
      { return _M_dataplus; }
# 1643 "/usr/include/c++/4.4/bits/basic_string.h" 3
      size_type
      find(const _CharT* __s, size_type __pos, size_type __n) const;
# 1656 "/usr/include/c++/4.4/bits/basic_string.h" 3
      size_type
      find(const basic_string& __str, size_type __pos = 0) const
      { return this->find(__str.data(), __pos, __str.size()); }
# 1670 "/usr/include/c++/4.4/bits/basic_string.h" 3
      size_type
      find(const _CharT* __s, size_type __pos = 0) const
      {
 ;
 return this->find(__s, __pos, traits_type::length(__s));
      }
# 1687 "/usr/include/c++/4.4/bits/basic_string.h" 3
      size_type
      find(_CharT __c, size_type __pos = 0) const;
# 1700 "/usr/include/c++/4.4/bits/basic_string.h" 3
      size_type
      rfind(const basic_string& __str, size_type __pos = npos) const
      { return this->rfind(__str.data(), __pos, __str.size()); }
# 1715 "/usr/include/c++/4.4/bits/basic_string.h" 3
      size_type
      rfind(const _CharT* __s, size_type __pos, size_type __n) const;
# 1728 "/usr/include/c++/4.4/bits/basic_string.h" 3
      size_type
      rfind(const _CharT* __s, size_type __pos = npos) const
      {
 ;
 return this->rfind(__s, __pos, traits_type::length(__s));
      }
# 1745 "/usr/include/c++/4.4/bits/basic_string.h" 3
      size_type
      rfind(_CharT __c, size_type __pos = npos) const;
# 1758 "/usr/include/c++/4.4/bits/basic_string.h" 3
      size_type
      find_first_of(const basic_string& __str, size_type __pos = 0) const
      { return this->find_first_of(__str.data(), __pos, __str.size()); }
# 1773 "/usr/include/c++/4.4/bits/basic_string.h" 3
      size_type
      find_first_of(const _CharT* __s, size_type __pos, size_type __n) const;
# 1786 "/usr/include/c++/4.4/bits/basic_string.h" 3
      size_type
      find_first_of(const _CharT* __s, size_type __pos = 0) const
      {
 ;
 return this->find_first_of(__s, __pos, traits_type::length(__s));
      }
# 1805 "/usr/include/c++/4.4/bits/basic_string.h" 3
      size_type
      find_first_of(_CharT __c, size_type __pos = 0) const
      { return this->find(__c, __pos); }
# 1819 "/usr/include/c++/4.4/bits/basic_string.h" 3
      size_type
      find_last_of(const basic_string& __str, size_type __pos = npos) const
      { return this->find_last_of(__str.data(), __pos, __str.size()); }
# 1834 "/usr/include/c++/4.4/bits/basic_string.h" 3
      size_type
      find_last_of(const _CharT* __s, size_type __pos, size_type __n) const;
# 1847 "/usr/include/c++/4.4/bits/basic_string.h" 3
      size_type
      find_last_of(const _CharT* __s, size_type __pos = npos) const
      {
 ;
 return this->find_last_of(__s, __pos, traits_type::length(__s));
      }
# 1866 "/usr/include/c++/4.4/bits/basic_string.h" 3
      size_type
      find_last_of(_CharT __c, size_type __pos = npos) const
      { return this->rfind(__c, __pos); }
# 1880 "/usr/include/c++/4.4/bits/basic_string.h" 3
      size_type
      find_first_not_of(const basic_string& __str, size_type __pos = 0) const
      { return this->find_first_not_of(__str.data(), __pos, __str.size()); }
# 1895 "/usr/include/c++/4.4/bits/basic_string.h" 3
      size_type
      find_first_not_of(const _CharT* __s, size_type __pos,
   size_type __n) const;
# 1909 "/usr/include/c++/4.4/bits/basic_string.h" 3
      size_type
      find_first_not_of(const _CharT* __s, size_type __pos = 0) const
      {
 ;
 return this->find_first_not_of(__s, __pos, traits_type::length(__s));
      }
# 1926 "/usr/include/c++/4.4/bits/basic_string.h" 3
      size_type
      find_first_not_of(_CharT __c, size_type __pos = 0) const;
# 1939 "/usr/include/c++/4.4/bits/basic_string.h" 3
      size_type
      find_last_not_of(const basic_string& __str, size_type __pos = npos) const
      { return this->find_last_not_of(__str.data(), __pos, __str.size()); }
# 1955 "/usr/include/c++/4.4/bits/basic_string.h" 3
      size_type
      find_last_not_of(const _CharT* __s, size_type __pos,
         size_type __n) const;
# 1968 "/usr/include/c++/4.4/bits/basic_string.h" 3
      size_type
      find_last_not_of(const _CharT* __s, size_type __pos = npos) const
      {
 ;
 return this->find_last_not_of(__s, __pos, traits_type::length(__s));
      }
# 1985 "/usr/include/c++/4.4/bits/basic_string.h" 3
      size_type
      find_last_not_of(_CharT __c, size_type __pos = npos) const;
# 2000 "/usr/include/c++/4.4/bits/basic_string.h" 3
      basic_string
      substr(size_type __pos = 0, size_type __n = npos) const
      { return basic_string(*this,
       _M_check(__pos, "basic_string::substr"), __n); }
# 2018 "/usr/include/c++/4.4/bits/basic_string.h" 3
      int
      compare(const basic_string& __str) const
      {
 const size_type __size = this->size();
 const size_type __osize = __str.size();
 const size_type __len = std::min(__size, __osize);

 int __r = traits_type::compare(_M_data(), __str.data(), __len);
 if (!__r)
   __r = _S_compare(__size, __osize);
 return __r;
      }
# 2048 "/usr/include/c++/4.4/bits/basic_string.h" 3
      int
      compare(size_type __pos, size_type __n, const basic_string& __str) const;
# 2072 "/usr/include/c++/4.4/bits/basic_string.h" 3
      int
      compare(size_type __pos1, size_type __n1, const basic_string& __str,
       size_type __pos2, size_type __n2) const;
# 2090 "/usr/include/c++/4.4/bits/basic_string.h" 3
      int
      compare(const _CharT* __s) const;
# 2113 "/usr/include/c++/4.4/bits/basic_string.h" 3
      int
      compare(size_type __pos, size_type __n1, const _CharT* __s) const;
# 2138 "/usr/include/c++/4.4/bits/basic_string.h" 3
      int
      compare(size_type __pos, size_type __n1, const _CharT* __s,
       size_type __n2) const;
  };

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>::
    basic_string()

    : _M_dataplus(_S_empty_rep()._M_refdata(), _Alloc()) { }
# 2159 "/usr/include/c++/4.4/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
      __str.append(__rhs);
      return __str;
    }







  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT,_Traits,_Alloc>
    operator+(const _CharT* __lhs,
       const basic_string<_CharT,_Traits,_Alloc>& __rhs);







  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT,_Traits,_Alloc>
    operator+(_CharT __lhs, const basic_string<_CharT,_Traits,_Alloc>& __rhs);







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
      const _CharT* __rhs)
    {
      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
      __str.append(__rhs);
      return __str;
    }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs, _CharT __rhs)
    {
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      __string_type __str(__lhs);
      __str.append(__size_type(1), __rhs);
      return __str;
    }
# 2230 "/usr/include/c++/4.4/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) == 0; }

  template<typename _CharT>
    inline
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, bool>::__type
    operator==(const basic_string<_CharT>& __lhs,
        const basic_string<_CharT>& __rhs)
    { return (__lhs.size() == __rhs.size()
       && !std::char_traits<_CharT>::compare(__lhs.data(), __rhs.data(),
          __lhs.size())); }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) == 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) == 0; }
# 2276 "/usr/include/c++/4.4/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return !(__lhs == __rhs); }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return !(__lhs == __rhs); }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return !(__lhs == __rhs); }
# 2313 "/usr/include/c++/4.4/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) < 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const _CharT* __rhs)
    { return __lhs.compare(__rhs) < 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) > 0; }
# 2350 "/usr/include/c++/4.4/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) > 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const _CharT* __rhs)
    { return __lhs.compare(__rhs) > 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) < 0; }
# 2387 "/usr/include/c++/4.4/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) <= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) <= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) >= 0; }
# 2424 "/usr/include/c++/4.4/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) >= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) >= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const _CharT* __lhs,
      const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) <= 0; }
# 2461 "/usr/include/c++/4.4/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline void
    swap(basic_string<_CharT, _Traits, _Alloc>& __lhs,
  basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { __lhs.swap(__rhs); }
# 2478 "/usr/include/c++/4.4/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is,
        basic_string<_CharT, _Traits, _Alloc>& __str);

  template<>
    basic_istream<char>&
    operator>>(basic_istream<char>& __is, basic_string<char>& __str);
# 2496 "/usr/include/c++/4.4/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os,
        const basic_string<_CharT, _Traits, _Alloc>& __str)
    {


      return __ostream_insert(__os, __str.data(), __str.size());
    }
# 2519 "/usr/include/c++/4.4/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __is,
     basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim);
# 2536 "/usr/include/c++/4.4/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __is,
     basic_string<_CharT, _Traits, _Alloc>& __str)
    { return getline(__is, __str, __is.widen('\n')); }

  template<>
    basic_istream<char>&
    getline(basic_istream<char>& __in, basic_string<char>& __str,
     char __delim);


  template<>
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>& __in, basic_string<wchar_t>& __str,
     wchar_t __delim);


}
# 54 "/usr/include/c++/4.4/string" 2 3


# 1 "/usr/include/c++/4.4/bits/basic_string.tcc" 1 3
# 42 "/usr/include/c++/4.4/bits/basic_string.tcc" 3
       
# 43 "/usr/include/c++/4.4/bits/basic_string.tcc" 3



namespace std __attribute__ ((__visibility__ ("default"))) {

  template<typename _CharT, typename _Traits, typename _Alloc>
    const typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    _Rep::_S_max_size = (((npos - sizeof(_Rep_base))/sizeof(_CharT)) - 1) / 4;

  template<typename _CharT, typename _Traits, typename _Alloc>
    const _CharT
    basic_string<_CharT, _Traits, _Alloc>::
    _Rep::_S_terminal = _CharT();

  template<typename _CharT, typename _Traits, typename _Alloc>
    const typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::npos;



  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::_Rep::_S_empty_rep_storage[
    (sizeof(_Rep_base) + sizeof(_CharT) + sizeof(size_type) - 1) /
      sizeof(size_type)];





  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InIterator>
      _CharT*
      basic_string<_CharT, _Traits, _Alloc>::
      _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a,
     input_iterator_tag)
      {

 if (__beg == __end && __a == _Alloc())
   return _S_empty_rep()._M_refdata();


 _CharT __buf[128];
 size_type __len = 0;
 while (__beg != __end && __len < sizeof(__buf) / sizeof(_CharT))
   {
     __buf[__len++] = *__beg;
     ++__beg;
   }
 _Rep* __r = _Rep::_S_create(__len, size_type(0), __a);
 _M_copy(__r->_M_refdata(), __buf, __len);
 try
   {
     while (__beg != __end)
       {
  if (__len == __r->_M_capacity)
    {

      _Rep* __another = _Rep::_S_create(__len + 1, __len, __a);
      _M_copy(__another->_M_refdata(), __r->_M_refdata(), __len);
      __r->_M_destroy(__a);
      __r = __another;
    }
  __r->_M_refdata()[__len++] = *__beg;
  ++__beg;
       }
   }
 catch(...)
   {
     __r->_M_destroy(__a);
     throw;
   }
 __r->_M_set_length_and_sharable(__len);
 return __r->_M_refdata();
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    template <typename _InIterator>
      _CharT*
      basic_string<_CharT, _Traits, _Alloc>::
      _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a,
     forward_iterator_tag)
      {

 if (__beg == __end && __a == _Alloc())
   return _S_empty_rep()._M_refdata();


 if (__builtin_expect(__gnu_cxx::__is_null_pointer(__beg)
        && __beg != __end, 0))
   __throw_logic_error(("basic_string::_S_construct NULL not valid"));

 const size_type __dnew = static_cast<size_type>(std::distance(__beg,
              __end));

 _Rep* __r = _Rep::_S_create(__dnew, size_type(0), __a);
 try
   { _S_copy_chars(__r->_M_refdata(), __beg, __end); }
 catch(...)
   {
     __r->_M_destroy(__a);
     throw;
   }
 __r->_M_set_length_and_sharable(__dnew);
 return __r->_M_refdata();
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    _CharT*
    basic_string<_CharT, _Traits, _Alloc>::
    _S_construct(size_type __n, _CharT __c, const _Alloc& __a)
    {

      if (__n == 0 && __a == _Alloc())
 return _S_empty_rep()._M_refdata();


      _Rep* __r = _Rep::_S_create(__n, size_type(0), __a);
      if (__n)
 _M_assign(__r->_M_refdata(), __n, __c);

      __r->_M_set_length_and_sharable(__n);
      return __r->_M_refdata();
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const basic_string& __str)
    : _M_dataplus(__str._M_rep()->_M_grab(_Alloc(__str.get_allocator()),
       __str.get_allocator()),
    __str.get_allocator())
    { }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const _Alloc& __a)
    : _M_dataplus(_S_construct(size_type(), _CharT(), __a), __a)
    { }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const basic_string& __str, size_type __pos, size_type __n)
    : _M_dataplus(_S_construct(__str._M_data()
          + __str._M_check(__pos,
      "basic_string::basic_string"),
          __str._M_data() + __str._M_limit(__pos, __n)
          + __pos, _Alloc()), _Alloc())
    { }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const basic_string& __str, size_type __pos,
   size_type __n, const _Alloc& __a)
    : _M_dataplus(_S_construct(__str._M_data()
          + __str._M_check(__pos,
      "basic_string::basic_string"),
          __str._M_data() + __str._M_limit(__pos, __n)
          + __pos, __a), __a)
    { }


  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const _CharT* __s, size_type __n, const _Alloc& __a)
    : _M_dataplus(_S_construct(__s, __s + __n, __a), __a)
    { }


  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const _CharT* __s, const _Alloc& __a)
    : _M_dataplus(_S_construct(__s, __s ? __s + traits_type::length(__s) :
          __s + npos, __a), __a)
    { }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(size_type __n, _CharT __c, const _Alloc& __a)
    : _M_dataplus(_S_construct(__n, __c, __a), __a)
    { }


  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InputIterator>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(_InputIterator __beg, _InputIterator __end, const _Alloc& __a)
    : _M_dataplus(_S_construct(__beg, __end, __a), __a)
    { }
# 241 "/usr/include/c++/4.4/bits/basic_string.tcc" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    assign(const basic_string& __str)
    {
      if (_M_rep() != __str._M_rep())
 {

   const allocator_type __a = this->get_allocator();
   _CharT* __tmp = __str._M_rep()->_M_grab(__a, __str.get_allocator());
   _M_rep()->_M_dispose(__a);
   _M_data(__tmp);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    assign(const _CharT* __s, size_type __n)
    {
      ;
      _M_check_length(this->size(), __n, "basic_string::assign");
      if (_M_disjunct(__s) || _M_rep()->_M_is_shared())
 return _M_replace_safe(size_type(0), this->size(), __s, __n);
      else
 {

   const size_type __pos = __s - _M_data();
   if (__pos >= __n)
     _M_copy(_M_data(), __s, __n);
   else if (__pos)
     _M_move(_M_data(), __s, __n);
   _M_rep()->_M_set_length_and_sharable(__n);
   return *this;
 }
     }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    append(size_type __n, _CharT __c)
    {
      if (__n)
 {
   _M_check_length(size_type(0), __n, "basic_string::append");
   const size_type __len = __n + this->size();
   if (__len > this->capacity() || _M_rep()->_M_is_shared())
     this->reserve(__len);
   _M_assign(_M_data() + this->size(), __n, __c);
   _M_rep()->_M_set_length_and_sharable(__len);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    append(const _CharT* __s, size_type __n)
    {
      ;
      if (__n)
 {
   _M_check_length(size_type(0), __n, "basic_string::append");
   const size_type __len = __n + this->size();
   if (__len > this->capacity() || _M_rep()->_M_is_shared())
     {
       if (_M_disjunct(__s))
  this->reserve(__len);
       else
  {
    const size_type __off = __s - _M_data();
    this->reserve(__len);
    __s = _M_data() + __off;
  }
     }
   _M_copy(_M_data() + this->size(), __s, __n);
   _M_rep()->_M_set_length_and_sharable(__len);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    append(const basic_string& __str)
    {
      const size_type __size = __str.size();
      if (__size)
 {
   const size_type __len = __size + this->size();
   if (__len > this->capacity() || _M_rep()->_M_is_shared())
     this->reserve(__len);
   _M_copy(_M_data() + this->size(), __str._M_data(), __size);
   _M_rep()->_M_set_length_and_sharable(__len);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    append(const basic_string& __str, size_type __pos, size_type __n)
    {
      __str._M_check(__pos, "basic_string::append");
      __n = __str._M_limit(__pos, __n);
      if (__n)
 {
   const size_type __len = __n + this->size();
   if (__len > this->capacity() || _M_rep()->_M_is_shared())
     this->reserve(__len);
   _M_copy(_M_data() + this->size(), __str._M_data() + __pos, __n);
   _M_rep()->_M_set_length_and_sharable(__len);
 }
      return *this;
    }

   template<typename _CharT, typename _Traits, typename _Alloc>
     basic_string<_CharT, _Traits, _Alloc>&
     basic_string<_CharT, _Traits, _Alloc>::
     insert(size_type __pos, const _CharT* __s, size_type __n)
     {
       ;
       _M_check(__pos, "basic_string::insert");
       _M_check_length(size_type(0), __n, "basic_string::insert");
       if (_M_disjunct(__s) || _M_rep()->_M_is_shared())
         return _M_replace_safe(__pos, size_type(0), __s, __n);
       else
         {

           const size_type __off = __s - _M_data();
           _M_mutate(__pos, 0, __n);
           __s = _M_data() + __off;
           _CharT* __p = _M_data() + __pos;
           if (__s + __n <= __p)
             _M_copy(__p, __s, __n);
           else if (__s >= __p)
             _M_copy(__p, __s + __n, __n);
           else
             {
        const size_type __nleft = __p - __s;
               _M_copy(__p, __s, __nleft);
               _M_copy(__p + __nleft, __p + __n, __n - __nleft);
             }
           return *this;
         }
     }

   template<typename _CharT, typename _Traits, typename _Alloc>
     typename basic_string<_CharT, _Traits, _Alloc>::iterator
     basic_string<_CharT, _Traits, _Alloc>::
     erase(iterator __first, iterator __last)
     {
       ;





       const size_type __size = __last - __first;
       if (__size)
  {
    const size_type __pos = __first - _M_ibegin();
    _M_mutate(__pos, __size, size_type(0));
    _M_rep()->_M_set_leaked();
    return iterator(_M_data() + __pos);
  }
       else
  return __first;
     }

   template<typename _CharT, typename _Traits, typename _Alloc>
     basic_string<_CharT, _Traits, _Alloc>&
     basic_string<_CharT, _Traits, _Alloc>::
     replace(size_type __pos, size_type __n1, const _CharT* __s,
      size_type __n2)
     {
       ;
       _M_check(__pos, "basic_string::replace");
       __n1 = _M_limit(__pos, __n1);
       _M_check_length(__n1, __n2, "basic_string::replace");
       bool __left;
       if (_M_disjunct(__s) || _M_rep()->_M_is_shared())
         return _M_replace_safe(__pos, __n1, __s, __n2);
       else if ((__left = __s + __n2 <= _M_data() + __pos)
  || _M_data() + __pos + __n1 <= __s)
  {

    size_type __off = __s - _M_data();
    __left ? __off : (__off += __n2 - __n1);
    _M_mutate(__pos, __n1, __n2);
    _M_copy(_M_data() + __pos, _M_data() + __off, __n2);
    return *this;
  }
       else
  {

    const basic_string __tmp(__s, __n2);
    return _M_replace_safe(__pos, __n1, __tmp._M_data(), __n2);
  }
     }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::_Rep::
    _M_destroy(const _Alloc& __a) throw ()
    {
      const size_type __size = sizeof(_Rep_base) +
                        (this->_M_capacity + 1) * sizeof(_CharT);
      _Raw_bytes_alloc(__a).deallocate(reinterpret_cast<char*>(this), __size);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_leak_hard()
    {

      if (_M_rep() == &_S_empty_rep())
 return;

      if (_M_rep()->_M_is_shared())
 _M_mutate(0, 0, 0);
      _M_rep()->_M_set_leaked();
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_mutate(size_type __pos, size_type __len1, size_type __len2)
    {
      const size_type __old_size = this->size();
      const size_type __new_size = __old_size + __len2 - __len1;
      const size_type __how_much = __old_size - __pos - __len1;

      if (__new_size > this->capacity() || _M_rep()->_M_is_shared())
 {

   const allocator_type __a = get_allocator();
   _Rep* __r = _Rep::_S_create(__new_size, this->capacity(), __a);

   if (__pos)
     _M_copy(__r->_M_refdata(), _M_data(), __pos);
   if (__how_much)
     _M_copy(__r->_M_refdata() + __pos + __len2,
      _M_data() + __pos + __len1, __how_much);

   _M_rep()->_M_dispose(__a);
   _M_data(__r->_M_refdata());
 }
      else if (__how_much && __len1 != __len2)
 {

   _M_move(_M_data() + __pos + __len2,
    _M_data() + __pos + __len1, __how_much);
 }
      _M_rep()->_M_set_length_and_sharable(__new_size);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    reserve(size_type __res)
    {
      if (__res != this->capacity() || _M_rep()->_M_is_shared())
        {

   if (__res < this->size())
     __res = this->size();
   const allocator_type __a = get_allocator();
   _CharT* __tmp = _M_rep()->_M_clone(__a, __res - this->size());
   _M_rep()->_M_dispose(__a);
   _M_data(__tmp);
        }
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    swap(basic_string& __s)
    {
      if (_M_rep()->_M_is_leaked())
 _M_rep()->_M_set_sharable();
      if (__s._M_rep()->_M_is_leaked())
 __s._M_rep()->_M_set_sharable();
      if (this->get_allocator() == __s.get_allocator())
 {
   _CharT* __tmp = _M_data();
   _M_data(__s._M_data());
   __s._M_data(__tmp);
 }

      else
 {
   const basic_string __tmp1(_M_ibegin(), _M_iend(),
        __s.get_allocator());
   const basic_string __tmp2(__s._M_ibegin(), __s._M_iend(),
        this->get_allocator());
   *this = __tmp2;
   __s = __tmp1;
 }
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::_Rep*
    basic_string<_CharT, _Traits, _Alloc>::_Rep::
    _S_create(size_type __capacity, size_type __old_capacity,
       const _Alloc& __alloc)
    {


      if (__capacity > _S_max_size)
 __throw_length_error(("basic_string::_S_create"));
# 578 "/usr/include/c++/4.4/bits/basic_string.tcc" 3
      const size_type __pagesize = 4096;
      const size_type __malloc_header_size = 4 * sizeof(void*);







      if (__capacity > __old_capacity && __capacity < 2 * __old_capacity)
 __capacity = 2 * __old_capacity;




      size_type __size = (__capacity + 1) * sizeof(_CharT) + sizeof(_Rep);

      const size_type __adj_size = __size + __malloc_header_size;
      if (__adj_size > __pagesize && __capacity > __old_capacity)
 {
   const size_type __extra = __pagesize - __adj_size % __pagesize;
   __capacity += __extra / sizeof(_CharT);

   if (__capacity > _S_max_size)
     __capacity = _S_max_size;
   __size = (__capacity + 1) * sizeof(_CharT) + sizeof(_Rep);
 }



      void* __place = _Raw_bytes_alloc(__alloc).allocate(__size);
      _Rep *__p = new (__place) _Rep;
      __p->_M_capacity = __capacity;







      __p->_M_set_sharable();
      return __p;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    _CharT*
    basic_string<_CharT, _Traits, _Alloc>::_Rep::
    _M_clone(const _Alloc& __alloc, size_type __res)
    {

      const size_type __requested_cap = this->_M_length + __res;
      _Rep* __r = _Rep::_S_create(__requested_cap, this->_M_capacity,
      __alloc);
      if (this->_M_length)
 _M_copy(__r->_M_refdata(), _M_refdata(), this->_M_length);

      __r->_M_set_length_and_sharable(this->_M_length);
      return __r->_M_refdata();
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    resize(size_type __n, _CharT __c)
    {
      const size_type __size = this->size();
      _M_check_length(__size, __n, "basic_string::resize");
      if (__size < __n)
 this->append(__n - __size, __c);
      else if (__n < __size)
 this->erase(__n);

    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InputIterator>
      basic_string<_CharT, _Traits, _Alloc>&
      basic_string<_CharT, _Traits, _Alloc>::
      _M_replace_dispatch(iterator __i1, iterator __i2, _InputIterator __k1,
     _InputIterator __k2, __false_type)
      {
 const basic_string __s(__k1, __k2);
 const size_type __n1 = __i2 - __i1;
 _M_check_length(__n1, __s.size(), "basic_string::_M_replace_dispatch");
 return _M_replace_safe(__i1 - _M_ibegin(), __n1, __s._M_data(),
          __s.size());
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    _M_replace_aux(size_type __pos1, size_type __n1, size_type __n2,
     _CharT __c)
    {
      _M_check_length(__n1, __n2, "basic_string::_M_replace_aux");
      _M_mutate(__pos1, __n1, __n2);
      if (__n2)
 _M_assign(_M_data() + __pos1, __n2, __c);
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    _M_replace_safe(size_type __pos1, size_type __n1, const _CharT* __s,
      size_type __n2)
    {
      _M_mutate(__pos1, __n1, __n2);
      if (__n2)
 _M_copy(_M_data() + __pos1, __s, __n2);
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      ;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      const __size_type __len = _Traits::length(__lhs);
      __string_type __str;
      __str.reserve(__len + __rhs.size());
      __str.append(__lhs, __len);
      __str.append(__rhs);
      return __str;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(_CharT __lhs, const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      __string_type __str;
      const __size_type __len = __rhs.size();
      __str.reserve(__len + 1);
      __str.append(__size_type(1), __lhs);
      __str.append(__rhs);
      return __str;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    copy(_CharT* __s, size_type __n, size_type __pos) const
    {
      _M_check(__pos, "basic_string::copy");
      __n = _M_limit(__pos, __n);
      ;
      if (__n)
 _M_copy(__s, _M_data() + __pos, __n);

      return __n;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      const size_type __size = this->size();
      const _CharT* __data = _M_data();

      if (__n == 0)
 return __pos <= __size ? __pos : npos;

      if (__n <= __size)
 {
   for (; __pos <= __size - __n; ++__pos)
     if (traits_type::eq(__data[__pos], __s[0])
  && traits_type::compare(__data + __pos + 1,
     __s + 1, __n - 1) == 0)
       return __pos;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find(_CharT __c, size_type __pos) const
    {
      size_type __ret = npos;
      const size_type __size = this->size();
      if (__pos < __size)
 {
   const _CharT* __data = _M_data();
   const size_type __n = __size - __pos;
   const _CharT* __p = traits_type::find(__data + __pos, __n, __c);
   if (__p)
     __ret = __p - __data;
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    rfind(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      const size_type __size = this->size();
      if (__n <= __size)
 {
   __pos = std::min(size_type(__size - __n), __pos);
   const _CharT* __data = _M_data();
   do
     {
       if (traits_type::compare(__data + __pos, __s, __n) == 0)
  return __pos;
     }
   while (__pos-- > 0);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    rfind(_CharT __c, size_type __pos) const
    {
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   for (++__size; __size-- > 0; )
     if (traits_type::eq(_M_data()[__size], __c))
       return __size;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      for (; __n && __pos < this->size(); ++__pos)
 {
   const _CharT* __p = traits_type::find(__s, __n, _M_data()[__pos]);
   if (__p)
     return __pos;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      size_type __size = this->size();
      if (__size && __n)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (traits_type::find(__s, __n, _M_data()[__size]))
  return __size;
     }
   while (__size-- != 0);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_not_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      for (; __pos < this->size(); ++__pos)
 if (!traits_type::find(__s, __n, _M_data()[__pos]))
   return __pos;
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_not_of(_CharT __c, size_type __pos) const
    {
      for (; __pos < this->size(); ++__pos)
 if (!traits_type::eq(_M_data()[__pos], __c))
   return __pos;
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_not_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (!traits_type::find(__s, __n, _M_data()[__size]))
  return __size;
     }
   while (__size--);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_not_of(_CharT __c, size_type __pos) const
    {
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (!traits_type::eq(_M_data()[__size], __c))
  return __size;
     }
   while (__size--);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n, const basic_string& __str) const
    {
      _M_check(__pos, "basic_string::compare");
      __n = _M_limit(__pos, __n);
      const size_type __osize = __str.size();
      const size_type __len = std::min(__n, __osize);
      int __r = traits_type::compare(_M_data() + __pos, __str.data(), __len);
      if (!__r)
 __r = _S_compare(__n, __osize);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(size_type __pos1, size_type __n1, const basic_string& __str,
     size_type __pos2, size_type __n2) const
    {
      _M_check(__pos1, "basic_string::compare");
      __str._M_check(__pos2, "basic_string::compare");
      __n1 = _M_limit(__pos1, __n1);
      __n2 = __str._M_limit(__pos2, __n2);
      const size_type __len = std::min(__n1, __n2);
      int __r = traits_type::compare(_M_data() + __pos1,
         __str.data() + __pos2, __len);
      if (!__r)
 __r = _S_compare(__n1, __n2);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(const _CharT* __s) const
    {
      ;
      const size_type __size = this->size();
      const size_type __osize = traits_type::length(__s);
      const size_type __len = std::min(__size, __osize);
      int __r = traits_type::compare(_M_data(), __s, __len);
      if (!__r)
 __r = _S_compare(__size, __osize);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string <_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n1, const _CharT* __s) const
    {
      ;
      _M_check(__pos, "basic_string::compare");
      __n1 = _M_limit(__pos, __n1);
      const size_type __osize = traits_type::length(__s);
      const size_type __len = std::min(__n1, __osize);
      int __r = traits_type::compare(_M_data() + __pos, __s, __len);
      if (!__r)
 __r = _S_compare(__n1, __osize);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string <_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n1, const _CharT* __s,
     size_type __n2) const
    {
      ;
      _M_check(__pos, "basic_string::compare");
      __n1 = _M_limit(__pos, __n1);
      const size_type __len = std::min(__n1, __n2);
      int __r = traits_type::compare(_M_data() + __pos, __s, __len);
      if (!__r)
 __r = _S_compare(__n1, __n2);
      return __r;
    }


  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in,
        basic_string<_CharT, _Traits, _Alloc>& __str)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __istream_type::ios_base __ios_base;
      typedef typename __istream_type::int_type __int_type;
      typedef typename __string_type::size_type __size_type;
      typedef ctype<_CharT> __ctype_type;
      typedef typename __ctype_type::ctype_base __ctype_base;

      __size_type __extracted = 0;
      typename __ios_base::iostate __err = __ios_base::goodbit;
      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
 {
   try
     {

       __str.erase();
       _CharT __buf[128];
       __size_type __len = 0;
       const streamsize __w = __in.width();
       const __size_type __n = __w > 0 ? static_cast<__size_type>(__w)
                                : __str.max_size();
       const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());
       const __int_type __eof = _Traits::eof();
       __int_type __c = __in.rdbuf()->sgetc();

       while (__extracted < __n
       && !_Traits::eq_int_type(__c, __eof)
       && !__ct.is(__ctype_base::space,
     _Traits::to_char_type(__c)))
  {
    if (__len == sizeof(__buf) / sizeof(_CharT))
      {
        __str.append(__buf, sizeof(__buf) / sizeof(_CharT));
        __len = 0;
      }
    __buf[__len++] = _Traits::to_char_type(__c);
    ++__extracted;
    __c = __in.rdbuf()->snextc();
  }
       __str.append(__buf, __len);

       if (_Traits::eq_int_type(__c, __eof))
  __err |= __ios_base::eofbit;
       __in.width(0);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __in._M_setstate(__ios_base::badbit);
       throw;
     }
   catch(...)
     {



       __in._M_setstate(__ios_base::badbit);
     }
 }

      if (!__extracted)
 __err |= __ios_base::failbit;
      if (__err)
 __in.setstate(__err);
      return __in;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __in,
     basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __istream_type::ios_base __ios_base;
      typedef typename __istream_type::int_type __int_type;
      typedef typename __string_type::size_type __size_type;

      __size_type __extracted = 0;
      const __size_type __n = __str.max_size();
      typename __ios_base::iostate __err = __ios_base::goodbit;
      typename __istream_type::sentry __cerb(__in, true);
      if (__cerb)
 {
   try
     {
       __str.erase();
       const __int_type __idelim = _Traits::to_int_type(__delim);
       const __int_type __eof = _Traits::eof();
       __int_type __c = __in.rdbuf()->sgetc();

       while (__extracted < __n
       && !_Traits::eq_int_type(__c, __eof)
       && !_Traits::eq_int_type(__c, __idelim))
  {
    __str += _Traits::to_char_type(__c);
    ++__extracted;
    __c = __in.rdbuf()->snextc();
  }

       if (_Traits::eq_int_type(__c, __eof))
  __err |= __ios_base::eofbit;
       else if (_Traits::eq_int_type(__c, __idelim))
  {
    ++__extracted;
    __in.rdbuf()->sbumpc();
  }
       else
  __err |= __ios_base::failbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __in._M_setstate(__ios_base::badbit);
       throw;
     }
   catch(...)
     {



       __in._M_setstate(__ios_base::badbit);
     }
 }
      if (!__extracted)
 __err |= __ios_base::failbit;
      if (__err)
 __in.setstate(__err);
      return __in;
    }





  extern template class basic_string<char>;
  extern template
    basic_istream<char>&
    operator>>(basic_istream<char>&, string&);
  extern template
    basic_ostream<char>&
    operator<<(basic_ostream<char>&, const string&);
  extern template
    basic_istream<char>&
    getline(basic_istream<char>&, string&, char);
  extern template
    basic_istream<char>&
    getline(basic_istream<char>&, string&);


  extern template class basic_string<wchar_t>;
  extern template
    basic_istream<wchar_t>&
    operator>>(basic_istream<wchar_t>&, wstring&);
  extern template
    basic_ostream<wchar_t>&
    operator<<(basic_ostream<wchar_t>&, const wstring&);
  extern template
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>&, wstring&, wchar_t);
  extern template
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>&, wstring&);



}
# 57 "/usr/include/c++/4.4/string" 2 3
# 177 "/usr/include/wx-2.8/wx/string.h" 2
# 1 "/usr/include/wx-2.8/wx/afterstd.h" 1
# 178 "/usr/include/wx-2.8/wx/string.h" 2



        typedef std::wstring wxStdString;
# 216 "/usr/include/wx-2.8/wx/string.h"
struct wxStringData
{
  int nRefs;
  size_t nDataLength,
          nAllocLength;


  wxChar* data() const { return (wxChar*)(this + 1); }


  bool IsEmpty() const { return (nRefs == -1); }
  bool IsShared() const { return (nRefs > 1); }


  void Lock() { if ( !IsEmpty() ) nRefs++; }
# 243 "/usr/include/wx-2.8/wx/string.h"
  void Unlock() { if ( !IsEmpty() && --nRefs == 0) free(this); }




  void Validate(bool b) { nRefs = (b ? 1 : 0); }
  bool IsValid() const { return (nRefs != 0); }
};

class wxStringBase
{

friend class wxArrayString;

public :

  static const size_t npos;
protected:

  wxChar *m_pchData;


  wxStringData* GetStringData() const { return (wxStringData*)m_pchData - 1; }




  void Init() { m_pchData = (wxChar *)wxEmptyString; }

  void InitWith(const wxChar *psz, size_t nPos = 0, size_t nLen = npos);

  void Reinit() { GetStringData()->Unlock(); Init(); }



  bool AllocBuffer(size_t nLen);

  bool AllocCopy(wxString&, int, int) const;

  bool AssignCopy(size_t, const wxChar *);


  bool ConcatSelf(size_t nLen, const wxChar *src, size_t nMaxLen);
  bool ConcatSelf(size_t nLen, const wxChar *src)
    { return ConcatSelf(nLen, src, nLen); }



  bool CopyBeforeWrite();
  bool AllocBeforeWrite(size_t);


  bool Alloc(size_t nLen);
public:

  typedef wxChar value_type;
  typedef wxChar char_type;
  typedef size_t size_type;
  typedef value_type& reference;
  typedef const value_type& const_reference;
  typedef value_type* pointer;
  typedef const value_type* const_pointer;
  typedef value_type *iterator;
  typedef const value_type *const_iterator;
# 336 "/usr/include/wx-2.8/wx/string.h"
  class const_reverse_iterator { public: typedef wxChar value_type; typedef const value_type& reference; typedef const value_type *pointer; typedef const value_type *iterator_type; const_reverse_iterator(iterator_type i) : m_cur(i) { } const_reverse_iterator(const const_reverse_iterator& ri) : m_cur(ri.m_cur) { } iterator_type base() const { return m_cur; } reference operator*() const { return *(m_cur - 1); } const_reverse_iterator& operator++() { --m_cur; return *this; } const_reverse_iterator operator++(int) { const_reverse_iterator tmp = *this; --m_cur; return tmp; } const_reverse_iterator& operator--() { ++m_cur; return *this; } const_reverse_iterator operator--(int) { const_reverse_iterator tmp = *this; ++m_cur; return tmp; } bool operator==(const_reverse_iterator ri) const { return m_cur == ri.m_cur; } bool operator!=(const_reverse_iterator ri) const { return !(*this == ri); } private: iterator_type m_cur; };


  class reverse_iterator { public: typedef wxChar value_type; typedef value_type& reference; typedef value_type *pointer; typedef value_type *iterator_type; reverse_iterator(iterator_type i) : m_cur(i) { } reverse_iterator(const reverse_iterator& ri) : m_cur(ri.m_cur) { } iterator_type base() const { return m_cur; } reference operator*() const { return *(m_cur - 1); } reverse_iterator& operator++() { --m_cur; return *this; } reverse_iterator operator++(int) { reverse_iterator tmp = *this; --m_cur; return tmp; } reverse_iterator& operator--() { ++m_cur; return *this; } reverse_iterator operator--(int) { reverse_iterator tmp = *this; ++m_cur; return tmp; } bool operator==(reverse_iterator ri) const { return m_cur == ri.m_cur; } bool operator!=(reverse_iterator ri) const { return !(*this == ri); } private: iterator_type m_cur; };







  wxStringBase() { Init(); }

  wxStringBase(const wxStringBase& stringSrc)
  {
    ;


    if ( stringSrc.empty() ) {

      Init();
    }
    else {
      m_pchData = stringSrc.m_pchData;
      GetStringData()->Lock();
    }
  }

  wxStringBase(size_type nRepeat, wxChar ch);


  wxStringBase(const wxChar *psz)
      { InitWith(psz, 0, npos); }
  wxStringBase(const wxChar *psz, size_t nLength)
      { InitWith(psz, 0, nLength); }
  wxStringBase(const wxChar *psz,
               const wxMBConv& ,
               size_t nLength = npos)
      { InitWith(psz, 0, nLength); }

  wxStringBase(const wxStringBase& str, size_t nPos, size_t nLen)
  {
    ;

    Init();
    size_t strLen = str.length() - nPos; nLen = strLen < nLen ? strLen : nLen;
    InitWith(str.c_str(), nPos, nLen);
  }

  wxStringBase(const void *pStart, const void *pEnd);


  ~wxStringBase()
  {






      GetStringData()->Unlock();
  }







  wxStringBase& operator=(const wxStringBase& stringSrc);

  wxStringBase& operator=(wxChar ch);

  wxStringBase& operator=(const wxChar *psz);


  size_type length() const { return GetStringData()->nDataLength; }

  size_type size() const { return length(); }

  size_type max_size() const { return npos; }

  void resize(size_t nSize, wxChar ch = L'\0');

  void clear() { erase(0, npos); }

  bool empty() const { return length() == 0; }

  void reserve(size_t sz) { Alloc(sz); }
  size_type capacity() const { return GetStringData()->nAllocLength; }



  value_type at(size_type n) const
    { ; return m_pchData[n]; }

  reference at(size_type n)
    { ; CopyBeforeWrite(); return m_pchData[n]; }



  wxStringBase& append(const wxStringBase& str, size_t pos, size_t n)
  {
    ;
    ConcatSelf(n, str.c_str() + pos, str.length() - pos);
    return *this;
  }

  wxStringBase& append(const wxStringBase& str)
    { ConcatSelf(str.length(), str.c_str()); return *this; }

  wxStringBase& append(const wxChar *sz)
    { ConcatSelf(wxStrlen(sz), sz); return *this; }
  wxStringBase& append(const wxChar *sz, size_t n)
    { ConcatSelf(n, sz); return *this; }

  wxStringBase& append(size_t n, wxChar ch);

  wxStringBase& append(const_iterator first, const_iterator last)
    { ConcatSelf(last - first, first); return *this; }


  wxStringBase& assign(const wxStringBase& str)
    { return *this = str; }

  wxStringBase& assign(const wxStringBase& str, size_t pos, size_t n)
    { clear(); return append(str, pos, n); }

  wxStringBase& assign(const wxChar *sz)
    { clear(); return append(sz, wxStrlen(sz)); }
  wxStringBase& assign(const wxChar *sz, size_t n)
    { clear(); return append(sz, n); }

  wxStringBase& assign(size_t n, wxChar ch)
    { clear(); return append(n, ch); }

  wxStringBase& assign(const_iterator first, const_iterator last)
    { clear(); return append(first, last); }


  const_iterator begin() const { return m_pchData; }
  iterator begin();

  const_iterator end() const { return m_pchData + length(); }
  iterator end();


  const_reverse_iterator rbegin() const { return const_reverse_iterator(end()); }
  reverse_iterator rbegin() { return reverse_iterator(end()); }

  const_reverse_iterator rend() const { return const_reverse_iterator(begin()); }
  reverse_iterator rend() { return reverse_iterator(begin()); }


  wxStringBase& insert(size_t nPos, const wxStringBase& str)
  {
    ;
    return insert(nPos, str.c_str(), str.length());
  }

  wxStringBase& insert(size_t nPos, const wxStringBase& str, size_t nStart, size_t n)
  {
    ;
    ;
    size_t strLen = str.length() - nStart;
    n = strLen < n ? strLen : n;
    return insert(nPos, str.c_str() + nStart, n);
  }

  wxStringBase& insert(size_t nPos, const wxChar *sz, size_t n = npos);

  wxStringBase& insert(size_t nPos, size_t n, wxChar ch)
    { return insert(nPos, wxStringBase(n, ch)); }
  iterator insert(iterator it, wxChar ch)
    { size_t idx = it - begin(); insert(idx, 1, ch); return begin() + idx; }
  void insert(iterator it, const_iterator first, const_iterator last)
    { insert(it - begin(), first, last - first); }
  void insert(iterator it, size_type n, wxChar ch)
    { insert(it - begin(), n, ch); }


  wxStringBase& erase(size_type pos = 0, size_type n = npos);
  iterator erase(iterator first, iterator last)
  {
    size_t idx = first - begin();
    erase(idx, last - first);
    return begin() + idx;
  }
  iterator erase(iterator first);


  const wxChar* c_str() const { return m_pchData; }
  const wxChar* data() const { return m_pchData; }


  wxStringBase& replace(size_t nStart, size_t nLen, const wxChar* sz);

  wxStringBase& replace(size_t nStart, size_t nLen, const wxStringBase& str)
    { return replace(nStart, nLen, str.c_str()); }

  wxStringBase& replace(size_t nStart, size_t nLen, size_t nCount, wxChar ch);

  wxStringBase& replace(size_t nStart, size_t nLen,
                        const wxStringBase& str, size_t nStart2, size_t nLen2);

  wxStringBase& replace(size_t nStart, size_t nLen,
                        const wxChar* sz, size_t nCount);
  wxStringBase& replace(iterator first, iterator last, const_pointer s)
    { return replace(first - begin(), last - first, s); }
  wxStringBase& replace(iterator first, iterator last, const_pointer s,
                        size_type n)
    { return replace(first - begin(), last - first, s, n); }
  wxStringBase& replace(iterator first, iterator last, const wxStringBase& s)
    { return replace(first - begin(), last - first, s); }
  wxStringBase& replace(iterator first, iterator last, size_type n, wxChar c)
    { return replace(first - begin(), last - first, n, c); }
  wxStringBase& replace(iterator first, iterator last,
                        const_iterator first1, const_iterator last1)
    { return replace(first - begin(), last - first, first1, last1 - first1); }


  void swap(wxStringBase& str);






  size_t find(const wxStringBase& str, size_t nStart = 0) const;


  size_t find(const wxChar* sz, size_t nStart = 0, size_t n = npos) const;


  size_t find(wxChar ch, size_t nStart = 0) const;




  size_t rfind(const wxStringBase& str, size_t nStart = npos) const;


  size_t rfind(const wxChar* sz, size_t nStart = npos,
               size_t n = npos) const;

  size_t rfind(wxChar ch, size_t nStart = npos) const;




  size_t find_first_of(const wxStringBase& str, size_t nStart = 0) const
    { return find_first_of(str.c_str(), nStart); }

  size_t find_first_of(const wxChar* sz, size_t nStart = 0) const;
  size_t find_first_of(const wxChar* sz, size_t nStart, size_t n) const;

  size_t find_first_of(wxChar c, size_t nStart = 0) const
    { return find(c, nStart); }

  size_t find_last_of (const wxStringBase& str, size_t nStart = npos) const
    { return find_last_of(str.c_str(), nStart); }

  size_t find_last_of (const wxChar* sz, size_t nStart = npos) const;
  size_t find_last_of(const wxChar* sz, size_t nStart, size_t n) const;

  size_t find_last_of(wxChar c, size_t nStart = npos) const
    { return rfind(c, nStart); }




  size_t find_first_not_of(const wxStringBase& str, size_t nStart = 0) const
    { return find_first_not_of(str.c_str(), nStart); }

  size_t find_first_not_of(const wxChar* sz, size_t nStart = 0) const;
  size_t find_first_not_of(const wxChar* sz, size_t nStart, size_t n) const;

  size_t find_first_not_of(wxChar ch, size_t nStart = 0) const;

  size_t find_last_not_of(const wxStringBase& str, size_t nStart = npos) const
    { return find_last_not_of(str.c_str(), nStart); }

  size_t find_last_not_of(const wxChar* sz, size_t nStart = npos) const;
  size_t find_last_not_of(const wxChar* sz, size_t nStart, size_t n) const;

  size_t find_last_not_of(wxChar ch, size_t nStart = npos) const;





  int compare(const wxStringBase& str) const;

  int compare(size_t nStart, size_t nLen, const wxStringBase& str) const;

  int compare(size_t nStart, size_t nLen,
              const wxStringBase& str, size_t nStart2, size_t nLen2) const;

  int compare(const wxChar* sz) const;

  int compare(size_t nStart, size_t nLen,
              const wxChar* sz, size_t nCount = npos) const;

  size_type copy(wxChar* s, size_type n, size_type pos = 0);


  wxStringBase substr(size_t nStart = 0, size_t nLen = npos) const;


  wxStringBase& operator+=(const wxStringBase& s) { return append(s); }

  wxStringBase& operator+=(const wxChar *psz) { return append(psz); }

  wxStringBase& operator+=(wxChar ch) { return append(1, ch); }
};
# 659 "/usr/include/wx-2.8/wx/string.h"
class wxString : public wxStringBase
{

friend class wxArrayString;





private:







  wxString& operator=(int);





  wxString(int);

public:


  wxString() : wxStringBase() { }

  wxString(const wxStringBase& stringSrc) : wxStringBase(stringSrc) { }
  wxString(const wxString& stringSrc) : wxStringBase(stringSrc) { }

  wxString(wxChar ch, size_t nRepeat = 1)
      : wxStringBase(nRepeat, ch) { }
  wxString(size_t nRepeat, wxChar ch)
      : wxStringBase(nRepeat, ch) { }


  wxString(const wxChar *psz)
      : wxStringBase(psz ? psz : L"") { }
  wxString(const wxChar *psz, size_t nLength)
      : wxStringBase(psz, nLength) { }
  wxString(const wxChar *psz,
           const wxMBConv& ,
           size_t nLength = npos)
      : wxStringBase(psz, nLength == npos ? wxStrlen(psz) : nLength) { }
# 714 "/usr/include/wx-2.8/wx/string.h"
  wxString(const wxStdString& s)
      : wxStringBase(s.c_str()) { }




  wxString(const char *psz, const wxMBConv& conv, size_t nLength = npos);

  wxString(const wxWCharBuffer& psz) : wxStringBase(psz.data()) { }
# 745 "/usr/include/wx-2.8/wx/string.h"
  size_t Len() const { return length(); }

  bool IsEmpty() const { return empty(); }

  bool operator!() const { return empty(); }

  wxString& Truncate(size_t uiLen);

  void Empty()
  {
    Truncate(0);

    ;
  }

  void Clear()
  {
    wxString tmp(wxEmptyString);
    swap(tmp);
  }



  bool IsAscii() const;

  bool IsNumber() const;

  bool IsWord() const;



    wxChar GetChar(size_t n) const
      { return at(n); }

    wxChar& GetWritableChar(size_t n)
      { return at(n); }

    void SetChar(size_t n, wxChar ch)
      { at(n) = ch; }


    wxChar Last() const
      {
          ;

          return at(length() - 1);
      }


    wxChar& Last()
      {
          ;
          return at(length() - 1);
      }
# 822 "/usr/include/wx-2.8/wx/string.h"
    wxChar& operator[](int n)
      { return wxStringBase::at(n); }
    wxChar& operator[](size_type n)
      { return wxStringBase::at(n); }






    operator const wxChar*() const { return c_str(); }


    const wxChar* wx_str() const { return c_str(); }

    const wxChar* GetData() const { return c_str(); }





    wxWritableCharBuffer char_str(const wxMBConv& conv = wxConvLibc) const
      { return mb_str(conv); }

    wxWritableWCharBuffer wchar_str() const { return wc_str(wxConvLibc); }
# 857 "/usr/include/wx-2.8/wx/string.h"
    static wxString FromAscii(const char *ascii);
    static wxString FromAscii(const char ascii);
    const wxCharBuffer ToAscii() const;
# 869 "/usr/include/wx-2.8/wx/string.h"
    static wxString FromUTF8(const char *utf8)
      { return wxString(utf8, wxConvUTF8); }
    static wxString FromUTF8(const char *utf8, size_t len)
      { return wxString(utf8, wxConvUTF8, len); }
    const wxCharBuffer utf8_str() const { return mb_str(wxConvUTF8); }
    const wxCharBuffer ToUTF8() const { return utf8_str(); }
# 893 "/usr/include/wx-2.8/wx/string.h"
    static wxString From8BitData(const char *data, size_t len)
      { return wxString(data, wxConvISO8859_1, len); }

    static wxString From8BitData(const char *data)
      { return wxString(data, wxConvISO8859_1); }
    const wxCharBuffer To8BitData() const { return mb_str(wxConvISO8859_1); }
# 919 "/usr/include/wx-2.8/wx/string.h"
    const wxCharBuffer mb_str(const wxMBConv& conv = wxConvLibc) const;

    const wxCharBuffer mbc_str() const { return mb_str(*wxConvCurrent); }

    const wxChar* wc_str() const { return c_str(); }


    const wxChar* wc_str(const wxMBConv& ) const { return c_str(); }


    const wxCharBuffer fn_str() const { return mb_str((*wxConvFileName)); }
# 953 "/usr/include/wx-2.8/wx/string.h"
  wxString& operator=(const wxStringBase& stringSrc)
    { return (wxString&)wxStringBase::operator=(stringSrc); }

  wxString& operator=(wxChar ch)
    { return (wxString&)wxStringBase::operator=(ch); }






  wxString& operator=(const wxChar *psz)
    { return (wxString&)wxStringBase::operator=(psz); }




  wxString& operator=(const wxWCharBuffer& psz)
    { (void) operator=((const wchar_t *)psz); return *this; }
# 992 "/usr/include/wx-2.8/wx/string.h"
  wxString& operator<<(const wxString& s)
  {

    ;



    append(s);
    return *this;
  }

  wxString& operator<<(const wxChar *psz)
    { append(psz); return *this; }

  wxString& operator<<(wxChar ch) { append(1, ch); return *this; }



  wxString& operator<<(const wxWCharBuffer& s)
    { (void)operator<<((const wchar_t *)s); return *this; }
  void operator+=(const wxWCharBuffer& s)
    { (void)operator<<((const wchar_t *)s); }
# 1022 "/usr/include/wx-2.8/wx/string.h"
  wxString& Append(const wxString& s)
    {

        if ( empty() )
            *this = s;
        else
            append(s);
        return *this;
    }
  wxString& Append(const wxChar* psz)
    { append(psz); return *this; }

  wxString& Append(wxChar ch, size_t count = 1u)
    { append(count, ch); return *this; }
  wxString& Append(const wxChar* psz, size_t nLen)
    { append(psz, nLen); return *this; }


  wxString& Prepend(const wxString& str)
    { *this = str + *this; return *this; }



  friend wxString operator+(const wxString& string1,
                                             const wxString& string2);

  friend wxString operator+(const wxString& string, wxChar ch);

  friend wxString operator+(wxChar ch, const wxString& string);

  friend wxString operator+(const wxString& string,
                                             const wxChar *psz);

  friend wxString operator+(const wxChar *psz,
                                             const wxString& string);



  wxString& operator<<(int i)
    { return (*this) << Format(L"%d", i); }

  wxString& operator<<(unsigned int ui)
    { return (*this) << Format(L"%u", ui); }

  wxString& operator<<(long l)
    { return (*this) << Format(L"%ld", l); }

  wxString& operator<<(unsigned long ul)
    { return (*this) << Format(L"%lu", ul); }


  wxString& operator<<(long long ll)
    {
      const wxChar *fmt = L"%" L"ll" L"d";
      return (*this) << Format(fmt, ll);
    }

  wxString& operator<<(unsigned long long ull)
    {
      const wxChar *fmt = L"%" L"ll" L"u";
      return (*this) << Format(fmt , ull);
    }


  wxString& operator<<(float f)
    { return (*this) << Format(L"%f", f); }

  wxString& operator<<(double d)
    { return (*this) << Format(L"%g", d); }



  int Cmp(const wxChar *psz) const;
  int Cmp(const wxString& s) const;

  int CmpNoCase(const wxChar *psz) const;
  int CmpNoCase(const wxString& s) const;


  bool IsSameAs(const wxChar *psz, bool compareWithCase = true) const
    { return (compareWithCase ? Cmp(psz) : CmpNoCase(psz)) == 0; }

  bool IsSameAs(wxChar c, bool compareWithCase = true) const
    {
      return (length() == 1) && (compareWithCase ? GetChar(0u) == c
                              : towupper(GetChar(0u)) == towupper(c));
    }




  wxString Mid(size_t nFirst, size_t nCount = npos) const;


  wxString operator()(size_t start, size_t len) const
    { return Mid(start, len); }




  bool StartsWith(const wxChar *prefix, wxString *rest = __null) const;



  bool EndsWith(const wxChar *suffix, wxString *rest = __null) const;


  wxString Left(size_t nCount) const;

  wxString Right(size_t nCount) const;


  wxString BeforeFirst(wxChar ch) const;


  wxString BeforeLast(wxChar ch) const;


  wxString AfterFirst(wxChar ch) const;


  wxString AfterLast(wxChar ch) const;


  wxString Before(wxChar ch) const { return BeforeLast(ch); }
  wxString After(wxChar ch) const { return AfterFirst(ch); }



  wxString& MakeUpper();


  wxString Upper() const ;

  wxString& MakeLower();

  wxString Lower() const ;



  wxString& Trim(bool bFromRight = true);

  wxString& Pad(size_t nCount, wxChar chPad = L' ', bool bFromRight = true);



  int Find(wxChar ch, bool bFromEnd = false) const;

  int Find(const wxChar *pszSub) const;


  size_t Replace(const wxChar *szOld,
                 const wxChar *szNew,
                 bool bReplaceAll = true);


  bool Matches(const wxChar *szMask) const;







    bool ToLong(long *val, int base = 10) const;

    bool ToULong(unsigned long *val, int base = 10) const;


    bool ToLongLong(long long *val, int base = 10) const;

    bool ToULongLong(unsigned long long *val, int base = 10) const;


    bool ToDouble(double *val) const;






  int Printf(const wxChar *pszFormat, ...) ;

  int PrintfV(const wxChar* pszFormat, va_list argptr);


  static wxString Format(const wxChar *pszFormat, ...) ;

  static wxString FormatV(const wxChar *pszFormat, va_list argptr);




  bool Alloc(size_t nLen) { reserve(nLen); return true; }


  bool Shrink();



  wxChar *GetWriteBuf(size_t nLen);

  void UngetWriteBuf();
  void UngetWriteBuf(size_t nLen);





  wxString SubString(size_t from, size_t to) const
      { return Mid(from, (to - from + 1)); }

  enum caseCompare {exact, ignoreCase};

  enum stripType {leading = 0x1, trailing = 0x2, both = 0x3};



  int sprintf(const wxChar *pszFormat, ...) ;


  inline int CompareTo(const wxChar* psz, caseCompare cmp = exact) const
    { return cmp == exact ? Cmp(psz) : CmpNoCase(psz); }


  size_t Length() const { return length(); }

  int Freq(wxChar ch) const;

  void LowerCase() { MakeLower(); }

  void UpperCase() { MakeUpper(); }

  wxString Strip(stripType w = trailing) const;


  size_t Index(const wxChar* psz) const { return Find(psz); }
  size_t Index(wxChar ch) const { return Find(ch); }

  wxString& Remove(size_t pos) { return Truncate(pos); }
  wxString& RemoveLast(size_t n = 1) { return Truncate(length() - n); }

  wxString& Remove(size_t nStart, size_t nLen)
      { return (wxString&)erase( nStart, nLen ); }


  int First( const wxChar ch ) const { return Find(ch); }
  int First( const wxChar* psz ) const { return Find(psz); }
  int First( const wxString &str ) const { return Find(str); }
  int Last( const wxChar ch ) const { return Find(ch, true); }
  bool Contains(const wxString& str) const { return Find(str) != (-1); }


  bool IsNull() const { return empty(); }




  wxString(const wxString& str, size_t nPos, size_t nLen)
      : wxStringBase(str, nPos, nLen) { }

  wxString(const void *pStart, const void *pEnd)
      : wxStringBase((const wxChar*)pStart, (const wxChar*)pEnd) { }







  wxString& append(const wxString& str, size_t pos, size_t n)
    { return (wxString&)wxStringBase::append(str, pos, n); }

  wxString& append(const wxString& str)
    { return (wxString&)wxStringBase::append(str); }

  wxString& append(const wxChar *sz)
    { return (wxString&)wxStringBase::append(sz); }
  wxString& append(const wxChar *sz, size_t n)
    { return (wxString&)wxStringBase::append(sz, n); }

  wxString& append(size_t n, wxChar ch)
    { return (wxString&)wxStringBase::append(n, ch); }

  wxString& append(const_iterator first, const_iterator last)
    { return (wxString&)wxStringBase::append(first, last); }


  wxString& assign(const wxString& str)
    { return (wxString&)wxStringBase::assign(str); }

  wxString& assign(const wxString& str, size_t pos, size_t n)
    { return (wxString&)wxStringBase::assign(str, pos, n); }

  wxString& assign(const wxChar *sz)
    { return (wxString&)wxStringBase::assign(sz); }
  wxString& assign(const wxChar *sz, size_t n)
    { return (wxString&)wxStringBase::assign(sz, n); }

  wxString& assign(size_t n, wxChar ch)
    { return (wxString&)wxStringBase::assign(n, ch); }

  wxString& assign(const_iterator first, const_iterator last)
    { return (wxString&)wxStringBase::assign(first, last); }
# 1343 "/usr/include/wx-2.8/wx/string.h"
  wxString& insert(size_t nPos, const wxString& str)
    { return (wxString&)wxStringBase::insert(nPos, str); }

  wxString& insert(size_t nPos, const wxString& str, size_t nStart, size_t n)
    { return (wxString&)wxStringBase::insert(nPos, str, nStart, n); }

  wxString& insert(size_t nPos, const wxChar *sz)
    { return (wxString&)wxStringBase::insert(nPos, sz); }
  wxString& insert(size_t nPos, const wxChar *sz, size_t n)
    { return (wxString&)wxStringBase::insert(nPos, sz, n); }

  wxString& insert(size_t nPos, size_t n, wxChar ch)
    { return (wxString&)wxStringBase::insert(nPos, n, ch); }
  iterator insert(iterator it, wxChar ch)
    { return wxStringBase::insert(it, ch); }
  void insert(iterator it, const_iterator first, const_iterator last)
    { wxStringBase::insert(it, first, last); }
  void insert(iterator it, size_type n, wxChar ch)
    { wxStringBase::insert(it, n, ch); }


  wxString& erase(size_type pos = 0, size_type n = npos)
    { return (wxString&)wxStringBase::erase(pos, n); }
  iterator erase(iterator first, iterator last)
    { return wxStringBase::erase(first, last); }
  iterator erase(iterator first)
    { return wxStringBase::erase(first); }






  wxString& replace(size_t nStart, size_t nLen, const wxChar* sz)
    { return (wxString&)wxStringBase::replace(nStart, nLen, sz); }

  wxString& replace(size_t nStart, size_t nLen, const wxString& str)
    { return (wxString&)wxStringBase::replace(nStart, nLen, str); }

  wxString& replace(size_t nStart, size_t nLen, size_t nCount, wxChar ch)
    { return (wxString&)wxStringBase::replace(nStart, nLen, nCount, ch); }

  wxString& replace(size_t nStart, size_t nLen,
                    const wxString& str, size_t nStart2, size_t nLen2)
    { return (wxString&)wxStringBase::replace(nStart, nLen, str,
                                              nStart2, nLen2); }

  wxString& replace(size_t nStart, size_t nLen,
                    const wxChar* sz, size_t nCount)
    { return (wxString&)wxStringBase::replace(nStart, nLen, sz, nCount); }
  wxString& replace(iterator first, iterator last, const_pointer s)
    { return (wxString&)wxStringBase::replace(first, last, s); }
  wxString& replace(iterator first, iterator last, const_pointer s,
                    size_type n)
    { return (wxString&)wxStringBase::replace(first, last, s, n); }
  wxString& replace(iterator first, iterator last, const wxString& s)
    { return (wxString&)wxStringBase::replace(first, last, s); }
  wxString& replace(iterator first, iterator last, size_type n, wxChar c)
    { return (wxString&)wxStringBase::replace(first, last, n, c); }
  wxString& replace(iterator first, iterator last,
                    const_iterator first1, const_iterator last1)
    { return (wxString&)wxStringBase::replace(first, last, first1, last1); }


  wxString& operator+=(const wxString& s)
    { return (wxString&)wxStringBase::operator+=(s); }

  wxString& operator+=(const wxChar *psz)
    { return (wxString&)wxStringBase::operator+=(psz); }

  wxString& operator+=(wxChar ch)
    { return (wxString&)wxStringBase::operator+=(ch); }
};





wxString operator+(const wxString& string1, const wxString& string2);
wxString operator+(const wxString& string, wxChar ch);
wxString operator+(wxChar ch, const wxString& string);
wxString operator+(const wxString& string, const wxChar *psz);
wxString operator+(const wxChar *psz, const wxString& string);
# 1438 "/usr/include/wx-2.8/wx/string.h"
    inline const wxString& wxGetEmptyString()
    {
        return *(wxString *)&wxEmptyString;
    }
# 1503 "/usr/include/wx-2.8/wx/string.h"
class wxStringBuffer
{
public:
    wxStringBuffer(wxString& str, size_t lenWanted = 1024)
        : m_str(str), m_buf(__null)
        { m_buf = m_str.GetWriteBuf(lenWanted); }

    ~wxStringBuffer() { m_str.UngetWriteBuf(); }

    operator wxChar*() const { return m_buf; }

private:
    wxString& m_str;
    wxChar *m_buf;

    private: wxStringBuffer(const wxStringBuffer&); wxStringBuffer& operator=(const wxStringBuffer&);
};

class wxStringBufferLength
{
public:
    wxStringBufferLength(wxString& str, size_t lenWanted = 1024)
        : m_str(str), m_buf(__null), m_len(0), m_lenSet(false)
    {
        m_buf = m_str.GetWriteBuf(lenWanted);
        ;
    }

    ~wxStringBufferLength()
    {
        ;
        m_str.UngetWriteBuf(m_len);
    }

    operator wxChar*() const { return m_buf; }
    void SetLength(size_t length) { m_len = length; m_lenSet = true; }

private:
    wxString& m_str;
    wxChar *m_buf;
    size_t m_len;
    bool m_lenSet;

    private: wxStringBufferLength(const wxStringBufferLength&); wxStringBufferLength& operator=(const wxStringBufferLength&);
};
# 1560 "/usr/include/wx-2.8/wx/string.h"
inline bool operator==(const wxString& s1, const wxString& s2)
    { return (s1.Len() == s2.Len()) && (s1.Cmp(s2) == 0); }
inline bool operator==(const wxString& s1, const wxChar * s2)
    { return s1.Cmp(s2) == 0; }
inline bool operator==(const wxChar * s1, const wxString& s2)
    { return s2.Cmp(s1) == 0; }
inline bool operator!=(const wxString& s1, const wxString& s2)
    { return (s1.Len() != s2.Len()) || (s1.Cmp(s2) != 0); }
inline bool operator!=(const wxString& s1, const wxChar * s2)
    { return s1.Cmp(s2) != 0; }
inline bool operator!=(const wxChar * s1, const wxString& s2)
    { return s2.Cmp(s1) != 0; }
inline bool operator< (const wxString& s1, const wxString& s2)
    { return s1.Cmp(s2) < 0; }
inline bool operator< (const wxString& s1, const wxChar * s2)
    { return s1.Cmp(s2) < 0; }
inline bool operator< (const wxChar * s1, const wxString& s2)
    { return s2.Cmp(s1) > 0; }
inline bool operator> (const wxString& s1, const wxString& s2)
    { return s1.Cmp(s2) > 0; }
inline bool operator> (const wxString& s1, const wxChar * s2)
    { return s1.Cmp(s2) > 0; }
inline bool operator> (const wxChar * s1, const wxString& s2)
    { return s2.Cmp(s1) < 0; }
inline bool operator<=(const wxString& s1, const wxString& s2)
    { return s1.Cmp(s2) <= 0; }
inline bool operator<=(const wxString& s1, const wxChar * s2)
    { return s1.Cmp(s2) <= 0; }
inline bool operator<=(const wxChar * s1, const wxString& s2)
    { return s2.Cmp(s1) >= 0; }
inline bool operator>=(const wxString& s1, const wxString& s2)
    { return s1.Cmp(s2) >= 0; }
inline bool operator>=(const wxString& s1, const wxChar * s2)
    { return s1.Cmp(s2) >= 0; }
inline bool operator>=(const wxChar * s1, const wxString& s2)
    { return s2.Cmp(s1) <= 0; }


inline bool operator==(const wxString& s1, const wxWCharBuffer& s2)
    { return (s1.Cmp((const wchar_t *)s2) == 0); }
inline bool operator==(const wxWCharBuffer& s1, const wxString& s2)
    { return (s2.Cmp((const wchar_t *)s1) == 0); }
inline bool operator!=(const wxString& s1, const wxWCharBuffer& s2)
    { return (s1.Cmp((const wchar_t *)s2) != 0); }
inline bool operator!=(const wxWCharBuffer& s1, const wxString& s2)
    { return (s2.Cmp((const wchar_t *)s1) != 0); }
# 1618 "/usr/include/wx-2.8/wx/string.h"
inline wxString operator+(const wxString& string, const wxWCharBuffer& buf)
    { return string + (const wchar_t *)buf; }
inline wxString operator+(const wxWCharBuffer& buf, const wxString& string)
    { return (const wchar_t *)buf + string; }
# 1633 "/usr/include/wx-2.8/wx/string.h"
inline bool operator==(wxChar c, const wxString& s) { return s.IsSameAs(c); }
inline bool operator==(const wxString& s, wxChar c) { return s.IsSameAs(c); }
inline bool operator!=(wxChar c, const wxString& s) { return !s.IsSameAs(c); }
inline bool operator!=(const wxString& s, wxChar c) { return !s.IsSameAs(c); }
# 1647 "/usr/include/wx-2.8/wx/string.h"
# 1 "/usr/include/wx-2.8/wx/iosfwrap.h" 1
# 1648 "/usr/include/wx-2.8/wx/string.h" 2

 std:: ostream& operator<<(std:: ostream&, const wxString&);
# 17 "/usr/include/wx-2.8/wx/memory.h" 2
# 1 "/usr/include/wx-2.8/wx/msgout.h" 1
# 27 "/usr/include/wx-2.8/wx/msgout.h"
class wxMessageOutput
{
public:
    virtual ~wxMessageOutput() { }


    virtual void Printf(const wxChar* format, ...) = 0;



    static wxMessageOutput* Get();


    static wxMessageOutput* Set(wxMessageOutput* msgout);

private:
    static wxMessageOutput* ms_msgOut;
};







class wxMessageOutputBest : public wxMessageOutput
{
public:
    wxMessageOutputBest() { }

    virtual void Printf(const wxChar* format, ...) ;
};





class wxMessageOutputStderr : public wxMessageOutput
{
public:
    wxMessageOutputStderr() { }

    virtual void Printf(const wxChar* format, ...) ;
};







class wxMessageOutputMessageBox : public wxMessageOutput
{
public:
    wxMessageOutputMessageBox() { }

    virtual void Printf(const wxChar* format, ...) ;
};







class wxMessageOutputDebug : public wxMessageOutput
{
public:
    wxMessageOutputDebug() { }

    virtual void Printf(const wxChar* format, ...) ;
};





class wxMessageOutputLog : public wxMessageOutput
{
public:
    wxMessageOutputLog() { }

    virtual void Printf(const wxChar* format, ...) ;
};
# 18 "/usr/include/wx-2.8/wx/memory.h" 2
# 21 "/usr/include/wx-2.8/wx/object.h" 2

class wxObject;
# 36 "/usr/include/wx-2.8/wx/object.h"
class wxClassInfo;
class wxHashTable;
class wxObjectRefData;





typedef wxObject *(*wxObjectConstructorFn)(void);

class wxClassInfo
{
public:
    wxClassInfo( const wxChar *className,
                 const wxClassInfo *baseInfo1,
                 const wxClassInfo *baseInfo2,
                 int size,
                 wxObjectConstructorFn ctor )
        : m_className(className)
        , m_objectSize(size)
        , m_objectConstructor(ctor)
        , m_baseInfo1(baseInfo1)
        , m_baseInfo2(baseInfo2)
        , m_next(sm_first)
        {
            sm_first = this;
            Register();
        }

    ~wxClassInfo();

    wxObject *CreateObject() const
        { return m_objectConstructor ? (*m_objectConstructor)() : 0; }
    bool IsDynamic() const { return (__null != m_objectConstructor); }

    const wxChar *GetClassName() const { return m_className; }
    const wxChar *GetBaseClassName1() const
        { return m_baseInfo1 ? m_baseInfo1->GetClassName() : __null; }
    const wxChar *GetBaseClassName2() const
        { return m_baseInfo2 ? m_baseInfo2->GetClassName() : __null; }
    const wxClassInfo *GetBaseClass1() const { return m_baseInfo1; }
    const wxClassInfo *GetBaseClass2() const { return m_baseInfo2; }
    int GetSize() const { return m_objectSize; }

    wxObjectConstructorFn GetConstructor() const
        { return m_objectConstructor; }
    static const wxClassInfo *GetFirst() { return sm_first; }
    const wxClassInfo *GetNext() const { return m_next; }
    static wxClassInfo *FindClass(const wxChar *className);




    bool IsKindOf(const wxClassInfo *info) const
    {
        return info != 0 &&
               ( info == this ||
                 ( m_baseInfo1 && m_baseInfo1->IsKindOf(info) ) ||
                 ( m_baseInfo2 && m_baseInfo2->IsKindOf(info) ) );
    }
# 104 "/usr/include/wx-2.8/wx/object.h"
public:
    const wxChar *m_className;
    int m_objectSize;
    wxObjectConstructorFn m_objectConstructor;



    const wxClassInfo *m_baseInfo1;
    const wxClassInfo *m_baseInfo2;




    static wxClassInfo *sm_first;
    wxClassInfo *m_next;



    static wxHashTable *sm_classTable;

private:

    static wxClassInfo *GetBaseByName(const wxChar *name);

    private: wxClassInfo(const wxClassInfo&); wxClassInfo& operator=(const wxClassInfo&);

protected:

    void Register();
    void Unregister();
};

 wxObject *wxCreateDynamicObject(const wxChar *name);
# 389 "/usr/include/wx-2.8/wx/object.h"
class wxObjectRefData
{
    friend class wxObject;

public:
    wxObjectRefData() : m_count(1) { }
    virtual ~wxObjectRefData() { }

    int GetRefCount() const { return m_count; }

private:
    int m_count;
};





class wxObject
{
    public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const;

public:
    wxObject() { m_refData = __null; }
    virtual ~wxObject() { UnRef(); }

    wxObject(const wxObject& other)
    {
         m_refData = other.m_refData;
         if (m_refData)
             m_refData->m_count++;
    }

    wxObject& operator=(const wxObject& other)
    {
        if ( this != &other )
        {
            Ref(other);
        }
        return *this;
    }

    bool IsKindOf(wxClassInfo *info) const;
# 467 "/usr/include/wx-2.8/wx/object.h"
    wxObjectRefData *GetRefData() const { return m_refData; }
    void SetRefData(wxObjectRefData *data) { m_refData = data; }


    void Ref(const wxObject& clone);


    void UnRef();


    void UnShare() { AllocExclusive(); }


    bool IsSameAs(const wxObject& o) const { return m_refData == o.m_refData; }

protected:



    void AllocExclusive();





    virtual wxObjectRefData *CreateRefData() const;


    virtual wxObjectRefData *CloneRefData(const wxObjectRefData *data) const;

    wxObjectRefData *m_refData;
};

inline wxObject *wxCheckDynamicCast(wxObject *obj, wxClassInfo *classInfo)
{
    return obj && obj->GetClassInfo()->IsKindOf(classInfo) ? obj : __null;
}
# 17 "/usr/include/wx-2.8/wx/wx.h" 2
# 1 "/usr/include/wx-2.8/wx/dynarray.h" 1
# 67 "/usr/include/wx-2.8/wx/dynarray.h"
extern "C"
{
typedef int ( *CMPFUNC)(const void* pItem1, const void* pItem2);
}
# 809 "/usr/include/wx-2.8/wx/dynarray.h"
typedef const void * _wxArraywxBaseArrayPtrVoid; class wxBaseArrayPtrVoid { typedef CMPFUNC SCMPFUNC; public: wxBaseArrayPtrVoid(); wxBaseArrayPtrVoid(const wxBaseArrayPtrVoid& array); wxBaseArrayPtrVoid& operator=(const wxBaseArrayPtrVoid& src); ~wxBaseArrayPtrVoid(); void Empty() { m_nCount = 0; } void Clear(); void Alloc(size_t n) { if ( n > m_nSize ) Realloc(n); } void Shrink(); size_t GetCount() const { return m_nCount; } void SetCount(size_t n, _wxArraywxBaseArrayPtrVoid defval = _wxArraywxBaseArrayPtrVoid()); bool IsEmpty() const { return m_nCount == 0; } size_t Count() const { return m_nCount; } typedef _wxArraywxBaseArrayPtrVoid base_type; protected: _wxArraywxBaseArrayPtrVoid& Item(size_t uiIndex) const { ; return m_pItems[uiIndex]; } _wxArraywxBaseArrayPtrVoid& operator[](size_t uiIndex) const { return Item(uiIndex); } int Index(_wxArraywxBaseArrayPtrVoid lItem, bool bFromEnd = false) const; int Index(_wxArraywxBaseArrayPtrVoid lItem, CMPFUNC fnCompare) const; size_t IndexForInsert(_wxArraywxBaseArrayPtrVoid lItem, CMPFUNC fnCompare) const; void Add(_wxArraywxBaseArrayPtrVoid lItem, size_t nInsert = 1); size_t Add(_wxArraywxBaseArrayPtrVoid lItem, CMPFUNC fnCompare); void Insert(_wxArraywxBaseArrayPtrVoid lItem, size_t uiIndex, size_t nInsert = 1); void Remove(_wxArraywxBaseArrayPtrVoid lItem); void RemoveAt(size_t uiIndex, size_t nRemove = 1); void Sort(CMPFUNC fnCompare); typedef _wxArraywxBaseArrayPtrVoid value_type; typedef value_type* iterator; typedef const value_type* const_iterator; typedef value_type& reference; typedef const value_type& const_reference; typedef int difference_type; typedef size_t size_type; void assign(const_iterator first, const_iterator last); void assign(size_type n, const_reference v); size_type capacity() const { return m_nSize; } iterator erase(iterator first, iterator last) { size_type idx = first - begin(); RemoveAt(idx, last - first); return begin() + idx; } iterator erase(iterator it) { return erase(it, it + 1); } void insert(iterator it, size_type n, const value_type& v) { Insert(v, it - begin(), n); } iterator insert(iterator it, const value_type& v = value_type()) { size_type idx = it - begin(); Insert(v, idx); return begin() + idx; } void insert(iterator it, const_iterator first, const_iterator last); void pop_back() { RemoveAt(size() - 1); } void push_back(const value_type& v) { Add(v); } void reserve(size_type n) { Alloc(n); } void resize(size_type n, value_type v = value_type()) { SetCount(n, v); } iterator begin() { return m_pItems; } iterator end() { return m_pItems + m_nCount; } const_iterator begin() const { return m_pItems; } const_iterator end() const { return m_pItems + m_nCount; } public: void clear() { Clear(); } bool empty() const { return IsEmpty(); } size_type max_size() const { return 2147483647; } size_type size() const { return GetCount(); } private: void Grow(size_t nIncrement = 0); bool Realloc(size_t nSize); size_t m_nSize, m_nCount; _wxArraywxBaseArrayPtrVoid *m_pItems; };

typedef char _wxArraywxBaseArrayChar; class wxBaseArrayChar { typedef CMPFUNC SCMPFUNC; public: wxBaseArrayChar(); wxBaseArrayChar(const wxBaseArrayChar& array); wxBaseArrayChar& operator=(const wxBaseArrayChar& src); ~wxBaseArrayChar(); void Empty() { m_nCount = 0; } void Clear(); void Alloc(size_t n) { if ( n > m_nSize ) Realloc(n); } void Shrink(); size_t GetCount() const { return m_nCount; } void SetCount(size_t n, _wxArraywxBaseArrayChar defval = _wxArraywxBaseArrayChar()); bool IsEmpty() const { return m_nCount == 0; } size_t Count() const { return m_nCount; } typedef _wxArraywxBaseArrayChar base_type; protected: _wxArraywxBaseArrayChar& Item(size_t uiIndex) const { ; return m_pItems[uiIndex]; } _wxArraywxBaseArrayChar& operator[](size_t uiIndex) const { return Item(uiIndex); } int Index(_wxArraywxBaseArrayChar lItem, bool bFromEnd = false) const; int Index(_wxArraywxBaseArrayChar lItem, CMPFUNC fnCompare) const; size_t IndexForInsert(_wxArraywxBaseArrayChar lItem, CMPFUNC fnCompare) const; void Add(_wxArraywxBaseArrayChar lItem, size_t nInsert = 1); size_t Add(_wxArraywxBaseArrayChar lItem, CMPFUNC fnCompare); void Insert(_wxArraywxBaseArrayChar lItem, size_t uiIndex, size_t nInsert = 1); void Remove(_wxArraywxBaseArrayChar lItem); void RemoveAt(size_t uiIndex, size_t nRemove = 1); void Sort(CMPFUNC fnCompare); typedef _wxArraywxBaseArrayChar value_type; typedef value_type* iterator; typedef const value_type* const_iterator; typedef value_type& reference; typedef const value_type& const_reference; typedef int difference_type; typedef size_t size_type; void assign(const_iterator first, const_iterator last); void assign(size_type n, const_reference v); size_type capacity() const { return m_nSize; } iterator erase(iterator first, iterator last) { size_type idx = first - begin(); RemoveAt(idx, last - first); return begin() + idx; } iterator erase(iterator it) { return erase(it, it + 1); } void insert(iterator it, size_type n, const value_type& v) { Insert(v, it - begin(), n); } iterator insert(iterator it, const value_type& v = value_type()) { size_type idx = it - begin(); Insert(v, idx); return begin() + idx; } void insert(iterator it, const_iterator first, const_iterator last); void pop_back() { RemoveAt(size() - 1); } void push_back(const value_type& v) { Add(v); } void reserve(size_type n) { Alloc(n); } void resize(size_type n, value_type v = value_type()) { SetCount(n, v); } iterator begin() { return m_pItems; } iterator end() { return m_pItems + m_nCount; } const_iterator begin() const { return m_pItems; } const_iterator end() const { return m_pItems + m_nCount; } public: void clear() { Clear(); } bool empty() const { return IsEmpty(); } size_type max_size() const { return 2147483647; } size_type size() const { return GetCount(); } private: void Grow(size_t nIncrement = 0); bool Realloc(size_t nSize); size_t m_nSize, m_nCount; _wxArraywxBaseArrayChar *m_pItems; };
typedef short _wxArraywxBaseArrayShort; class wxBaseArrayShort { typedef CMPFUNC SCMPFUNC; public: wxBaseArrayShort(); wxBaseArrayShort(const wxBaseArrayShort& array); wxBaseArrayShort& operator=(const wxBaseArrayShort& src); ~wxBaseArrayShort(); void Empty() { m_nCount = 0; } void Clear(); void Alloc(size_t n) { if ( n > m_nSize ) Realloc(n); } void Shrink(); size_t GetCount() const { return m_nCount; } void SetCount(size_t n, _wxArraywxBaseArrayShort defval = _wxArraywxBaseArrayShort()); bool IsEmpty() const { return m_nCount == 0; } size_t Count() const { return m_nCount; } typedef _wxArraywxBaseArrayShort base_type; protected: _wxArraywxBaseArrayShort& Item(size_t uiIndex) const { ; return m_pItems[uiIndex]; } _wxArraywxBaseArrayShort& operator[](size_t uiIndex) const { return Item(uiIndex); } int Index(_wxArraywxBaseArrayShort lItem, bool bFromEnd = false) const; int Index(_wxArraywxBaseArrayShort lItem, CMPFUNC fnCompare) const; size_t IndexForInsert(_wxArraywxBaseArrayShort lItem, CMPFUNC fnCompare) const; void Add(_wxArraywxBaseArrayShort lItem, size_t nInsert = 1); size_t Add(_wxArraywxBaseArrayShort lItem, CMPFUNC fnCompare); void Insert(_wxArraywxBaseArrayShort lItem, size_t uiIndex, size_t nInsert = 1); void Remove(_wxArraywxBaseArrayShort lItem); void RemoveAt(size_t uiIndex, size_t nRemove = 1); void Sort(CMPFUNC fnCompare); typedef _wxArraywxBaseArrayShort value_type; typedef value_type* iterator; typedef const value_type* const_iterator; typedef value_type& reference; typedef const value_type& const_reference; typedef int difference_type; typedef size_t size_type; void assign(const_iterator first, const_iterator last); void assign(size_type n, const_reference v); size_type capacity() const { return m_nSize; } iterator erase(iterator first, iterator last) { size_type idx = first - begin(); RemoveAt(idx, last - first); return begin() + idx; } iterator erase(iterator it) { return erase(it, it + 1); } void insert(iterator it, size_type n, const value_type& v) { Insert(v, it - begin(), n); } iterator insert(iterator it, const value_type& v = value_type()) { size_type idx = it - begin(); Insert(v, idx); return begin() + idx; } void insert(iterator it, const_iterator first, const_iterator last); void pop_back() { RemoveAt(size() - 1); } void push_back(const value_type& v) { Add(v); } void reserve(size_type n) { Alloc(n); } void resize(size_type n, value_type v = value_type()) { SetCount(n, v); } iterator begin() { return m_pItems; } iterator end() { return m_pItems + m_nCount; } const_iterator begin() const { return m_pItems; } const_iterator end() const { return m_pItems + m_nCount; } public: void clear() { Clear(); } bool empty() const { return IsEmpty(); } size_type max_size() const { return 2147483647; } size_type size() const { return GetCount(); } private: void Grow(size_t nIncrement = 0); bool Realloc(size_t nSize); size_t m_nSize, m_nCount; _wxArraywxBaseArrayShort *m_pItems; };
typedef int _wxArraywxBaseArrayInt; class wxBaseArrayInt { typedef CMPFUNC SCMPFUNC; public: wxBaseArrayInt(); wxBaseArrayInt(const wxBaseArrayInt& array); wxBaseArrayInt& operator=(const wxBaseArrayInt& src); ~wxBaseArrayInt(); void Empty() { m_nCount = 0; } void Clear(); void Alloc(size_t n) { if ( n > m_nSize ) Realloc(n); } void Shrink(); size_t GetCount() const { return m_nCount; } void SetCount(size_t n, _wxArraywxBaseArrayInt defval = _wxArraywxBaseArrayInt()); bool IsEmpty() const { return m_nCount == 0; } size_t Count() const { return m_nCount; } typedef _wxArraywxBaseArrayInt base_type; protected: _wxArraywxBaseArrayInt& Item(size_t uiIndex) const { ; return m_pItems[uiIndex]; } _wxArraywxBaseArrayInt& operator[](size_t uiIndex) const { return Item(uiIndex); } int Index(_wxArraywxBaseArrayInt lItem, bool bFromEnd = false) const; int Index(_wxArraywxBaseArrayInt lItem, CMPFUNC fnCompare) const; size_t IndexForInsert(_wxArraywxBaseArrayInt lItem, CMPFUNC fnCompare) const; void Add(_wxArraywxBaseArrayInt lItem, size_t nInsert = 1); size_t Add(_wxArraywxBaseArrayInt lItem, CMPFUNC fnCompare); void Insert(_wxArraywxBaseArrayInt lItem, size_t uiIndex, size_t nInsert = 1); void Remove(_wxArraywxBaseArrayInt lItem); void RemoveAt(size_t uiIndex, size_t nRemove = 1); void Sort(CMPFUNC fnCompare); typedef _wxArraywxBaseArrayInt value_type; typedef value_type* iterator; typedef const value_type* const_iterator; typedef value_type& reference; typedef const value_type& const_reference; typedef int difference_type; typedef size_t size_type; void assign(const_iterator first, const_iterator last); void assign(size_type n, const_reference v); size_type capacity() const { return m_nSize; } iterator erase(iterator first, iterator last) { size_type idx = first - begin(); RemoveAt(idx, last - first); return begin() + idx; } iterator erase(iterator it) { return erase(it, it + 1); } void insert(iterator it, size_type n, const value_type& v) { Insert(v, it - begin(), n); } iterator insert(iterator it, const value_type& v = value_type()) { size_type idx = it - begin(); Insert(v, idx); return begin() + idx; } void insert(iterator it, const_iterator first, const_iterator last); void pop_back() { RemoveAt(size() - 1); } void push_back(const value_type& v) { Add(v); } void reserve(size_type n) { Alloc(n); } void resize(size_type n, value_type v = value_type()) { SetCount(n, v); } iterator begin() { return m_pItems; } iterator end() { return m_pItems + m_nCount; } const_iterator begin() const { return m_pItems; } const_iterator end() const { return m_pItems + m_nCount; } public: void clear() { Clear(); } bool empty() const { return IsEmpty(); } size_type max_size() const { return 2147483647; } size_type size() const { return GetCount(); } private: void Grow(size_t nIncrement = 0); bool Realloc(size_t nSize); size_t m_nSize, m_nCount; _wxArraywxBaseArrayInt *m_pItems; };
typedef long _wxArraywxBaseArrayLong; class wxBaseArrayLong { typedef CMPFUNC SCMPFUNC; public: wxBaseArrayLong(); wxBaseArrayLong(const wxBaseArrayLong& array); wxBaseArrayLong& operator=(const wxBaseArrayLong& src); ~wxBaseArrayLong(); void Empty() { m_nCount = 0; } void Clear(); void Alloc(size_t n) { if ( n > m_nSize ) Realloc(n); } void Shrink(); size_t GetCount() const { return m_nCount; } void SetCount(size_t n, _wxArraywxBaseArrayLong defval = _wxArraywxBaseArrayLong()); bool IsEmpty() const { return m_nCount == 0; } size_t Count() const { return m_nCount; } typedef _wxArraywxBaseArrayLong base_type; protected: _wxArraywxBaseArrayLong& Item(size_t uiIndex) const { ; return m_pItems[uiIndex]; } _wxArraywxBaseArrayLong& operator[](size_t uiIndex) const { return Item(uiIndex); } int Index(_wxArraywxBaseArrayLong lItem, bool bFromEnd = false) const; int Index(_wxArraywxBaseArrayLong lItem, CMPFUNC fnCompare) const; size_t IndexForInsert(_wxArraywxBaseArrayLong lItem, CMPFUNC fnCompare) const; void Add(_wxArraywxBaseArrayLong lItem, size_t nInsert = 1); size_t Add(_wxArraywxBaseArrayLong lItem, CMPFUNC fnCompare); void Insert(_wxArraywxBaseArrayLong lItem, size_t uiIndex, size_t nInsert = 1); void Remove(_wxArraywxBaseArrayLong lItem); void RemoveAt(size_t uiIndex, size_t nRemove = 1); void Sort(CMPFUNC fnCompare); typedef _wxArraywxBaseArrayLong value_type; typedef value_type* iterator; typedef const value_type* const_iterator; typedef value_type& reference; typedef const value_type& const_reference; typedef int difference_type; typedef size_t size_type; void assign(const_iterator first, const_iterator last); void assign(size_type n, const_reference v); size_type capacity() const { return m_nSize; } iterator erase(iterator first, iterator last) { size_type idx = first - begin(); RemoveAt(idx, last - first); return begin() + idx; } iterator erase(iterator it) { return erase(it, it + 1); } void insert(iterator it, size_type n, const value_type& v) { Insert(v, it - begin(), n); } iterator insert(iterator it, const value_type& v = value_type()) { size_type idx = it - begin(); Insert(v, idx); return begin() + idx; } void insert(iterator it, const_iterator first, const_iterator last); void pop_back() { RemoveAt(size() - 1); } void push_back(const value_type& v) { Add(v); } void reserve(size_type n) { Alloc(n); } void resize(size_type n, value_type v = value_type()) { SetCount(n, v); } iterator begin() { return m_pItems; } iterator end() { return m_pItems + m_nCount; } const_iterator begin() const { return m_pItems; } const_iterator end() const { return m_pItems + m_nCount; } public: void clear() { Clear(); } bool empty() const { return IsEmpty(); } size_type max_size() const { return 2147483647; } size_type size() const { return GetCount(); } private: void Grow(size_t nIncrement = 0); bool Realloc(size_t nSize); size_t m_nSize, m_nCount; _wxArraywxBaseArrayLong *m_pItems; };
typedef size_t _wxArraywxBaseArraySizeT; class wxBaseArraySizeT { typedef CMPFUNC SCMPFUNC; public: wxBaseArraySizeT(); wxBaseArraySizeT(const wxBaseArraySizeT& array); wxBaseArraySizeT& operator=(const wxBaseArraySizeT& src); ~wxBaseArraySizeT(); void Empty() { m_nCount = 0; } void Clear(); void Alloc(size_t n) { if ( n > m_nSize ) Realloc(n); } void Shrink(); size_t GetCount() const { return m_nCount; } void SetCount(size_t n, _wxArraywxBaseArraySizeT defval = _wxArraywxBaseArraySizeT()); bool IsEmpty() const { return m_nCount == 0; } size_t Count() const { return m_nCount; } typedef _wxArraywxBaseArraySizeT base_type; protected: _wxArraywxBaseArraySizeT& Item(size_t uiIndex) const { ; return m_pItems[uiIndex]; } _wxArraywxBaseArraySizeT& operator[](size_t uiIndex) const { return Item(uiIndex); } int Index(_wxArraywxBaseArraySizeT lItem, bool bFromEnd = false) const; int Index(_wxArraywxBaseArraySizeT lItem, CMPFUNC fnCompare) const; size_t IndexForInsert(_wxArraywxBaseArraySizeT lItem, CMPFUNC fnCompare) const; void Add(_wxArraywxBaseArraySizeT lItem, size_t nInsert = 1); size_t Add(_wxArraywxBaseArraySizeT lItem, CMPFUNC fnCompare); void Insert(_wxArraywxBaseArraySizeT lItem, size_t uiIndex, size_t nInsert = 1); void Remove(_wxArraywxBaseArraySizeT lItem); void RemoveAt(size_t uiIndex, size_t nRemove = 1); void Sort(CMPFUNC fnCompare); typedef _wxArraywxBaseArraySizeT value_type; typedef value_type* iterator; typedef const value_type* const_iterator; typedef value_type& reference; typedef const value_type& const_reference; typedef int difference_type; typedef size_t size_type; void assign(const_iterator first, const_iterator last); void assign(size_type n, const_reference v); size_type capacity() const { return m_nSize; } iterator erase(iterator first, iterator last) { size_type idx = first - begin(); RemoveAt(idx, last - first); return begin() + idx; } iterator erase(iterator it) { return erase(it, it + 1); } void insert(iterator it, size_type n, const value_type& v) { Insert(v, it - begin(), n); } iterator insert(iterator it, const value_type& v = value_type()) { size_type idx = it - begin(); Insert(v, idx); return begin() + idx; } void insert(iterator it, const_iterator first, const_iterator last); void pop_back() { RemoveAt(size() - 1); } void push_back(const value_type& v) { Add(v); } void reserve(size_type n) { Alloc(n); } void resize(size_type n, value_type v = value_type()) { SetCount(n, v); } iterator begin() { return m_pItems; } iterator end() { return m_pItems + m_nCount; } const_iterator begin() const { return m_pItems; } const_iterator end() const { return m_pItems + m_nCount; } public: void clear() { Clear(); } bool empty() const { return IsEmpty(); } size_type max_size() const { return 2147483647; } size_type size() const { return GetCount(); } private: void Grow(size_t nIncrement = 0); bool Realloc(size_t nSize); size_t m_nSize, m_nCount; _wxArraywxBaseArraySizeT *m_pItems; };
typedef double _wxArraywxBaseArrayDouble; class wxBaseArrayDouble { typedef CMPFUNC SCMPFUNC; public: wxBaseArrayDouble(); wxBaseArrayDouble(const wxBaseArrayDouble& array); wxBaseArrayDouble& operator=(const wxBaseArrayDouble& src); ~wxBaseArrayDouble(); void Empty() { m_nCount = 0; } void Clear(); void Alloc(size_t n) { if ( n > m_nSize ) Realloc(n); } void Shrink(); size_t GetCount() const { return m_nCount; } void SetCount(size_t n, _wxArraywxBaseArrayDouble defval = _wxArraywxBaseArrayDouble()); bool IsEmpty() const { return m_nCount == 0; } size_t Count() const { return m_nCount; } typedef _wxArraywxBaseArrayDouble base_type; protected: _wxArraywxBaseArrayDouble& Item(size_t uiIndex) const { ; return m_pItems[uiIndex]; } _wxArraywxBaseArrayDouble& operator[](size_t uiIndex) const { return Item(uiIndex); } int Index(_wxArraywxBaseArrayDouble lItem, bool bFromEnd = false) const; int Index(_wxArraywxBaseArrayDouble lItem, CMPFUNC fnCompare) const; size_t IndexForInsert(_wxArraywxBaseArrayDouble lItem, CMPFUNC fnCompare) const; void Add(_wxArraywxBaseArrayDouble lItem, size_t nInsert = 1); size_t Add(_wxArraywxBaseArrayDouble lItem, CMPFUNC fnCompare); void Insert(_wxArraywxBaseArrayDouble lItem, size_t uiIndex, size_t nInsert = 1); void Remove(_wxArraywxBaseArrayDouble lItem); void RemoveAt(size_t uiIndex, size_t nRemove = 1); void Sort(CMPFUNC fnCompare); typedef _wxArraywxBaseArrayDouble value_type; typedef value_type* iterator; typedef const value_type* const_iterator; typedef value_type& reference; typedef const value_type& const_reference; typedef int difference_type; typedef size_t size_type; void assign(const_iterator first, const_iterator last); void assign(size_type n, const_reference v); size_type capacity() const { return m_nSize; } iterator erase(iterator first, iterator last) { size_type idx = first - begin(); RemoveAt(idx, last - first); return begin() + idx; } iterator erase(iterator it) { return erase(it, it + 1); } void insert(iterator it, size_type n, const value_type& v) { Insert(v, it - begin(), n); } iterator insert(iterator it, const value_type& v = value_type()) { size_type idx = it - begin(); Insert(v, idx); return begin() + idx; } void insert(iterator it, const_iterator first, const_iterator last); void pop_back() { RemoveAt(size() - 1); } void push_back(const value_type& v) { Add(v); } void reserve(size_type n) { Alloc(n); } void resize(size_type n, value_type v = value_type()) { SetCount(n, v); } iterator begin() { return m_pItems; } iterator end() { return m_pItems + m_nCount; } const_iterator begin() const { return m_pItems; } const_iterator end() const { return m_pItems + m_nCount; } public: void clear() { Clear(); } bool empty() const { return IsEmpty(); } size_type max_size() const { return 2147483647; } size_type size() const { return GetCount(); } private: void Grow(size_t nIncrement = 0); bool Realloc(size_t nSize); size_t m_nSize, m_nCount; _wxArraywxBaseArrayDouble *m_pItems; };
# 993 "/usr/include/wx-2.8/wx/dynarray.h"
typedef short _wxArraywxArrayShort; struct wxAssert_wxArrayShort { unsigned int TypeTooBigToBeStoredInwxBaseArrayShort: sizeof(_wxArraywxArrayShort) <= sizeof(wxBaseArrayShort::base_type); }; typedef int ( *CMPFUNC_wxArraywxArrayShort)(_wxArraywxArrayShort *pItem1, _wxArraywxArrayShort *pItem2); class wxArrayShort : public wxBaseArrayShort { public: wxArrayShort() { } ~wxArrayShort() { } wxArrayShort& operator=(const wxArrayShort& src) { wxBaseArrayShort* temp = (wxBaseArrayShort*) this; (*temp) = ((const wxBaseArrayShort&)src); return *this; } _wxArraywxArrayShort& operator[](size_t uiIndex) const { return (_wxArraywxArrayShort&)(wxBaseArrayShort::operator[](uiIndex)); } _wxArraywxArrayShort& Item(size_t uiIndex) const { return (_wxArraywxArrayShort&)(wxBaseArrayShort::operator[](uiIndex)); } _wxArraywxArrayShort& Last() const { return (_wxArraywxArrayShort&)(wxBaseArrayShort::operator[](Count() - 1)); } int Index(_wxArraywxArrayShort lItem, bool bFromEnd = false) const { return wxBaseArrayShort::Index((base_type)lItem, bFromEnd); } void Add(_wxArraywxArrayShort lItem, size_t nInsert = 1) { wxBaseArrayShort::Add((base_type)lItem, nInsert); } void Insert(_wxArraywxArrayShort lItem, size_t uiIndex, size_t nInsert = 1) { wxBaseArrayShort::Insert((base_type)lItem, uiIndex, nInsert) ; } void RemoveAt(size_t uiIndex, size_t nRemove = 1) { wxBaseArrayShort::RemoveAt(uiIndex, nRemove); } void Remove(_wxArraywxArrayShort lItem) { int iIndex = Index(lItem); if ( iIndex != (-1) ) ; else { ; return; } typedef int wxDummyCheckInt; wxBaseArrayShort::RemoveAt((size_t)iIndex); } void Sort(CMPFUNC_wxArraywxArrayShort fCmp) { wxBaseArrayShort::Sort((CMPFUNC)fCmp); } private: typedef wxBaseArrayShort::iterator biterator; typedef wxBaseArrayShort::const_iterator bconst_iterator; typedef wxBaseArrayShort::value_type bvalue_type; typedef wxBaseArrayShort::const_reference bconst_reference; public: typedef _wxArraywxArrayShort value_type; typedef value_type* pointer; typedef const value_type* const_pointer; typedef value_type* iterator; typedef const value_type* const_iterator; typedef value_type& reference; typedef const value_type& const_reference; typedef wxBaseArrayShort::difference_type difference_type; typedef wxBaseArrayShort::size_type size_type; class reverse_iterator { typedef _wxArraywxArrayShort value_type; typedef value_type& reference; typedef value_type* pointer; typedef reverse_iterator itor; friend inline itor operator+(int o, const itor& it) { return it.m_ptr - o; } friend inline itor operator+(const itor& it, int o) { return it.m_ptr - o; } friend inline itor operator-(const itor& it, int o) { return it.m_ptr + o; } friend inline difference_type operator-(const itor& i1, const itor& i2) { return i1.m_ptr - i2.m_ptr; } public: pointer m_ptr; reverse_iterator() : m_ptr(__null) { } reverse_iterator(pointer ptr) : m_ptr(ptr) { } reverse_iterator(const itor& it) : m_ptr(it.m_ptr) { } reference operator*() const { return *m_ptr; } itor& operator++() { --m_ptr; return *this; } const itor operator++(int) { reverse_iterator tmp = *this; --m_ptr; return tmp; } itor& operator--() { ++m_ptr; return *this; } const itor operator--(int) { itor tmp = *this; ++m_ptr; return tmp; } bool operator ==(const itor& it) const { return m_ptr == it.m_ptr; } bool operator !=(const itor& it) const { return m_ptr != it.m_ptr; } }; class const_reverse_iterator { typedef _wxArraywxArrayShort value_type; typedef const value_type& reference; typedef const value_type* pointer; typedef const_reverse_iterator itor; friend inline itor operator+(int o, const itor& it) { return it.m_ptr - o; } friend inline itor operator+(const itor& it, int o) { return it.m_ptr - o; } friend inline itor operator-(const itor& it, int o) { return it.m_ptr + o; } friend inline difference_type operator-(const itor& i1, const itor& i2) { return i1.m_ptr - i2.m_ptr; } public: pointer m_ptr; const_reverse_iterator() : m_ptr(__null) { } const_reverse_iterator(pointer ptr) : m_ptr(ptr) { } const_reverse_iterator(const itor& it) : m_ptr(it.m_ptr) { } const_reverse_iterator(const reverse_iterator& it) : m_ptr(it.m_ptr) { } reference operator*() const { return *m_ptr; } itor& operator++() { --m_ptr; return *this; } const itor operator++(int) { itor tmp = *this; --m_ptr; return tmp; } itor& operator--() { ++m_ptr; return *this; } const itor operator--(int) { itor tmp = *this; ++m_ptr; return tmp; } bool operator ==(const itor& it) const { return m_ptr == it.m_ptr; } bool operator !=(const itor& it) const { return m_ptr != it.m_ptr; } }; wxArrayShort(size_type n, const_reference v) { assign(n, v); } wxArrayShort(const_iterator first, const_iterator last) { assign(first, last); } void assign(const_iterator first, const_iterator last) { wxBaseArrayShort::assign((bconst_iterator)first, (bconst_iterator)last); } void assign(size_type n, const_reference v) { wxBaseArrayShort::assign(n, (bconst_reference)v); } reference back() { return *(end() - 1); } const_reference back() const { return *(end() - 1); } iterator begin() { return (iterator)wxBaseArrayShort::begin(); } const_iterator begin() const { return (const_iterator)wxBaseArrayShort::begin(); } size_type capacity() const { return wxBaseArrayShort::capacity(); } iterator end() { return (iterator)wxBaseArrayShort::end(); } const_iterator end() const { return (const_iterator)wxBaseArrayShort::end(); } iterator erase(iterator first, iterator last) { return (iterator)wxBaseArrayShort::erase((biterator)first, (biterator)last); } iterator erase(iterator it) { return (iterator)wxBaseArrayShort::erase((biterator)it); } reference front() { return *begin(); } const_reference front() const { return *begin(); } void insert(iterator it, size_type n, const_reference v) { wxBaseArrayShort::insert((biterator)it, n, (bconst_reference)v); } iterator insert(iterator it, const_reference v = value_type()) { return (iterator)wxBaseArrayShort::insert((biterator)it, (bconst_reference)v); } void insert(iterator it, const_iterator first, const_iterator last) { wxBaseArrayShort::insert((biterator)it, (bconst_iterator)first, (bconst_iterator)last); } void pop_back() { wxBaseArrayShort::pop_back(); } void push_back(const_reference v) { wxBaseArrayShort::push_back((bconst_reference)v); } reverse_iterator rbegin() { return reverse_iterator(end() - 1); } const_reverse_iterator rbegin() const; reverse_iterator rend() { return reverse_iterator(begin() - 1); } const_reverse_iterator rend() const; void reserve(size_type n) { wxBaseArrayShort::reserve(n); } void resize(size_type n, value_type v = value_type()) { wxBaseArrayShort::resize(n, v); } };
typedef int _wxArraywxArrayInt; struct wxAssert_wxArrayInt { unsigned int TypeTooBigToBeStoredInwxBaseArrayInt: sizeof(_wxArraywxArrayInt) <= sizeof(wxBaseArrayInt::base_type); }; typedef int ( *CMPFUNC_wxArraywxArrayInt)(_wxArraywxArrayInt *pItem1, _wxArraywxArrayInt *pItem2); class wxArrayInt : public wxBaseArrayInt { public: wxArrayInt() { } ~wxArrayInt() { } wxArrayInt& operator=(const wxArrayInt& src) { wxBaseArrayInt* temp = (wxBaseArrayInt*) this; (*temp) = ((const wxBaseArrayInt&)src); return *this; } _wxArraywxArrayInt& operator[](size_t uiIndex) const { return (_wxArraywxArrayInt&)(wxBaseArrayInt::operator[](uiIndex)); } _wxArraywxArrayInt& Item(size_t uiIndex) const { return (_wxArraywxArrayInt&)(wxBaseArrayInt::operator[](uiIndex)); } _wxArraywxArrayInt& Last() const { return (_wxArraywxArrayInt&)(wxBaseArrayInt::operator[](Count() - 1)); } int Index(_wxArraywxArrayInt lItem, bool bFromEnd = false) const { return wxBaseArrayInt::Index((base_type)lItem, bFromEnd); } void Add(_wxArraywxArrayInt lItem, size_t nInsert = 1) { wxBaseArrayInt::Add((base_type)lItem, nInsert); } void Insert(_wxArraywxArrayInt lItem, size_t uiIndex, size_t nInsert = 1) { wxBaseArrayInt::Insert((base_type)lItem, uiIndex, nInsert) ; } void RemoveAt(size_t uiIndex, size_t nRemove = 1) { wxBaseArrayInt::RemoveAt(uiIndex, nRemove); } void Remove(_wxArraywxArrayInt lItem) { int iIndex = Index(lItem); if ( iIndex != (-1) ) ; else { ; return; } typedef int wxDummyCheckInt; wxBaseArrayInt::RemoveAt((size_t)iIndex); } void Sort(CMPFUNC_wxArraywxArrayInt fCmp) { wxBaseArrayInt::Sort((CMPFUNC)fCmp); } private: typedef wxBaseArrayInt::iterator biterator; typedef wxBaseArrayInt::const_iterator bconst_iterator; typedef wxBaseArrayInt::value_type bvalue_type; typedef wxBaseArrayInt::const_reference bconst_reference; public: typedef _wxArraywxArrayInt value_type; typedef value_type* pointer; typedef const value_type* const_pointer; typedef value_type* iterator; typedef const value_type* const_iterator; typedef value_type& reference; typedef const value_type& const_reference; typedef wxBaseArrayInt::difference_type difference_type; typedef wxBaseArrayInt::size_type size_type; class reverse_iterator { typedef _wxArraywxArrayInt value_type; typedef value_type& reference; typedef value_type* pointer; typedef reverse_iterator itor; friend inline itor operator+(int o, const itor& it) { return it.m_ptr - o; } friend inline itor operator+(const itor& it, int o) { return it.m_ptr - o; } friend inline itor operator-(const itor& it, int o) { return it.m_ptr + o; } friend inline difference_type operator-(const itor& i1, const itor& i2) { return i1.m_ptr - i2.m_ptr; } public: pointer m_ptr; reverse_iterator() : m_ptr(__null) { } reverse_iterator(pointer ptr) : m_ptr(ptr) { } reverse_iterator(const itor& it) : m_ptr(it.m_ptr) { } reference operator*() const { return *m_ptr; } itor& operator++() { --m_ptr; return *this; } const itor operator++(int) { reverse_iterator tmp = *this; --m_ptr; return tmp; } itor& operator--() { ++m_ptr; return *this; } const itor operator--(int) { itor tmp = *this; ++m_ptr; return tmp; } bool operator ==(const itor& it) const { return m_ptr == it.m_ptr; } bool operator !=(const itor& it) const { return m_ptr != it.m_ptr; } }; class const_reverse_iterator { typedef _wxArraywxArrayInt value_type; typedef const value_type& reference; typedef const value_type* pointer; typedef const_reverse_iterator itor; friend inline itor operator+(int o, const itor& it) { return it.m_ptr - o; } friend inline itor operator+(const itor& it, int o) { return it.m_ptr - o; } friend inline itor operator-(const itor& it, int o) { return it.m_ptr + o; } friend inline difference_type operator-(const itor& i1, const itor& i2) { return i1.m_ptr - i2.m_ptr; } public: pointer m_ptr; const_reverse_iterator() : m_ptr(__null) { } const_reverse_iterator(pointer ptr) : m_ptr(ptr) { } const_reverse_iterator(const itor& it) : m_ptr(it.m_ptr) { } const_reverse_iterator(const reverse_iterator& it) : m_ptr(it.m_ptr) { } reference operator*() const { return *m_ptr; } itor& operator++() { --m_ptr; return *this; } const itor operator++(int) { itor tmp = *this; --m_ptr; return tmp; } itor& operator--() { ++m_ptr; return *this; } const itor operator--(int) { itor tmp = *this; ++m_ptr; return tmp; } bool operator ==(const itor& it) const { return m_ptr == it.m_ptr; } bool operator !=(const itor& it) const { return m_ptr != it.m_ptr; } }; wxArrayInt(size_type n, const_reference v) { assign(n, v); } wxArrayInt(const_iterator first, const_iterator last) { assign(first, last); } void assign(const_iterator first, const_iterator last) { wxBaseArrayInt::assign((bconst_iterator)first, (bconst_iterator)last); } void assign(size_type n, const_reference v) { wxBaseArrayInt::assign(n, (bconst_reference)v); } reference back() { return *(end() - 1); } const_reference back() const { return *(end() - 1); } iterator begin() { return (iterator)wxBaseArrayInt::begin(); } const_iterator begin() const { return (const_iterator)wxBaseArrayInt::begin(); } size_type capacity() const { return wxBaseArrayInt::capacity(); } iterator end() { return (iterator)wxBaseArrayInt::end(); } const_iterator end() const { return (const_iterator)wxBaseArrayInt::end(); } iterator erase(iterator first, iterator last) { return (iterator)wxBaseArrayInt::erase((biterator)first, (biterator)last); } iterator erase(iterator it) { return (iterator)wxBaseArrayInt::erase((biterator)it); } reference front() { return *begin(); } const_reference front() const { return *begin(); } void insert(iterator it, size_type n, const_reference v) { wxBaseArrayInt::insert((biterator)it, n, (bconst_reference)v); } iterator insert(iterator it, const_reference v = value_type()) { return (iterator)wxBaseArrayInt::insert((biterator)it, (bconst_reference)v); } void insert(iterator it, const_iterator first, const_iterator last) { wxBaseArrayInt::insert((biterator)it, (bconst_iterator)first, (bconst_iterator)last); } void pop_back() { wxBaseArrayInt::pop_back(); } void push_back(const_reference v) { wxBaseArrayInt::push_back((bconst_reference)v); } reverse_iterator rbegin() { return reverse_iterator(end() - 1); } const_reverse_iterator rbegin() const; reverse_iterator rend() { return reverse_iterator(begin() - 1); } const_reverse_iterator rend() const; void reserve(size_type n) { wxBaseArrayInt::reserve(n); } void resize(size_type n, value_type v = value_type()) { wxBaseArrayInt::resize(n, v); } };
typedef double _wxArraywxArrayDouble; struct wxAssert_wxArrayDouble { unsigned int TypeTooBigToBeStoredInwxBaseArrayDouble: sizeof(_wxArraywxArrayDouble) <= sizeof(wxBaseArrayDouble::base_type); }; typedef int ( *CMPFUNC_wxArraywxArrayDouble)(_wxArraywxArrayDouble *pItem1, _wxArraywxArrayDouble *pItem2); class wxArrayDouble : public wxBaseArrayDouble { public: wxArrayDouble() { } ~wxArrayDouble() { } wxArrayDouble& operator=(const wxArrayDouble& src) { wxBaseArrayDouble* temp = (wxBaseArrayDouble*) this; (*temp) = ((const wxBaseArrayDouble&)src); return *this; } _wxArraywxArrayDouble& operator[](size_t uiIndex) const { return (_wxArraywxArrayDouble&)(wxBaseArrayDouble::operator[](uiIndex)); } _wxArraywxArrayDouble& Item(size_t uiIndex) const { return (_wxArraywxArrayDouble&)(wxBaseArrayDouble::operator[](uiIndex)); } _wxArraywxArrayDouble& Last() const { return (_wxArraywxArrayDouble&)(wxBaseArrayDouble::operator[](Count() - 1)); } int Index(_wxArraywxArrayDouble lItem, bool bFromEnd = false) const { return wxBaseArrayDouble::Index((base_type)lItem, bFromEnd); } void Add(_wxArraywxArrayDouble lItem, size_t nInsert = 1) { wxBaseArrayDouble::Add((base_type)lItem, nInsert); } void Insert(_wxArraywxArrayDouble lItem, size_t uiIndex, size_t nInsert = 1) { wxBaseArrayDouble::Insert((base_type)lItem, uiIndex, nInsert) ; } void RemoveAt(size_t uiIndex, size_t nRemove = 1) { wxBaseArrayDouble::RemoveAt(uiIndex, nRemove); } void Remove(_wxArraywxArrayDouble lItem) { int iIndex = Index(lItem); if ( iIndex != (-1) ) ; else { ; return; } typedef int wxDummyCheckInt; wxBaseArrayDouble::RemoveAt((size_t)iIndex); } void Sort(CMPFUNC_wxArraywxArrayDouble fCmp) { wxBaseArrayDouble::Sort((CMPFUNC)fCmp); } private: typedef wxBaseArrayDouble::iterator biterator; typedef wxBaseArrayDouble::const_iterator bconst_iterator; typedef wxBaseArrayDouble::value_type bvalue_type; typedef wxBaseArrayDouble::const_reference bconst_reference; public: typedef _wxArraywxArrayDouble value_type; typedef value_type* pointer; typedef const value_type* const_pointer; typedef value_type* iterator; typedef const value_type* const_iterator; typedef value_type& reference; typedef const value_type& const_reference; typedef wxBaseArrayDouble::difference_type difference_type; typedef wxBaseArrayDouble::size_type size_type; class reverse_iterator { typedef _wxArraywxArrayDouble value_type; typedef value_type& reference; typedef value_type* pointer; typedef reverse_iterator itor; friend inline itor operator+(int o, const itor& it) { return it.m_ptr - o; } friend inline itor operator+(const itor& it, int o) { return it.m_ptr - o; } friend inline itor operator-(const itor& it, int o) { return it.m_ptr + o; } friend inline difference_type operator-(const itor& i1, const itor& i2) { return i1.m_ptr - i2.m_ptr; } public: pointer m_ptr; reverse_iterator() : m_ptr(__null) { } reverse_iterator(pointer ptr) : m_ptr(ptr) { } reverse_iterator(const itor& it) : m_ptr(it.m_ptr) { } reference operator*() const { return *m_ptr; } itor& operator++() { --m_ptr; return *this; } const itor operator++(int) { reverse_iterator tmp = *this; --m_ptr; return tmp; } itor& operator--() { ++m_ptr; return *this; } const itor operator--(int) { itor tmp = *this; ++m_ptr; return tmp; } bool operator ==(const itor& it) const { return m_ptr == it.m_ptr; } bool operator !=(const itor& it) const { return m_ptr != it.m_ptr; } }; class const_reverse_iterator { typedef _wxArraywxArrayDouble value_type; typedef const value_type& reference; typedef const value_type* pointer; typedef const_reverse_iterator itor; friend inline itor operator+(int o, const itor& it) { return it.m_ptr - o; } friend inline itor operator+(const itor& it, int o) { return it.m_ptr - o; } friend inline itor operator-(const itor& it, int o) { return it.m_ptr + o; } friend inline difference_type operator-(const itor& i1, const itor& i2) { return i1.m_ptr - i2.m_ptr; } public: pointer m_ptr; const_reverse_iterator() : m_ptr(__null) { } const_reverse_iterator(pointer ptr) : m_ptr(ptr) { } const_reverse_iterator(const itor& it) : m_ptr(it.m_ptr) { } const_reverse_iterator(const reverse_iterator& it) : m_ptr(it.m_ptr) { } reference operator*() const { return *m_ptr; } itor& operator++() { --m_ptr; return *this; } const itor operator++(int) { itor tmp = *this; --m_ptr; return tmp; } itor& operator--() { ++m_ptr; return *this; } const itor operator--(int) { itor tmp = *this; ++m_ptr; return tmp; } bool operator ==(const itor& it) const { return m_ptr == it.m_ptr; } bool operator !=(const itor& it) const { return m_ptr != it.m_ptr; } }; wxArrayDouble(size_type n, const_reference v) { assign(n, v); } wxArrayDouble(const_iterator first, const_iterator last) { assign(first, last); } void assign(const_iterator first, const_iterator last) { wxBaseArrayDouble::assign((bconst_iterator)first, (bconst_iterator)last); } void assign(size_type n, const_reference v) { wxBaseArrayDouble::assign(n, (bconst_reference)v); } reference back() { return *(end() - 1); } const_reference back() const { return *(end() - 1); } iterator begin() { return (iterator)wxBaseArrayDouble::begin(); } const_iterator begin() const { return (const_iterator)wxBaseArrayDouble::begin(); } size_type capacity() const { return wxBaseArrayDouble::capacity(); } iterator end() { return (iterator)wxBaseArrayDouble::end(); } const_iterator end() const { return (const_iterator)wxBaseArrayDouble::end(); } iterator erase(iterator first, iterator last) { return (iterator)wxBaseArrayDouble::erase((biterator)first, (biterator)last); } iterator erase(iterator it) { return (iterator)wxBaseArrayDouble::erase((biterator)it); } reference front() { return *begin(); } const_reference front() const { return *begin(); } void insert(iterator it, size_type n, const_reference v) { wxBaseArrayDouble::insert((biterator)it, n, (bconst_reference)v); } iterator insert(iterator it, const_reference v = value_type()) { return (iterator)wxBaseArrayDouble::insert((biterator)it, (bconst_reference)v); } void insert(iterator it, const_iterator first, const_iterator last) { wxBaseArrayDouble::insert((biterator)it, (bconst_iterator)first, (bconst_iterator)last); } void pop_back() { wxBaseArrayDouble::pop_back(); } void push_back(const_reference v) { wxBaseArrayDouble::push_back((bconst_reference)v); } reverse_iterator rbegin() { return reverse_iterator(end() - 1); } const_reverse_iterator rbegin() const; reverse_iterator rend() { return reverse_iterator(begin() - 1); } const_reverse_iterator rend() const; void reserve(size_type n) { wxBaseArrayDouble::reserve(n); } void resize(size_type n, value_type v = value_type()) { wxBaseArrayDouble::resize(n, v); } };
typedef long _wxArraywxArrayLong; struct wxAssert_wxArrayLong { unsigned int TypeTooBigToBeStoredInwxBaseArrayLong: sizeof(_wxArraywxArrayLong) <= sizeof(wxBaseArrayLong::base_type); }; typedef int ( *CMPFUNC_wxArraywxArrayLong)(_wxArraywxArrayLong *pItem1, _wxArraywxArrayLong *pItem2); class wxArrayLong : public wxBaseArrayLong { public: wxArrayLong() { } ~wxArrayLong() { } wxArrayLong& operator=(const wxArrayLong& src) { wxBaseArrayLong* temp = (wxBaseArrayLong*) this; (*temp) = ((const wxBaseArrayLong&)src); return *this; } _wxArraywxArrayLong& operator[](size_t uiIndex) const { return (_wxArraywxArrayLong&)(wxBaseArrayLong::operator[](uiIndex)); } _wxArraywxArrayLong& Item(size_t uiIndex) const { return (_wxArraywxArrayLong&)(wxBaseArrayLong::operator[](uiIndex)); } _wxArraywxArrayLong& Last() const { return (_wxArraywxArrayLong&)(wxBaseArrayLong::operator[](Count() - 1)); } int Index(_wxArraywxArrayLong lItem, bool bFromEnd = false) const { return wxBaseArrayLong::Index((base_type)lItem, bFromEnd); } void Add(_wxArraywxArrayLong lItem, size_t nInsert = 1) { wxBaseArrayLong::Add((base_type)lItem, nInsert); } void Insert(_wxArraywxArrayLong lItem, size_t uiIndex, size_t nInsert = 1) { wxBaseArrayLong::Insert((base_type)lItem, uiIndex, nInsert) ; } void RemoveAt(size_t uiIndex, size_t nRemove = 1) { wxBaseArrayLong::RemoveAt(uiIndex, nRemove); } void Remove(_wxArraywxArrayLong lItem) { int iIndex = Index(lItem); if ( iIndex != (-1) ) ; else { ; return; } typedef int wxDummyCheckInt; wxBaseArrayLong::RemoveAt((size_t)iIndex); } void Sort(CMPFUNC_wxArraywxArrayLong fCmp) { wxBaseArrayLong::Sort((CMPFUNC)fCmp); } private: typedef wxBaseArrayLong::iterator biterator; typedef wxBaseArrayLong::const_iterator bconst_iterator; typedef wxBaseArrayLong::value_type bvalue_type; typedef wxBaseArrayLong::const_reference bconst_reference; public: typedef _wxArraywxArrayLong value_type; typedef value_type* pointer; typedef const value_type* const_pointer; typedef value_type* iterator; typedef const value_type* const_iterator; typedef value_type& reference; typedef const value_type& const_reference; typedef wxBaseArrayLong::difference_type difference_type; typedef wxBaseArrayLong::size_type size_type; class reverse_iterator { typedef _wxArraywxArrayLong value_type; typedef value_type& reference; typedef value_type* pointer; typedef reverse_iterator itor; friend inline itor operator+(int o, const itor& it) { return it.m_ptr - o; } friend inline itor operator+(const itor& it, int o) { return it.m_ptr - o; } friend inline itor operator-(const itor& it, int o) { return it.m_ptr + o; } friend inline difference_type operator-(const itor& i1, const itor& i2) { return i1.m_ptr - i2.m_ptr; } public: pointer m_ptr; reverse_iterator() : m_ptr(__null) { } reverse_iterator(pointer ptr) : m_ptr(ptr) { } reverse_iterator(const itor& it) : m_ptr(it.m_ptr) { } reference operator*() const { return *m_ptr; } itor& operator++() { --m_ptr; return *this; } const itor operator++(int) { reverse_iterator tmp = *this; --m_ptr; return tmp; } itor& operator--() { ++m_ptr; return *this; } const itor operator--(int) { itor tmp = *this; ++m_ptr; return tmp; } bool operator ==(const itor& it) const { return m_ptr == it.m_ptr; } bool operator !=(const itor& it) const { return m_ptr != it.m_ptr; } }; class const_reverse_iterator { typedef _wxArraywxArrayLong value_type; typedef const value_type& reference; typedef const value_type* pointer; typedef const_reverse_iterator itor; friend inline itor operator+(int o, const itor& it) { return it.m_ptr - o; } friend inline itor operator+(const itor& it, int o) { return it.m_ptr - o; } friend inline itor operator-(const itor& it, int o) { return it.m_ptr + o; } friend inline difference_type operator-(const itor& i1, const itor& i2) { return i1.m_ptr - i2.m_ptr; } public: pointer m_ptr; const_reverse_iterator() : m_ptr(__null) { } const_reverse_iterator(pointer ptr) : m_ptr(ptr) { } const_reverse_iterator(const itor& it) : m_ptr(it.m_ptr) { } const_reverse_iterator(const reverse_iterator& it) : m_ptr(it.m_ptr) { } reference operator*() const { return *m_ptr; } itor& operator++() { --m_ptr; return *this; } const itor operator++(int) { itor tmp = *this; --m_ptr; return tmp; } itor& operator--() { ++m_ptr; return *this; } const itor operator--(int) { itor tmp = *this; ++m_ptr; return tmp; } bool operator ==(const itor& it) const { return m_ptr == it.m_ptr; } bool operator !=(const itor& it) const { return m_ptr != it.m_ptr; } }; wxArrayLong(size_type n, const_reference v) { assign(n, v); } wxArrayLong(const_iterator first, const_iterator last) { assign(first, last); } void assign(const_iterator first, const_iterator last) { wxBaseArrayLong::assign((bconst_iterator)first, (bconst_iterator)last); } void assign(size_type n, const_reference v) { wxBaseArrayLong::assign(n, (bconst_reference)v); } reference back() { return *(end() - 1); } const_reference back() const { return *(end() - 1); } iterator begin() { return (iterator)wxBaseArrayLong::begin(); } const_iterator begin() const { return (const_iterator)wxBaseArrayLong::begin(); } size_type capacity() const { return wxBaseArrayLong::capacity(); } iterator end() { return (iterator)wxBaseArrayLong::end(); } const_iterator end() const { return (const_iterator)wxBaseArrayLong::end(); } iterator erase(iterator first, iterator last) { return (iterator)wxBaseArrayLong::erase((biterator)first, (biterator)last); } iterator erase(iterator it) { return (iterator)wxBaseArrayLong::erase((biterator)it); } reference front() { return *begin(); } const_reference front() const { return *begin(); } void insert(iterator it, size_type n, const_reference v) { wxBaseArrayLong::insert((biterator)it, n, (bconst_reference)v); } iterator insert(iterator it, const_reference v = value_type()) { return (iterator)wxBaseArrayLong::insert((biterator)it, (bconst_reference)v); } void insert(iterator it, const_iterator first, const_iterator last) { wxBaseArrayLong::insert((biterator)it, (bconst_iterator)first, (bconst_iterator)last); } void pop_back() { wxBaseArrayLong::pop_back(); } void push_back(const_reference v) { wxBaseArrayLong::push_back((bconst_reference)v); } reverse_iterator rbegin() { return reverse_iterator(end() - 1); } const_reverse_iterator rbegin() const; reverse_iterator rend() { return reverse_iterator(begin() - 1); } const_reverse_iterator rend() const; void reserve(size_type n) { wxBaseArrayLong::reserve(n); } void resize(size_type n, value_type v = value_type()) { wxBaseArrayLong::resize(n, v); } };
typedef void * _wxArraywxArrayPtrVoid; struct wxAssert_wxArrayPtrVoid { unsigned int TypeTooBigToBeStoredInwxBaseArrayPtrVoid: sizeof(_wxArraywxArrayPtrVoid) <= sizeof(wxBaseArrayPtrVoid::base_type); }; typedef int ( *CMPFUNC_wxArraywxArrayPtrVoid)(_wxArraywxArrayPtrVoid *pItem1, _wxArraywxArrayPtrVoid *pItem2); class wxArrayPtrVoid : public wxBaseArrayPtrVoid { public: wxArrayPtrVoid() { } ~wxArrayPtrVoid() { } wxArrayPtrVoid& operator=(const wxArrayPtrVoid& src) { wxBaseArrayPtrVoid* temp = (wxBaseArrayPtrVoid*) this; (*temp) = ((const wxBaseArrayPtrVoid&)src); return *this; } _wxArraywxArrayPtrVoid& operator[](size_t uiIndex) const { return (_wxArraywxArrayPtrVoid&)(wxBaseArrayPtrVoid::operator[](uiIndex)); } _wxArraywxArrayPtrVoid& Item(size_t uiIndex) const { return (_wxArraywxArrayPtrVoid&)(wxBaseArrayPtrVoid::operator[](uiIndex)); } _wxArraywxArrayPtrVoid& Last() const { return (_wxArraywxArrayPtrVoid&)(wxBaseArrayPtrVoid::operator[](Count() - 1)); } int Index(_wxArraywxArrayPtrVoid lItem, bool bFromEnd = false) const { return wxBaseArrayPtrVoid::Index((base_type)lItem, bFromEnd); } void Add(_wxArraywxArrayPtrVoid lItem, size_t nInsert = 1) { wxBaseArrayPtrVoid::Add((base_type)lItem, nInsert); } void Insert(_wxArraywxArrayPtrVoid lItem, size_t uiIndex, size_t nInsert = 1) { wxBaseArrayPtrVoid::Insert((base_type)lItem, uiIndex, nInsert) ; } void RemoveAt(size_t uiIndex, size_t nRemove = 1) { wxBaseArrayPtrVoid::RemoveAt(uiIndex, nRemove); } void Remove(_wxArraywxArrayPtrVoid lItem) { int iIndex = Index(lItem); if ( iIndex != (-1) ) ; else { ; return; } typedef int wxDummyCheckInt; wxBaseArrayPtrVoid::RemoveAt((size_t)iIndex); } void Sort(CMPFUNC_wxArraywxArrayPtrVoid fCmp) { wxBaseArrayPtrVoid::Sort((CMPFUNC)fCmp); } private: typedef wxBaseArrayPtrVoid::iterator biterator; typedef wxBaseArrayPtrVoid::const_iterator bconst_iterator; typedef wxBaseArrayPtrVoid::value_type bvalue_type; typedef wxBaseArrayPtrVoid::const_reference bconst_reference; public: typedef _wxArraywxArrayPtrVoid value_type; typedef value_type* pointer; typedef const value_type* const_pointer; typedef value_type* iterator; typedef const value_type* const_iterator; typedef value_type& reference; typedef const value_type& const_reference; typedef wxBaseArrayPtrVoid::difference_type difference_type; typedef wxBaseArrayPtrVoid::size_type size_type; class reverse_iterator { typedef _wxArraywxArrayPtrVoid value_type; typedef value_type& reference; typedef value_type* pointer; typedef reverse_iterator itor; friend inline itor operator+(int o, const itor& it) { return it.m_ptr - o; } friend inline itor operator+(const itor& it, int o) { return it.m_ptr - o; } friend inline itor operator-(const itor& it, int o) { return it.m_ptr + o; } friend inline difference_type operator-(const itor& i1, const itor& i2) { return i1.m_ptr - i2.m_ptr; } public: pointer m_ptr; reverse_iterator() : m_ptr(__null) { } reverse_iterator(pointer ptr) : m_ptr(ptr) { } reverse_iterator(const itor& it) : m_ptr(it.m_ptr) { } reference operator*() const { return *m_ptr; } itor& operator++() { --m_ptr; return *this; } const itor operator++(int) { reverse_iterator tmp = *this; --m_ptr; return tmp; } itor& operator--() { ++m_ptr; return *this; } const itor operator--(int) { itor tmp = *this; ++m_ptr; return tmp; } bool operator ==(const itor& it) const { return m_ptr == it.m_ptr; } bool operator !=(const itor& it) const { return m_ptr != it.m_ptr; } }; class const_reverse_iterator { typedef _wxArraywxArrayPtrVoid value_type; typedef const value_type& reference; typedef const value_type* pointer; typedef const_reverse_iterator itor; friend inline itor operator+(int o, const itor& it) { return it.m_ptr - o; } friend inline itor operator+(const itor& it, int o) { return it.m_ptr - o; } friend inline itor operator-(const itor& it, int o) { return it.m_ptr + o; } friend inline difference_type operator-(const itor& i1, const itor& i2) { return i1.m_ptr - i2.m_ptr; } public: pointer m_ptr; const_reverse_iterator() : m_ptr(__null) { } const_reverse_iterator(pointer ptr) : m_ptr(ptr) { } const_reverse_iterator(const itor& it) : m_ptr(it.m_ptr) { } const_reverse_iterator(const reverse_iterator& it) : m_ptr(it.m_ptr) { } reference operator*() const { return *m_ptr; } itor& operator++() { --m_ptr; return *this; } const itor operator++(int) { itor tmp = *this; --m_ptr; return tmp; } itor& operator--() { ++m_ptr; return *this; } const itor operator--(int) { itor tmp = *this; ++m_ptr; return tmp; } bool operator ==(const itor& it) const { return m_ptr == it.m_ptr; } bool operator !=(const itor& it) const { return m_ptr != it.m_ptr; } }; wxArrayPtrVoid(size_type n, const_reference v) { assign(n, v); } wxArrayPtrVoid(const_iterator first, const_iterator last) { assign(first, last); } void assign(const_iterator first, const_iterator last) { wxBaseArrayPtrVoid::assign((bconst_iterator)first, (bconst_iterator)last); } void assign(size_type n, const_reference v) { wxBaseArrayPtrVoid::assign(n, (bconst_reference)v); } reference back() { return *(end() - 1); } const_reference back() const { return *(end() - 1); } iterator begin() { return (iterator)wxBaseArrayPtrVoid::begin(); } const_iterator begin() const { return (const_iterator)wxBaseArrayPtrVoid::begin(); } size_type capacity() const { return wxBaseArrayPtrVoid::capacity(); } iterator end() { return (iterator)wxBaseArrayPtrVoid::end(); } const_iterator end() const { return (const_iterator)wxBaseArrayPtrVoid::end(); } iterator erase(iterator first, iterator last) { return (iterator)wxBaseArrayPtrVoid::erase((biterator)first, (biterator)last); } iterator erase(iterator it) { return (iterator)wxBaseArrayPtrVoid::erase((biterator)it); } reference front() { return *begin(); } const_reference front() const { return *begin(); } void insert(iterator it, size_type n, const_reference v) { wxBaseArrayPtrVoid::insert((biterator)it, n, (bconst_reference)v); } iterator insert(iterator it, const_reference v = value_type()) { return (iterator)wxBaseArrayPtrVoid::insert((biterator)it, (bconst_reference)v); } void insert(iterator it, const_iterator first, const_iterator last) { wxBaseArrayPtrVoid::insert((biterator)it, (bconst_iterator)first, (bconst_iterator)last); } void pop_back() { wxBaseArrayPtrVoid::pop_back(); } void push_back(const_reference v) { wxBaseArrayPtrVoid::push_back((bconst_reference)v); } reverse_iterator rbegin() { return reverse_iterator(end() - 1); } const_reverse_iterator rbegin() const; reverse_iterator rend() { return reverse_iterator(begin() - 1); } const_reverse_iterator rend() const; void reserve(size_type n) { wxBaseArrayPtrVoid::reserve(n); } void resize(size_type n, value_type v = value_type()) { wxBaseArrayPtrVoid::resize(n, v); } };
# 18 "/usr/include/wx-2.8/wx/wx.h" 2
# 1 "/usr/include/wx-2.8/wx/list.h" 1
# 52 "/usr/include/wx-2.8/wx/list.h"
extern "C"
{
typedef int (* wxSortCompareFunction)(const void *elem1, const void *elem2);
}

class wxObjectListNode;
typedef wxObjectListNode wxNode;


typedef int (* wxListIterateFunction)(void *current);
# 70 "/usr/include/wx-2.8/wx/list.h"
enum wxKeyType
{
    wxKEY_NONE,
    wxKEY_INTEGER,
    wxKEY_STRING
};
# 385 "/usr/include/wx-2.8/wx/list.h"
union wxListKeyValue
{
    long integer;
    wxChar *string;
};







class wxListKey
{
public:

    wxListKey() : m_keyType(wxKEY_NONE)
        { }
    wxListKey(long i) : m_keyType(wxKEY_INTEGER)
        { m_key.integer = i; }
    wxListKey(const wxChar *s) : m_keyType(wxKEY_STRING)
        { m_key.string = wxStrdupW(s); }
    wxListKey(const wxString& s) : m_keyType(wxKEY_STRING)
        { m_key.string = wxStrdupW(s.c_str()); }


    wxKeyType GetKeyType() const { return m_keyType; }
    const wxChar *GetString() const
        { ; return m_key.string; }
    long GetNumber() const
        { ; return m_key.integer; }




    bool operator==(wxListKeyValue value) const ;


    ~wxListKey()
    {
        if ( m_keyType == wxKEY_STRING )
            free(m_key.string);
    }

private:
    wxKeyType m_keyType;
    wxListKeyValue m_key;
};





extern wxListKey wxDefaultListKey;

class wxListBase;

class wxNodeBase
{
friend class wxListBase;
public:

    wxNodeBase(wxListBase *list = (wxListBase *)__null,
               wxNodeBase *previous = (wxNodeBase *)__null,
               wxNodeBase *next = (wxNodeBase *)__null,
               void *data = __null,
               const wxListKey& key = wxDefaultListKey);

    virtual ~wxNodeBase();


    const wxChar *GetKeyString() const { return m_key.string; }
    long GetKeyInteger() const { return m_key.integer; }


    void SetKeyString(wxChar* s) { m_key.string = s; }
    void SetKeyInteger(long i) { m_key.integer = i; }



    wxNode *Next() const __attribute__ ((deprecated));
    wxNode *Previous() const __attribute__ ((deprecated));
    wxObject *Data() const __attribute__ ((deprecated));


protected:

    wxNodeBase *GetNext() const { return m_next; }
    wxNodeBase *GetPrevious() const { return m_previous; }

    void *GetData() const { return m_data; }
    void SetData(void *data) { m_data = data; }


    int IndexOf() const;

    virtual void DeleteData() { }
public:

    void** GetDataPtr() const { return &(((wxNodeBase*)this)->m_data); }
private:

    wxListKeyValue m_key;

    void *m_data;
    wxNodeBase *m_next,
                *m_previous;

    wxListBase *m_list;

    private: wxNodeBase(const wxNodeBase&); wxNodeBase& operator=(const wxNodeBase&);
};





class wxList;

class wxListBase : public wxObject
{
friend class wxNodeBase;
friend class wxHashTableBase;

public:

    wxListBase(wxKeyType keyType = wxKEY_NONE)
        { Init(keyType); }
    virtual ~wxListBase();



    size_t GetCount() const { return m_count; }


    bool IsEmpty() const { return m_count == 0; }




    void Clear();


    void DeleteContents(bool destroy) { m_destroy = destroy; }


    bool GetDeleteContents() const
        { return m_destroy; }


    wxKeyType GetKeyType() const
        { return m_keyType; }


    void SetKeyType(wxKeyType keyType)
        { ; m_keyType = keyType; }



    int Number() const __attribute__ ((deprecated));
    wxNode *First() const __attribute__ ((deprecated));
    wxNode *Last() const __attribute__ ((deprecated));
    wxNode *Nth(size_t n) const __attribute__ ((deprecated));


    operator wxList&() const __attribute__ ((deprecated));


protected:





    virtual wxNodeBase *CreateNode(wxNodeBase *prev, wxNodeBase *next,
                                   void *data,
                                   const wxListKey& key = wxDefaultListKey) = 0;
# 570 "/usr/include/wx-2.8/wx/list.h"
    wxListBase(size_t count, void *elements[]);

    wxListBase(void *object, ... );

protected:
    void Assign(const wxListBase& list)
        { Clear(); DoCopy(list); }


    wxNodeBase *GetFirst() const { return m_nodeFirst; }
    wxNodeBase *GetLast() const { return m_nodeLast; }


    wxNodeBase *Item(size_t index) const;


    void *operator[](size_t n) const
    {
        wxNodeBase *node = Item(n);

        return node ? node->GetData() : (wxNodeBase *)__null;
    }



    wxNodeBase *Prepend(void *object)
        { return (wxNodeBase *)wxListBase::Insert(object); }

    wxNodeBase *Append(void *object);

    wxNodeBase *Insert(void *object) { return Insert( (wxNodeBase*)__null, object); }

    wxNodeBase *Insert(size_t pos, void *object)
        { return pos == GetCount() ? Append(object)
                                   : Insert(Item(pos), object); }

    wxNodeBase *Insert(wxNodeBase *prev, void *object);


    wxNodeBase *Append(long key, void *object);
    wxNodeBase *Append(const wxChar *key, void *object);



    wxNodeBase *DetachNode(wxNodeBase *node);

    bool DeleteNode(wxNodeBase *node);


    bool DeleteObject(void *object);



    wxNodeBase *Find(const void *object) const;


    wxNodeBase *Find(const wxListKey& key) const;


    int IndexOf( void *object ) const;



    void Sort(const wxSortCompareFunction compfunc);


    void *FirstThat(wxListIterateFunction func);
    void ForEach(wxListIterateFunction func);
    void *LastThat(wxListIterateFunction func);



    void Reverse();
    void DeleteNodes(wxNodeBase* first, wxNodeBase* last);
private:


    void Init(wxKeyType keyType = wxKEY_NONE);



    void DoCopy(const wxListBase& list);

    wxNodeBase *AppendCommon(wxNodeBase *node);

    void DoDeleteNode(wxNodeBase *node);

    size_t m_count;
    bool m_destroy;
    wxNodeBase *m_nodeFirst,
               *m_nodeLast;

    wxKeyType m_keyType;
};
# 1162 "/usr/include/wx-2.8/wx/list.h"
inline wxNode *wxNodeBase::Next() const { return (wxNode *)GetNext(); }
inline wxNode *wxNodeBase::Previous() const { return (wxNode *)GetPrevious(); }
inline wxObject *wxNodeBase::Data() const { return (wxObject *)GetData(); }





inline int wxListBase::Number() const { return (int)GetCount(); }
inline wxNode *wxListBase::First() const { return (wxNode *)GetFirst(); }
inline wxNode *wxListBase::Last() const { return (wxNode *)GetLast(); }
inline wxNode *wxListBase::Nth(size_t n) const { return (wxNode *)Item(n); }
inline wxListBase::operator wxList&() const { return *(wxList*)this; }
# 1185 "/usr/include/wx-2.8/wx/list.h"
typedef int (*wxSortFuncFor_wxObjectList)(const wxObject **, const wxObject **); class wxObjectListNode : public wxNodeBase { public: wxObjectListNode(wxListBase *list = (wxListBase *)__null, wxObjectListNode *previous = (wxObjectListNode *)__null, wxObjectListNode *next = (wxObjectListNode *)__null, wxObject *data = (wxObject *)__null, const wxListKey& key = wxDefaultListKey) : wxNodeBase(list, previous, next, data, key) { } wxObjectListNode *GetNext() const { return (wxObjectListNode *)wxNodeBase::GetNext(); } wxObjectListNode *GetPrevious() const { return (wxObjectListNode *)wxNodeBase::GetPrevious(); } wxObject *GetData() const { return (wxObject *)wxNodeBase::GetData(); } void SetData(wxObject *data) { wxNodeBase::SetData(data); } protected: virtual void DeleteData(); private: wxObjectListNode(const wxObjectListNode&); wxObjectListNode& operator=(const wxObjectListNode&); }; class wxObjectList : public wxListBase { public: typedef wxObjectListNode Node; class compatibility_iterator { public: compatibility_iterator(Node *ptr = __null) : m_ptr(ptr) { } Node *operator->() const { return m_ptr; } operator Node *() const { return m_ptr; } private: Node *m_ptr; }; wxObjectList(wxKeyType keyType = wxKEY_NONE) : wxListBase(keyType) { } wxObjectList(const wxObjectList& list) : wxListBase(list.GetKeyType()) { Assign(list); } wxObjectList(size_t count, wxObject *elements[]) : wxListBase(count, (void **)elements) { } wxObjectList& operator=(const wxObjectList& list) { Assign(list); return *this; } wxObjectListNode *GetFirst() const { return (wxObjectListNode *)wxListBase::GetFirst(); } wxObjectListNode *GetLast() const { return (wxObjectListNode *)wxListBase::GetLast(); } wxObjectListNode *Item(size_t index) const { return (wxObjectListNode *)wxListBase::Item(index); } wxObject *operator[](size_t index) const { wxObjectListNode *node = Item(index); return node ? (wxObject*)(node->GetData()) : (wxObject*)__null; } wxObjectListNode *Append(wxObject *object) { return (wxObjectListNode *)wxListBase::Append(object); } wxObjectListNode *Insert(wxObject *object) { return (wxObjectListNode *)Insert((wxObjectListNode*)__null, object); } wxObjectListNode *Insert(size_t pos, wxObject *object) { return (wxObjectListNode *)wxListBase::Insert(pos, object); } wxObjectListNode *Insert(wxObjectListNode *prev, wxObject *object) { return (wxObjectListNode *)wxListBase::Insert(prev, object); } wxObjectListNode *Append(long key, void *object) { return (wxObjectListNode *)wxListBase::Append(key, object); } wxObjectListNode *Append(const wxChar *key, void *object) { return (wxObjectListNode *)wxListBase::Append(key, object); } wxObjectListNode *DetachNode(wxObjectListNode *node) { return (wxObjectListNode *)wxListBase::DetachNode(node); } bool DeleteNode(wxObjectListNode *node) { return wxListBase::DeleteNode(node); } bool DeleteObject(wxObject *object) { return wxListBase::DeleteObject(object); } void Erase(wxObjectListNode *it) { DeleteNode(it); } wxObjectListNode *Find(const wxObject *object) const { return (wxObjectListNode *)wxListBase::Find(object); } virtual wxObjectListNode *Find(const wxListKey& key) const { return (wxObjectListNode *)wxListBase::Find(key); } int IndexOf(wxObject *object) const { return wxListBase::IndexOf(object); } void Sort(wxSortCompareFunction func) { wxListBase::Sort(func); } void Sort(wxSortFuncFor_wxObjectList func) { Sort((wxSortCompareFunction)func); } protected: virtual wxNodeBase *CreateNode(wxNodeBase *prev, wxNodeBase *next, void *data, const wxListKey& key = wxDefaultListKey) { return new wxObjectListNode(this, (wxObjectListNode *)prev, (wxObjectListNode *)next, (wxObject *)data, key); } public: typedef size_t size_type; typedef int difference_type; typedef wxObject* value_type; typedef wxObject* base_value_type; typedef value_type& reference; typedef const value_type& const_reference; typedef base_value_type& base_reference; typedef const base_value_type& const_base_reference; class iterator { typedef wxObjectList list; public: typedef wxObjectListNode Node; typedef iterator itor; typedef wxObject* value_type; typedef value_type* ptr_type; typedef value_type& reference; Node* m_node; Node* m_init; public: typedef reference reference_type; typedef ptr_type pointer_type; iterator(Node* node, Node* init) : m_node(node), m_init(init) {} iterator() : m_node(__null), m_init(__null) { } reference_type operator*() const { return *(pointer_type)m_node->GetDataPtr(); } itor& operator++() { m_node = m_node->GetNext(); return *this; } const itor operator++(int) { itor tmp = *this; m_node = m_node->GetNext(); return tmp; } itor& operator--() { m_node = m_node ? m_node->GetPrevious() : m_init; return *this; } const itor operator--(int) { itor tmp = *this; m_node = m_node ? m_node->GetPrevious() : m_init; return tmp; } bool operator!=(const itor& it) const { return it.m_node != m_node; } bool operator==(const itor& it) const { return it.m_node == m_node; } }; class const_iterator { typedef wxObjectList list; public: typedef wxObjectListNode Node; typedef wxObject* value_type; typedef const value_type& const_reference; typedef const_iterator itor; typedef value_type* ptr_type; Node* m_node; Node* m_init; public: typedef const_reference reference_type; typedef const ptr_type pointer_type; const_iterator(Node* node, Node* init) : m_node(node), m_init(init) { } const_iterator() : m_node(__null), m_init(__null) { } const_iterator(const iterator& it) : m_node(it.m_node), m_init(it.m_init) { } reference_type operator*() const { return *(pointer_type)m_node->GetDataPtr(); } itor& operator++() { m_node = m_node->GetNext(); return *this; } const itor operator++(int) { itor tmp = *this; m_node = m_node->GetNext(); return tmp; } itor& operator--() { m_node = m_node ? m_node->GetPrevious() : m_init; return *this; } const itor operator--(int) { itor tmp = *this; m_node = m_node ? m_node->GetPrevious() : m_init; return tmp; } bool operator!=(const itor& it) const { return it.m_node != m_node; } bool operator==(const itor& it) const { return it.m_node == m_node; } }; class reverse_iterator { typedef wxObjectList list; public: typedef wxObjectListNode Node; typedef wxObject* value_type; typedef reverse_iterator itor; typedef value_type* ptr_type; typedef value_type& reference; Node* m_node; Node* m_init; public: typedef reference reference_type; typedef ptr_type pointer_type; reverse_iterator(Node* node, Node* init) : m_node(node), m_init(init) { } reverse_iterator() : m_node(__null), m_init(__null) { } reference_type operator*() const { return *(pointer_type)m_node->GetDataPtr(); } itor& operator++() { m_node = m_node->GetPrevious(); return *this; } const itor operator++(int) { itor tmp = *this; m_node = m_node->GetPrevious(); return tmp; } itor& operator--() { m_node = m_node ? m_node->GetNext() : m_init; return *this; } const itor operator--(int) { itor tmp = *this; m_node = m_node ? m_node->GetNext() : m_init; return tmp; } bool operator!=(const itor& it) const { return it.m_node != m_node; } bool operator==(const itor& it) const { return it.m_node == m_node; } }; class const_reverse_iterator { typedef wxObjectList list; public: typedef wxObjectListNode Node; typedef wxObject* value_type; typedef const_reverse_iterator itor; typedef value_type* ptr_type; typedef const value_type& const_reference; Node* m_node; Node* m_init; public: typedef const_reference reference_type; typedef const ptr_type pointer_type; const_reverse_iterator(Node* node, Node* init) : m_node(node), m_init(init) { } const_reverse_iterator() : m_node(__null), m_init(__null) { } const_reverse_iterator(const reverse_iterator& it) : m_node(it.m_node), m_init(it.m_init) { } reference_type operator*() const { return *(pointer_type)m_node->GetDataPtr(); } itor& operator++() { m_node = m_node->GetPrevious(); return *this; } const itor operator++(int) { itor tmp = *this; m_node = m_node->GetPrevious(); return tmp; } itor& operator--() { m_node = m_node ? m_node->GetNext() : m_init; return *this;} const itor operator--(int) { itor tmp = *this; m_node = m_node ? m_node->GetNext() : m_init; return tmp; } bool operator!=(const itor& it) const { return it.m_node != m_node; } bool operator==(const itor& it) const { return it.m_node == m_node; } }; explicit wxObjectList(size_type n, const_reference v = value_type()) { assign(n, v); } wxObjectList(const const_iterator& first, const const_iterator& last) { assign(first, last); } iterator begin() { return iterator(GetFirst(), GetLast()); } const_iterator begin() const { return const_iterator(GetFirst(), GetLast()); } iterator end() { return iterator(__null, GetLast()); } const_iterator end() const { return const_iterator(__null, GetLast()); } reverse_iterator rbegin() { return reverse_iterator(GetLast(), GetFirst()); } const_reverse_iterator rbegin() const { return const_reverse_iterator(GetLast(), GetFirst()); } reverse_iterator rend() { return reverse_iterator(__null, GetFirst()); } const_reverse_iterator rend() const { return const_reverse_iterator(__null, GetFirst()); } void resize(size_type n, value_type v = value_type()) { while (n < size()) pop_back(); while (n > size()) push_back(v); } size_type size() const { return GetCount(); } size_type max_size() const { return 2147483647; } bool empty() const { return IsEmpty(); } reference front() { return *begin(); } const_reference front() const { return *begin(); } reference back() { iterator tmp = end(); return *--tmp; } const_reference back() const { const_iterator tmp = end(); return *--tmp; } void push_front(const_reference v = value_type()) { Insert(GetFirst(), (const_base_reference)v); } void pop_front() { DeleteNode(GetFirst()); } void push_back(const_reference v = value_type()) { Append((const_base_reference)v); } void pop_back() { DeleteNode(GetLast()); } void assign(const_iterator first, const const_iterator& last) { clear(); for(; first != last; ++first) Append((const_base_reference)*first); } void assign(size_type n, const_reference v = value_type()) { clear(); for(size_type i = 0; i < n; ++i) Append((const_base_reference)v); } iterator insert(const iterator& it, const_reference v = value_type()) { if ( it == end() ) Append((const_base_reference)v); else Insert(it.m_node, (const_base_reference)v); iterator itprev(it); return itprev--; } void insert(const iterator& it, size_type n, const_reference v = value_type()) { for(size_type i = 0; i < n; ++i) insert(it, v); } void insert(const iterator& it, const_iterator first, const const_iterator& last) { for(; first != last; ++first) insert(it, *first); } iterator erase(const iterator& it) { iterator next = iterator(it.m_node->GetNext(), GetLast()); DeleteNode(it.m_node); return next; } iterator erase(const iterator& first, const iterator& last) { iterator next = last; if ( next != end() ) ++next; DeleteNodes(first.m_node, last.m_node); return next; } void clear() { Clear(); } void splice(const iterator& it, wxObjectList& l, const iterator& first, const iterator& last) { insert(it, first, last); l.erase(first, last); } void splice(const iterator& it, wxObjectList& l) { splice(it, l, l.begin(), l.end() ); } void splice(const iterator& it, wxObjectList& l, const iterator& first) { if ( it != first ) { insert(it, *first); l.erase(first); } } void remove(const_reference v) { DeleteObject((const_base_reference)v); } void reverse() { Reverse(); } };


class wxList : public wxObjectList
{
public:




    wxList(int key_type = wxKEY_NONE);



   ~wxList() { }


    wxList& operator=(const wxList& list)
        { (void) wxListBase::operator=(list); return *this; }


    void Sort(wxSortCompareFunction compfunc) { wxListBase::Sort(compfunc); }




    wxNode *Member(wxObject *object) const { return (wxNode *)Find(object); }


private:

    public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();

};






typedef int (*wxSortFuncFor_wxStringListBase)(const wxChar **, const wxChar **); class wxStringListNode : public wxNodeBase { public: wxStringListNode(wxListBase *list = (wxListBase *)__null, wxStringListNode *previous = (wxStringListNode *)__null, wxStringListNode *next = (wxStringListNode *)__null, wxChar *data = (wxChar *)__null, const wxListKey& key = wxDefaultListKey) : wxNodeBase(list, previous, next, data, key) { } wxStringListNode *GetNext() const { return (wxStringListNode *)wxNodeBase::GetNext(); } wxStringListNode *GetPrevious() const { return (wxStringListNode *)wxNodeBase::GetPrevious(); } wxChar *GetData() const { return (wxChar *)wxNodeBase::GetData(); } void SetData(wxChar *data) { wxNodeBase::SetData(data); } protected: virtual void DeleteData(); private: wxStringListNode(const wxStringListNode&); wxStringListNode& operator=(const wxStringListNode&); }; class wxStringListBase : public wxListBase { public: typedef wxStringListNode Node; class compatibility_iterator { public: compatibility_iterator(Node *ptr = __null) : m_ptr(ptr) { } Node *operator->() const { return m_ptr; } operator Node *() const { return m_ptr; } private: Node *m_ptr; }; wxStringListBase(wxKeyType keyType = wxKEY_NONE) : wxListBase(keyType) { } wxStringListBase(const wxStringListBase& list) : wxListBase(list.GetKeyType()) { Assign(list); } wxStringListBase(size_t count, wxChar *elements[]) : wxListBase(count, (void **)elements) { } wxStringListBase& operator=(const wxStringListBase& list) { Assign(list); return *this; } wxStringListNode *GetFirst() const { return (wxStringListNode *)wxListBase::GetFirst(); } wxStringListNode *GetLast() const { return (wxStringListNode *)wxListBase::GetLast(); } wxStringListNode *Item(size_t index) const { return (wxStringListNode *)wxListBase::Item(index); } wxChar *operator[](size_t index) const { wxStringListNode *node = Item(index); return node ? (wxChar*)(node->GetData()) : (wxChar*)__null; } wxStringListNode *Append(wxChar *object) { return (wxStringListNode *)wxListBase::Append(object); } wxStringListNode *Insert(wxChar *object) { return (wxStringListNode *)Insert((wxStringListNode*)__null, object); } wxStringListNode *Insert(size_t pos, wxChar *object) { return (wxStringListNode *)wxListBase::Insert(pos, object); } wxStringListNode *Insert(wxStringListNode *prev, wxChar *object) { return (wxStringListNode *)wxListBase::Insert(prev, object); } wxStringListNode *Append(long key, void *object) { return (wxStringListNode *)wxListBase::Append(key, object); } wxStringListNode *Append(const wxChar *key, void *object) { return (wxStringListNode *)wxListBase::Append(key, object); } wxStringListNode *DetachNode(wxStringListNode *node) { return (wxStringListNode *)wxListBase::DetachNode(node); } bool DeleteNode(wxStringListNode *node) { return wxListBase::DeleteNode(node); } bool DeleteObject(wxChar *object) { return wxListBase::DeleteObject(object); } void Erase(wxStringListNode *it) { DeleteNode(it); } wxStringListNode *Find(const wxChar *object) const { return (wxStringListNode *)wxListBase::Find(object); } virtual wxStringListNode *Find(const wxListKey& key) const { return (wxStringListNode *)wxListBase::Find(key); } int IndexOf(wxChar *object) const { return wxListBase::IndexOf(object); } void Sort(wxSortCompareFunction func) { wxListBase::Sort(func); } void Sort(wxSortFuncFor_wxStringListBase func) { Sort((wxSortCompareFunction)func); } protected: virtual wxNodeBase *CreateNode(wxNodeBase *prev, wxNodeBase *next, void *data, const wxListKey& key = wxDefaultListKey) { return new wxStringListNode(this, (wxStringListNode *)prev, (wxStringListNode *)next, (wxChar *)data, key); } public: typedef size_t size_type; typedef int difference_type; typedef wxChar* value_type; typedef wxChar* base_value_type; typedef value_type& reference; typedef const value_type& const_reference; typedef base_value_type& base_reference; typedef const base_value_type& const_base_reference; class iterator { typedef wxStringListBase list; public: typedef wxStringListNode Node; typedef iterator itor; typedef wxChar* value_type; typedef value_type* ptr_type; typedef value_type& reference; Node* m_node; Node* m_init; public: typedef reference reference_type; typedef ptr_type pointer_type; iterator(Node* node, Node* init) : m_node(node), m_init(init) {} iterator() : m_node(__null), m_init(__null) { } reference_type operator*() const { return *(pointer_type)m_node->GetDataPtr(); } itor& operator++() { m_node = m_node->GetNext(); return *this; } const itor operator++(int) { itor tmp = *this; m_node = m_node->GetNext(); return tmp; } itor& operator--() { m_node = m_node ? m_node->GetPrevious() : m_init; return *this; } const itor operator--(int) { itor tmp = *this; m_node = m_node ? m_node->GetPrevious() : m_init; return tmp; } bool operator!=(const itor& it) const { return it.m_node != m_node; } bool operator==(const itor& it) const { return it.m_node == m_node; } }; class const_iterator { typedef wxStringListBase list; public: typedef wxStringListNode Node; typedef wxChar* value_type; typedef const value_type& const_reference; typedef const_iterator itor; typedef value_type* ptr_type; Node* m_node; Node* m_init; public: typedef const_reference reference_type; typedef const ptr_type pointer_type; const_iterator(Node* node, Node* init) : m_node(node), m_init(init) { } const_iterator() : m_node(__null), m_init(__null) { } const_iterator(const iterator& it) : m_node(it.m_node), m_init(it.m_init) { } reference_type operator*() const { return *(pointer_type)m_node->GetDataPtr(); } itor& operator++() { m_node = m_node->GetNext(); return *this; } const itor operator++(int) { itor tmp = *this; m_node = m_node->GetNext(); return tmp; } itor& operator--() { m_node = m_node ? m_node->GetPrevious() : m_init; return *this; } const itor operator--(int) { itor tmp = *this; m_node = m_node ? m_node->GetPrevious() : m_init; return tmp; } bool operator!=(const itor& it) const { return it.m_node != m_node; } bool operator==(const itor& it) const { return it.m_node == m_node; } }; class reverse_iterator { typedef wxStringListBase list; public: typedef wxStringListNode Node; typedef wxChar* value_type; typedef reverse_iterator itor; typedef value_type* ptr_type; typedef value_type& reference; Node* m_node; Node* m_init; public: typedef reference reference_type; typedef ptr_type pointer_type; reverse_iterator(Node* node, Node* init) : m_node(node), m_init(init) { } reverse_iterator() : m_node(__null), m_init(__null) { } reference_type operator*() const { return *(pointer_type)m_node->GetDataPtr(); } itor& operator++() { m_node = m_node->GetPrevious(); return *this; } const itor operator++(int) { itor tmp = *this; m_node = m_node->GetPrevious(); return tmp; } itor& operator--() { m_node = m_node ? m_node->GetNext() : m_init; return *this; } const itor operator--(int) { itor tmp = *this; m_node = m_node ? m_node->GetNext() : m_init; return tmp; } bool operator!=(const itor& it) const { return it.m_node != m_node; } bool operator==(const itor& it) const { return it.m_node == m_node; } }; class const_reverse_iterator { typedef wxStringListBase list; public: typedef wxStringListNode Node; typedef wxChar* value_type; typedef const_reverse_iterator itor; typedef value_type* ptr_type; typedef const value_type& const_reference; Node* m_node; Node* m_init; public: typedef const_reference reference_type; typedef const ptr_type pointer_type; const_reverse_iterator(Node* node, Node* init) : m_node(node), m_init(init) { } const_reverse_iterator() : m_node(__null), m_init(__null) { } const_reverse_iterator(const reverse_iterator& it) : m_node(it.m_node), m_init(it.m_init) { } reference_type operator*() const { return *(pointer_type)m_node->GetDataPtr(); } itor& operator++() { m_node = m_node->GetPrevious(); return *this; } const itor operator++(int) { itor tmp = *this; m_node = m_node->GetPrevious(); return tmp; } itor& operator--() { m_node = m_node ? m_node->GetNext() : m_init; return *this;} const itor operator--(int) { itor tmp = *this; m_node = m_node ? m_node->GetNext() : m_init; return tmp; } bool operator!=(const itor& it) const { return it.m_node != m_node; } bool operator==(const itor& it) const { return it.m_node == m_node; } }; explicit wxStringListBase(size_type n, const_reference v = value_type()) { assign(n, v); } wxStringListBase(const const_iterator& first, const const_iterator& last) { assign(first, last); } iterator begin() { return iterator(GetFirst(), GetLast()); } const_iterator begin() const { return const_iterator(GetFirst(), GetLast()); } iterator end() { return iterator(__null, GetLast()); } const_iterator end() const { return const_iterator(__null, GetLast()); } reverse_iterator rbegin() { return reverse_iterator(GetLast(), GetFirst()); } const_reverse_iterator rbegin() const { return const_reverse_iterator(GetLast(), GetFirst()); } reverse_iterator rend() { return reverse_iterator(__null, GetFirst()); } const_reverse_iterator rend() const { return const_reverse_iterator(__null, GetFirst()); } void resize(size_type n, value_type v = value_type()) { while (n < size()) pop_back(); while (n > size()) push_back(v); } size_type size() const { return GetCount(); } size_type max_size() const { return 2147483647; } bool empty() const { return IsEmpty(); } reference front() { return *begin(); } const_reference front() const { return *begin(); } reference back() { iterator tmp = end(); return *--tmp; } const_reference back() const { const_iterator tmp = end(); return *--tmp; } void push_front(const_reference v = value_type()) { Insert(GetFirst(), (const_base_reference)v); } void pop_front() { DeleteNode(GetFirst()); } void push_back(const_reference v = value_type()) { Append((const_base_reference)v); } void pop_back() { DeleteNode(GetLast()); } void assign(const_iterator first, const const_iterator& last) { clear(); for(; first != last; ++first) Append((const_base_reference)*first); } void assign(size_type n, const_reference v = value_type()) { clear(); for(size_type i = 0; i < n; ++i) Append((const_base_reference)v); } iterator insert(const iterator& it, const_reference v = value_type()) { if ( it == end() ) Append((const_base_reference)v); else Insert(it.m_node, (const_base_reference)v); iterator itprev(it); return itprev--; } void insert(const iterator& it, size_type n, const_reference v = value_type()) { for(size_type i = 0; i < n; ++i) insert(it, v); } void insert(const iterator& it, const_iterator first, const const_iterator& last) { for(; first != last; ++first) insert(it, *first); } iterator erase(const iterator& it) { iterator next = iterator(it.m_node->GetNext(), GetLast()); DeleteNode(it.m_node); return next; } iterator erase(const iterator& first, const iterator& last) { iterator next = last; if ( next != end() ) ++next; DeleteNodes(first.m_node, last.m_node); return next; } void clear() { Clear(); } void splice(const iterator& it, wxStringListBase& l, const iterator& first, const iterator& last) { insert(it, first, last); l.erase(first, last); } void splice(const iterator& it, wxStringListBase& l) { splice(it, l, l.begin(), l.end() ); } void splice(const iterator& it, wxStringListBase& l, const iterator& first) { if ( it != first ) { insert(it, *first); l.erase(first); } } void remove(const_reference v) { DeleteObject((const_base_reference)v); } void reverse() { Reverse(); } };

class wxStringList : public wxStringListBase
{
public:






    wxStringList();
    wxStringList(const wxChar *first ...);




    wxStringList(const wxStringList& other) : wxStringListBase() { DeleteContents(true); DoCopy(other); }
    wxStringList& operator=(const wxStringList& other)
        { Clear(); DoCopy(other); return *this; }



    wxNode *Add(const wxChar *s);


    wxNode *Prepend(const wxChar *s);

    bool Delete(const wxChar *s);

    wxChar **ListToArray(bool new_copies = false) const;
    bool Member(const wxChar *s) const;


    void Sort();

private:
    void DoCopy(const wxStringList&);

    public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};
# 19 "/usr/include/wx-2.8/wx/wx.h" 2
# 1 "/usr/include/wx-2.8/wx/hash.h" 1
# 104 "/usr/include/wx-2.8/wx/hash.h"
union wxHashKeyValue
{
    long integer;
    wxChar *string;
};



class wxHashTableBase;

class wxHashTableBase_Node
{
    friend class wxHashTableBase;
    typedef class wxHashTableBase_Node _Node;
public:
    wxHashTableBase_Node( long key, void* value,
                          wxHashTableBase* table );
    wxHashTableBase_Node( const wxChar* key, void* value,
                          wxHashTableBase* table );
    ~wxHashTableBase_Node();

    long GetKeyInteger() const { return m_key.integer; }
    const wxChar* GetKeyString() const { return m_key.string; }

    void* GetData() const { return m_value; }
    void SetData( void* data ) { m_value = data; }

protected:
    _Node* GetNext() const { return m_next; }

protected:

    wxHashTableBase_Node* m_next;


    wxHashKeyValue m_key;


    void* m_value;






    wxHashTableBase* m_hashPtr;
};

class wxHashTableBase

    : public wxObject

{
    friend class wxHashTableBase_Node;
public:
    typedef wxHashTableBase_Node Node;

    wxHashTableBase();
    virtual ~wxHashTableBase() { }

    void Create( wxKeyType keyType = wxKEY_INTEGER,
                 size_t size = (1000) );
    void Clear();
    void Destroy();

    size_t GetSize() const { return m_size; }
    size_t GetCount() const { return m_count; }

    void DeleteContents( bool flag ) { m_deleteContents = flag; }

    static long MakeKey(const wxChar *string);

protected:
    void DoPut( long key, long hash, void* data );
    void DoPut( const wxChar* key, long hash, void* data );
    void* DoGet( long key, long hash ) const;
    void* DoGet( const wxChar* key, long hash ) const;
    void* DoDelete( long key, long hash );
    void* DoDelete( const wxChar* key, long hash );

private:


    void DoRemoveNode( wxHashTableBase_Node* node );




    void DoDestroyNode( wxHashTableBase_Node* node );


    void DoInsertNode( size_t bucket, wxHashTableBase_Node* node );



    void DoUnlinkNode( size_t bucket, wxHashTableBase_Node* node,
                       wxHashTableBase_Node* prev );



    virtual void DoDeleteContents( wxHashTableBase_Node* node ) = 0;

protected:

    size_t m_size;


    size_t m_count;


    Node** m_table;


    wxKeyType m_keyType;


    bool m_deleteContents;

private:
    private: wxHashTableBase(const wxHashTableBase&); wxHashTableBase& operator=(const wxHashTableBase&);
};
# 313 "/usr/include/wx-2.8/wx/hash.h"
class wxHashTable_Node : public wxHashTableBase_Node
{
    friend class wxHashTable;
public:
    wxHashTable_Node( long key, void* value,
                      wxHashTableBase* table )
        : wxHashTableBase_Node( key, value, table ) { }
    wxHashTable_Node( const wxChar* key, void* value,
                      wxHashTableBase* table )
        : wxHashTableBase_Node( key, value, table ) { }

    wxObject* GetData() const
        { return (wxObject*)wxHashTableBase_Node::GetData(); }
    void SetData( wxObject* data )
        { wxHashTableBase_Node::SetData( data ); }

    wxHashTable_Node* GetNext() const
        { return (wxHashTable_Node*)wxHashTableBase_Node::GetNext(); }
};



class wxHashTable : public wxHashTableBase
{
    typedef wxHashTableBase hash;
public:
    typedef wxHashTable_Node Node;
    typedef wxHashTable_Node* compatibility_iterator;
public:
    wxHashTable( wxKeyType keyType = wxKEY_INTEGER,
                 size_t size = (1000) )
        : wxHashTableBase() { Create( keyType, size ); BeginFind(); }
    wxHashTable( const wxHashTable& table );

    virtual ~wxHashTable() { Destroy(); }

    const wxHashTable& operator=( const wxHashTable& );


    void Put(long value, wxObject *object)
        { DoPut( value, value, object ); }
    void Put(long lhash, long value, wxObject *object)
        { DoPut( value, lhash, object ); }
    void Put(const wxChar *value, wxObject *object)
        { DoPut( value, MakeKey( value ), object ); }
    void Put(long lhash, const wxChar *value, wxObject *object)
        { DoPut( value, lhash, object ); }


    wxObject *Get(long value) const
        { return (wxObject*)DoGet( value, value ); }
    wxObject *Get(long lhash, long value) const
        { return (wxObject*)DoGet( value, lhash ); }
    wxObject *Get(const wxChar *value) const
        { return (wxObject*)DoGet( value, MakeKey( value ) ); }
    wxObject *Get(long lhash, const wxChar *value) const
        { return (wxObject*)DoGet( value, lhash ); }


    wxObject *Delete(long key)
        { return (wxObject*)DoDelete( key, key ); }
    wxObject *Delete(long lhash, long key)
        { return (wxObject*)DoDelete( key, lhash ); }
    wxObject *Delete(const wxChar *key)
        { return (wxObject*)DoDelete( key, MakeKey( key ) ); }
    wxObject *Delete(long lhash, const wxChar *key)
        { return (wxObject*)DoDelete( key, lhash ); }



    long MakeKey(const wxChar *string) const
        { return wxHashTableBase::MakeKey(string); }




    void BeginFind() { m_curr = __null; m_currBucket = 0; }
    Node* Next();

    void Clear() { wxHashTableBase::Clear(); }

    size_t GetCount() const { return wxHashTableBase::GetCount(); }
protected:

    void DoCopy( const wxHashTable& copy );



    void GetNextNode( size_t bucketStart );
private:
    virtual void DoDeleteContents( wxHashTableBase_Node* node );


    Node* m_curr;


    size_t m_currBucket;
};
# 20 "/usr/include/wx-2.8/wx/wx.h" 2

# 1 "/usr/include/wx-2.8/wx/hashmap.h" 1
# 68 "/usr/include/wx-2.8/wx/hashmap.h"
# 1 "/usr/lib/gcc/i686-linux-gnu/4.4.5/include/stddef.h" 1 3 4
# 69 "/usr/include/wx-2.8/wx/hashmap.h" 2



struct _wxHashTable_NodeBase
{
    _wxHashTable_NodeBase() : m_nxt(0) {}

    _wxHashTable_NodeBase* m_nxt;




};


class _wxHashTableBase2
{
public:
    typedef void (*NodeDtor)(_wxHashTable_NodeBase*);
    typedef unsigned long (*BucketFromNode)(_wxHashTableBase2*,_wxHashTable_NodeBase*);
    typedef _wxHashTable_NodeBase* (*ProcessNode)(_wxHashTable_NodeBase*);
protected:
    static _wxHashTable_NodeBase* DummyProcessNode(_wxHashTable_NodeBase* node);
    static void DeleteNodes( size_t buckets, _wxHashTable_NodeBase** table,
                             NodeDtor dtor );
    static _wxHashTable_NodeBase* GetFirstNode( size_t buckets,
                                                _wxHashTable_NodeBase** table )
    {
        for( size_t i = 0; i < buckets; ++i )
            if( table[i] )
                return table[i];
        return 0;
    }


    enum { prime_count = 31 };
    static const unsigned long ms_primes[prime_count];


    static unsigned long GetNextPrime( unsigned long n );



    static unsigned long GetPreviousPrime( unsigned long n );

    static void CopyHashTable( _wxHashTable_NodeBase** srcTable,
                               size_t srcBuckets, _wxHashTableBase2* dst,
                               _wxHashTable_NodeBase** dstTable,
                               BucketFromNode func, ProcessNode proc );

    static void** AllocTable( size_t sz )
    {
        return (void **)calloc(sz, sizeof(void*));
    }
    static void FreeTable(void *table)
    {
        free(table);
    }
};
# 461 "/usr/include/wx-2.8/wx/hashmap.h"
inline bool never_grow( size_t, size_t ) { return false; }
inline bool never_shrink( size_t, size_t ) { return false; }
inline bool grow_lf70( size_t buckets, size_t items )
{
    return float(items)/float(buckets) >= 0.85;
}
# 525 "/usr/include/wx-2.8/wx/hashmap.h"
class wxIntegerHash
{
public:
    wxIntegerHash() { }
    unsigned long operator()( long x ) const { return (unsigned long)x; }
    unsigned long operator()( unsigned long x ) const { return x; }
    unsigned long operator()( int x ) const { return (unsigned long)x; }
    unsigned long operator()( unsigned int x ) const { return x; }
    unsigned long operator()( short x ) const { return (unsigned long)x; }
    unsigned long operator()( unsigned short x ) const { return x; }

    unsigned long long operator()( long long x ) const { return static_cast<unsigned long long>(x); }
    unsigned long long operator()( unsigned long long x ) const { return x; }


    wxIntegerHash& operator=(const wxIntegerHash&) { return *this; }
};



class wxIntegerEqual
{
public:
    wxIntegerEqual() { }
    bool operator()( long a, long b ) const { return a == b; }
    bool operator()( unsigned long a, unsigned long b ) const { return a == b; }
    bool operator()( int a, int b ) const { return a == b; }
    bool operator()( unsigned int a, unsigned int b ) const { return a == b; }
    bool operator()( short a, short b ) const { return a == b; }
    bool operator()( unsigned short a, unsigned short b ) const { return a == b; }

    bool operator()( long long a, long long b ) const { return a == b; }
    bool operator()( unsigned long long a, unsigned long long b ) const { return a == b; }


    wxIntegerEqual& operator=(const wxIntegerEqual&) { return *this; }
};


class wxPointerHash
{
public:
    wxPointerHash() { }


    wxUIntPtr operator()( const void* k ) const { return wxPtrToUInt(k); }




    wxPointerHash& operator=(const wxPointerHash&) { return *this; }
};

class wxPointerEqual
{
public:
    wxPointerEqual() { }
    bool operator()( const void* a, const void* b ) const { return a == b; }

    wxPointerEqual& operator=(const wxPointerEqual&) { return *this; }
};


class wxStringHash
{
public:
    wxStringHash() {}
    unsigned long operator()( const wxString& x ) const
        { return wxCharStringHash( x.c_str() ); }
    unsigned long operator()( const wxChar* x ) const
        { return wxCharStringHash( x ); }
    static unsigned long wxCharStringHash( const wxChar* );

    unsigned long operator()( const char* x ) const
        { return charStringHash( x ); }
    static unsigned long charStringHash( const char* );


    wxStringHash& operator=(const wxStringHash&) { return *this; }
};

class wxStringEqual
{
public:
    wxStringEqual() {}
    bool operator()( const wxString& a, const wxString& b ) const
        { return a == b; }
    bool operator()( const wxChar* a, const wxChar* b ) const
        { return wcscmp( a, b ) == 0; }

    bool operator()( const char* a, const char* b ) const
        { return strcmp( a, b ) == 0; }


    wxStringEqual& operator=(const wxStringEqual&) { return *this; }
};
# 735 "/usr/include/wx-2.8/wx/hashmap.h"
class wxLongToLongHashMap_wxImplementation_Pair { public: typedef long t1; typedef long t2; typedef const long const_t1; typedef const long const_t2; wxLongToLongHashMap_wxImplementation_Pair( const const_t1& f, const const_t2& s ):first(t1(f)),second(t2(s)) {} t1 first; t2 second; }; class wxLongToLongHashMap_wxImplementation_KeyEx { typedef long key_type; typedef wxLongToLongHashMap_wxImplementation_Pair pair_type; typedef const key_type const_key_type; typedef const pair_type const_pair_type; typedef const_key_type& const_key_reference; typedef const_pair_type& const_pair_reference; public: wxLongToLongHashMap_wxImplementation_KeyEx() { } const_key_reference operator()( const_pair_reference pair ) const { return pair.first; } wxLongToLongHashMap_wxImplementation_KeyEx& operator=(const wxLongToLongHashMap_wxImplementation_KeyEx&) { return *this; } }; class wxLongToLongHashMap_wxImplementation_HashTable : protected _wxHashTableBase2 { public: typedef long key_type; typedef wxLongToLongHashMap_wxImplementation_Pair value_type; typedef wxIntegerHash hasher; typedef wxIntegerEqual key_equal; typedef size_t size_type; typedef ptrdiff_t difference_type; typedef value_type* pointer; typedef const value_type* const_pointer; typedef value_type& reference; typedef const value_type& const_reference; typedef const long const_key_type; typedef const wxLongToLongHashMap_wxImplementation_Pair const_mapped_type; public: struct Node; typedef wxLongToLongHashMap_wxImplementation_KeyEx key_extractor; typedef wxLongToLongHashMap_wxImplementation_HashTable Self; protected: Node** m_table; size_t m_tableBuckets; size_t m_items; hasher m_hasher; key_equal m_equals; key_extractor m_getKey; public: struct Node:public _wxHashTable_NodeBase { public: Node( const value_type& value ) : m_value( value ) {} Node* m_next() { return (Node*)this->m_nxt; } value_type m_value; }; class Iterator; friend class Iterator; protected: static void DeleteNode( _wxHashTable_NodeBase* node ) { delete (Node*)node; } public: class Iterator { public: Node* m_node; Self* m_ht; Iterator() : m_node(0), m_ht(0) {} Iterator( Node* node, const Self* ht ) : m_node(node), m_ht((Self*)ht) {} bool operator ==( const Iterator& it ) const { return m_node == it.m_node; } bool operator !=( const Iterator& it ) const { return m_node != it.m_node; } protected: Node* GetNextNode() { size_type bucket = GetBucketForNode(m_ht,m_node); for( size_type i = bucket + 1; i < m_ht->m_tableBuckets; ++i ) { if( m_ht->m_table[i] ) return m_ht->m_table[i]; } return 0; } void PlusPlus() { Node* next = m_node->m_next(); m_node = next ? next : GetNextNode(); } }; public: class iterator : public Iterator { public: iterator() : Iterator() {} iterator( Node* node, Self* ht ) : Iterator( node, ht ) {} iterator& operator++() { PlusPlus(); return *this; } iterator operator++(int) { iterator it=*this;PlusPlus();return it; } reference operator *() const { return m_node->m_value; } pointer operator ->() const { return &(m_node->m_value); } }; class const_iterator : public Iterator { public: const_iterator() : Iterator() {} const_iterator(iterator i) : Iterator(i) {} const_iterator( Node* node, const Self* ht ) : Iterator( node, (Self*)ht ) {} const_iterator& operator++() { PlusPlus();return *this; } const_iterator operator++(int) { const_iterator it=*this;PlusPlus();return it; } const_reference operator *() const { return m_node->m_value; } const_pointer operator ->() const { return &(m_node->m_value); } }; wxLongToLongHashMap_wxImplementation_HashTable( size_type sz = 10, const hasher& hfun = hasher(), const key_equal& k_eq = key_equal(), const key_extractor& k_ex = key_extractor() ) : m_tableBuckets( GetNextPrime( (unsigned long) sz ) ), m_items( 0 ), m_hasher( hfun ), m_equals( k_eq ), m_getKey( k_ex ) { m_table = (Node**)AllocTable( m_tableBuckets ); } wxLongToLongHashMap_wxImplementation_HashTable( const Self& ht ) : m_table( 0 ), m_tableBuckets( 0 ), m_items( ht.m_items ), m_hasher( ht.m_hasher ), m_equals( ht.m_equals ), m_getKey( ht.m_getKey ) { HashCopy( ht ); } const Self& operator=( const Self& ht ) { clear(); m_hasher = ht.m_hasher; m_equals = ht.m_equals; m_getKey = ht.m_getKey; m_items = ht.m_items; HashCopy( ht ); return *this; } ~wxLongToLongHashMap_wxImplementation_HashTable() { clear(); FreeTable(m_table); } hasher hash_funct() { return m_hasher; } key_equal key_eq() { return m_equals; } void clear() { DeleteNodes( m_tableBuckets, (_wxHashTable_NodeBase**)m_table, DeleteNode ); m_items = 0; } size_type size() const { return m_items; } size_type max_size() const { return size_type(-1); } bool empty() const { return size() == 0; } const_iterator end() const { return const_iterator( 0, this ); } iterator end() { return iterator( 0, this ); } const_iterator begin() const { return const_iterator( (Node*)GetFirstNode( m_tableBuckets, (_wxHashTable_NodeBase**)m_table ), this ); } iterator begin() { return iterator( (Node*)GetFirstNode( m_tableBuckets, (_wxHashTable_NodeBase**)m_table ), this ); } size_type erase( const const_key_type& key ) { Node** node = GetNodePtr( key ); if( !node ) return 0; --m_items; Node* temp = (*node)->m_next(); delete *node; (*node) = temp; if( never_shrink( m_tableBuckets, m_items ) ) ResizeTable( GetPreviousPrime( (unsigned long) m_tableBuckets ) - 1 ); return 1; } protected: static size_type GetBucketForNode( Self* ht, Node* node ) { return ht->m_hasher( ht->m_getKey( node->m_value ) ) % ht->m_tableBuckets; } static Node* CopyNode( Node* node ) { return new Node( *node ); } Node* GetOrCreateNode( const value_type& value, bool& created ) { const const_key_type& key = m_getKey( value ); size_t bucket = m_hasher( key ) % m_tableBuckets; Node* node = m_table[bucket]; while( node ) { if( m_equals( m_getKey( node->m_value ), key ) ) { created = false; return node; } node = node->m_next(); } created = true; return CreateNode( value, bucket); } Node * CreateNode( const value_type& value, size_t bucket ) { Node* node = new Node( value ); node->m_nxt = m_table[bucket]; m_table[bucket] = node; ++m_items; if( grow_lf70( m_tableBuckets, m_items ) ) ResizeTable( m_tableBuckets ); return node; } void CreateNode( const value_type& value ) { CreateNode(value, m_hasher( m_getKey(value) ) % m_tableBuckets ); } Node** GetNodePtr( const const_key_type& key ) const { size_t bucket = m_hasher( key ) % m_tableBuckets; Node** node = &m_table[bucket]; while( *node ) { if( m_equals( m_getKey( (*node)->m_value ), key ) ) return node; node = (Node**)&(*node)->m_nxt; } return __null; } Node* GetNode( const const_key_type& key ) const { size_t bucket = m_hasher( key ) % m_tableBuckets; Node* node = m_table[bucket]; while( node ) { if( m_equals( m_getKey( node->m_value ), key ) ) return node; node = node->m_next(); } return 0; } void ResizeTable( size_t newSize ) { newSize = GetNextPrime( (unsigned long)newSize ); Node** srcTable = m_table; size_t srcBuckets = m_tableBuckets; m_table = (Node**)AllocTable( newSize ); m_tableBuckets = newSize; CopyHashTable( (_wxHashTable_NodeBase**)srcTable, srcBuckets, this, (_wxHashTable_NodeBase**)m_table, (BucketFromNode)GetBucketForNode, (ProcessNode)&DummyProcessNode ); FreeTable(srcTable); } void HashCopy( const Self& ht ) { ResizeTable( ht.size() ); CopyHashTable( (_wxHashTable_NodeBase**)ht.m_table, ht.m_tableBuckets, (_wxHashTableBase2*)this, (_wxHashTable_NodeBase**)m_table, (BucketFromNode)GetBucketForNode, (ProcessNode)CopyNode ); } }; class wxLongToLongHashMap:public wxLongToLongHashMap_wxImplementation_HashTable { public: typedef long mapped_type; class Insert_Result { public: typedef iterator t1; typedef bool t2; typedef const iterator const_t1; typedef const bool const_t2; Insert_Result( const const_t1& f, const const_t2& s ):first(t1(f)),second(t2(s)) {} t1 first; t2 second; }; explicit wxLongToLongHashMap( size_type hint = 100, hasher hf = hasher(), key_equal eq = key_equal() ) : wxLongToLongHashMap_wxImplementation_HashTable( hint, hf, eq, wxLongToLongHashMap_wxImplementation_KeyEx() ) {} mapped_type& operator[]( const const_key_type& key ) { bool created; return GetOrCreateNode( wxLongToLongHashMap_wxImplementation_Pair( key, mapped_type() ), created)->m_value.second; } const_iterator find( const const_key_type& key ) const { return const_iterator( GetNode( key ), this ); } iterator find( const const_key_type& key ) { return iterator( GetNode( key ), this ); } Insert_Result insert( const value_type& v ) { bool created; Node *node = GetOrCreateNode( wxLongToLongHashMap_wxImplementation_Pair( v.first, v.second ), created); return Insert_Result(iterator(node, this), created); } size_type erase( const key_type& k ) { return wxLongToLongHashMap_wxImplementation_HashTable::erase( k ); } void erase( const iterator& it ) { erase( it->first ); } void erase( const const_iterator& it ) { erase( it->first ); } size_type count( const const_key_type& key ) { return (size_type)(GetNode( key ) ? 1 : 0); } };
# 22 "/usr/include/wx-2.8/wx/wx.h" 2
# 1 "/usr/include/wx-2.8/wx/arrstr.h" 1
# 18 "/usr/include/wx-2.8/wx/arrstr.h"
 int wxStringSortAscending(wxString*, wxString*);
 int wxStringSortDescending(wxString*, wxString*);
# 98 "/usr/include/wx-2.8/wx/arrstr.h"
class wxArrayString
{
public:

  typedef int ( *CompareFunction)(const wxString& first,
                                 const wxString& second);


  typedef int ( *CompareFunction2)(wxString* first,
                                  wxString* second);



  wxArrayString() { Init(false); }
# 120 "/usr/include/wx-2.8/wx/arrstr.h"
  wxArrayString(int autoSort) { Init(autoSort != 0); }

  wxArrayString(size_t sz, const wxChar** a);

  wxArrayString(size_t sz, const wxString* a);

  wxArrayString(const wxArrayString& array);

  wxArrayString& operator=(const wxArrayString& src);

 ~wxArrayString();



  void Empty();

  void Clear();

  void Alloc(size_t nCount);

  void Shrink();



  size_t GetCount() const { return m_nCount; }

  bool IsEmpty() const { return m_nCount == 0; }

  size_t Count() const { return m_nCount; }



  wxString& Item(size_t nIndex) const
    {
        ;


        return *(wxString *)&(m_pItems[nIndex]);
    }


  wxString& operator[](size_t nIndex) const { return Item(nIndex); }

  wxString& Last() const
  {
      ;

      return Item(Count() - 1);
  }
# 183 "/usr/include/wx-2.8/wx/arrstr.h"
  int Index (const wxChar *sz, bool bCase = true, bool bFromEnd = false) const;


  size_t Add(const wxString& str, size_t nInsert = 1);

  void Insert(const wxString& str, size_t uiIndex, size_t nInsert = 1);

  void SetCount(size_t count);

  void Remove(const wxChar *sz);




  void RemoveAt(size_t nIndex, size_t nRemove = 1);




  void Sort(bool reverseOrder = false);

  void Sort(CompareFunction compareFunction);
  void Sort(CompareFunction2 compareFunction);



  bool operator==(const wxArrayString& a) const;

  bool operator!=(const wxArrayString& a) const { return !(*this == a); }


  typedef wxString value_type;
  typedef value_type* pointer;
  typedef const value_type* const_pointer;
  typedef value_type* iterator;
  typedef const value_type* const_iterator;
  typedef value_type& reference;
  typedef const value_type& const_reference;
  typedef int difference_type;
  typedef size_t size_type;


  class reverse_iterator
  {
    typedef wxString value_type;
    typedef value_type* pointer;
    typedef value_type& reference;
    typedef reverse_iterator itor;
    friend itor operator+(int o, const itor& it);
    friend itor operator+(const itor& it, int o);
    friend itor operator-(const itor& it, int o);
    friend difference_type operator -(const itor& i1, const itor& i2);
  public:
    pointer m_ptr;
    reverse_iterator() : m_ptr(__null) { }
    reverse_iterator(pointer ptr) : m_ptr(ptr) { }
    reverse_iterator(const itor& it) : m_ptr(it.m_ptr) { }
    reference operator*() const { return *m_ptr; }
    pointer operator->() const { return m_ptr; }
    itor& operator++() { --m_ptr; return *this; }
    const itor operator++(int)
      { reverse_iterator tmp = *this; --m_ptr; return tmp; }
    itor& operator--() { ++m_ptr; return *this; }
    const itor operator--(int) { itor tmp = *this; ++m_ptr; return tmp; }
    bool operator ==(const itor& it) const { return m_ptr == it.m_ptr; }
    bool operator !=(const itor& it) const { return m_ptr != it.m_ptr; }
  };

  class const_reverse_iterator
  {
    typedef wxString value_type;
    typedef const value_type* pointer;
    typedef const value_type& reference;
    typedef const_reverse_iterator itor;
    friend itor operator+(int o, const itor& it);
    friend itor operator+(const itor& it, int o);
    friend itor operator-(const itor& it, int o);
    friend difference_type operator -(const itor& i1, const itor& i2);
  public:
    pointer m_ptr;
    const_reverse_iterator() : m_ptr(__null) { }
    const_reverse_iterator(pointer ptr) : m_ptr(ptr) { }
    const_reverse_iterator(const itor& it) : m_ptr(it.m_ptr) { }
    const_reverse_iterator(const reverse_iterator& it) : m_ptr(it.m_ptr) { }
    reference operator*() const { return *m_ptr; }
    pointer operator->() const { return m_ptr; }
    itor& operator++() { --m_ptr; return *this; }
    const itor operator++(int)
      { itor tmp = *this; --m_ptr; return tmp; }
    itor& operator--() { ++m_ptr; return *this; }
    const itor operator--(int) { itor tmp = *this; ++m_ptr; return tmp; }
    bool operator ==(const itor& it) const { return m_ptr == it.m_ptr; }
    bool operator !=(const itor& it) const { return m_ptr != it.m_ptr; }
  };

  wxArrayString(const_iterator first, const_iterator last)
    { Init(false); assign(first, last); }
  wxArrayString(size_type n, const_reference v) { Init(false); assign(n, v); }
  void assign(const_iterator first, const_iterator last);
  void assign(size_type n, const_reference v)
    { clear(); Add(v, n); }
  reference back() { return *(end() - 1); }
  const_reference back() const { return *(end() - 1); }
  iterator begin() { return (wxString *)&(m_pItems[0]); }
  const_iterator begin() const { return (wxString *)&(m_pItems[0]); }
  size_type capacity() const { return m_nSize; }
  void clear() { Clear(); }
  bool empty() const { return IsEmpty(); }
  iterator end() { return begin() + GetCount(); }
  const_iterator end() const { return begin() + GetCount(); }
  iterator erase(iterator first, iterator last)
  {
      size_t idx = first - begin();
      RemoveAt(idx, last - first);
      return begin() + idx;
  }
  iterator erase(iterator it) { return erase(it, it + 1); }
  reference front() { return *begin(); }
  const_reference front() const { return *begin(); }
  void insert(iterator it, size_type n, const_reference v)
    { Insert(v, it - begin(), n); }
  iterator insert(iterator it, const_reference v = value_type())
    { size_t idx = it - begin(); Insert(v, idx); return begin() + idx; }
  void insert(iterator it, const_iterator first, const_iterator last);
  size_type max_size() const { return 2147483647; }
  void pop_back() { RemoveAt(GetCount() - 1); }
  void push_back(const_reference v) { Add(v); }
  reverse_iterator rbegin() { return reverse_iterator(end() - 1); }
  const_reverse_iterator rbegin() const;
  reverse_iterator rend() { return reverse_iterator(begin() - 1); }
  const_reverse_iterator rend() const;
  void reserve(size_type n) ;
  void resize(size_type n, value_type v = value_type());
  size_type size() const { return GetCount(); }

protected:
  void Init(bool autoSort);
  void Copy(const wxArrayString& src);

private:
  void Grow(size_t nIncrement = 0);
  void Free();

  void DoSort();

  size_t m_nSize,
          m_nCount;

  wxChar **m_pItems;

  bool m_autoSort;
};

class wxSortedArrayString : public wxArrayString
{
public:
  wxSortedArrayString() : wxArrayString(true)
    { }
  wxSortedArrayString(const wxArrayString& array) : wxArrayString(true)
    { Copy(array); }
};





class wxCArrayString
{
public:
    wxCArrayString( const wxArrayString& array )
        : m_array( array ), m_strings( __null )
    { }
    ~wxCArrayString() { delete[] m_strings; }

    size_t GetCount() const { return m_array.GetCount(); }
    wxString* GetStrings()
    {
        if( m_strings ) return m_strings;
        size_t count = m_array.GetCount();
        m_strings = new wxString[count];
        for( size_t i = 0; i < count; ++i )
            m_strings[i] = m_array[i];
        return m_strings;
    }


    wxString* Release();


private:
    const wxArrayString& m_array;
    wxString* m_strings;
};
# 23 "/usr/include/wx-2.8/wx/wx.h" 2
# 1 "/usr/include/wx-2.8/wx/intl.h" 1
# 25 "/usr/include/wx-2.8/wx/intl.h"
enum wxLayoutDirection
{
    wxLayout_Default,
    wxLayout_LeftToRight,
    wxLayout_RightToLeft
};
# 60 "/usr/include/wx-2.8/wx/intl.h"
class wxLocale;
class wxLanguageInfoArray;
class wxMsgCatalog;
# 76 "/usr/include/wx-2.8/wx/intl.h"
enum wxLanguage
{

    wxLANGUAGE_DEFAULT,

    wxLANGUAGE_UNKNOWN,

    wxLANGUAGE_ABKHAZIAN,
    wxLANGUAGE_AFAR,
    wxLANGUAGE_AFRIKAANS,
    wxLANGUAGE_ALBANIAN,
    wxLANGUAGE_AMHARIC,
    wxLANGUAGE_ARABIC,
    wxLANGUAGE_ARABIC_ALGERIA,
    wxLANGUAGE_ARABIC_BAHRAIN,
    wxLANGUAGE_ARABIC_EGYPT,
    wxLANGUAGE_ARABIC_IRAQ,
    wxLANGUAGE_ARABIC_JORDAN,
    wxLANGUAGE_ARABIC_KUWAIT,
    wxLANGUAGE_ARABIC_LEBANON,
    wxLANGUAGE_ARABIC_LIBYA,
    wxLANGUAGE_ARABIC_MOROCCO,
    wxLANGUAGE_ARABIC_OMAN,
    wxLANGUAGE_ARABIC_QATAR,
    wxLANGUAGE_ARABIC_SAUDI_ARABIA,
    wxLANGUAGE_ARABIC_SUDAN,
    wxLANGUAGE_ARABIC_SYRIA,
    wxLANGUAGE_ARABIC_TUNISIA,
    wxLANGUAGE_ARABIC_UAE,
    wxLANGUAGE_ARABIC_YEMEN,
    wxLANGUAGE_ARMENIAN,
    wxLANGUAGE_ASSAMESE,
    wxLANGUAGE_AYMARA,
    wxLANGUAGE_AZERI,
    wxLANGUAGE_AZERI_CYRILLIC,
    wxLANGUAGE_AZERI_LATIN,
    wxLANGUAGE_BASHKIR,
    wxLANGUAGE_BASQUE,
    wxLANGUAGE_BELARUSIAN,
    wxLANGUAGE_BENGALI,
    wxLANGUAGE_BHUTANI,
    wxLANGUAGE_BIHARI,
    wxLANGUAGE_BISLAMA,
    wxLANGUAGE_BRETON,
    wxLANGUAGE_BULGARIAN,
    wxLANGUAGE_BURMESE,
    wxLANGUAGE_CAMBODIAN,
    wxLANGUAGE_CATALAN,
    wxLANGUAGE_CHINESE,
    wxLANGUAGE_CHINESE_SIMPLIFIED,
    wxLANGUAGE_CHINESE_TRADITIONAL,
    wxLANGUAGE_CHINESE_HONGKONG,
    wxLANGUAGE_CHINESE_MACAU,
    wxLANGUAGE_CHINESE_SINGAPORE,
    wxLANGUAGE_CHINESE_TAIWAN,
    wxLANGUAGE_CORSICAN,
    wxLANGUAGE_CROATIAN,
    wxLANGUAGE_CZECH,
    wxLANGUAGE_DANISH,
    wxLANGUAGE_DUTCH,
    wxLANGUAGE_DUTCH_BELGIAN,
    wxLANGUAGE_ENGLISH,
    wxLANGUAGE_ENGLISH_UK,
    wxLANGUAGE_ENGLISH_US,
    wxLANGUAGE_ENGLISH_AUSTRALIA,
    wxLANGUAGE_ENGLISH_BELIZE,
    wxLANGUAGE_ENGLISH_BOTSWANA,
    wxLANGUAGE_ENGLISH_CANADA,
    wxLANGUAGE_ENGLISH_CARIBBEAN,
    wxLANGUAGE_ENGLISH_DENMARK,
    wxLANGUAGE_ENGLISH_EIRE,
    wxLANGUAGE_ENGLISH_JAMAICA,
    wxLANGUAGE_ENGLISH_NEW_ZEALAND,
    wxLANGUAGE_ENGLISH_PHILIPPINES,
    wxLANGUAGE_ENGLISH_SOUTH_AFRICA,
    wxLANGUAGE_ENGLISH_TRINIDAD,
    wxLANGUAGE_ENGLISH_ZIMBABWE,
    wxLANGUAGE_ESPERANTO,
    wxLANGUAGE_ESTONIAN,
    wxLANGUAGE_FAEROESE,
    wxLANGUAGE_FARSI,
    wxLANGUAGE_FIJI,
    wxLANGUAGE_FINNISH,
    wxLANGUAGE_FRENCH,
    wxLANGUAGE_FRENCH_BELGIAN,
    wxLANGUAGE_FRENCH_CANADIAN,
    wxLANGUAGE_FRENCH_LUXEMBOURG,
    wxLANGUAGE_FRENCH_MONACO,
    wxLANGUAGE_FRENCH_SWISS,
    wxLANGUAGE_FRISIAN,
    wxLANGUAGE_GALICIAN,
    wxLANGUAGE_GEORGIAN,
    wxLANGUAGE_GERMAN,
    wxLANGUAGE_GERMAN_AUSTRIAN,
    wxLANGUAGE_GERMAN_BELGIUM,
    wxLANGUAGE_GERMAN_LIECHTENSTEIN,
    wxLANGUAGE_GERMAN_LUXEMBOURG,
    wxLANGUAGE_GERMAN_SWISS,
    wxLANGUAGE_GREEK,
    wxLANGUAGE_GREENLANDIC,
    wxLANGUAGE_GUARANI,
    wxLANGUAGE_GUJARATI,
    wxLANGUAGE_HAUSA,
    wxLANGUAGE_HEBREW,
    wxLANGUAGE_HINDI,
    wxLANGUAGE_HUNGARIAN,
    wxLANGUAGE_ICELANDIC,
    wxLANGUAGE_INDONESIAN,
    wxLANGUAGE_INTERLINGUA,
    wxLANGUAGE_INTERLINGUE,
    wxLANGUAGE_INUKTITUT,
    wxLANGUAGE_INUPIAK,
    wxLANGUAGE_IRISH,
    wxLANGUAGE_ITALIAN,
    wxLANGUAGE_ITALIAN_SWISS,
    wxLANGUAGE_JAPANESE,
    wxLANGUAGE_JAVANESE,
    wxLANGUAGE_KANNADA,
    wxLANGUAGE_KASHMIRI,
    wxLANGUAGE_KASHMIRI_INDIA,
    wxLANGUAGE_KAZAKH,
    wxLANGUAGE_KERNEWEK,
    wxLANGUAGE_KINYARWANDA,
    wxLANGUAGE_KIRGHIZ,
    wxLANGUAGE_KIRUNDI,
    wxLANGUAGE_KONKANI,
    wxLANGUAGE_KOREAN,
    wxLANGUAGE_KURDISH,
    wxLANGUAGE_LAOTHIAN,
    wxLANGUAGE_LATIN,
    wxLANGUAGE_LATVIAN,
    wxLANGUAGE_LINGALA,
    wxLANGUAGE_LITHUANIAN,
    wxLANGUAGE_MACEDONIAN,
    wxLANGUAGE_MALAGASY,
    wxLANGUAGE_MALAY,
    wxLANGUAGE_MALAYALAM,
    wxLANGUAGE_MALAY_BRUNEI_DARUSSALAM,
    wxLANGUAGE_MALAY_MALAYSIA,
    wxLANGUAGE_MALTESE,
    wxLANGUAGE_MANIPURI,
    wxLANGUAGE_MAORI,
    wxLANGUAGE_MARATHI,
    wxLANGUAGE_MOLDAVIAN,
    wxLANGUAGE_MONGOLIAN,
    wxLANGUAGE_NAURU,
    wxLANGUAGE_NEPALI,
    wxLANGUAGE_NEPALI_INDIA,
    wxLANGUAGE_NORWEGIAN_BOKMAL,
    wxLANGUAGE_NORWEGIAN_NYNORSK,
    wxLANGUAGE_OCCITAN,
    wxLANGUAGE_ORIYA,
    wxLANGUAGE_OROMO,
    wxLANGUAGE_PASHTO,
    wxLANGUAGE_POLISH,
    wxLANGUAGE_PORTUGUESE,
    wxLANGUAGE_PORTUGUESE_BRAZILIAN,
    wxLANGUAGE_PUNJABI,
    wxLANGUAGE_QUECHUA,
    wxLANGUAGE_RHAETO_ROMANCE,
    wxLANGUAGE_ROMANIAN,
    wxLANGUAGE_RUSSIAN,
    wxLANGUAGE_RUSSIAN_UKRAINE,
    wxLANGUAGE_SAMOAN,
    wxLANGUAGE_SANGHO,
    wxLANGUAGE_SANSKRIT,
    wxLANGUAGE_SCOTS_GAELIC,
    wxLANGUAGE_SERBIAN,
    wxLANGUAGE_SERBIAN_CYRILLIC,
    wxLANGUAGE_SERBIAN_LATIN,
    wxLANGUAGE_SERBO_CROATIAN,
    wxLANGUAGE_SESOTHO,
    wxLANGUAGE_SETSWANA,
    wxLANGUAGE_SHONA,
    wxLANGUAGE_SINDHI,
    wxLANGUAGE_SINHALESE,
    wxLANGUAGE_SISWATI,
    wxLANGUAGE_SLOVAK,
    wxLANGUAGE_SLOVENIAN,
    wxLANGUAGE_SOMALI,
    wxLANGUAGE_SPANISH,
    wxLANGUAGE_SPANISH_ARGENTINA,
    wxLANGUAGE_SPANISH_BOLIVIA,
    wxLANGUAGE_SPANISH_CHILE,
    wxLANGUAGE_SPANISH_COLOMBIA,
    wxLANGUAGE_SPANISH_COSTA_RICA,
    wxLANGUAGE_SPANISH_DOMINICAN_REPUBLIC,
    wxLANGUAGE_SPANISH_ECUADOR,
    wxLANGUAGE_SPANISH_EL_SALVADOR,
    wxLANGUAGE_SPANISH_GUATEMALA,
    wxLANGUAGE_SPANISH_HONDURAS,
    wxLANGUAGE_SPANISH_MEXICAN,
    wxLANGUAGE_SPANISH_MODERN,
    wxLANGUAGE_SPANISH_NICARAGUA,
    wxLANGUAGE_SPANISH_PANAMA,
    wxLANGUAGE_SPANISH_PARAGUAY,
    wxLANGUAGE_SPANISH_PERU,
    wxLANGUAGE_SPANISH_PUERTO_RICO,
    wxLANGUAGE_SPANISH_URUGUAY,
    wxLANGUAGE_SPANISH_US,
    wxLANGUAGE_SPANISH_VENEZUELA,
    wxLANGUAGE_SUNDANESE,
    wxLANGUAGE_SWAHILI,
    wxLANGUAGE_SWEDISH,
    wxLANGUAGE_SWEDISH_FINLAND,
    wxLANGUAGE_TAGALOG,
    wxLANGUAGE_TAJIK,
    wxLANGUAGE_TAMIL,
    wxLANGUAGE_TATAR,
    wxLANGUAGE_TELUGU,
    wxLANGUAGE_THAI,
    wxLANGUAGE_TIBETAN,
    wxLANGUAGE_TIGRINYA,
    wxLANGUAGE_TONGA,
    wxLANGUAGE_TSONGA,
    wxLANGUAGE_TURKISH,
    wxLANGUAGE_TURKMEN,
    wxLANGUAGE_TWI,
    wxLANGUAGE_UIGHUR,
    wxLANGUAGE_UKRAINIAN,
    wxLANGUAGE_URDU,
    wxLANGUAGE_URDU_INDIA,
    wxLANGUAGE_URDU_PAKISTAN,
    wxLANGUAGE_UZBEK,
    wxLANGUAGE_UZBEK_CYRILLIC,
    wxLANGUAGE_UZBEK_LATIN,
    wxLANGUAGE_VIETNAMESE,
    wxLANGUAGE_VOLAPUK,
    wxLANGUAGE_WELSH,
    wxLANGUAGE_WOLOF,
    wxLANGUAGE_XHOSA,
    wxLANGUAGE_YIDDISH,
    wxLANGUAGE_YORUBA,
    wxLANGUAGE_ZHUANG,
    wxLANGUAGE_ZULU,


    wxLANGUAGE_USER_DEFINED







    , wxLANGUAGE_VALENCIAN = 0x1fffffff,
    wxLANGUAGE_SAMI

};
# 333 "/usr/include/wx-2.8/wx/intl.h"
struct wxLanguageInfo
{
    int Language;
    wxString CanonicalName;




    wxString Description;
    wxLayoutDirection LayoutDirection;
};





enum wxLocaleCategory
{

    wxLOCALE_CAT_NUMBER,


    wxLOCALE_CAT_DATE,


    wxLOCALE_CAT_MONEY,

    wxLOCALE_CAT_MAX
};





enum wxLocaleInfo
{

    wxLOCALE_THOUSANDS_SEP,


    wxLOCALE_DECIMAL_POINT

};






enum wxLocaleInitFlags
{
    wxLOCALE_LOAD_DEFAULT = 0x0001,
    wxLOCALE_CONV_ENCODING = 0x0002
};

class wxLocale
{
public:




    wxLocale() { DoCommonInit(); }


    wxLocale(const wxChar *szName,
             const wxChar *szShort = (const wxChar *) __null,
             const wxChar *szLocale = (const wxChar *) __null,
             bool bLoadDefault = true,
             bool bConvertEncoding = false)
        {
            DoCommonInit();

            Init(szName, szShort, szLocale, bLoadDefault, bConvertEncoding);
        }

    wxLocale(int language,
             int flags = wxLOCALE_LOAD_DEFAULT | wxLOCALE_CONV_ENCODING)
        {
            DoCommonInit();

            Init(language, flags);
        }


    bool Init(const wxChar *szName,
              const wxChar *szShort = (const wxChar *) __null,
              const wxChar *szLocale = (const wxChar *) __null,
              bool bLoadDefault = true,
              bool bConvertEncoding = false);


    bool Init(int language = wxLANGUAGE_DEFAULT,
              int flags = wxLOCALE_LOAD_DEFAULT | wxLOCALE_CONV_ENCODING);


    virtual ~wxLocale();



    static int GetSystemLanguage();



    static wxFontEncoding GetSystemEncoding();



    static wxString GetSystemEncodingName();



    static wxString GetInfo(wxLocaleInfo index, wxLocaleCategory cat);


    bool IsOk() const { return m_pszOldLocale != __null; }


    const wxChar *GetLocale() const { return m_strLocale; }


    int GetLanguage() const { return m_language; }


    wxString GetSysName() const;




    wxString GetCanonicalName() const { return m_strShort; }






    static void AddCatalogLookupPathPrefix(const wxString& prefix);
# 478 "/usr/include/wx-2.8/wx/intl.h"
    bool AddCatalog(const wxChar *szDomain);
    bool AddCatalog(const wxChar *szDomain,
                    wxLanguage msgIdLanguage, const wxChar *msgIdCharset);


    static bool IsAvailable(int lang);


    bool IsLoaded(const wxChar *szDomain) const;




    static const wxLanguageInfo *GetLanguageInfo(int lang);



    static wxString GetLanguageName(int lang);






    static const wxLanguageInfo *FindLanguageInfo(const wxString& locale);




    static void AddLanguage(const wxLanguageInfo& info);
# 520 "/usr/include/wx-2.8/wx/intl.h"
    virtual const wxChar *GetString(const wxChar *szOrigString,
                                    const wxChar *szDomain = __null) const;

    virtual const wxChar *GetString(const wxChar *szOrigString,
                                    const wxChar *szOrigString2,
                                    size_t n,
                                    const wxChar *szDomain = __null) const;


    const wxString& GetName() const { return m_strShort; }


    wxString GetHeaderValue( const wxChar* szHeader,
                             const wxChar* szDomain = __null ) const;




    static void CreateLanguagesDB();
    static void DestroyLanguagesDB();

private:

    wxMsgCatalog *FindCatalog(const wxChar *szDomain) const;



    static void InitLanguagesDB();


    void DoCommonInit();

    wxString m_strLocale,
                   m_strShort;
    int m_language;

    const wxChar *m_pszOldLocale;
    wxLocale *m_pOldLocale;

    wxMsgCatalog *m_pMsgCat;

    bool m_bConvertEncoding;

    bool m_initialized;

    static wxLanguageInfoArray *ms_languagesDB;

    private: wxLocale(const wxLocale&); wxLocale& operator=(const wxLocale&);
};






extern wxLocale* wxGetLocale();


inline const wxChar *
wxGetTranslation(const wxChar *sz, const wxChar* domain = __null)
{
    wxLocale *pLoc = wxGetLocale();
    if (pLoc)
        return pLoc->GetString(sz, domain);
    else
        return sz;
}

inline const wxChar *
wxGetTranslation(const wxChar *sz1, const wxChar *sz2,
                 size_t n,
                 const wxChar *domain = __null)
{
    wxLocale *pLoc = wxGetLocale();
    if (pLoc)
        return pLoc->GetString(sz1, sz2, n, domain);
    else
        return n == 1 ? sz1 : sz2;
}
# 24 "/usr/include/wx-2.8/wx/wx.h" 2
# 1 "/usr/include/wx-2.8/wx/log.h" 1
# 40 "/usr/include/wx-2.8/wx/log.h"
typedef unsigned long wxTraceMask;
typedef unsigned long wxLogLevel;
# 72 "/usr/include/wx-2.8/wx/log.h"
    class wxTextCtrl;
    class wxLogFrame;
    class wxFrame;
    class wxWindow;







enum
{
    wxLOG_FatalError,
    wxLOG_Error,
    wxLOG_Warning,
    wxLOG_Message,
    wxLOG_Status,
    wxLOG_Info,
    wxLOG_Debug,
    wxLOG_Trace,
    wxLOG_Progress,
    wxLOG_User = 100,
    wxLOG_Max = 10000
};
# 111 "/usr/include/wx-2.8/wx/log.h"
# 1 "/usr/include/wx-2.8/wx/iosfwrap.h" 1
# 112 "/usr/include/wx-2.8/wx/log.h" 2






class wxLog
{
public:

    wxLog(){}




    static bool IsEnabled() { return ms_doLog; }


    static bool EnableLogging(bool doIt = true)
        { bool doLogOld = ms_doLog; ms_doLog = doIt; return doLogOld; }



    static void OnLog(wxLogLevel level, const wxChar *szString, time_t t);






    virtual void Flush();


    static void FlushActive()
    {
        if ( !ms_suspendCount )
        {
            wxLog *log = GetActiveTarget();
            if ( log )
                log->Flush();
        }
    }




    static wxLog *GetActiveTarget();


    static wxLog *SetActiveTarget(wxLog *pLogger);




    static void Suspend() { ms_suspendCount++; }


    static void Resume() { ms_suspendCount--; }




    static void SetVerbose(bool bVerbose = true) { ms_bVerbose = bVerbose; }


    static void SetLogLevel(wxLogLevel logLevel) { ms_logLevel = logLevel; }




    static void DontCreateOnDemand();



    static void DoCreateOnDemand();



    static void SetRepetitionCounting(bool bRepetCounting = true)
        { ms_bRepetCounting = bRepetCounting; }


    static bool GetRepetitionCounting() { return ms_bRepetCounting; }


    static void SetTraceMask(wxTraceMask ulMask) { ms_ulTraceMask = ulMask; }


    static void AddTraceMask(const wxString& str)
        { ms_aTraceMasks.push_back(str); }


    static void RemoveTraceMask(const wxString& str);


    static void ClearTraceMasks();


    static const wxArrayString &GetTraceMasks() { return ms_aTraceMasks; }




    static void SetTimestamp(const wxChar *ts) { ms_timestamp = ts; }





    static bool GetVerbose() { return ms_bVerbose; }


    static wxTraceMask GetTraceMask() { return ms_ulTraceMask; }


    static bool IsAllowedTraceMask(const wxChar *mask);


    static wxLogLevel GetLogLevel() { return ms_logLevel; }


    static const wxChar *GetTimestamp() { return ms_timestamp; }






    static void TimeStamp(wxString *str);


    virtual ~wxLog();



    bool HasPendingMessages() const { return true; }



    static wxChar *SetLogBuffer(wxChar *buf, size_t size = 0) __attribute__ ((deprecated));


protected:




    virtual void DoLog(wxLogLevel level, const wxChar *szString, time_t t);



    virtual void DoLogString(const wxChar *szString, time_t t);



    static unsigned DoLogNumberOfRepeats();

private:




    static bool ms_bRepetCounting;
    static wxString ms_prevString;

    static unsigned ms_prevCounter;
    static time_t ms_prevTimeStamp;
    static wxLogLevel ms_prevLevel;

    static wxLog *ms_pLogger;
    static bool ms_doLog;
    static bool ms_bAutoCreate;
    static bool ms_bVerbose;

    static wxLogLevel ms_logLevel;

    static size_t ms_suspendCount;



    static const wxChar *ms_timestamp;

    static wxTraceMask ms_ulTraceMask;
    static wxArrayString ms_aTraceMasks;




    unsigned LogLastRepeatIfNeeded();



    unsigned LogLastRepeatIfNeededUnlocked();
};






class wxLogBuffer : public wxLog
{
public:
    wxLogBuffer() { }


    const wxString& GetBuffer() const { return m_str; }



    virtual void Flush();

protected:
    virtual void DoLog(wxLogLevel level, const wxChar *szString, time_t t);
    virtual void DoLogString(const wxChar *szString, time_t t);

private:
    wxString m_str;

    private: wxLogBuffer(const wxLogBuffer&); wxLogBuffer& operator=(const wxLogBuffer&);
};



class wxLogStderr : public wxLog
{
public:

    wxLogStderr(FILE *fp = (FILE *) __null);

protected:

    virtual void DoLogString(const wxChar *szString, time_t t);

    FILE *m_fp;

    private: wxLogStderr(const wxLogStderr&); wxLogStderr& operator=(const wxLogStderr&);
};




class wxLogStream : public wxLog
{
public:

    wxLogStream(std:: ostream *ostr = (std:: ostream *) __null);

protected:

    virtual void DoLogString(const wxChar *szString, time_t t);


    std:: ostream *m_ostr;
};
# 390 "/usr/include/wx-2.8/wx/log.h"
class wxLogNull
{
public:
    wxLogNull() : m_flagOld(wxLog::EnableLogging(false)) { }
    ~wxLogNull() { (void)wxLog::EnableLogging(m_flagOld); }

private:
    bool m_flagOld;
};
# 409 "/usr/include/wx-2.8/wx/log.h"
class wxLogChain : public wxLog
{
public:
    wxLogChain(wxLog *logger);
    virtual ~wxLogChain();


    void SetLog(wxLog *logger);



    void PassMessages(bool bDoPass) { m_bPassMessages = bDoPass; }


    bool IsPassingMessages() const { return m_bPassMessages; }


    wxLog *GetOldLog() const { return m_logOld; }


    virtual void Flush();



    void DetachOldLog() { m_logOld = __null; }


protected:

    virtual void DoLog(wxLogLevel level, const wxChar *szString, time_t t);

private:

    wxLog *m_logNew;


    wxLog *m_logOld;


    bool m_bPassMessages;

    private: wxLogChain(const wxLogChain&); wxLogChain& operator=(const wxLogChain&);
};


class wxLogPassThrough : public wxLogChain
{
public:
    wxLogPassThrough();

private:
    private: wxLogPassThrough(const wxLogPassThrough&); wxLogPassThrough& operator=(const wxLogPassThrough&);
};



# 1 "/usr/include/wx-2.8/wx/generic/logg.h" 1
# 26 "/usr/include/wx-2.8/wx/generic/logg.h"
class wxLogTextCtrl : public wxLog
{
public:
    wxLogTextCtrl(wxTextCtrl *pTextCtrl);

protected:

    virtual void DoLogString(const wxChar *szString, time_t t);

private:

    wxTextCtrl *m_pTextCtrl;

    private: wxLogTextCtrl(const wxLogTextCtrl&); wxLogTextCtrl& operator=(const wxLogTextCtrl&);
};
# 50 "/usr/include/wx-2.8/wx/generic/logg.h"
class wxLogGui : public wxLog
{
public:

    wxLogGui();


    virtual void Flush();

protected:
    virtual void DoLog(wxLogLevel level, const wxChar *szString, time_t t);


    void Clear();

    wxArrayString m_aMessages;
    wxArrayInt m_aSeverity;
    wxArrayLong m_aTimes;
    bool m_bErrors,
                  m_bWarnings,
                  m_bHasMessages;

};
# 85 "/usr/include/wx-2.8/wx/generic/logg.h"
class wxLogWindow : public wxLogPassThrough
{
public:
    wxLogWindow(wxWindow *pParent,
                const wxChar *szTitle,
                bool bShow = true,
                bool bPassToOld = true);

    virtual ~wxLogWindow();



    void Show(bool bShow = true);

    wxFrame *GetFrame() const;




    virtual void OnFrameCreate(wxFrame *frame);




    virtual bool OnFrameClose(wxFrame *frame);


    virtual void OnFrameDelete(wxFrame *frame);

protected:
    virtual void DoLog(wxLogLevel level, const wxChar *szString, time_t t);
    virtual void DoLogString(const wxChar *szString, time_t t);

private:
    wxLogFrame *m_pLogFrame;

    private: wxLogWindow(const wxLogWindow&); wxLogWindow& operator=(const wxLogWindow&);
};
# 466 "/usr/include/wx-2.8/wx/log.h" 2
# 482 "/usr/include/wx-2.8/wx/log.h"
 unsigned long wxSysErrorCode();


 const wxChar* wxSysErrorMsg(unsigned long nErrCode = 0);
# 540 "/usr/include/wx-2.8/wx/log.h"
extern void wxVLogGeneric(wxLogLevel level, const wxChar *szFormat, va_list argptr); extern void wxLogGeneric(wxLogLevel level, const wxChar *szFormat, ...) ;


extern void wxVLogFatalError(const wxChar *szFormat, va_list argptr); extern void wxLogFatalError(const wxChar *szFormat, ...) ;
extern void wxVLogError(const wxChar *szFormat, va_list argptr); extern void wxLogError(const wxChar *szFormat, ...) ;
extern void wxVLogWarning(const wxChar *szFormat, va_list argptr); extern void wxLogWarning(const wxChar *szFormat, ...) ;
extern void wxVLogMessage(const wxChar *szFormat, va_list argptr); extern void wxLogMessage(const wxChar *szFormat, ...) ;
extern void wxVLogInfo(const wxChar *szFormat, va_list argptr); extern void wxLogInfo(const wxChar *szFormat, ...) ;
extern void wxVLogVerbose(const wxChar *szFormat, va_list argptr); extern void wxLogVerbose(const wxChar *szFormat, ...) ;



extern void wxVLogStatus(const wxChar *szFormat, va_list argptr); extern void wxLogStatus(const wxChar *szFormat, ...) ;



    class wxFrame;

    extern void wxVLogStatus(wxFrame * pFrame, const wxChar *szFormat, va_list argptr); extern void wxLogStatus(wxFrame * pFrame, const wxChar *szFormat, ...) ;




extern void wxVLogSysError(const wxChar *szFormat, va_list argptr); extern void wxLogSysError(const wxChar *szFormat, ...) ;



extern void wxVLogSysError(long lErrCode, const wxChar *szFormat, va_list argptr); extern void wxLogSysError(long lErrCode, const wxChar *szFormat, ...) ;
# 596 "/usr/include/wx-2.8/wx/log.h"
    inline void wxLogNop() { }
# 617 "/usr/include/wx-2.8/wx/log.h"
void
wxSafeShowMessage(const wxString& title, const wxString& text);
# 25 "/usr/include/wx-2.8/wx/wx.h" 2
# 1 "/usr/include/wx-2.8/wx/event.h" 1
# 18 "/usr/include/wx-2.8/wx/event.h"
# 1 "/usr/include/wx-2.8/wx/clntdata.h" 1
# 19 "/usr/include/wx-2.8/wx/clntdata.h"
typedef int (*wxShadowObjectMethod)(void*, void*);
class wxShadowObjectMethods_wxImplementation_Pair { public: typedef wxString t1; typedef wxShadowObjectMethod t2; typedef const wxString const_t1; typedef const wxShadowObjectMethod const_t2; wxShadowObjectMethods_wxImplementation_Pair( const const_t1& f, const const_t2& s ):first(t1(f)),second(t2(s)) {} t1 first; t2 second; }; class wxShadowObjectMethods_wxImplementation_KeyEx { typedef wxString key_type; typedef wxShadowObjectMethods_wxImplementation_Pair pair_type; typedef const key_type const_key_type; typedef const pair_type const_pair_type; typedef const_key_type& const_key_reference; typedef const_pair_type& const_pair_reference; public: wxShadowObjectMethods_wxImplementation_KeyEx() { } const_key_reference operator()( const_pair_reference pair ) const { return pair.first; } wxShadowObjectMethods_wxImplementation_KeyEx& operator=(const wxShadowObjectMethods_wxImplementation_KeyEx&) { return *this; } }; class wxShadowObjectMethods_wxImplementation_HashTable : protected _wxHashTableBase2 { public: typedef wxString key_type; typedef wxShadowObjectMethods_wxImplementation_Pair value_type; typedef wxStringHash hasher; typedef wxStringEqual key_equal; typedef size_t size_type; typedef ptrdiff_t difference_type; typedef value_type* pointer; typedef const value_type* const_pointer; typedef value_type& reference; typedef const value_type& const_reference; typedef const wxString const_key_type; typedef const wxShadowObjectMethods_wxImplementation_Pair const_mapped_type; public: struct Node; typedef wxShadowObjectMethods_wxImplementation_KeyEx key_extractor; typedef wxShadowObjectMethods_wxImplementation_HashTable Self; protected: Node** m_table; size_t m_tableBuckets; size_t m_items; hasher m_hasher; key_equal m_equals; key_extractor m_getKey; public: struct Node:public _wxHashTable_NodeBase { public: Node( const value_type& value ) : m_value( value ) {} Node* m_next() { return (Node*)this->m_nxt; } value_type m_value; }; class Iterator; friend class Iterator; protected: static void DeleteNode( _wxHashTable_NodeBase* node ) { delete (Node*)node; } public: class Iterator { public: Node* m_node; Self* m_ht; Iterator() : m_node(0), m_ht(0) {} Iterator( Node* node, const Self* ht ) : m_node(node), m_ht((Self*)ht) {} bool operator ==( const Iterator& it ) const { return m_node == it.m_node; } bool operator !=( const Iterator& it ) const { return m_node != it.m_node; } protected: Node* GetNextNode() { size_type bucket = GetBucketForNode(m_ht,m_node); for( size_type i = bucket + 1; i < m_ht->m_tableBuckets; ++i ) { if( m_ht->m_table[i] ) return m_ht->m_table[i]; } return 0; } void PlusPlus() { Node* next = m_node->m_next(); m_node = next ? next : GetNextNode(); } }; public: class iterator : public Iterator { public: iterator() : Iterator() {} iterator( Node* node, Self* ht ) : Iterator( node, ht ) {} iterator& operator++() { PlusPlus(); return *this; } iterator operator++(int) { iterator it=*this;PlusPlus();return it; } reference operator *() const { return m_node->m_value; } pointer operator ->() const { return &(m_node->m_value); } }; class const_iterator : public Iterator { public: const_iterator() : Iterator() {} const_iterator(iterator i) : Iterator(i) {} const_iterator( Node* node, const Self* ht ) : Iterator( node, (Self*)ht ) {} const_iterator& operator++() { PlusPlus();return *this; } const_iterator operator++(int) { const_iterator it=*this;PlusPlus();return it; } const_reference operator *() const { return m_node->m_value; } const_pointer operator ->() const { return &(m_node->m_value); } }; wxShadowObjectMethods_wxImplementation_HashTable( size_type sz = 10, const hasher& hfun = hasher(), const key_equal& k_eq = key_equal(), const key_extractor& k_ex = key_extractor() ) : m_tableBuckets( GetNextPrime( (unsigned long) sz ) ), m_items( 0 ), m_hasher( hfun ), m_equals( k_eq ), m_getKey( k_ex ) { m_table = (Node**)AllocTable( m_tableBuckets ); } wxShadowObjectMethods_wxImplementation_HashTable( const Self& ht ) : m_table( 0 ), m_tableBuckets( 0 ), m_items( ht.m_items ), m_hasher( ht.m_hasher ), m_equals( ht.m_equals ), m_getKey( ht.m_getKey ) { HashCopy( ht ); } const Self& operator=( const Self& ht ) { clear(); m_hasher = ht.m_hasher; m_equals = ht.m_equals; m_getKey = ht.m_getKey; m_items = ht.m_items; HashCopy( ht ); return *this; } ~wxShadowObjectMethods_wxImplementation_HashTable() { clear(); FreeTable(m_table); } hasher hash_funct() { return m_hasher; } key_equal key_eq() { return m_equals; } void clear() { DeleteNodes( m_tableBuckets, (_wxHashTable_NodeBase**)m_table, DeleteNode ); m_items = 0; } size_type size() const { return m_items; } size_type max_size() const { return size_type(-1); } bool empty() const { return size() == 0; } const_iterator end() const { return const_iterator( 0, this ); } iterator end() { return iterator( 0, this ); } const_iterator begin() const { return const_iterator( (Node*)GetFirstNode( m_tableBuckets, (_wxHashTable_NodeBase**)m_table ), this ); } iterator begin() { return iterator( (Node*)GetFirstNode( m_tableBuckets, (_wxHashTable_NodeBase**)m_table ), this ); } size_type erase( const const_key_type& key ) { Node** node = GetNodePtr( key ); if( !node ) return 0; --m_items; Node* temp = (*node)->m_next(); delete *node; (*node) = temp; if( never_shrink( m_tableBuckets, m_items ) ) ResizeTable( GetPreviousPrime( (unsigned long) m_tableBuckets ) - 1 ); return 1; } protected: static size_type GetBucketForNode( Self* ht, Node* node ) { return ht->m_hasher( ht->m_getKey( node->m_value ) ) % ht->m_tableBuckets; } static Node* CopyNode( Node* node ) { return new Node( *node ); } Node* GetOrCreateNode( const value_type& value, bool& created ) { const const_key_type& key = m_getKey( value ); size_t bucket = m_hasher( key ) % m_tableBuckets; Node* node = m_table[bucket]; while( node ) { if( m_equals( m_getKey( node->m_value ), key ) ) { created = false; return node; } node = node->m_next(); } created = true; return CreateNode( value, bucket); } Node * CreateNode( const value_type& value, size_t bucket ) { Node* node = new Node( value ); node->m_nxt = m_table[bucket]; m_table[bucket] = node; ++m_items; if( grow_lf70( m_tableBuckets, m_items ) ) ResizeTable( m_tableBuckets ); return node; } void CreateNode( const value_type& value ) { CreateNode(value, m_hasher( m_getKey(value) ) % m_tableBuckets ); } Node** GetNodePtr( const const_key_type& key ) const { size_t bucket = m_hasher( key ) % m_tableBuckets; Node** node = &m_table[bucket]; while( *node ) { if( m_equals( m_getKey( (*node)->m_value ), key ) ) return node; node = (Node**)&(*node)->m_nxt; } return __null; } Node* GetNode( const const_key_type& key ) const { size_t bucket = m_hasher( key ) % m_tableBuckets; Node* node = m_table[bucket]; while( node ) { if( m_equals( m_getKey( node->m_value ), key ) ) return node; node = node->m_next(); } return 0; } void ResizeTable( size_t newSize ) { newSize = GetNextPrime( (unsigned long)newSize ); Node** srcTable = m_table; size_t srcBuckets = m_tableBuckets; m_table = (Node**)AllocTable( newSize ); m_tableBuckets = newSize; CopyHashTable( (_wxHashTable_NodeBase**)srcTable, srcBuckets, this, (_wxHashTable_NodeBase**)m_table, (BucketFromNode)GetBucketForNode, (ProcessNode)&DummyProcessNode ); FreeTable(srcTable); } void HashCopy( const Self& ht ) { ResizeTable( ht.size() ); CopyHashTable( (_wxHashTable_NodeBase**)ht.m_table, ht.m_tableBuckets, (_wxHashTableBase2*)this, (_wxHashTable_NodeBase**)m_table, (BucketFromNode)GetBucketForNode, (ProcessNode)CopyNode ); } }; class wxShadowObjectMethods:public wxShadowObjectMethods_wxImplementation_HashTable { public: typedef wxShadowObjectMethod mapped_type; class Insert_Result { public: typedef iterator t1; typedef bool t2; typedef const iterator const_t1; typedef const bool const_t2; Insert_Result( const const_t1& f, const const_t2& s ):first(t1(f)),second(t2(s)) {} t1 first; t2 second; }; explicit wxShadowObjectMethods( size_type hint = 100, hasher hf = hasher(), key_equal eq = key_equal() ) : wxShadowObjectMethods_wxImplementation_HashTable( hint, hf, eq, wxShadowObjectMethods_wxImplementation_KeyEx() ) {} mapped_type& operator[]( const const_key_type& key ) { bool created; return GetOrCreateNode( wxShadowObjectMethods_wxImplementation_Pair( key, mapped_type() ), created)->m_value.second; } const_iterator find( const const_key_type& key ) const { return const_iterator( GetNode( key ), this ); } iterator find( const const_key_type& key ) { return iterator( GetNode( key ), this ); } Insert_Result insert( const value_type& v ) { bool created; Node *node = GetOrCreateNode( wxShadowObjectMethods_wxImplementation_Pair( v.first, v.second ), created); return Insert_Result(iterator(node, this), created); } size_type erase( const key_type& k ) { return wxShadowObjectMethods_wxImplementation_HashTable::erase( k ); } void erase( const iterator& it ) { erase( it->first ); } void erase( const const_iterator& it ) { erase( it->first ); } size_type count( const const_key_type& key ) { return (size_type)(GetNode( key ) ? 1 : 0); } };




class wxShadowObjectFields_wxImplementation_Pair { public: typedef wxString t1; typedef void * t2; typedef const wxString const_t1; typedef const void * const_t2; wxShadowObjectFields_wxImplementation_Pair( const const_t1& f, const const_t2& s ):first(t1(f)),second(t2(s)) {} t1 first; t2 second; }; class wxShadowObjectFields_wxImplementation_KeyEx { typedef wxString key_type; typedef wxShadowObjectFields_wxImplementation_Pair pair_type; typedef const key_type const_key_type; typedef const pair_type const_pair_type; typedef const_key_type& const_key_reference; typedef const_pair_type& const_pair_reference; public: wxShadowObjectFields_wxImplementation_KeyEx() { } const_key_reference operator()( const_pair_reference pair ) const { return pair.first; } wxShadowObjectFields_wxImplementation_KeyEx& operator=(const wxShadowObjectFields_wxImplementation_KeyEx&) { return *this; } }; class wxShadowObjectFields_wxImplementation_HashTable : protected _wxHashTableBase2 { public: typedef wxString key_type; typedef wxShadowObjectFields_wxImplementation_Pair value_type; typedef wxStringHash hasher; typedef wxStringEqual key_equal; typedef size_t size_type; typedef ptrdiff_t difference_type; typedef value_type* pointer; typedef const value_type* const_pointer; typedef value_type& reference; typedef const value_type& const_reference; typedef const wxString const_key_type; typedef const wxShadowObjectFields_wxImplementation_Pair const_mapped_type; public: struct Node; typedef wxShadowObjectFields_wxImplementation_KeyEx key_extractor; typedef wxShadowObjectFields_wxImplementation_HashTable Self; protected: Node** m_table; size_t m_tableBuckets; size_t m_items; hasher m_hasher; key_equal m_equals; key_extractor m_getKey; public: struct Node:public _wxHashTable_NodeBase { public: Node( const value_type& value ) : m_value( value ) {} Node* m_next() { return (Node*)this->m_nxt; } value_type m_value; }; class Iterator; friend class Iterator; protected: static void DeleteNode( _wxHashTable_NodeBase* node ) { delete (Node*)node; } public: class Iterator { public: Node* m_node; Self* m_ht; Iterator() : m_node(0), m_ht(0) {} Iterator( Node* node, const Self* ht ) : m_node(node), m_ht((Self*)ht) {} bool operator ==( const Iterator& it ) const { return m_node == it.m_node; } bool operator !=( const Iterator& it ) const { return m_node != it.m_node; } protected: Node* GetNextNode() { size_type bucket = GetBucketForNode(m_ht,m_node); for( size_type i = bucket + 1; i < m_ht->m_tableBuckets; ++i ) { if( m_ht->m_table[i] ) return m_ht->m_table[i]; } return 0; } void PlusPlus() { Node* next = m_node->m_next(); m_node = next ? next : GetNextNode(); } }; public: class iterator : public Iterator { public: iterator() : Iterator() {} iterator( Node* node, Self* ht ) : Iterator( node, ht ) {} iterator& operator++() { PlusPlus(); return *this; } iterator operator++(int) { iterator it=*this;PlusPlus();return it; } reference operator *() const { return m_node->m_value; } pointer operator ->() const { return &(m_node->m_value); } }; class const_iterator : public Iterator { public: const_iterator() : Iterator() {} const_iterator(iterator i) : Iterator(i) {} const_iterator( Node* node, const Self* ht ) : Iterator( node, (Self*)ht ) {} const_iterator& operator++() { PlusPlus();return *this; } const_iterator operator++(int) { const_iterator it=*this;PlusPlus();return it; } const_reference operator *() const { return m_node->m_value; } const_pointer operator ->() const { return &(m_node->m_value); } }; wxShadowObjectFields_wxImplementation_HashTable( size_type sz = 10, const hasher& hfun = hasher(), const key_equal& k_eq = key_equal(), const key_extractor& k_ex = key_extractor() ) : m_tableBuckets( GetNextPrime( (unsigned long) sz ) ), m_items( 0 ), m_hasher( hfun ), m_equals( k_eq ), m_getKey( k_ex ) { m_table = (Node**)AllocTable( m_tableBuckets ); } wxShadowObjectFields_wxImplementation_HashTable( const Self& ht ) : m_table( 0 ), m_tableBuckets( 0 ), m_items( ht.m_items ), m_hasher( ht.m_hasher ), m_equals( ht.m_equals ), m_getKey( ht.m_getKey ) { HashCopy( ht ); } const Self& operator=( const Self& ht ) { clear(); m_hasher = ht.m_hasher; m_equals = ht.m_equals; m_getKey = ht.m_getKey; m_items = ht.m_items; HashCopy( ht ); return *this; } ~wxShadowObjectFields_wxImplementation_HashTable() { clear(); FreeTable(m_table); } hasher hash_funct() { return m_hasher; } key_equal key_eq() { return m_equals; } void clear() { DeleteNodes( m_tableBuckets, (_wxHashTable_NodeBase**)m_table, DeleteNode ); m_items = 0; } size_type size() const { return m_items; } size_type max_size() const { return size_type(-1); } bool empty() const { return size() == 0; } const_iterator end() const { return const_iterator( 0, this ); } iterator end() { return iterator( 0, this ); } const_iterator begin() const { return const_iterator( (Node*)GetFirstNode( m_tableBuckets, (_wxHashTable_NodeBase**)m_table ), this ); } iterator begin() { return iterator( (Node*)GetFirstNode( m_tableBuckets, (_wxHashTable_NodeBase**)m_table ), this ); } size_type erase( const const_key_type& key ) { Node** node = GetNodePtr( key ); if( !node ) return 0; --m_items; Node* temp = (*node)->m_next(); delete *node; (*node) = temp; if( never_shrink( m_tableBuckets, m_items ) ) ResizeTable( GetPreviousPrime( (unsigned long) m_tableBuckets ) - 1 ); return 1; } protected: static size_type GetBucketForNode( Self* ht, Node* node ) { return ht->m_hasher( ht->m_getKey( node->m_value ) ) % ht->m_tableBuckets; } static Node* CopyNode( Node* node ) { return new Node( *node ); } Node* GetOrCreateNode( const value_type& value, bool& created ) { const const_key_type& key = m_getKey( value ); size_t bucket = m_hasher( key ) % m_tableBuckets; Node* node = m_table[bucket]; while( node ) { if( m_equals( m_getKey( node->m_value ), key ) ) { created = false; return node; } node = node->m_next(); } created = true; return CreateNode( value, bucket); } Node * CreateNode( const value_type& value, size_t bucket ) { Node* node = new Node( value ); node->m_nxt = m_table[bucket]; m_table[bucket] = node; ++m_items; if( grow_lf70( m_tableBuckets, m_items ) ) ResizeTable( m_tableBuckets ); return node; } void CreateNode( const value_type& value ) { CreateNode(value, m_hasher( m_getKey(value) ) % m_tableBuckets ); } Node** GetNodePtr( const const_key_type& key ) const { size_t bucket = m_hasher( key ) % m_tableBuckets; Node** node = &m_table[bucket]; while( *node ) { if( m_equals( m_getKey( (*node)->m_value ), key ) ) return node; node = (Node**)&(*node)->m_nxt; } return __null; } Node* GetNode( const const_key_type& key ) const { size_t bucket = m_hasher( key ) % m_tableBuckets; Node* node = m_table[bucket]; while( node ) { if( m_equals( m_getKey( node->m_value ), key ) ) return node; node = node->m_next(); } return 0; } void ResizeTable( size_t newSize ) { newSize = GetNextPrime( (unsigned long)newSize ); Node** srcTable = m_table; size_t srcBuckets = m_tableBuckets; m_table = (Node**)AllocTable( newSize ); m_tableBuckets = newSize; CopyHashTable( (_wxHashTable_NodeBase**)srcTable, srcBuckets, this, (_wxHashTable_NodeBase**)m_table, (BucketFromNode)GetBucketForNode, (ProcessNode)&DummyProcessNode ); FreeTable(srcTable); } void HashCopy( const Self& ht ) { ResizeTable( ht.size() ); CopyHashTable( (_wxHashTable_NodeBase**)ht.m_table, ht.m_tableBuckets, (_wxHashTableBase2*)this, (_wxHashTable_NodeBase**)m_table, (BucketFromNode)GetBucketForNode, (ProcessNode)CopyNode ); } }; class wxShadowObjectFields:public wxShadowObjectFields_wxImplementation_HashTable { public: typedef void * mapped_type; class Insert_Result { public: typedef iterator t1; typedef bool t2; typedef const iterator const_t1; typedef const bool const_t2; Insert_Result( const const_t1& f, const const_t2& s ):first(t1(f)),second(t2(s)) {} t1 first; t2 second; }; explicit wxShadowObjectFields( size_type hint = 100, hasher hf = hasher(), key_equal eq = key_equal() ) : wxShadowObjectFields_wxImplementation_HashTable( hint, hf, eq, wxShadowObjectFields_wxImplementation_KeyEx() ) {} mapped_type& operator[]( const const_key_type& key ) { bool created; return GetOrCreateNode( wxShadowObjectFields_wxImplementation_Pair( key, mapped_type() ), created)->m_value.second; } const_iterator find( const const_key_type& key ) const { return const_iterator( GetNode( key ), this ); } iterator find( const const_key_type& key ) { return iterator( GetNode( key ), this ); } Insert_Result insert( const value_type& v ) { bool created; Node *node = GetOrCreateNode( wxShadowObjectFields_wxImplementation_Pair( v.first, v.second ), created); return Insert_Result(iterator(node, this), created); } size_type erase( const key_type& k ) { return wxShadowObjectFields_wxImplementation_HashTable::erase( k ); } void erase( const iterator& it ) { erase( it->first ); } void erase( const const_iterator& it ) { erase( it->first ); } size_type count( const const_key_type& key ) { return (size_type)(GetNode( key ) ? 1 : 0); } };





class wxShadowObject
{
public:
    wxShadowObject() { }

    void AddMethod( const wxString &name, wxShadowObjectMethod method )
    {
        wxShadowObjectMethods::iterator it = m_methods.find( name );
        if (it == m_methods.end())
            m_methods[ name ] = method;
        else
            it->second = method;
    }

    bool InvokeMethod( const wxString &name, void* window, void* param, int* returnValue )
    {
        wxShadowObjectMethods::iterator it = m_methods.find( name );
        if (it == m_methods.end())
            return false;
        wxShadowObjectMethod method = it->second;
        int ret = (*method)(window, param);
        if (returnValue)
            *returnValue = ret;
        return true;
    }

    void AddField( const wxString &name, void* initialValue = __null )
    {
        wxShadowObjectFields::iterator it = m_fields.find( name );
        if (it == m_fields.end())
            m_fields[ name ] = initialValue;
        else
            it->second = initialValue;
    }

    void SetField( const wxString &name, void* value )
    {
        wxShadowObjectFields::iterator it = m_fields.find( name );
        if (it == m_fields.end())
            return;
        it->second = value;
    }

    void* GetField( const wxString &name, void *defaultValue = __null )
    {
        wxShadowObjectFields::iterator it = m_fields.find( name );
        if (it == m_fields.end())
            return defaultValue;
        return it->second;
    }

private:
    wxShadowObjectMethods m_methods;
    wxShadowObjectFields m_fields;
};





enum wxClientDataType
{
    wxClientData_None,
    wxClientData_Object,
    wxClientData_Void
};

class wxClientData
{
public:
    wxClientData() { }
    virtual ~wxClientData() { }
};

class wxStringClientData : public wxClientData
{
public:
    wxStringClientData() : m_data() { }
    wxStringClientData( const wxString &data ) : m_data(data) { }
    void SetData( const wxString &data ) { m_data = data; }
    const wxString& GetData() const { return m_data; }

private:
    wxString m_data;
};
# 126 "/usr/include/wx-2.8/wx/clntdata.h"
class wxClientDataContainer
{
public:
    wxClientDataContainer();
    virtual ~wxClientDataContainer();

    void SetClientObject( wxClientData *data ) { DoSetClientObject(data); }
    wxClientData *GetClientObject() const { return DoGetClientObject(); }

    void SetClientData( void *data ) { DoSetClientData(data); }
    void *GetClientData() const { return DoGetClientData(); }

protected:





    union
    {
        wxClientData *m_clientObject;
        void *m_clientData;
    };


    virtual void DoSetClientObject( wxClientData *data );
    virtual wxClientData *DoGetClientObject() const;

    virtual void DoSetClientData( void *data );
    virtual void *DoGetClientData() const;


    wxClientDataType m_clientDataType;

};

# 1 "/usr/include/wx-2.8/wx/vector.h" 1
# 16 "/usr/include/wx-2.8/wx/vector.h"
class wxVectorBase
{
public:
    typedef size_t size_type;
private:
    size_type m_allocsize;
    size_type m_size,
              m_capacity;
    void **m_objects;

protected:
    bool Alloc(size_type sz)
    {

        sz = (sz / m_allocsize + 1) * m_allocsize;
        if (sz <= m_capacity)
            return true;


        void *mem = realloc(m_objects, sizeof(void *) * sz);
        if (! mem)
            return false;

        m_objects = (void **) mem;
        m_capacity = sz;
        return true;
    }


    virtual void Free(void *) = 0;

    virtual void *Copy(const void *) const = 0;

    const void *GetItem(size_type idx) const
    {
        ;
        return m_objects[idx];
    }

    void Append(void *obj)
    {
        ;
        m_objects[m_size] = obj;
        m_size++;
    }

    void RemoveAt(size_type idx)
    {
        ;
        Free(m_objects[idx]);
        if (idx < m_size - 1)
            memcpy(
                m_objects + idx,
                m_objects + idx + 1,
                ( m_size - idx - 1 ) * sizeof(void*) );
        m_size--;
    }

    bool copy(const wxVectorBase& vb)
    {
        clear();
        if (! Alloc(vb.size()))
            return false;

        for (size_type i = 0; i < vb.size(); i++)
        {
            void *o = vb.Copy(vb.GetItem(i));
            if (! o)
                return false;
            Append(o);
        }

        return true;
    }

public:
    wxVectorBase() : m_allocsize(16), m_size(0), m_capacity(0), m_objects(0) {}
    virtual ~wxVectorBase() {}

    void clear()
    {
        for (size_type i = 0; i < size(); i++)
            Free(m_objects[i]);
        free(m_objects);
        m_objects = 0;
        m_size = m_capacity = 0;
    }

    void reserve(size_type n)
    {
        if ( !Alloc(n) )
        {
            ;
        }
    }

    size_type size() const
    {
        return m_size;
    }

    size_type capacity() const
    {
        return m_capacity;
    }

    bool empty() const
    {
        return size() == 0;
    }

    wxVectorBase& operator = (const wxVectorBase& vb)
    {
        if ( copy(vb) ) ; else { ; return *this; } typedef int wxDummyCheckInt;
        return *this;
    }
};
# 163 "/usr/include/wx-2.8/wx/clntdata.h" 2

struct wxClientDataDictionaryPair
{
    wxClientDataDictionaryPair( size_t idx ) : index( idx ), data( 0 ) { }

    size_t index;
    wxClientData* data;
};

class wxClientDataDictionaryPairVector : public wxVectorBase{ protected: virtual void Free(void *o) { delete (wxClientDataDictionaryPair *) o; } virtual void *Copy(const void *o) const { return new wxClientDataDictionaryPair(*(wxClientDataDictionaryPair *) o); }public: wxClientDataDictionaryPairVector() {} wxClientDataDictionaryPairVector(const wxClientDataDictionaryPairVector& c) : wxVectorBase() { if ( copy(c) ) ; else { ; return; } typedef int wxDummyCheckInt; } ~wxClientDataDictionaryPairVector() { clear(); }public: void push_back(const wxClientDataDictionaryPair& o) { if ( Alloc(size() + 1) ) ; else { ; return; } typedef int wxDummyCheckInt; Append(new wxClientDataDictionaryPair(o)); } void pop_back() { RemoveAt(size() - 1); } const wxClientDataDictionaryPair& at(size_type idx) const { return *(wxClientDataDictionaryPair *) GetItem(idx); } wxClientDataDictionaryPair& at(size_type idx) { return *(wxClientDataDictionaryPair *) GetItem(idx); } const wxClientDataDictionaryPair& operator[](size_type idx) const { return at(idx); } wxClientDataDictionaryPair& operator[](size_type idx) { return at(idx); } const wxClientDataDictionaryPair& front() const { return at(0); } wxClientDataDictionaryPair& front() { return at(0); } const wxClientDataDictionaryPair& back() const { return at(size() - 1); } wxClientDataDictionaryPair& back() { return at(size() - 1); } size_type erase(size_type idx) { RemoveAt(idx); return idx; }};
# 184 "/usr/include/wx-2.8/wx/clntdata.h"
class wxClientDataDictionary
{
public:
    wxClientDataDictionary() {}


    void DestroyData()
    {
        for( size_t i = 0, end = m_vec.size(); i != end; ++i )
            delete m_vec[i].data;
        m_vec.clear();
    }




    void Set( size_t index, wxClientData* data, bool doDelete )
    {
        size_t ptr = Find( index );

        if( !data )
        {
            if( ptr == m_vec.size() ) return;
            if( doDelete )
                delete m_vec[ptr].data;
            m_vec.erase( ptr );
        }
        else
        {
            if( ptr == m_vec.size() )
            {
                m_vec.push_back( wxClientDataDictionaryPair( index ) );
                ptr = m_vec.size() - 1;
            }

            if( doDelete )
                delete m_vec[ptr].data;
            m_vec[ptr].data = data;
        }
    }



    wxClientData* Get( size_t index ) const
    {
        size_t it = Find( index );
        if( it == m_vec.size() ) return 0;
        return (wxClientData*)m_vec[it].data;
    }




    void Delete( size_t index, bool doDelete )
    {
        size_t todel = m_vec.size();

        for( size_t i = 0, end = m_vec.size(); i != end; ++i )
        {
            if( m_vec[i].index == index )
                todel = i;
            else if( m_vec[i].index > index )
                --(m_vec[i].index);
        }

        if( todel != m_vec.size() )
        {
            if( doDelete )
                delete m_vec[todel].data;
            m_vec.erase( todel );
        }
    }
private:

    size_t Find( size_t index ) const
    {
        for( size_t i = 0, end = m_vec.size(); i != end; ++i )
        {
            if( m_vec[i].index == index )
                return i;
        }

        return m_vec.size();
    }

    wxClientDataDictionaryPairVector m_vec;
};
# 19 "/usr/include/wx-2.8/wx/event.h" 2


# 1 "/usr/include/wx-2.8/wx/gdicmn.h" 1
# 24 "/usr/include/wx-2.8/wx/gdicmn.h"
# 1 "/usr/include/wx-2.8/wx/math.h" 1
# 19 "/usr/include/wx-2.8/wx/math.h"
# 1 "/usr/include/math.h" 1 3 4
# 30 "/usr/include/math.h" 3 4
extern "C" {



# 1 "/usr/include/bits/huge_val.h" 1 3 4
# 35 "/usr/include/math.h" 2 3 4

# 1 "/usr/include/bits/huge_valf.h" 1 3 4
# 37 "/usr/include/math.h" 2 3 4
# 1 "/usr/include/bits/huge_vall.h" 1 3 4
# 38 "/usr/include/math.h" 2 3 4


# 1 "/usr/include/bits/inf.h" 1 3 4
# 41 "/usr/include/math.h" 2 3 4


# 1 "/usr/include/bits/nan.h" 1 3 4
# 44 "/usr/include/math.h" 2 3 4



# 1 "/usr/include/bits/mathdef.h" 1 3 4
# 26 "/usr/include/bits/mathdef.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 27 "/usr/include/bits/mathdef.h" 2 3 4
# 38 "/usr/include/bits/mathdef.h" 3 4
typedef long double float_t;

typedef long double double_t;
# 48 "/usr/include/math.h" 2 3 4
# 71 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/bits/mathcalls.h" 3 4


extern double acos (double __x) throw (); extern double __acos (double __x) throw ();

extern double asin (double __x) throw (); extern double __asin (double __x) throw ();

extern double atan (double __x) throw (); extern double __atan (double __x) throw ();

extern double atan2 (double __y, double __x) throw (); extern double __atan2 (double __y, double __x) throw ();


extern double cos (double __x) throw (); extern double __cos (double __x) throw ();

extern double sin (double __x) throw (); extern double __sin (double __x) throw ();

extern double tan (double __x) throw (); extern double __tan (double __x) throw ();




extern double cosh (double __x) throw (); extern double __cosh (double __x) throw ();

extern double sinh (double __x) throw (); extern double __sinh (double __x) throw ();

extern double tanh (double __x) throw (); extern double __tanh (double __x) throw ();




extern void sincos (double __x, double *__sinx, double *__cosx) throw (); extern void __sincos (double __x, double *__sinx, double *__cosx) throw ();






extern double acosh (double __x) throw (); extern double __acosh (double __x) throw ();

extern double asinh (double __x) throw (); extern double __asinh (double __x) throw ();

extern double atanh (double __x) throw (); extern double __atanh (double __x) throw ();







extern double exp (double __x) throw (); extern double __exp (double __x) throw ();


extern double frexp (double __x, int *__exponent) throw (); extern double __frexp (double __x, int *__exponent) throw ();


extern double ldexp (double __x, int __exponent) throw (); extern double __ldexp (double __x, int __exponent) throw ();


extern double log (double __x) throw (); extern double __log (double __x) throw ();


extern double log10 (double __x) throw (); extern double __log10 (double __x) throw ();


extern double modf (double __x, double *__iptr) throw (); extern double __modf (double __x, double *__iptr) throw ();




extern double exp10 (double __x) throw (); extern double __exp10 (double __x) throw ();

extern double pow10 (double __x) throw (); extern double __pow10 (double __x) throw ();





extern double expm1 (double __x) throw (); extern double __expm1 (double __x) throw ();


extern double log1p (double __x) throw (); extern double __log1p (double __x) throw ();


extern double logb (double __x) throw (); extern double __logb (double __x) throw ();






extern double exp2 (double __x) throw (); extern double __exp2 (double __x) throw ();


extern double log2 (double __x) throw (); extern double __log2 (double __x) throw ();








extern double pow (double __x, double __y) throw (); extern double __pow (double __x, double __y) throw ();


extern double sqrt (double __x) throw (); extern double __sqrt (double __x) throw ();





extern double hypot (double __x, double __y) throw (); extern double __hypot (double __x, double __y) throw ();






extern double cbrt (double __x) throw (); extern double __cbrt (double __x) throw ();








extern double ceil (double __x) throw () __attribute__ ((__const__)); extern double __ceil (double __x) throw () __attribute__ ((__const__));


extern double fabs (double __x) throw () __attribute__ ((__const__)); extern double __fabs (double __x) throw () __attribute__ ((__const__));


extern double floor (double __x) throw () __attribute__ ((__const__)); extern double __floor (double __x) throw () __attribute__ ((__const__));


extern double fmod (double __x, double __y) throw (); extern double __fmod (double __x, double __y) throw ();




extern int __isinf (double __value) throw () __attribute__ ((__const__));


extern int __finite (double __value) throw () __attribute__ ((__const__));





extern int isinf (double __value) throw () __attribute__ ((__const__));


extern int finite (double __value) throw () __attribute__ ((__const__));


extern double drem (double __x, double __y) throw (); extern double __drem (double __x, double __y) throw ();



extern double significand (double __x) throw (); extern double __significand (double __x) throw ();





extern double copysign (double __x, double __y) throw () __attribute__ ((__const__)); extern double __copysign (double __x, double __y) throw () __attribute__ ((__const__));






extern double nan (__const char *__tagb) throw () __attribute__ ((__const__)); extern double __nan (__const char *__tagb) throw () __attribute__ ((__const__));





extern int __isnan (double __value) throw () __attribute__ ((__const__));



extern int isnan (double __value) throw () __attribute__ ((__const__));


extern double j0 (double) throw (); extern double __j0 (double) throw ();
extern double j1 (double) throw (); extern double __j1 (double) throw ();
extern double jn (int, double) throw (); extern double __jn (int, double) throw ();
extern double y0 (double) throw (); extern double __y0 (double) throw ();
extern double y1 (double) throw (); extern double __y1 (double) throw ();
extern double yn (int, double) throw (); extern double __yn (int, double) throw ();






extern double erf (double) throw (); extern double __erf (double) throw ();
extern double erfc (double) throw (); extern double __erfc (double) throw ();
extern double lgamma (double) throw (); extern double __lgamma (double) throw ();






extern double tgamma (double) throw (); extern double __tgamma (double) throw ();





extern double gamma (double) throw (); extern double __gamma (double) throw ();






extern double lgamma_r (double, int *__signgamp) throw (); extern double __lgamma_r (double, int *__signgamp) throw ();







extern double rint (double __x) throw (); extern double __rint (double __x) throw ();


extern double nextafter (double __x, double __y) throw () __attribute__ ((__const__)); extern double __nextafter (double __x, double __y) throw () __attribute__ ((__const__));

extern double nexttoward (double __x, long double __y) throw () __attribute__ ((__const__)); extern double __nexttoward (double __x, long double __y) throw () __attribute__ ((__const__));



extern double remainder (double __x, double __y) throw (); extern double __remainder (double __x, double __y) throw ();



extern double scalbn (double __x, int __n) throw (); extern double __scalbn (double __x, int __n) throw ();



extern int ilogb (double __x) throw (); extern int __ilogb (double __x) throw ();




extern double scalbln (double __x, long int __n) throw (); extern double __scalbln (double __x, long int __n) throw ();



extern double nearbyint (double __x) throw (); extern double __nearbyint (double __x) throw ();



extern double round (double __x) throw () __attribute__ ((__const__)); extern double __round (double __x) throw () __attribute__ ((__const__));



extern double trunc (double __x) throw () __attribute__ ((__const__)); extern double __trunc (double __x) throw () __attribute__ ((__const__));




extern double remquo (double __x, double __y, int *__quo) throw (); extern double __remquo (double __x, double __y, int *__quo) throw ();






extern long int lrint (double __x) throw (); extern long int __lrint (double __x) throw ();
extern long long int llrint (double __x) throw (); extern long long int __llrint (double __x) throw ();



extern long int lround (double __x) throw (); extern long int __lround (double __x) throw ();
extern long long int llround (double __x) throw (); extern long long int __llround (double __x) throw ();



extern double fdim (double __x, double __y) throw (); extern double __fdim (double __x, double __y) throw ();


extern double fmax (double __x, double __y) throw (); extern double __fmax (double __x, double __y) throw ();


extern double fmin (double __x, double __y) throw (); extern double __fmin (double __x, double __y) throw ();



extern int __fpclassify (double __value) throw ()
     __attribute__ ((__const__));


extern int __signbit (double __value) throw ()
     __attribute__ ((__const__));



extern double fma (double __x, double __y, double __z) throw (); extern double __fma (double __x, double __y, double __z) throw ();








extern double scalb (double __x, double __n) throw (); extern double __scalb (double __x, double __n) throw ();
# 72 "/usr/include/math.h" 2 3 4
# 94 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/bits/mathcalls.h" 3 4


extern float acosf (float __x) throw (); extern float __acosf (float __x) throw ();

extern float asinf (float __x) throw (); extern float __asinf (float __x) throw ();

extern float atanf (float __x) throw (); extern float __atanf (float __x) throw ();

extern float atan2f (float __y, float __x) throw (); extern float __atan2f (float __y, float __x) throw ();


extern float cosf (float __x) throw (); extern float __cosf (float __x) throw ();

extern float sinf (float __x) throw (); extern float __sinf (float __x) throw ();

extern float tanf (float __x) throw (); extern float __tanf (float __x) throw ();




extern float coshf (float __x) throw (); extern float __coshf (float __x) throw ();

extern float sinhf (float __x) throw (); extern float __sinhf (float __x) throw ();

extern float tanhf (float __x) throw (); extern float __tanhf (float __x) throw ();




extern void sincosf (float __x, float *__sinx, float *__cosx) throw (); extern void __sincosf (float __x, float *__sinx, float *__cosx) throw ();






extern float acoshf (float __x) throw (); extern float __acoshf (float __x) throw ();

extern float asinhf (float __x) throw (); extern float __asinhf (float __x) throw ();

extern float atanhf (float __x) throw (); extern float __atanhf (float __x) throw ();







extern float expf (float __x) throw (); extern float __expf (float __x) throw ();


extern float frexpf (float __x, int *__exponent) throw (); extern float __frexpf (float __x, int *__exponent) throw ();


extern float ldexpf (float __x, int __exponent) throw (); extern float __ldexpf (float __x, int __exponent) throw ();


extern float logf (float __x) throw (); extern float __logf (float __x) throw ();


extern float log10f (float __x) throw (); extern float __log10f (float __x) throw ();


extern float modff (float __x, float *__iptr) throw (); extern float __modff (float __x, float *__iptr) throw ();




extern float exp10f (float __x) throw (); extern float __exp10f (float __x) throw ();

extern float pow10f (float __x) throw (); extern float __pow10f (float __x) throw ();





extern float expm1f (float __x) throw (); extern float __expm1f (float __x) throw ();


extern float log1pf (float __x) throw (); extern float __log1pf (float __x) throw ();


extern float logbf (float __x) throw (); extern float __logbf (float __x) throw ();






extern float exp2f (float __x) throw (); extern float __exp2f (float __x) throw ();


extern float log2f (float __x) throw (); extern float __log2f (float __x) throw ();








extern float powf (float __x, float __y) throw (); extern float __powf (float __x, float __y) throw ();


extern float sqrtf (float __x) throw (); extern float __sqrtf (float __x) throw ();





extern float hypotf (float __x, float __y) throw (); extern float __hypotf (float __x, float __y) throw ();






extern float cbrtf (float __x) throw (); extern float __cbrtf (float __x) throw ();








extern float ceilf (float __x) throw () __attribute__ ((__const__)); extern float __ceilf (float __x) throw () __attribute__ ((__const__));


extern float fabsf (float __x) throw () __attribute__ ((__const__)); extern float __fabsf (float __x) throw () __attribute__ ((__const__));


extern float floorf (float __x) throw () __attribute__ ((__const__)); extern float __floorf (float __x) throw () __attribute__ ((__const__));


extern float fmodf (float __x, float __y) throw (); extern float __fmodf (float __x, float __y) throw ();




extern int __isinff (float __value) throw () __attribute__ ((__const__));


extern int __finitef (float __value) throw () __attribute__ ((__const__));





extern int isinff (float __value) throw () __attribute__ ((__const__));


extern int finitef (float __value) throw () __attribute__ ((__const__));


extern float dremf (float __x, float __y) throw (); extern float __dremf (float __x, float __y) throw ();



extern float significandf (float __x) throw (); extern float __significandf (float __x) throw ();





extern float copysignf (float __x, float __y) throw () __attribute__ ((__const__)); extern float __copysignf (float __x, float __y) throw () __attribute__ ((__const__));






extern float nanf (__const char *__tagb) throw () __attribute__ ((__const__)); extern float __nanf (__const char *__tagb) throw () __attribute__ ((__const__));





extern int __isnanf (float __value) throw () __attribute__ ((__const__));



extern int isnanf (float __value) throw () __attribute__ ((__const__));


extern float j0f (float) throw (); extern float __j0f (float) throw ();
extern float j1f (float) throw (); extern float __j1f (float) throw ();
extern float jnf (int, float) throw (); extern float __jnf (int, float) throw ();
extern float y0f (float) throw (); extern float __y0f (float) throw ();
extern float y1f (float) throw (); extern float __y1f (float) throw ();
extern float ynf (int, float) throw (); extern float __ynf (int, float) throw ();






extern float erff (float) throw (); extern float __erff (float) throw ();
extern float erfcf (float) throw (); extern float __erfcf (float) throw ();
extern float lgammaf (float) throw (); extern float __lgammaf (float) throw ();






extern float tgammaf (float) throw (); extern float __tgammaf (float) throw ();





extern float gammaf (float) throw (); extern float __gammaf (float) throw ();






extern float lgammaf_r (float, int *__signgamp) throw (); extern float __lgammaf_r (float, int *__signgamp) throw ();







extern float rintf (float __x) throw (); extern float __rintf (float __x) throw ();


extern float nextafterf (float __x, float __y) throw () __attribute__ ((__const__)); extern float __nextafterf (float __x, float __y) throw () __attribute__ ((__const__));

extern float nexttowardf (float __x, long double __y) throw () __attribute__ ((__const__)); extern float __nexttowardf (float __x, long double __y) throw () __attribute__ ((__const__));



extern float remainderf (float __x, float __y) throw (); extern float __remainderf (float __x, float __y) throw ();



extern float scalbnf (float __x, int __n) throw (); extern float __scalbnf (float __x, int __n) throw ();



extern int ilogbf (float __x) throw (); extern int __ilogbf (float __x) throw ();




extern float scalblnf (float __x, long int __n) throw (); extern float __scalblnf (float __x, long int __n) throw ();



extern float nearbyintf (float __x) throw (); extern float __nearbyintf (float __x) throw ();



extern float roundf (float __x) throw () __attribute__ ((__const__)); extern float __roundf (float __x) throw () __attribute__ ((__const__));



extern float truncf (float __x) throw () __attribute__ ((__const__)); extern float __truncf (float __x) throw () __attribute__ ((__const__));




extern float remquof (float __x, float __y, int *__quo) throw (); extern float __remquof (float __x, float __y, int *__quo) throw ();






extern long int lrintf (float __x) throw (); extern long int __lrintf (float __x) throw ();
extern long long int llrintf (float __x) throw (); extern long long int __llrintf (float __x) throw ();



extern long int lroundf (float __x) throw (); extern long int __lroundf (float __x) throw ();
extern long long int llroundf (float __x) throw (); extern long long int __llroundf (float __x) throw ();



extern float fdimf (float __x, float __y) throw (); extern float __fdimf (float __x, float __y) throw ();


extern float fmaxf (float __x, float __y) throw (); extern float __fmaxf (float __x, float __y) throw ();


extern float fminf (float __x, float __y) throw (); extern float __fminf (float __x, float __y) throw ();



extern int __fpclassifyf (float __value) throw ()
     __attribute__ ((__const__));


extern int __signbitf (float __value) throw ()
     __attribute__ ((__const__));



extern float fmaf (float __x, float __y, float __z) throw (); extern float __fmaf (float __x, float __y, float __z) throw ();








extern float scalbf (float __x, float __n) throw (); extern float __scalbf (float __x, float __n) throw ();
# 95 "/usr/include/math.h" 2 3 4
# 145 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/bits/mathcalls.h" 3 4


extern long double acosl (long double __x) throw (); extern long double __acosl (long double __x) throw ();

extern long double asinl (long double __x) throw (); extern long double __asinl (long double __x) throw ();

extern long double atanl (long double __x) throw (); extern long double __atanl (long double __x) throw ();

extern long double atan2l (long double __y, long double __x) throw (); extern long double __atan2l (long double __y, long double __x) throw ();


extern long double cosl (long double __x) throw (); extern long double __cosl (long double __x) throw ();

extern long double sinl (long double __x) throw (); extern long double __sinl (long double __x) throw ();

extern long double tanl (long double __x) throw (); extern long double __tanl (long double __x) throw ();




extern long double coshl (long double __x) throw (); extern long double __coshl (long double __x) throw ();

extern long double sinhl (long double __x) throw (); extern long double __sinhl (long double __x) throw ();

extern long double tanhl (long double __x) throw (); extern long double __tanhl (long double __x) throw ();




extern void sincosl (long double __x, long double *__sinx, long double *__cosx) throw (); extern void __sincosl (long double __x, long double *__sinx, long double *__cosx) throw ();






extern long double acoshl (long double __x) throw (); extern long double __acoshl (long double __x) throw ();

extern long double asinhl (long double __x) throw (); extern long double __asinhl (long double __x) throw ();

extern long double atanhl (long double __x) throw (); extern long double __atanhl (long double __x) throw ();







extern long double expl (long double __x) throw (); extern long double __expl (long double __x) throw ();


extern long double frexpl (long double __x, int *__exponent) throw (); extern long double __frexpl (long double __x, int *__exponent) throw ();


extern long double ldexpl (long double __x, int __exponent) throw (); extern long double __ldexpl (long double __x, int __exponent) throw ();


extern long double logl (long double __x) throw (); extern long double __logl (long double __x) throw ();


extern long double log10l (long double __x) throw (); extern long double __log10l (long double __x) throw ();


extern long double modfl (long double __x, long double *__iptr) throw (); extern long double __modfl (long double __x, long double *__iptr) throw ();




extern long double exp10l (long double __x) throw (); extern long double __exp10l (long double __x) throw ();

extern long double pow10l (long double __x) throw (); extern long double __pow10l (long double __x) throw ();





extern long double expm1l (long double __x) throw (); extern long double __expm1l (long double __x) throw ();


extern long double log1pl (long double __x) throw (); extern long double __log1pl (long double __x) throw ();


extern long double logbl (long double __x) throw (); extern long double __logbl (long double __x) throw ();






extern long double exp2l (long double __x) throw (); extern long double __exp2l (long double __x) throw ();


extern long double log2l (long double __x) throw (); extern long double __log2l (long double __x) throw ();








extern long double powl (long double __x, long double __y) throw (); extern long double __powl (long double __x, long double __y) throw ();


extern long double sqrtl (long double __x) throw (); extern long double __sqrtl (long double __x) throw ();





extern long double hypotl (long double __x, long double __y) throw (); extern long double __hypotl (long double __x, long double __y) throw ();






extern long double cbrtl (long double __x) throw (); extern long double __cbrtl (long double __x) throw ();








extern long double ceill (long double __x) throw () __attribute__ ((__const__)); extern long double __ceill (long double __x) throw () __attribute__ ((__const__));


extern long double fabsl (long double __x) throw () __attribute__ ((__const__)); extern long double __fabsl (long double __x) throw () __attribute__ ((__const__));


extern long double floorl (long double __x) throw () __attribute__ ((__const__)); extern long double __floorl (long double __x) throw () __attribute__ ((__const__));


extern long double fmodl (long double __x, long double __y) throw (); extern long double __fmodl (long double __x, long double __y) throw ();




extern int __isinfl (long double __value) throw () __attribute__ ((__const__));


extern int __finitel (long double __value) throw () __attribute__ ((__const__));





extern int isinfl (long double __value) throw () __attribute__ ((__const__));


extern int finitel (long double __value) throw () __attribute__ ((__const__));


extern long double dreml (long double __x, long double __y) throw (); extern long double __dreml (long double __x, long double __y) throw ();



extern long double significandl (long double __x) throw (); extern long double __significandl (long double __x) throw ();





extern long double copysignl (long double __x, long double __y) throw () __attribute__ ((__const__)); extern long double __copysignl (long double __x, long double __y) throw () __attribute__ ((__const__));






extern long double nanl (__const char *__tagb) throw () __attribute__ ((__const__)); extern long double __nanl (__const char *__tagb) throw () __attribute__ ((__const__));





extern int __isnanl (long double __value) throw () __attribute__ ((__const__));



extern int isnanl (long double __value) throw () __attribute__ ((__const__));


extern long double j0l (long double) throw (); extern long double __j0l (long double) throw ();
extern long double j1l (long double) throw (); extern long double __j1l (long double) throw ();
extern long double jnl (int, long double) throw (); extern long double __jnl (int, long double) throw ();
extern long double y0l (long double) throw (); extern long double __y0l (long double) throw ();
extern long double y1l (long double) throw (); extern long double __y1l (long double) throw ();
extern long double ynl (int, long double) throw (); extern long double __ynl (int, long double) throw ();






extern long double erfl (long double) throw (); extern long double __erfl (long double) throw ();
extern long double erfcl (long double) throw (); extern long double __erfcl (long double) throw ();
extern long double lgammal (long double) throw (); extern long double __lgammal (long double) throw ();






extern long double tgammal (long double) throw (); extern long double __tgammal (long double) throw ();





extern long double gammal (long double) throw (); extern long double __gammal (long double) throw ();






extern long double lgammal_r (long double, int *__signgamp) throw (); extern long double __lgammal_r (long double, int *__signgamp) throw ();







extern long double rintl (long double __x) throw (); extern long double __rintl (long double __x) throw ();


extern long double nextafterl (long double __x, long double __y) throw () __attribute__ ((__const__)); extern long double __nextafterl (long double __x, long double __y) throw () __attribute__ ((__const__));

extern long double nexttowardl (long double __x, long double __y) throw () __attribute__ ((__const__)); extern long double __nexttowardl (long double __x, long double __y) throw () __attribute__ ((__const__));



extern long double remainderl (long double __x, long double __y) throw (); extern long double __remainderl (long double __x, long double __y) throw ();



extern long double scalbnl (long double __x, int __n) throw (); extern long double __scalbnl (long double __x, int __n) throw ();



extern int ilogbl (long double __x) throw (); extern int __ilogbl (long double __x) throw ();




extern long double scalblnl (long double __x, long int __n) throw (); extern long double __scalblnl (long double __x, long int __n) throw ();



extern long double nearbyintl (long double __x) throw (); extern long double __nearbyintl (long double __x) throw ();



extern long double roundl (long double __x) throw () __attribute__ ((__const__)); extern long double __roundl (long double __x) throw () __attribute__ ((__const__));



extern long double truncl (long double __x) throw () __attribute__ ((__const__)); extern long double __truncl (long double __x) throw () __attribute__ ((__const__));




extern long double remquol (long double __x, long double __y, int *__quo) throw (); extern long double __remquol (long double __x, long double __y, int *__quo) throw ();






extern long int lrintl (long double __x) throw (); extern long int __lrintl (long double __x) throw ();
extern long long int llrintl (long double __x) throw (); extern long long int __llrintl (long double __x) throw ();



extern long int lroundl (long double __x) throw (); extern long int __lroundl (long double __x) throw ();
extern long long int llroundl (long double __x) throw (); extern long long int __llroundl (long double __x) throw ();



extern long double fdiml (long double __x, long double __y) throw (); extern long double __fdiml (long double __x, long double __y) throw ();


extern long double fmaxl (long double __x, long double __y) throw (); extern long double __fmaxl (long double __x, long double __y) throw ();


extern long double fminl (long double __x, long double __y) throw (); extern long double __fminl (long double __x, long double __y) throw ();



extern int __fpclassifyl (long double __value) throw ()
     __attribute__ ((__const__));


extern int __signbitl (long double __value) throw ()
     __attribute__ ((__const__));



extern long double fmal (long double __x, long double __y, long double __z) throw (); extern long double __fmal (long double __x, long double __y, long double __z) throw ();








extern long double scalbl (long double __x, long double __n) throw (); extern long double __scalbl (long double __x, long double __n) throw ();
# 146 "/usr/include/math.h" 2 3 4
# 161 "/usr/include/math.h" 3 4
extern int signgam;
# 202 "/usr/include/math.h" 3 4
enum
  {
    FP_NAN,

    FP_INFINITE,

    FP_ZERO,

    FP_SUBNORMAL,

    FP_NORMAL

  };
# 295 "/usr/include/math.h" 3 4
typedef enum
{
  _IEEE_ = -1,
  _SVID_,
  _XOPEN_,
  _POSIX_,
  _ISOC_
} _LIB_VERSION_TYPE;




extern _LIB_VERSION_TYPE _LIB_VERSION;
# 318 "/usr/include/math.h" 3 4
struct __exception



  {
    int type;
    char *name;
    double arg1;
    double arg2;
    double retval;
  };


extern int matherr (struct __exception *__exc) throw ();
# 420 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathinline.h" 1 3 4
# 25 "/usr/include/bits/mathinline.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 26 "/usr/include/bits/mathinline.h" 2 3 4
# 37 "/usr/include/bits/mathinline.h" 3 4
extern __inline __attribute__ ((__gnu_inline__)) int
__signbitf (float __x) throw ()
{

  __extension__ union { float __f; int __i; } __u = { __f: __x };
  return __u.__i < 0;





}
extern __inline __attribute__ ((__gnu_inline__)) int
__signbit (double __x) throw ()
{

  __extension__ union { double __d; int __i[2]; } __u = { __d: __x };
  return __u.__i[1] < 0;





}
extern __inline __attribute__ ((__gnu_inline__)) int
__signbitl (long double __x) throw ()
{
  __extension__ union { long double __l; int __i[3]; } __u = { __l: __x };
  return (__u.__i[2] & 0x8000) != 0;
}
# 421 "/usr/include/math.h" 2 3 4
# 476 "/usr/include/math.h" 3 4
}
# 20 "/usr/include/wx-2.8/wx/math.h" 2
# 102 "/usr/include/wx-2.8/wx/math.h"
        inline bool wxIsSameDouble(double x, double y) { return x == y; }



    inline bool wxIsNullDouble(double x) { return wxIsSameDouble(x, 0.); }

    inline int wxRound(double x)
    {

            return int(round(x));



    }
# 129 "/usr/include/wx-2.8/wx/math.h"
    extern "C" {


    wxFloat64 ConvertFromIeeeExtended(const wxInt8 *bytes);
    void ConvertToIeeeExtended(wxFloat64 num, wxInt8 *bytes);

    }
# 25 "/usr/include/wx-2.8/wx/gdicmn.h" 2





class wxBitmap;
class wxBrush;
class wxColour;
class wxCursor;
class wxFont;
class wxIcon;
class wxPalette;
class wxPen;
class wxRegion;
class wxString;






enum wxBitmapType
{
    wxBITMAP_TYPE_INVALID,
    wxBITMAP_TYPE_BMP,
    wxBITMAP_TYPE_BMP_RESOURCE,
    wxBITMAP_TYPE_RESOURCE = wxBITMAP_TYPE_BMP_RESOURCE,
    wxBITMAP_TYPE_ICO,
    wxBITMAP_TYPE_ICO_RESOURCE,
    wxBITMAP_TYPE_CUR,
    wxBITMAP_TYPE_CUR_RESOURCE,
    wxBITMAP_TYPE_XBM,
    wxBITMAP_TYPE_XBM_DATA,
    wxBITMAP_TYPE_XPM,
    wxBITMAP_TYPE_XPM_DATA,
    wxBITMAP_TYPE_TIF,
    wxBITMAP_TYPE_TIF_RESOURCE,
    wxBITMAP_TYPE_GIF,
    wxBITMAP_TYPE_GIF_RESOURCE,
    wxBITMAP_TYPE_PNG,
    wxBITMAP_TYPE_PNG_RESOURCE,
    wxBITMAP_TYPE_JPEG,
    wxBITMAP_TYPE_JPEG_RESOURCE,
    wxBITMAP_TYPE_PNM,
    wxBITMAP_TYPE_PNM_RESOURCE,
    wxBITMAP_TYPE_PCX,
    wxBITMAP_TYPE_PCX_RESOURCE,
    wxBITMAP_TYPE_PICT,
    wxBITMAP_TYPE_PICT_RESOURCE,
    wxBITMAP_TYPE_ICON,
    wxBITMAP_TYPE_ICON_RESOURCE,
    wxBITMAP_TYPE_ANI,
    wxBITMAP_TYPE_IFF,
    wxBITMAP_TYPE_TGA,
    wxBITMAP_TYPE_MACCURSOR,
    wxBITMAP_TYPE_MACCURSOR_RESOURCE,
    wxBITMAP_TYPE_ANY = 50
};


enum wxStockCursor
{
    wxCURSOR_NONE,
    wxCURSOR_ARROW,
    wxCURSOR_RIGHT_ARROW,
    wxCURSOR_BULLSEYE,
    wxCURSOR_CHAR,
    wxCURSOR_CROSS,
    wxCURSOR_HAND,
    wxCURSOR_IBEAM,
    wxCURSOR_LEFT_BUTTON,
    wxCURSOR_MAGNIFIER,
    wxCURSOR_MIDDLE_BUTTON,
    wxCURSOR_NO_ENTRY,
    wxCURSOR_PAINT_BRUSH,
    wxCURSOR_PENCIL,
    wxCURSOR_POINT_LEFT,
    wxCURSOR_POINT_RIGHT,
    wxCURSOR_QUESTION_ARROW,
    wxCURSOR_RIGHT_BUTTON,
    wxCURSOR_SIZENESW,
    wxCURSOR_SIZENS,
    wxCURSOR_SIZENWSE,
    wxCURSOR_SIZEWE,
    wxCURSOR_SIZING,
    wxCURSOR_SPRAYCAN,
    wxCURSOR_WAIT,
    wxCURSOR_WATCH,
    wxCURSOR_BLANK,

    wxCURSOR_DEFAULT,
# 128 "/usr/include/wx-2.8/wx/gdicmn.h"
    wxCURSOR_ARROWWAIT,

    wxCURSOR_MAX
};
# 207 "/usr/include/wx-2.8/wx/gdicmn.h"
class wxSize
{
public:

    int x, y;


    wxSize() : x(0), y(0) { }
    wxSize(int xx, int yy) : x(xx), y(yy) { }



    bool operator==(const wxSize& sz) const { return x == sz.x && y == sz.y; }
    bool operator!=(const wxSize& sz) const { return x != sz.x || y != sz.y; }

    wxSize operator+(const wxSize& sz) const { return wxSize(x + sz.x, y + sz.y); }
    wxSize operator-(const wxSize& sz) const { return wxSize(x - sz.x, y - sz.y); }
    wxSize operator/(int i) const { return wxSize(x / i, y / i); }
    wxSize operator*(int i) const { return wxSize(x * i, y * i); }

    wxSize& operator+=(const wxSize& sz) { x += sz.x; y += sz.y; return *this; }
    wxSize& operator-=(const wxSize& sz) { x -= sz.x; y -= sz.y; return *this; }
    wxSize& operator/=(const int i) { x /= i; y /= i; return *this; }
    wxSize& operator*=(const int i) { x *= i; y *= i; return *this; }

    void IncTo(const wxSize& sz)
        { if ( sz.x > x ) x = sz.x; if ( sz.y > y ) y = sz.y; }
    void DecTo(const wxSize& sz)
        { if ( sz.x < x ) x = sz.x; if ( sz.y < y ) y = sz.y; }

    void IncBy(int dx, int dy) { x += dx; y += dy; }
    void IncBy(const wxSize& sz) { IncBy(sz.x, sz.y); }
    void IncBy(int d) { IncBy(d, d); }

    void DecBy(int dx, int dy) { IncBy(-dx, -dy); }
    void DecBy(const wxSize& sz) { DecBy(sz.x, sz.y); }
    void DecBy(int d) { DecBy(d, d); }


    wxSize& Scale(float xscale, float yscale)
        { x = (int)(x*xscale); y = (int)(y*yscale); return *this; }


    void Set(int xx, int yy) { x = xx; y = yy; }
    void SetWidth(int w) { x = w; }
    void SetHeight(int h) { y = h; }

    int GetWidth() const { return x; }
    int GetHeight() const { return y; }

    bool IsFullySpecified() const { return x != wxDefaultCoord && y != wxDefaultCoord; }



    void SetDefaults(const wxSize& size)
    {
        if ( x == wxDefaultCoord )
            x = size.x;
        if ( y == wxDefaultCoord )
            y = size.y;
    }


    int GetX() const { return x; }
    int GetY() const { return y; }
};





class wxRealPoint
{
public:
    double x;
    double y;

    wxRealPoint() : x(0.0), y(0.0) { }
    wxRealPoint(double xx, double yy) : x(xx), y(yy) { }

    wxRealPoint operator+(const wxRealPoint& pt) const { return wxRealPoint(x + pt.x, y + pt.y); }
    wxRealPoint operator-(const wxRealPoint& pt) const { return wxRealPoint(x - pt.x, y - pt.y); }

    bool operator==(const wxRealPoint& pt) const
    {
        return wxIsSameDouble(x, pt.x) && wxIsSameDouble(y, pt.y);
    }
    bool operator!=(const wxRealPoint& pt) const { return !(*this == pt); }
};


class wxPoint
{
public:
    int x, y;

    wxPoint() : x(0), y(0) { }
    wxPoint(int xx, int yy) : x(xx), y(yy) { }




    bool operator==(const wxPoint& p) const { return x == p.x && y == p.y; }
    bool operator!=(const wxPoint& p) const { return !(*this == p); }


    wxPoint operator+(const wxPoint& p) const { return wxPoint(x + p.x, y + p.y); }
    wxPoint operator-(const wxPoint& p) const { return wxPoint(x - p.x, y - p.y); }

    wxPoint& operator+=(const wxPoint& p) { x += p.x; y += p.y; return *this; }
    wxPoint& operator-=(const wxPoint& p) { x -= p.x; y -= p.y; return *this; }

    wxPoint& operator+=(const wxSize& s) { x += s.GetWidth(); y += s.GetHeight(); return *this; }
    wxPoint& operator-=(const wxSize& s) { x -= s.GetWidth(); y -= s.GetHeight(); return *this; }

    wxPoint operator+(const wxSize& s) const { return wxPoint(x + s.GetWidth(), y + s.GetHeight()); }
    wxPoint operator-(const wxSize& s) const { return wxPoint(x - s.GetWidth(), y - s.GetHeight()); }

    wxPoint operator-() const { return wxPoint(-x, -y); }
};





class wxRect
{
public:
    wxRect()
        : x(0), y(0), width(0), height(0)
        { }
    wxRect(int xx, int yy, int ww, int hh)
        : x(xx), y(yy), width(ww), height(hh)
        { }
    wxRect(const wxPoint& topLeft, const wxPoint& bottomRight);
    wxRect(const wxPoint& pt, const wxSize& size)
        : x(pt.x), y(pt.y), width(size.x), height(size.y)
        { }
    wxRect(const wxSize& size)
        : x(0), y(0), width(size.x), height(size.y)
        { }



    int GetX() const { return x; }
    void SetX(int xx) { x = xx; }

    int GetY() const { return y; }
    void SetY(int yy) { y = yy; }

    int GetWidth() const { return width; }
    void SetWidth(int w) { width = w; }

    int GetHeight() const { return height; }
    void SetHeight(int h) { height = h; }

    wxPoint GetPosition() const { return wxPoint(x, y); }
    void SetPosition( const wxPoint &p ) { x = p.x; y = p.y; }

    wxSize GetSize() const { return wxSize(width, height); }
    void SetSize( const wxSize &s ) { width = s.GetWidth(); height = s.GetHeight(); }

    bool IsEmpty() const { return (width <= 0) || (height <= 0); }

    int GetLeft() const { return x; }
    int GetTop() const { return y; }
    int GetBottom() const { return y + height - 1; }
    int GetRight() const { return x + width - 1; }

    void SetLeft(int left) { x = left; }
    void SetRight(int right) { width = right - x + 1; }
    void SetTop(int top) { y = top; }
    void SetBottom(int bottom) { height = bottom - y + 1; }

    wxPoint GetTopLeft() const { return GetPosition(); }
    wxPoint GetLeftTop() const { return GetTopLeft(); }
    void SetTopLeft(const wxPoint &p) { SetPosition(p); }
    void SetLeftTop(const wxPoint &p) { SetTopLeft(p); }

    wxPoint GetBottomRight() const { return wxPoint(GetRight(), GetBottom()); }
    wxPoint GetRightBottom() const { return GetBottomRight(); }
    void SetBottomRight(const wxPoint &p) { SetRight(p.x); SetBottom(p.y); }
    void SetRightBottom(const wxPoint &p) { SetBottomRight(p); }

    wxPoint GetTopRight() const { return wxPoint(GetRight(), GetTop()); }
    wxPoint GetRightTop() const { return GetTopRight(); }
    void SetTopRight(const wxPoint &p) { SetRight(p.x); SetTop(p.y); }
    void SetRightTop(const wxPoint &p) { SetTopLeft(p); }

    wxPoint GetBottomLeft() const { return wxPoint(GetLeft(), GetBottom()); }
    wxPoint GetLeftBottom() const { return GetBottomLeft(); }
    void SetBottomLeft(const wxPoint &p) { SetLeft(p.x); SetBottom(p.y); }
    void SetLeftBottom(const wxPoint &p) { SetBottomLeft(p); }


    wxRect& Inflate(wxCoord dx, wxCoord dy);
    wxRect& Inflate(const wxSize& d) { return Inflate(d.x, d.y); }
    wxRect& Inflate(wxCoord d) { return Inflate(d, d); }
    wxRect Inflate(wxCoord dx, wxCoord dy) const
    {
        wxRect r = *this;
        r.Inflate(dx, dy);
        return r;
    }

    wxRect& Deflate(wxCoord dx, wxCoord dy) { return Inflate(-dx, -dy); }
    wxRect& Deflate(const wxSize& d) { return Inflate(-d.x, -d.y); }
    wxRect& Deflate(wxCoord d) { return Inflate(-d); }
    wxRect Deflate(wxCoord dx, wxCoord dy) const
    {
        wxRect r = *this;
        r.Deflate(dx, dy);
        return r;
    }

    void Offset(wxCoord dx, wxCoord dy) { x += dx; y += dy; }
    void Offset(const wxPoint& pt) { Offset(pt.x, pt.y); }

    wxRect& Intersect(const wxRect& rect);
    wxRect Intersect(const wxRect& rect) const
    {
        wxRect r = *this;
        r.Intersect(rect);
        return r;
    }

    wxRect& Union(const wxRect& rect);
    wxRect Union(const wxRect& rect) const
    {
        wxRect r = *this;
        r.Union(rect);
        return r;
    }


    bool operator==(const wxRect& rect) const;
    bool operator!=(const wxRect& rect) const { return !(*this == rect); }


    bool Contains(int x, int y) const;
    bool Contains(const wxPoint& pt) const { return Contains(pt.x, pt.y); }

    bool Contains(const wxRect& rect) const;



    bool Inside(int x, int y) const __attribute__ ((deprecated));
    bool Inside(const wxPoint& pt) const __attribute__ ((deprecated));
    bool Inside(const wxRect& rect) const __attribute__ ((deprecated));



    bool Intersects(const wxRect& rect) const;



    wxRect operator+(const wxRect& rect) const;
    wxRect& operator+=(const wxRect& rect)
    {
        *this = *this + rect;
        return *this;
    }




    wxRect CentreIn(const wxRect& r, int dir = wxBOTH) const
    {
        return wxRect(dir & wxHORIZONTAL ? r.x + (r.width - width)/2 : x,
                      dir & wxVERTICAL ? r.y + (r.height - height)/2 : y,
                      width, height);
    }

    wxRect CenterIn(const wxRect& r, int dir = wxBOTH) const
    {
        return CentreIn(r, dir);
    }

public:
    int x, y, width, height;
};


inline bool wxRect::Inside(int cx, int cy) const { return Contains(cx, cy); }
inline bool wxRect::Inside(const wxPoint& pt) const { return Contains(pt); }
inline bool wxRect::Inside(const wxRect& rect) const { return Contains(rect); }







typedef wxInt8 wxDash;

class wxGDIObjListBase {
public:
    wxGDIObjListBase();
    ~wxGDIObjListBase();

protected:
    wxList list;
};

class wxPenList: public wxGDIObjListBase
{
public:
    wxPen *FindOrCreatePen(const wxColour& colour, int width, int style);

    void AddPen(wxPen*) __attribute__ ((deprecated));
    void RemovePen(wxPen*) __attribute__ ((deprecated));

};

class wxBrushList: public wxGDIObjListBase
{
public:
    wxBrush *FindOrCreateBrush(const wxColour& colour, int style = wxSOLID);

    void AddBrush(wxBrush*) __attribute__ ((deprecated));
    void RemoveBrush(wxBrush*) __attribute__ ((deprecated));

};

class wxFontList: public wxGDIObjListBase
{
public:
    wxFont *FindOrCreateFont(int pointSize, int family, int style, int weight,
                             bool underline = false,
                             const wxString& face = wxEmptyString,
                             wxFontEncoding encoding = wxFONTENCODING_DEFAULT);

    void AddFont(wxFont*) __attribute__ ((deprecated));
    void RemoveFont(wxFont*) __attribute__ ((deprecated));

};

class wxStringToColourHashMap_wxImplementation_Pair { public: typedef wxString t1; typedef wxColour* t2; typedef const wxString const_t1; typedef const wxColour* const_t2; wxStringToColourHashMap_wxImplementation_Pair( const const_t1& f, const const_t2& s ):first(t1(f)),second(t2(s)) {} t1 first; t2 second; }; class wxStringToColourHashMap_wxImplementation_KeyEx { typedef wxString key_type; typedef wxStringToColourHashMap_wxImplementation_Pair pair_type; typedef const key_type const_key_type; typedef const pair_type const_pair_type; typedef const_key_type& const_key_reference; typedef const_pair_type& const_pair_reference; public: wxStringToColourHashMap_wxImplementation_KeyEx() { } const_key_reference operator()( const_pair_reference pair ) const { return pair.first; } wxStringToColourHashMap_wxImplementation_KeyEx& operator=(const wxStringToColourHashMap_wxImplementation_KeyEx&) { return *this; } }; class wxStringToColourHashMap_wxImplementation_HashTable : protected _wxHashTableBase2 { public: typedef wxString key_type; typedef wxStringToColourHashMap_wxImplementation_Pair value_type; typedef wxStringHash hasher; typedef wxStringEqual key_equal; typedef size_t size_type; typedef ptrdiff_t difference_type; typedef value_type* pointer; typedef const value_type* const_pointer; typedef value_type& reference; typedef const value_type& const_reference; typedef const wxString const_key_type; typedef const wxStringToColourHashMap_wxImplementation_Pair const_mapped_type; public: struct Node; typedef wxStringToColourHashMap_wxImplementation_KeyEx key_extractor; typedef wxStringToColourHashMap_wxImplementation_HashTable Self; protected: Node** m_table; size_t m_tableBuckets; size_t m_items; hasher m_hasher; key_equal m_equals; key_extractor m_getKey; public: struct Node:public _wxHashTable_NodeBase { public: Node( const value_type& value ) : m_value( value ) {} Node* m_next() { return (Node*)this->m_nxt; } value_type m_value; }; class Iterator; friend class Iterator; protected: static void DeleteNode( _wxHashTable_NodeBase* node ) { delete (Node*)node; } public: class Iterator { public: Node* m_node; Self* m_ht; Iterator() : m_node(0), m_ht(0) {} Iterator( Node* node, const Self* ht ) : m_node(node), m_ht((Self*)ht) {} bool operator ==( const Iterator& it ) const { return m_node == it.m_node; } bool operator !=( const Iterator& it ) const { return m_node != it.m_node; } protected: Node* GetNextNode() { size_type bucket = GetBucketForNode(m_ht,m_node); for( size_type i = bucket + 1; i < m_ht->m_tableBuckets; ++i ) { if( m_ht->m_table[i] ) return m_ht->m_table[i]; } return 0; } void PlusPlus() { Node* next = m_node->m_next(); m_node = next ? next : GetNextNode(); } }; public: class iterator : public Iterator { public: iterator() : Iterator() {} iterator( Node* node, Self* ht ) : Iterator( node, ht ) {} iterator& operator++() { PlusPlus(); return *this; } iterator operator++(int) { iterator it=*this;PlusPlus();return it; } reference operator *() const { return m_node->m_value; } pointer operator ->() const { return &(m_node->m_value); } }; class const_iterator : public Iterator { public: const_iterator() : Iterator() {} const_iterator(iterator i) : Iterator(i) {} const_iterator( Node* node, const Self* ht ) : Iterator( node, (Self*)ht ) {} const_iterator& operator++() { PlusPlus();return *this; } const_iterator operator++(int) { const_iterator it=*this;PlusPlus();return it; } const_reference operator *() const { return m_node->m_value; } const_pointer operator ->() const { return &(m_node->m_value); } }; wxStringToColourHashMap_wxImplementation_HashTable( size_type sz = 10, const hasher& hfun = hasher(), const key_equal& k_eq = key_equal(), const key_extractor& k_ex = key_extractor() ) : m_tableBuckets( GetNextPrime( (unsigned long) sz ) ), m_items( 0 ), m_hasher( hfun ), m_equals( k_eq ), m_getKey( k_ex ) { m_table = (Node**)AllocTable( m_tableBuckets ); } wxStringToColourHashMap_wxImplementation_HashTable( const Self& ht ) : m_table( 0 ), m_tableBuckets( 0 ), m_items( ht.m_items ), m_hasher( ht.m_hasher ), m_equals( ht.m_equals ), m_getKey( ht.m_getKey ) { HashCopy( ht ); } const Self& operator=( const Self& ht ) { clear(); m_hasher = ht.m_hasher; m_equals = ht.m_equals; m_getKey = ht.m_getKey; m_items = ht.m_items; HashCopy( ht ); return *this; } ~wxStringToColourHashMap_wxImplementation_HashTable() { clear(); FreeTable(m_table); } hasher hash_funct() { return m_hasher; } key_equal key_eq() { return m_equals; } void clear() { DeleteNodes( m_tableBuckets, (_wxHashTable_NodeBase**)m_table, DeleteNode ); m_items = 0; } size_type size() const { return m_items; } size_type max_size() const { return size_type(-1); } bool empty() const { return size() == 0; } const_iterator end() const { return const_iterator( 0, this ); } iterator end() { return iterator( 0, this ); } const_iterator begin() const { return const_iterator( (Node*)GetFirstNode( m_tableBuckets, (_wxHashTable_NodeBase**)m_table ), this ); } iterator begin() { return iterator( (Node*)GetFirstNode( m_tableBuckets, (_wxHashTable_NodeBase**)m_table ), this ); } size_type erase( const const_key_type& key ) { Node** node = GetNodePtr( key ); if( !node ) return 0; --m_items; Node* temp = (*node)->m_next(); delete *node; (*node) = temp; if( never_shrink( m_tableBuckets, m_items ) ) ResizeTable( GetPreviousPrime( (unsigned long) m_tableBuckets ) - 1 ); return 1; } protected: static size_type GetBucketForNode( Self* ht, Node* node ) { return ht->m_hasher( ht->m_getKey( node->m_value ) ) % ht->m_tableBuckets; } static Node* CopyNode( Node* node ) { return new Node( *node ); } Node* GetOrCreateNode( const value_type& value, bool& created ) { const const_key_type& key = m_getKey( value ); size_t bucket = m_hasher( key ) % m_tableBuckets; Node* node = m_table[bucket]; while( node ) { if( m_equals( m_getKey( node->m_value ), key ) ) { created = false; return node; } node = node->m_next(); } created = true; return CreateNode( value, bucket); } Node * CreateNode( const value_type& value, size_t bucket ) { Node* node = new Node( value ); node->m_nxt = m_table[bucket]; m_table[bucket] = node; ++m_items; if( grow_lf70( m_tableBuckets, m_items ) ) ResizeTable( m_tableBuckets ); return node; } void CreateNode( const value_type& value ) { CreateNode(value, m_hasher( m_getKey(value) ) % m_tableBuckets ); } Node** GetNodePtr( const const_key_type& key ) const { size_t bucket = m_hasher( key ) % m_tableBuckets; Node** node = &m_table[bucket]; while( *node ) { if( m_equals( m_getKey( (*node)->m_value ), key ) ) return node; node = (Node**)&(*node)->m_nxt; } return __null; } Node* GetNode( const const_key_type& key ) const { size_t bucket = m_hasher( key ) % m_tableBuckets; Node* node = m_table[bucket]; while( node ) { if( m_equals( m_getKey( node->m_value ), key ) ) return node; node = node->m_next(); } return 0; } void ResizeTable( size_t newSize ) { newSize = GetNextPrime( (unsigned long)newSize ); Node** srcTable = m_table; size_t srcBuckets = m_tableBuckets; m_table = (Node**)AllocTable( newSize ); m_tableBuckets = newSize; CopyHashTable( (_wxHashTable_NodeBase**)srcTable, srcBuckets, this, (_wxHashTable_NodeBase**)m_table, (BucketFromNode)GetBucketForNode, (ProcessNode)&DummyProcessNode ); FreeTable(srcTable); } void HashCopy( const Self& ht ) { ResizeTable( ht.size() ); CopyHashTable( (_wxHashTable_NodeBase**)ht.m_table, ht.m_tableBuckets, (_wxHashTableBase2*)this, (_wxHashTable_NodeBase**)m_table, (BucketFromNode)GetBucketForNode, (ProcessNode)CopyNode ); } }; class wxStringToColourHashMap:public wxStringToColourHashMap_wxImplementation_HashTable { public: typedef wxColour* mapped_type; class Insert_Result { public: typedef iterator t1; typedef bool t2; typedef const iterator const_t1; typedef const bool const_t2; Insert_Result( const const_t1& f, const const_t2& s ):first(t1(f)),second(t2(s)) {} t1 first; t2 second; }; explicit wxStringToColourHashMap( size_type hint = 100, hasher hf = hasher(), key_equal eq = key_equal() ) : wxStringToColourHashMap_wxImplementation_HashTable( hint, hf, eq, wxStringToColourHashMap_wxImplementation_KeyEx() ) {} mapped_type& operator[]( const const_key_type& key ) { bool created; return GetOrCreateNode( wxStringToColourHashMap_wxImplementation_Pair( key, mapped_type() ), created)->m_value.second; } const_iterator find( const const_key_type& key ) const { return const_iterator( GetNode( key ), this ); } iterator find( const const_key_type& key ) { return iterator( GetNode( key ), this ); } Insert_Result insert( const value_type& v ) { bool created; Node *node = GetOrCreateNode( wxStringToColourHashMap_wxImplementation_Pair( v.first, v.second ), created); return Insert_Result(iterator(node, this), created); } size_type erase( const key_type& k ) { return wxStringToColourHashMap_wxImplementation_HashTable::erase( k ); } void erase( const iterator& it ) { erase( it->first ); } void erase( const const_iterator& it ) { erase( it->first ); } size_type count( const const_key_type& key ) { return (size_type)(GetNode( key ) ? 1 : 0); } };

class wxColourDatabase
{
public:
    wxColourDatabase();
    ~wxColourDatabase();


    wxColour Find(const wxString& name) const;
    wxString FindName(const wxColour& colour) const;


    void AddColour(const wxString& name, const wxColour& colour);



    wxColour *FindColour(const wxString& name) __attribute__ ((deprecated));
# 571 "/usr/include/wx-2.8/wx/gdicmn.h"
private:


    void Initialize();

    wxStringToColourHashMap *m_map;
};

class wxResourceCache: public wxList
{
public:
    wxResourceCache() { }

    wxResourceCache(const unsigned int keyType) : wxList(keyType) { }

    virtual ~wxResourceCache();
};






extern wxPenList* wxThePenList;
extern wxBrushList* wxTheBrushList;
extern wxFontList* wxTheFontList;
# 608 "/usr/include/wx-2.8/wx/gdicmn.h"
class wxStockGDI
{
public:
    enum Item {
        BRUSH_BLACK,
        BRUSH_BLUE,
        BRUSH_CYAN,
        BRUSH_GREEN,
        BRUSH_GREY,
        BRUSH_LIGHTGREY,
        BRUSH_MEDIUMGREY,
        BRUSH_RED,
        BRUSH_TRANSPARENT,
        BRUSH_WHITE,
        COLOUR_BLACK,
        COLOUR_BLUE,
        COLOUR_CYAN,
        COLOUR_GREEN,
        COLOUR_LIGHTGREY,
        COLOUR_RED,
        COLOUR_WHITE,
        CURSOR_CROSS,
        CURSOR_HOURGLASS,
        CURSOR_STANDARD,
        FONT_ITALIC,
        FONT_NORMAL,
        FONT_SMALL,
        FONT_SWISS,
        PEN_BLACK,
        PEN_BLACKDASHED,
        PEN_CYAN,
        PEN_GREEN,
        PEN_GREY,
        PEN_LIGHTGREY,
        PEN_MEDIUMGREY,
        PEN_RED,
        PEN_TRANSPARENT,
        PEN_WHITE,
        ITEMCOUNT
    };

    wxStockGDI();
    virtual ~wxStockGDI();
    static void DeleteAll();

    static wxStockGDI& instance() { return *ms_instance; }

    static const wxBrush* GetBrush(Item item);
    static const wxColour* GetColour(Item item);
    static const wxCursor* GetCursor(Item item);

    virtual const wxFont* GetFont(Item item);
    static const wxPen* GetPen(Item item);

protected:
    static wxStockGDI* ms_instance;

    static wxObject* ms_stockObject[ITEMCOUNT];

    private: wxStockGDI(const wxStockGDI&); wxStockGDI& operator=(const wxStockGDI&);
};
# 710 "/usr/include/wx-2.8/wx/gdicmn.h"
extern wxBitmap wxNullBitmap;
extern wxIcon wxNullIcon;
extern wxCursor wxNullCursor;
extern wxPen wxNullPen;
extern wxBrush wxNullBrush;
extern wxPalette wxNullPalette;
extern wxFont wxNullFont;
extern wxColour wxNullColour;

extern wxColourDatabase* wxTheColourDatabase;

extern const wxChar wxPanelNameStr[];

extern const wxSize wxDefaultSize;
extern const wxPoint wxDefaultPosition;






extern void wxInitializeStockLists();
extern void wxDeleteStockLists();


extern bool wxColourDisplay();


extern int wxDisplayDepth();



extern void wxDisplaySize(int *width, int *height);
extern wxSize wxGetDisplaySize();
extern void wxDisplaySizeMM(int *width, int *height);
extern wxSize wxGetDisplaySizeMM();


extern void wxClientDisplayRect(int *x, int *y, int *width, int *height);
extern wxRect wxGetClientDisplayRect();


extern void wxSetCursor(const wxCursor& cursor);
# 22 "/usr/include/wx-2.8/wx/event.h" 2
# 1 "/usr/include/wx-2.8/wx/cursor.h" 1
# 24 "/usr/include/wx-2.8/wx/cursor.h"
# 1 "/usr/include/wx-2.8/wx/gtk/cursor.h" 1
# 15 "/usr/include/wx-2.8/wx/gtk/cursor.h"
class wxColour;
class wxImage;





class wxCursor: public wxObject
{
public:

    wxCursor();
    wxCursor( int cursorId );

    wxCursor( const wxImage & image );

    wxCursor( const char bits[], int width, int height,
              int hotSpotX=-1, int hotSpotY=-1,
              const char maskBits[] = __null, const wxColour *fg = __null, const wxColour *bg = __null );
    virtual ~wxCursor();
    bool Ok() const { return IsOk(); }
    bool IsOk() const;



    GdkCursor *GetCursor() const;

private:
    public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};
# 25 "/usr/include/wx-2.8/wx/cursor.h" 2
# 41 "/usr/include/wx-2.8/wx/cursor.h"
# 1 "/usr/include/wx-2.8/wx/utils.h" 1
# 21 "/usr/include/wx-2.8/wx/utils.h"
# 1 "/usr/include/wx-2.8/wx/filefn.h" 1
# 29 "/usr/include/wx-2.8/wx/filefn.h"
# 1 "/usr/include/sys/stat.h" 1 3 4
# 105 "/usr/include/sys/stat.h" 3 4
extern "C" {

# 1 "/usr/include/bits/stat.h" 1 3 4
# 46 "/usr/include/bits/stat.h" 3 4
struct stat
  {
    __dev_t st_dev;

    unsigned short int __pad1;




    __ino_t __st_ino;


    __mode_t st_mode;
    __nlink_t st_nlink;




    __uid_t st_uid;
    __gid_t st_gid;



    __dev_t st_rdev;

    unsigned short int __pad2;




    __off64_t st_size;

    __blksize_t st_blksize;



    __blkcnt64_t st_blocks;
# 91 "/usr/include/bits/stat.h" 3 4
    struct timespec st_atim;
    struct timespec st_mtim;
    struct timespec st_ctim;
# 112 "/usr/include/bits/stat.h" 3 4
    __ino64_t st_ino;


  };



struct stat64
  {
    __dev_t st_dev;





    unsigned int __pad1;
    __ino_t __st_ino;
    __mode_t st_mode;
    __nlink_t st_nlink;

    __uid_t st_uid;
    __gid_t st_gid;





    __dev_t st_rdev;
    unsigned int __pad2;
    __off64_t st_size;

    __blksize_t st_blksize;
    __blkcnt64_t st_blocks;







    struct timespec st_atim;
    struct timespec st_mtim;
    struct timespec st_ctim;
# 169 "/usr/include/bits/stat.h" 3 4
    __ino64_t st_ino;

  };
# 108 "/usr/include/sys/stat.h" 2 3 4
# 219 "/usr/include/sys/stat.h" 3 4
extern int stat (__const char *__restrict __file, struct stat *__restrict __buf) throw () __asm__ ("" "stat64")

     __attribute__ ((__nonnull__ (1, 2)));
extern int fstat (int __fd, struct stat *__buf) throw () __asm__ ("" "fstat64")
     __attribute__ ((__nonnull__ (2)));






extern int stat64 (__const char *__restrict __file,
     struct stat64 *__restrict __buf) throw () __attribute__ ((__nonnull__ (1, 2)));
extern int fstat64 (int __fd, struct stat64 *__buf) throw () __attribute__ ((__nonnull__ (2)));
# 245 "/usr/include/sys/stat.h" 3 4
extern int fstatat (int __fd, __const char *__restrict __file, struct stat *__restrict __buf, int __flag) throw () __asm__ ("" "fstatat64") __attribute__ ((__nonnull__ (2, 3)));
# 255 "/usr/include/sys/stat.h" 3 4
extern int fstatat64 (int __fd, __const char *__restrict __file,
        struct stat64 *__restrict __buf, int __flag)
     throw () __attribute__ ((__nonnull__ (2, 3)));
# 269 "/usr/include/sys/stat.h" 3 4
extern int lstat (__const char *__restrict __file, struct stat *__restrict __buf) throw () __asm__ ("" "lstat64")


     __attribute__ ((__nonnull__ (1, 2)));





extern int lstat64 (__const char *__restrict __file,
      struct stat64 *__restrict __buf)
     throw () __attribute__ ((__nonnull__ (1, 2)));





extern int chmod (__const char *__file, __mode_t __mode)
     throw () __attribute__ ((__nonnull__ (1)));





extern int lchmod (__const char *__file, __mode_t __mode)
     throw () __attribute__ ((__nonnull__ (1)));




extern int fchmod (int __fd, __mode_t __mode) throw ();





extern int fchmodat (int __fd, __const char *__file, __mode_t __mode,
       int __flag)
     throw () __attribute__ ((__nonnull__ (2))) __attribute__ ((__warn_unused_result__));






extern __mode_t umask (__mode_t __mask) throw ();




extern __mode_t getumask (void) throw ();



extern int mkdir (__const char *__path, __mode_t __mode)
     throw () __attribute__ ((__nonnull__ (1)));





extern int mkdirat (int __fd, __const char *__path, __mode_t __mode)
     throw () __attribute__ ((__nonnull__ (2)));






extern int mknod (__const char *__path, __mode_t __mode, __dev_t __dev)
     throw () __attribute__ ((__nonnull__ (1)));





extern int mknodat (int __fd, __const char *__path, __mode_t __mode,
      __dev_t __dev) throw () __attribute__ ((__nonnull__ (2)));





extern int mkfifo (__const char *__path, __mode_t __mode)
     throw () __attribute__ ((__nonnull__ (1)));





extern int mkfifoat (int __fd, __const char *__path, __mode_t __mode)
     throw () __attribute__ ((__nonnull__ (2)));





extern int utimensat (int __fd, __const char *__path,
        __const struct timespec __times[2],
        int __flags)
     throw () __attribute__ ((__nonnull__ (2)));




extern int futimens (int __fd, __const struct timespec __times[2]) throw ();
# 412 "/usr/include/sys/stat.h" 3 4
extern int __fxstat (int __ver, int __fildes, struct stat *__stat_buf) throw () __asm__ ("" "__fxstat64")

     __attribute__ ((__nonnull__ (3)));
extern int __xstat (int __ver, __const char *__filename, struct stat *__stat_buf) throw () __asm__ ("" "__xstat64")

     __attribute__ ((__nonnull__ (2, 3)));
extern int __lxstat (int __ver, __const char *__filename, struct stat *__stat_buf) throw () __asm__ ("" "__lxstat64")

     __attribute__ ((__nonnull__ (2, 3)));
extern int __fxstatat (int __ver, int __fildes, __const char *__filename, struct stat *__stat_buf, int __flag) throw () __asm__ ("" "__fxstatat64") __attribute__ ((__nonnull__ (3, 4)));
# 434 "/usr/include/sys/stat.h" 3 4
extern int __fxstat64 (int __ver, int __fildes, struct stat64 *__stat_buf)
     throw () __attribute__ ((__nonnull__ (3)));
extern int __xstat64 (int __ver, __const char *__filename,
        struct stat64 *__stat_buf) throw () __attribute__ ((__nonnull__ (2, 3)));
extern int __lxstat64 (int __ver, __const char *__filename,
         struct stat64 *__stat_buf) throw () __attribute__ ((__nonnull__ (2, 3)));
extern int __fxstatat64 (int __ver, int __fildes, __const char *__filename,
    struct stat64 *__stat_buf, int __flag)
     throw () __attribute__ ((__nonnull__ (3, 4)));

extern int __xmknod (int __ver, __const char *__path, __mode_t __mode,
       __dev_t *__dev) throw () __attribute__ ((__nonnull__ (2, 4)));

extern int __xmknodat (int __ver, int __fd, __const char *__path,
         __mode_t __mode, __dev_t *__dev)
     throw () __attribute__ ((__nonnull__ (3, 5)));




extern __inline __attribute__ ((__gnu_inline__)) int
stat (__const char *__path, struct stat *__statbuf) throw ()
{
  return __xstat (3, __path, __statbuf);
}


extern __inline __attribute__ ((__gnu_inline__)) int
lstat (__const char *__path, struct stat *__statbuf) throw ()
{
  return __lxstat (3, __path, __statbuf);
}


extern __inline __attribute__ ((__gnu_inline__)) int
fstat (int __fd, struct stat *__statbuf) throw ()
{
  return __fxstat (3, __fd, __statbuf);
}


extern __inline __attribute__ ((__gnu_inline__)) int
fstatat (int __fd, __const char *__filename, struct stat *__statbuf, int __flag) throw ()

{
  return __fxstatat (3, __fd, __filename, __statbuf, __flag);
}



extern __inline __attribute__ ((__gnu_inline__)) int
mknod (__const char *__path, __mode_t __mode, __dev_t __dev) throw ()
{
  return __xmknod (1, __path, __mode, &__dev);
}



extern __inline __attribute__ ((__gnu_inline__)) int
mknodat (int __fd, __const char *__path, __mode_t __mode, __dev_t __dev) throw ()

{
  return __xmknodat (1, __fd, __path, __mode, &__dev);
}





extern __inline __attribute__ ((__gnu_inline__)) int
stat64 (__const char *__path, struct stat64 *__statbuf) throw ()
{
  return __xstat64 (3, __path, __statbuf);
}


extern __inline __attribute__ ((__gnu_inline__)) int
lstat64 (__const char *__path, struct stat64 *__statbuf) throw ()
{
  return __lxstat64 (3, __path, __statbuf);
}


extern __inline __attribute__ ((__gnu_inline__)) int
fstat64 (int __fd, struct stat64 *__statbuf) throw ()
{
  return __fxstat64 (3, __fd, __statbuf);
}


extern __inline __attribute__ ((__gnu_inline__)) int
fstatat64 (int __fd, __const char *__filename, struct stat64 *__statbuf, int __flag) throw ()

{
  return __fxstatat64 (3, __fd, __filename, __statbuf, __flag);
}






}
# 30 "/usr/include/wx-2.8/wx/filefn.h" 2
# 57 "/usr/include/wx-2.8/wx/filefn.h"
# 1 "/usr/include/dirent.h" 1 3 4
# 28 "/usr/include/dirent.h" 3 4
extern "C" {
# 62 "/usr/include/dirent.h" 3 4
# 1 "/usr/include/bits/dirent.h" 1 3 4
# 23 "/usr/include/bits/dirent.h" 3 4
struct dirent
  {




    __ino64_t d_ino;
    __off64_t d_off;

    unsigned short int d_reclen;
    unsigned char d_type;
    char d_name[256];
  };


struct dirent64
  {
    __ino64_t d_ino;
    __off64_t d_off;
    unsigned short int d_reclen;
    unsigned char d_type;
    char d_name[256];
  };
# 63 "/usr/include/dirent.h" 2 3 4
# 98 "/usr/include/dirent.h" 3 4
enum
  {
    DT_UNKNOWN = 0,

    DT_FIFO = 1,

    DT_CHR = 2,

    DT_DIR = 4,

    DT_BLK = 6,

    DT_REG = 8,

    DT_LNK = 10,

    DT_SOCK = 12,

    DT_WHT = 14

  };
# 128 "/usr/include/dirent.h" 3 4
typedef struct __dirstream DIR;






extern DIR *opendir (__const char *__name) __attribute__ ((__nonnull__ (1)));






extern DIR *fdopendir (int __fd);







extern int closedir (DIR *__dirp) __attribute__ ((__nonnull__ (1)));
# 166 "/usr/include/dirent.h" 3 4
extern struct dirent *readdir (DIR *__dirp) __asm__ ("" "readdir64")
     __attribute__ ((__nonnull__ (1)));






extern struct dirent64 *readdir64 (DIR *__dirp) __attribute__ ((__nonnull__ (1)));
# 190 "/usr/include/dirent.h" 3 4
extern int readdir_r (DIR *__restrict __dirp, struct dirent *__restrict __entry, struct dirent **__restrict __result) __asm__ ("" "readdir64_r") __attribute__ ((__nonnull__ (1, 2, 3)));
# 201 "/usr/include/dirent.h" 3 4
extern int readdir64_r (DIR *__restrict __dirp,
   struct dirent64 *__restrict __entry,
   struct dirent64 **__restrict __result)
     __attribute__ ((__nonnull__ (1, 2, 3)));




extern void rewinddir (DIR *__dirp) throw () __attribute__ ((__nonnull__ (1)));





extern void seekdir (DIR *__dirp, long int __pos) throw () __attribute__ ((__nonnull__ (1)));


extern long int telldir (DIR *__dirp) throw () __attribute__ ((__nonnull__ (1)));





extern int dirfd (DIR *__dirp) throw () __attribute__ ((__nonnull__ (1)));
# 245 "/usr/include/dirent.h" 3 4
# 1 "/usr/lib/gcc/i686-linux-gnu/4.4.5/include/stddef.h" 1 3 4
# 246 "/usr/include/dirent.h" 2 3 4
# 260 "/usr/include/dirent.h" 3 4
extern int scandir (__const char *__restrict __dir, struct dirent ***__restrict __namelist, int (*__selector) (__const struct dirent *), int (*__cmp) (__const struct dirent **, __const struct dirent **)) __asm__ ("" "scandir64") __attribute__ ((__nonnull__ (1, 2)));
# 275 "/usr/include/dirent.h" 3 4
extern int scandir64 (__const char *__restrict __dir,
        struct dirent64 ***__restrict __namelist,
        int (*__selector) (__const struct dirent64 *),
        int (*__cmp) (__const struct dirent64 **,
        __const struct dirent64 **))
     __attribute__ ((__nonnull__ (1, 2)));
# 290 "/usr/include/dirent.h" 3 4
extern int alphasort (__const struct dirent **__e1, __const struct dirent **__e2) throw () __asm__ ("" "alphasort64") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 300 "/usr/include/dirent.h" 3 4
extern int alphasort64 (__const struct dirent64 **__e1,
   __const struct dirent64 **__e2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 319 "/usr/include/dirent.h" 3 4
extern __ssize_t getdirentries (int __fd, char *__restrict __buf, size_t __nbytes, __off64_t *__restrict __basep) throw () __asm__ ("" "getdirentries64") __attribute__ ((__nonnull__ (2, 4)));
# 330 "/usr/include/dirent.h" 3 4
extern __ssize_t getdirentries64 (int __fd, char *__restrict __buf,
      size_t __nbytes,
      __off64_t *__restrict __basep)
     throw () __attribute__ ((__nonnull__ (2, 4)));
# 345 "/usr/include/dirent.h" 3 4
extern int versionsort (__const struct dirent **__e1, __const struct dirent **__e2) throw () __asm__ ("" "versionsort64")



     __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));






extern int versionsort64 (__const struct dirent64 **__e1,
     __const struct dirent64 **__e2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));



}
# 58 "/usr/include/wx-2.8/wx/filefn.h" 2
# 92 "/usr/include/wx-2.8/wx/filefn.h"
# 1 "/usr/include/fcntl.h" 1 3 4
# 30 "/usr/include/fcntl.h" 3 4
extern "C" {



# 1 "/usr/include/bits/fcntl.h" 1 3 4
# 26 "/usr/include/bits/fcntl.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 27 "/usr/include/bits/fcntl.h" 2 3 4

# 1 "/usr/include/bits/uio.h" 1 3 4
# 44 "/usr/include/bits/uio.h" 3 4
struct iovec
  {
    void *iov_base;
    size_t iov_len;
  };
# 29 "/usr/include/bits/fcntl.h" 2 3 4
# 165 "/usr/include/bits/fcntl.h" 3 4
struct flock
  {
    short int l_type;
    short int l_whence;




    __off64_t l_start;
    __off64_t l_len;

    __pid_t l_pid;
  };


struct flock64
  {
    short int l_type;
    short int l_whence;
    __off64_t l_start;
    __off64_t l_len;
    __pid_t l_pid;
  };




enum __pid_type
  {
    F_OWNER_TID = 0,
    F_OWNER_PID,
    F_OWNER_PGRP,
    F_OWNER_GID = F_OWNER_PGRP
  };


struct f_owner_ex
  {
    enum __pid_type type;
    __pid_t pid;
  };
# 263 "/usr/include/bits/fcntl.h" 3 4
extern "C" {




extern ssize_t readahead (int __fd, __off64_t __offset, size_t __count)
    throw ();



extern int sync_file_range (int __fd, __off64_t __offset, __off64_t __count,
       unsigned int __flags);



extern ssize_t vmsplice (int __fdout, const struct iovec *__iov,
    size_t __count, unsigned int __flags);


extern ssize_t splice (int __fdin, __off64_t *__offin, int __fdout,
         __off64_t *__offout, size_t __len,
         unsigned int __flags);


extern ssize_t tee (int __fdin, int __fdout, size_t __len,
      unsigned int __flags);






extern int fallocate (int __fd, int __mode, __off64_t __offset, __off64_t __len) __asm__ ("" "fallocate64");







extern int fallocate64 (int __fd, int __mode, __off64_t __offset,
   __off64_t __len);



}
# 35 "/usr/include/fcntl.h" 2 3 4






# 1 "/usr/include/bits/stat.h" 1 3 4
# 42 "/usr/include/fcntl.h" 2 3 4
# 110 "/usr/include/fcntl.h" 3 4
extern int fcntl (int __fd, int __cmd, ...);
# 122 "/usr/include/fcntl.h" 3 4
extern int open (__const char *__file, int __oflag, ...) __asm__ ("" "open64")
     __attribute__ ((__nonnull__ (1)));





extern int open64 (__const char *__file, int __oflag, ...) __attribute__ ((__nonnull__ (1)));
# 147 "/usr/include/fcntl.h" 3 4
extern int openat (int __fd, __const char *__file, int __oflag, ...) __asm__ ("" "openat64") __attribute__ ((__nonnull__ (2)));






extern int openat64 (int __fd, __const char *__file, int __oflag, ...)
     __attribute__ ((__nonnull__ (2)));
# 168 "/usr/include/fcntl.h" 3 4
extern int creat (__const char *__file, __mode_t __mode) __asm__ ("" "creat64") __attribute__ ((__nonnull__ (1)));






extern int creat64 (__const char *__file, __mode_t __mode) __attribute__ ((__nonnull__ (1)));
# 215 "/usr/include/fcntl.h" 3 4
extern int posix_fadvise (int __fd, __off64_t __offset, __off64_t __len, int __advise) throw () __asm__ ("" "posix_fadvise64");







extern int posix_fadvise64 (int __fd, __off64_t __offset, __off64_t __len,
       int __advise) throw ();
# 236 "/usr/include/fcntl.h" 3 4
extern int posix_fallocate (int __fd, __off64_t __offset, __off64_t __len) __asm__ ("" "posix_fallocate64");







extern int posix_fallocate64 (int __fd, __off64_t __offset, __off64_t __len);







# 1 "/usr/include/bits/fcntl2.h" 1 3 4
# 31 "/usr/include/bits/fcntl2.h" 3 4
extern int __open_2 (__const char *__path, int __oflag) __asm__ ("" "__open64_2") __attribute__ ((__nonnull__ (1)));

extern int __open_alias (__const char *__path, int __oflag, ...) __asm__ ("" "open64") __attribute__ ((__nonnull__ (1)));


extern void __open_too_many_args (void) __attribute__((__error__ ("open can be called either with 2 or 3 arguments, not more")));

extern void __open_missing_mode (void) __attribute__((__error__ ("open with O_CREAT in second argument needs 3 arguments")));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) int
open (__const char *__path, int __oflag, ...)
{
  if (__builtin_va_arg_pack_len () > 1)
    __open_too_many_args ();

  if (__builtin_constant_p (__oflag))
    {
      if ((__oflag & 0100) != 0 && __builtin_va_arg_pack_len () < 1)
 {
   __open_missing_mode ();
   return __open_2 (__path, __oflag);
 }
      return __open_alias (__path, __oflag, __builtin_va_arg_pack ());
    }

  if (__builtin_va_arg_pack_len () < 1)
    return __open_2 (__path, __oflag);

  return __open_alias (__path, __oflag, __builtin_va_arg_pack ());
}



extern int __open64_2 (__const char *__path, int __oflag) __attribute__ ((__nonnull__ (1)));
extern int __open64_alias (__const char *__path, int __oflag, ...) __asm__ ("" "open64") __attribute__ ((__nonnull__ (1)));

extern void __open64_too_many_args (void) __attribute__((__error__ ("open64 can be called either with 2 or 3 arguments, not more")));

extern void __open64_missing_mode (void) __attribute__((__error__ ("open64 with O_CREAT in second argument needs 3 arguments")));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) int
open64 (__const char *__path, int __oflag, ...)
{
  if (__builtin_va_arg_pack_len () > 1)
    __open64_too_many_args ();

  if (__builtin_constant_p (__oflag))
    {
      if ((__oflag & 0100) != 0 && __builtin_va_arg_pack_len () < 1)
 {
   __open64_missing_mode ();
   return __open64_2 (__path, __oflag);
 }
      return __open64_alias (__path, __oflag, __builtin_va_arg_pack ());
    }

  if (__builtin_va_arg_pack_len () < 1)
    return __open64_2 (__path, __oflag);

  return __open64_alias (__path, __oflag, __builtin_va_arg_pack ());
}
# 105 "/usr/include/bits/fcntl2.h" 3 4
extern int __openat_2 (int __fd, __const char *__path, int __oflag) __asm__ ("" "__openat64_2")

     __attribute__ ((__nonnull__ (2)));
extern int __openat_alias (int __fd, __const char *__path, int __oflag, ...) __asm__ ("" "openat64")

     __attribute__ ((__nonnull__ (2)));

extern void __openat_too_many_args (void) __attribute__((__error__ ("openat can be called either with 3 or 4 arguments, not more")));

extern void __openat_missing_mode (void) __attribute__((__error__ ("openat with O_CREAT in third argument needs 4 arguments")));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) int
openat (int __fd, __const char *__path, int __oflag, ...)
{
  if (__builtin_va_arg_pack_len () > 1)
    __openat_too_many_args ();

  if (__builtin_constant_p (__oflag))
    {
      if ((__oflag & 0100) != 0 && __builtin_va_arg_pack_len () < 1)
 {
   __openat_missing_mode ();
   return __openat_2 (__fd, __path, __oflag);
 }
      return __openat_alias (__fd, __path, __oflag, __builtin_va_arg_pack ());
    }

  if (__builtin_va_arg_pack_len () < 1)
    return __openat_2 (__fd, __path, __oflag);

  return __openat_alias (__fd, __path, __oflag, __builtin_va_arg_pack ());
}



extern int __openat64_2 (int __fd, __const char *__path, int __oflag)
     __attribute__ ((__nonnull__ (2)));
extern int __openat64_alias (int __fd, __const char *__path, int __oflag, ...) __asm__ ("" "openat64")

     __attribute__ ((__nonnull__ (2)));
extern void __openat64_too_many_args (void) __attribute__((__error__ ("openat64 can be called either with 3 or 4 arguments, not more")));

extern void __openat64_missing_mode (void) __attribute__((__error__ ("openat64 with O_CREAT in third argument needs 4 arguments")));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) int
openat64 (int __fd, __const char *__path, int __oflag, ...)
{
  if (__builtin_va_arg_pack_len () > 1)
    __openat64_too_many_args ();

  if (__builtin_constant_p (__oflag))
    {
      if ((__oflag & 0100) != 0 && __builtin_va_arg_pack_len () < 1)
 {
   __openat64_missing_mode ();
   return __openat64_2 (__fd, __path, __oflag);
 }
      return __openat64_alias (__fd, __path, __oflag, __builtin_va_arg_pack ());
    }

  if (__builtin_va_arg_pack_len () < 1)
    return __openat64_2 (__fd, __path, __oflag);

  return __openat64_alias (__fd, __path, __oflag, __builtin_va_arg_pack ());
}
# 253 "/usr/include/fcntl.h" 2 3 4


}
# 93 "/usr/include/wx-2.8/wx/filefn.h" 2
# 117 "/usr/include/wx-2.8/wx/filefn.h"
enum wxSeekMode
{
  wxFromStart,
  wxFromCurrent,
  wxFromEnd
};

enum wxFileKind
{
  wxFILE_KIND_UNKNOWN,
  wxFILE_KIND_DISK,
  wxFILE_KIND_TERMINAL,
  wxFILE_KIND_PIPE
};
# 411 "/usr/include/wx-2.8/wx/filefn.h"
    typedef off_t wxFileOffset;


        struct wxAssert_415 { unsigned int BadFileSizeType: sizeof(off_t) == sizeof(long long); };
# 452 "/usr/include/wx-2.8/wx/filefn.h"
        int wxStat( const wxChar *file_name, struct stat *buf );
        int wxLstat( const wxChar *file_name, struct stat *buf );
        int wxAccess( const wxChar *pathname, int mode );
        int wxOpen( const wxChar *pathname, int flags, mode_t mode );
# 494 "/usr/include/wx-2.8/wx/filefn.h"
const int wxInvalidOffset = -1;





 bool wxFileExists(const wxString& filename);


 bool wxDirExists(const wxChar *pszPathName);

 bool wxIsAbsolutePath(const wxString& filename);


 wxChar* wxFileNameFromPath(wxChar *path);
 wxString wxFileNameFromPath(const wxString& path);


 wxString wxPathOnly(const wxString& path);


 wxString wxRealPath(const wxString& path);

 void wxDos2UnixFilename(wxChar *s);

 void wxUnix2DosFilename(wxChar *s);


 void wxStripExtension(wxChar *buffer);
 void wxStripExtension(wxString& buffer);


 wxChar* wxGetTempFileName(const wxString& prefix, wxChar *buf = (wxChar *) __null);
 bool wxGetTempFileName(const wxString& prefix, wxString& buf);


 wxChar* wxExpandPath(wxChar *dest, const wxChar *path);
 bool wxExpandPath(wxString& dest, const wxChar *path);




 wxChar* wxContractPath(const wxString& filename,
                                   const wxString& envname = wxEmptyString,
                                   const wxString& user = wxEmptyString);


 wxChar* wxRealPath(wxChar *path);


 wxChar* wxCopyAbsolutePath(const wxString& path);





 wxString wxFindFirstFile(const wxChar *spec, int flags = 1);
 wxString wxFindNextFile();


 bool wxIsWild(const wxString& pattern);




 bool wxMatchWild(const wxString& pattern, const wxString& text, bool dot_special = true);


 bool wxConcatFiles(const wxString& file1, const wxString& file2, const wxString& file3);


 bool wxCopyFile(const wxString& file1, const wxString& file2,
                                 bool overwrite = true);


 bool wxRemoveFile(const wxString& file);


 bool wxRenameFile(const wxString& file1, const wxString& file2, bool overwrite = true);







 wxChar* wxGetWorkingDirectory(wxChar *buf = (wxChar *) __null, int sz = 1000) __attribute__ ((deprecated));



 wxString wxGetCwd();


 bool wxSetWorkingDirectory(const wxString& d);


 bool wxMkdir(const wxString& dir, int perm = 0777);


 bool wxRmdir(const wxString& dir, int flags = 0);


 wxFileKind wxGetFileKind(int fd);
 wxFileKind wxGetFileKind(FILE *fp);



inline bool wxPathExists(const wxChar *pszPathName) __attribute__ ((deprecated));
inline bool wxPathExists(const wxChar *pszPathName)
{
    return wxDirExists(pszPathName);
}



 bool wxIsWritable(const wxString &path);
 bool wxIsReadable(const wxString &path);
 bool wxIsExecutable(const wxString &path);
# 659 "/usr/include/wx-2.8/wx/filefn.h"
inline bool wxIsPathSeparator(wxChar c)
{


    return c == L'/';



}


 bool wxEndsWithPathSeparator(const wxChar *pszFileName);



 void wxSplitPath(const wxChar *pszFileName,
                             wxString *pstrPath,
                             wxString *pstrName,
                             wxString *pstrExt);


 bool wxFindFileInPath(wxString *pStr, const wxChar *pszPath, const wxChar *pszFile);



 wxString wxGetOSDirectory();




 time_t wxFileModificationTime(const wxString& filename);
# 698 "/usr/include/wx-2.8/wx/filefn.h"
 int wxParseCommonDialogsFilter(const wxString& wildCard, wxArrayString& descriptions, wxArrayString& filters);
# 707 "/usr/include/wx-2.8/wx/filefn.h"
class wxUmaskChanger
{
public:



    wxUmaskChanger(int umaskNew)
    {
        m_umaskOld = umaskNew == -1 ? -1 : (int)umask((mode_t)umaskNew);
    }

    ~wxUmaskChanger()
    {
        if ( m_umaskOld != -1 )
            umask((mode_t)m_umaskOld);
    }

private:
    int m_umaskOld;
};
# 740 "/usr/include/wx-2.8/wx/filefn.h"
class wxPathList : public wxArrayString
{
public:
    wxPathList() {}
    wxPathList(const wxArrayString &arr)
        { Add(arr); }


    void AddEnvList(const wxString& envVariable);


    bool Add(const wxString& path);
    void Add(const wxArrayString &paths);


    wxString FindValidPath(const wxString& filename) const;



    wxString FindAbsoluteValidPath(const wxString& filename) const;


    bool EnsureFileAccessible(const wxString& path);



    bool Member(const wxString& path) const __attribute__ ((deprecated));

};
# 22 "/usr/include/wx-2.8/wx/utils.h" 2




class wxArrayString;
class wxArrayInt;



# 1 "/usr/include/wx-2.8/wx/longlong.h" 1
# 22 "/usr/include/wx-2.8/wx/longlong.h"
# 1 "/usr/lib/gcc/i686-linux-gnu/4.4.5/include-fixed/limits.h" 1 3 4
# 23 "/usr/include/wx-2.8/wx/longlong.h" 2
# 89 "/usr/include/wx-2.8/wx/longlong.h"
    class wxLongLongNative;
    class wxULongLongNative;
    typedef wxLongLongNative wxLongLong;
    typedef wxULongLongNative wxULongLong;
# 103 "/usr/include/wx-2.8/wx/longlong.h"
# 1 "/usr/include/wx-2.8/wx/iosfwrap.h" 1
# 104 "/usr/include/wx-2.8/wx/longlong.h" 2



class wxLongLongNative
{
public:


    wxLongLongNative() : m_ll(0) { }

    wxLongLongNative(long long ll) : m_ll(ll) { }

    wxLongLongNative(wxInt32 hi, wxUint32 lo)
    {

        m_ll = ((long long) hi) << 32;
        m_ll |= (long long) lo;
    }
# 133 "/usr/include/wx-2.8/wx/longlong.h"
    wxLongLongNative& operator=(long long ll)
        { m_ll = ll; return *this; }
    wxLongLongNative& operator=(unsigned long long ll)
        { m_ll = ll; return *this; }

    wxLongLongNative& operator=(const wxULongLongNative &ll);
    wxLongLongNative& operator=(int l)
        { m_ll = l; return *this; }
    wxLongLongNative& operator=(long l)
        { m_ll = l; return *this; }
    wxLongLongNative& operator=(unsigned int l)
        { m_ll = l; return *this; }
    wxLongLongNative& operator=(unsigned long l)
        { m_ll = l; return *this; }
# 156 "/usr/include/wx-2.8/wx/longlong.h"
    wxLongLongNative& Assign(double d)
        { m_ll = (long long)d; return *this; }





    wxInt32 GetHi() const
        { return ((wxInt32)(m_ll >> 32)); }

    wxUint32 GetLo() const
        { return ((wxUint32)(m_ll)); }


    wxLongLongNative Abs() const { return wxLongLongNative(*this).Abs(); }
    wxLongLongNative& Abs() { if ( m_ll < 0 ) m_ll = -m_ll; return *this; }


    long long GetValue() const { return m_ll; }


    long ToLong() const
    {
        ;


        return ((long)(m_ll));
    }


    double ToDouble() const { return ((double)(m_ll)); }







    wxLongLongNative operator+(const wxLongLongNative& ll) const
        { return wxLongLongNative(m_ll + ll.m_ll); }
    wxLongLongNative& operator+=(const wxLongLongNative& ll)
        { m_ll += ll.m_ll; return *this; }

    wxLongLongNative operator+(const long long ll) const
        { return wxLongLongNative(m_ll + ll); }
    wxLongLongNative& operator+=(const long long ll)
        { m_ll += ll; return *this; }


    wxLongLongNative& operator++()
        { m_ll++; return *this; }


    wxLongLongNative operator++(int)
        { wxLongLongNative value(*this); m_ll++; return value; }


    wxLongLongNative operator-() const
        { return wxLongLongNative(-m_ll); }
    wxLongLongNative& Negate() { m_ll = -m_ll; return *this; }


    wxLongLongNative operator-(const wxLongLongNative& ll) const
        { return wxLongLongNative(m_ll - ll.m_ll); }
    wxLongLongNative& operator-=(const wxLongLongNative& ll)
        { m_ll -= ll.m_ll; return *this; }

    wxLongLongNative operator-(const long long ll) const
        { return wxLongLongNative(m_ll - ll); }
    wxLongLongNative& operator-=(const long long ll)
        { m_ll -= ll; return *this; }


    wxLongLongNative& operator--()
        { m_ll--; return *this; }


    wxLongLongNative operator--(int)
        { wxLongLongNative value(*this); m_ll--; return value; }



    wxLongLongNative operator<<(int shift) const
        { return wxLongLongNative(m_ll << shift); }
    wxLongLongNative& operator<<=(int shift)
        { m_ll <<= shift; return *this; }


    wxLongLongNative operator>>(int shift) const
        { return wxLongLongNative(m_ll >> shift); }
    wxLongLongNative& operator>>=(int shift)
        { m_ll >>= shift; return *this; }


    wxLongLongNative operator&(const wxLongLongNative& ll) const
        { return wxLongLongNative(m_ll & ll.m_ll); }
    wxLongLongNative& operator&=(const wxLongLongNative& ll)
        { m_ll &= ll.m_ll; return *this; }

    wxLongLongNative operator|(const wxLongLongNative& ll) const
        { return wxLongLongNative(m_ll | ll.m_ll); }
    wxLongLongNative& operator|=(const wxLongLongNative& ll)
        { m_ll |= ll.m_ll; return *this; }

    wxLongLongNative operator^(const wxLongLongNative& ll) const
        { return wxLongLongNative(m_ll ^ ll.m_ll); }
    wxLongLongNative& operator^=(const wxLongLongNative& ll)
        { m_ll ^= ll.m_ll; return *this; }


    wxLongLongNative operator*(const wxLongLongNative& ll) const
        { return wxLongLongNative(m_ll * ll.m_ll); }
    wxLongLongNative operator*(long l) const
        { return wxLongLongNative(m_ll * l); }
    wxLongLongNative& operator*=(const wxLongLongNative& ll)
        { m_ll *= ll.m_ll; return *this; }
    wxLongLongNative& operator*=(long l)
        { m_ll *= l; return *this; }

    wxLongLongNative operator/(const wxLongLongNative& ll) const
        { return wxLongLongNative(m_ll / ll.m_ll); }
    wxLongLongNative operator/(long l) const
        { return wxLongLongNative(m_ll / l); }
    wxLongLongNative& operator/=(const wxLongLongNative& ll)
        { m_ll /= ll.m_ll; return *this; }
    wxLongLongNative& operator/=(long l)
        { m_ll /= l; return *this; }

    wxLongLongNative operator%(const wxLongLongNative& ll) const
        { return wxLongLongNative(m_ll % ll.m_ll); }
    wxLongLongNative operator%(long l) const
        { return wxLongLongNative(m_ll % l); }


    bool operator==(const wxLongLongNative& ll) const
        { return m_ll == ll.m_ll; }
    bool operator==(long l) const
        { return m_ll == l; }
    bool operator!=(const wxLongLongNative& ll) const
        { return m_ll != ll.m_ll; }
    bool operator!=(long l) const
        { return m_ll != l; }
    bool operator<(const wxLongLongNative& ll) const
        { return m_ll < ll.m_ll; }
    bool operator<(long l) const
        { return m_ll < l; }
    bool operator>(const wxLongLongNative& ll) const
        { return m_ll > ll.m_ll; }
    bool operator>(long l) const
        { return m_ll > l; }
    bool operator<=(const wxLongLongNative& ll) const
        { return m_ll <= ll.m_ll; }
    bool operator<=(long l) const
        { return m_ll <= l; }
    bool operator>=(const wxLongLongNative& ll) const
        { return m_ll >= ll.m_ll; }
    bool operator>=(long l) const
        { return m_ll >= l; }




    wxString ToString() const;


    void *asArray() const;



    friend
    std:: ostream& operator<<(std:: ostream&, const wxLongLongNative&);


    friend
    wxString& operator<<(wxString&, const wxLongLongNative&);


    friend
    class wxTextOutputStream& operator<<(class wxTextOutputStream&, const wxLongLongNative&);
    friend
    class wxTextInputStream& operator>>(class wxTextInputStream&, wxLongLongNative&);


private:
    long long m_ll;
};


class wxULongLongNative
{
public:


    wxULongLongNative() : m_ll(0) { }

    wxULongLongNative(unsigned long long ll) : m_ll(ll) { }

    wxULongLongNative(wxUint32 hi, wxUint32 lo) : m_ll(0)
    {

        m_ll = ((unsigned long long) hi) << 32;
        m_ll |= (unsigned long long) lo;
    }
# 371 "/usr/include/wx-2.8/wx/longlong.h"
    wxULongLongNative& operator=(unsigned long long ll)
        { m_ll = ll; return *this; }
    wxULongLongNative& operator=(long long ll)
        { m_ll = ll; return *this; }

    wxULongLongNative& operator=(int l)
        { m_ll = l; return *this; }
    wxULongLongNative& operator=(long l)
        { m_ll = l; return *this; }
    wxULongLongNative& operator=(unsigned int l)
        { m_ll = l; return *this; }
    wxULongLongNative& operator=(unsigned long l)
        { m_ll = l; return *this; }
    wxULongLongNative& operator=(const wxLongLongNative &ll)
        { m_ll = ll.GetValue(); return *this; }
# 395 "/usr/include/wx-2.8/wx/longlong.h"
    wxUint32 GetHi() const
        { return ((wxUint32)(m_ll >> 32)); }

    wxUint32 GetLo() const
        { return ((wxUint32)(m_ll)); }


    unsigned long long GetValue() const { return m_ll; }


    unsigned long ToULong() const
    {
        ;


        return ((unsigned long)(m_ll));
    }





    double ToDouble() const { return ((double)(m_ll)); }




    wxULongLongNative operator+(const wxULongLongNative& ll) const
        { return wxULongLongNative(m_ll + ll.m_ll); }
    wxULongLongNative& operator+=(const wxULongLongNative& ll)
        { m_ll += ll.m_ll; return *this; }

    wxULongLongNative operator+(const unsigned long long ll) const
        { return wxULongLongNative(m_ll + ll); }
    wxULongLongNative& operator+=(const unsigned long long ll)
        { m_ll += ll; return *this; }


    wxULongLongNative& operator++()
        { m_ll++; return *this; }


    wxULongLongNative operator++(int)
        { wxULongLongNative value(*this); m_ll++; return value; }


    wxULongLongNative operator-(const wxULongLongNative& ll) const
        { return wxULongLongNative(m_ll - ll.m_ll); }
    wxULongLongNative& operator-=(const wxULongLongNative& ll)
        { m_ll -= ll.m_ll; return *this; }

    wxULongLongNative operator-(const unsigned long long ll) const
        { return wxULongLongNative(m_ll - ll); }
    wxULongLongNative& operator-=(const unsigned long long ll)
        { m_ll -= ll; return *this; }


    wxULongLongNative& operator--()
        { m_ll--; return *this; }


    wxULongLongNative operator--(int)
        { wxULongLongNative value(*this); m_ll--; return value; }



    wxULongLongNative operator<<(int shift) const
        { return wxULongLongNative(m_ll << shift); }
    wxULongLongNative& operator<<=(int shift)
        { m_ll <<= shift; return *this; }


    wxULongLongNative operator>>(int shift) const
        { return wxULongLongNative(m_ll >> shift); }
    wxULongLongNative& operator>>=(int shift)
        { m_ll >>= shift; return *this; }


    wxULongLongNative operator&(const wxULongLongNative& ll) const
        { return wxULongLongNative(m_ll & ll.m_ll); }
    wxULongLongNative& operator&=(const wxULongLongNative& ll)
        { m_ll &= ll.m_ll; return *this; }

    wxULongLongNative operator|(const wxULongLongNative& ll) const
        { return wxULongLongNative(m_ll | ll.m_ll); }
    wxULongLongNative& operator|=(const wxULongLongNative& ll)
        { m_ll |= ll.m_ll; return *this; }

    wxULongLongNative operator^(const wxULongLongNative& ll) const
        { return wxULongLongNative(m_ll ^ ll.m_ll); }
    wxULongLongNative& operator^=(const wxULongLongNative& ll)
        { m_ll ^= ll.m_ll; return *this; }


    wxULongLongNative operator*(const wxULongLongNative& ll) const
        { return wxULongLongNative(m_ll * ll.m_ll); }
    wxULongLongNative operator*(unsigned long l) const
        { return wxULongLongNative(m_ll * l); }
    wxULongLongNative& operator*=(const wxULongLongNative& ll)
        { m_ll *= ll.m_ll; return *this; }
    wxULongLongNative& operator*=(unsigned long l)
        { m_ll *= l; return *this; }

    wxULongLongNative operator/(const wxULongLongNative& ll) const
        { return wxULongLongNative(m_ll / ll.m_ll); }
    wxULongLongNative operator/(unsigned long l) const
        { return wxULongLongNative(m_ll / l); }
    wxULongLongNative& operator/=(const wxULongLongNative& ll)
        { m_ll /= ll.m_ll; return *this; }
    wxULongLongNative& operator/=(unsigned long l)
        { m_ll /= l; return *this; }

    wxULongLongNative operator%(const wxULongLongNative& ll) const
        { return wxULongLongNative(m_ll % ll.m_ll); }
    wxULongLongNative operator%(unsigned long l) const
        { return wxULongLongNative(m_ll % l); }


    bool operator==(const wxULongLongNative& ll) const
        { return m_ll == ll.m_ll; }
    bool operator==(unsigned long l) const
        { return m_ll == l; }
    bool operator!=(const wxULongLongNative& ll) const
        { return m_ll != ll.m_ll; }
    bool operator!=(unsigned long l) const
        { return m_ll != l; }
    bool operator<(const wxULongLongNative& ll) const
        { return m_ll < ll.m_ll; }
    bool operator<(unsigned long l) const
        { return m_ll < l; }
    bool operator>(const wxULongLongNative& ll) const
        { return m_ll > ll.m_ll; }
    bool operator>(unsigned long l) const
        { return m_ll > l; }
    bool operator<=(const wxULongLongNative& ll) const
        { return m_ll <= ll.m_ll; }
    bool operator<=(unsigned long l) const
        { return m_ll <= l; }
    bool operator>=(const wxULongLongNative& ll) const
        { return m_ll >= ll.m_ll; }
    bool operator>=(unsigned long l) const
        { return m_ll >= l; }




    wxString ToString() const;


    void *asArray() const;



    friend
    std:: ostream& operator<<(std:: ostream&, const wxULongLongNative&);


    friend
    wxString& operator<<(wxString&, const wxULongLongNative&);


    friend
    class wxTextOutputStream& operator<<(class wxTextOutputStream&, const wxULongLongNative&);
    friend
    class wxTextInputStream& operator>>(class wxTextInputStream&, wxULongLongNative&);


private:
    unsigned long long m_ll;
};

inline
wxLongLongNative& wxLongLongNative::operator=(const wxULongLongNative &ll)
{
    m_ll = ll.GetValue();
    return *this;
}
# 1040 "/usr/include/wx-2.8/wx/longlong.h"
inline bool operator<(long l, const wxLongLong& ll) { return ll > l; }
inline bool operator>(long l, const wxLongLong& ll) { return ll < l; }
inline bool operator<=(long l, const wxLongLong& ll) { return ll >= l; }
inline bool operator>=(long l, const wxLongLong& ll) { return ll <= l; }
inline bool operator==(long l, const wxLongLong& ll) { return ll == l; }
inline bool operator!=(long l, const wxLongLong& ll) { return ll != l; }

inline wxLongLong operator+(long l, const wxLongLong& ll) { return ll + l; }
inline wxLongLong operator-(long l, const wxLongLong& ll)
{
    return wxLongLong(l) - ll;
}

inline bool operator<(unsigned long l, const wxULongLong& ull) { return ull > l; }
inline bool operator>(unsigned long l, const wxULongLong& ull) { return ull < l; }
inline bool operator<=(unsigned long l, const wxULongLong& ull) { return ull >= l; }
inline bool operator>=(unsigned long l, const wxULongLong& ull) { return ull <= l; }
inline bool operator==(unsigned long l, const wxULongLong& ull) { return ull == l; }
inline bool operator!=(unsigned long l, const wxULongLong& ull) { return ull != l; }

inline wxULongLong operator+(unsigned long l, const wxULongLong& ull) { return ull + l; }

inline wxLongLong operator-(unsigned long l, const wxULongLong& ull)
{
    wxULongLong ret = wxULongLong(l) - ull;
    return wxLongLong((long)ret.GetHi(),ret.GetLo());
}



 class wxTextOutputStream &operator<<(class wxTextOutputStream &stream, unsigned long long value);
 class wxTextOutputStream &operator<<(class wxTextOutputStream &stream, long long value);

 class wxTextInputStream &operator>>(class wxTextInputStream &stream, unsigned long long &value);
 class wxTextInputStream &operator>>(class wxTextInputStream &stream, long long &value);
# 32 "/usr/include/wx-2.8/wx/utils.h" 2


# 1 "/usr/include/wx-2.8/wx/platinfo.h" 1
# 26 "/usr/include/wx-2.8/wx/platinfo.h"
enum wxOperatingSystemId
{
    wxOS_UNKNOWN = 0,

    wxOS_MAC_OS = 1 << 0,
    wxOS_MAC_OSX_DARWIN = 1 << 1,
    wxOS_MAC = wxOS_MAC_OS|wxOS_MAC_OSX_DARWIN,

    wxOS_WINDOWS_9X = 1 << 2,
    wxOS_WINDOWS_NT = 1 << 3,
    wxOS_WINDOWS_MICRO = 1 << 4,
    wxOS_WINDOWS_CE = 1 << 5,
    wxOS_WINDOWS = wxOS_WINDOWS_9X |
                   wxOS_WINDOWS_NT |
                   wxOS_WINDOWS_MICRO |
                   wxOS_WINDOWS_CE,

    wxOS_UNIX_LINUX = 1 << 6,
    wxOS_UNIX_FREEBSD = 1 << 7,
    wxOS_UNIX_OPENBSD = 1 << 8,
    wxOS_UNIX_NETBSD = 1 << 9,
    wxOS_UNIX_SOLARIS = 1 << 10,
    wxOS_UNIX_AIX = 1 << 11,
    wxOS_UNIX_HPUX = 1 << 12,
    wxOS_UNIX = wxOS_UNIX_LINUX |
                wxOS_UNIX_FREEBSD |
                wxOS_UNIX_OPENBSD |
                wxOS_UNIX_NETBSD |
                wxOS_UNIX_SOLARIS |
                wxOS_UNIX_AIX |
                wxOS_UNIX_HPUX,



    wxOS_DOS = 1 << 15,
    wxOS_OS2 = 1 << 16
};



enum wxPortId
{
    wxPORT_UNKNOWN = 0,

    wxPORT_BASE = 1 << 0,

    wxPORT_MSW = 1 << 1,
    wxPORT_MOTIF = 1 << 2,
    wxPORT_GTK = 1 << 3,
    wxPORT_MGL = 1 << 4,
    wxPORT_X11 = 1 << 5,
    wxPORT_PM = 1 << 6,
    wxPORT_OS2 = wxPORT_PM,
    wxPORT_MAC = 1 << 7,
    wxPORT_COCOA = 1 << 8,
    wxPORT_WINCE = 1 << 9,
    wxPORT_PALMOS = 1 << 10,
    wxPORT_DFB = 1 << 11
};




enum wxArchitecture
{
    wxARCH_INVALID = -1,

    wxARCH_32,
    wxARCH_64,

    wxARCH_MAX
};



enum wxEndianness
{
    wxENDIAN_INVALID = -1,

    wxENDIAN_BIG,
    wxENDIAN_LITTLE,
    wxENDIAN_PDP,

    wxENDIAN_MAX
};



class wxPlatformInfo
{
public:
    wxPlatformInfo();
    wxPlatformInfo(wxPortId pid,
                   int tkMajor = -1, int tkMinor = -1,
                   wxOperatingSystemId id = wxOS_UNKNOWN,
                   int osMajor = -1, int osMinor = -1,
                   wxArchitecture arch = wxARCH_INVALID,
                   wxEndianness endian = wxENDIAN_INVALID,
                   bool usingUniversal = false);



    bool operator==(const wxPlatformInfo &t) const;

    bool operator!=(const wxPlatformInfo &t) const
        { return !(*this == t); }



    static const wxPlatformInfo& Get();






    static wxOperatingSystemId GetOperatingSystemId(const wxString &name);
    static wxPortId GetPortId(const wxString &portname);

    static wxArchitecture GetArch(const wxString &arch);
    static wxEndianness GetEndianness(const wxString &end);




    static wxString GetOperatingSystemFamilyName(wxOperatingSystemId os);
    static wxString GetOperatingSystemIdName(wxOperatingSystemId os);
    static wxString GetPortIdName(wxPortId port, bool usingUniversal);
    static wxString GetPortIdShortName(wxPortId port, bool usingUniversal);

    static wxString GetArchName(wxArchitecture arch);
    static wxString GetEndiannessName(wxEndianness end);




    int GetOSMajorVersion() const
        { return m_osVersionMajor; }
    int GetOSMinorVersion() const
        { return m_osVersionMinor; }


    bool CheckOSVersion(int major, int minor) const
    {
        return DoCheckVersion(GetOSMajorVersion(),
                              GetOSMinorVersion(),
                              major,
                              minor);
    }

    int GetToolkitMajorVersion() const
        { return m_tkVersionMajor; }
    int GetToolkitMinorVersion() const
        { return m_tkVersionMinor; }

    bool CheckToolkitVersion(int major, int minor) const
    {
        return DoCheckVersion(GetToolkitMajorVersion(),
                              GetToolkitMinorVersion(),
                              major,
                              minor);
    }

    bool IsUsingUniversalWidgets() const
        { return m_usingUniversal; }

    wxOperatingSystemId GetOperatingSystemId() const
        { return m_os; }
    wxPortId GetPortId() const
        { return m_port; }
    wxArchitecture GetArchitecture() const
        { return m_arch; }
    wxEndianness GetEndianness() const
        { return m_endian; }





    wxString GetOperatingSystemFamilyName() const
        { return GetOperatingSystemFamilyName(m_os); }
    wxString GetOperatingSystemIdName() const
        { return GetOperatingSystemIdName(m_os); }
    wxString GetPortIdName() const
        { return GetPortIdName(m_port, m_usingUniversal); }
    wxString GetPortIdShortName() const
        { return GetPortIdShortName(m_port, m_usingUniversal); }
    wxString GetArchName() const
        { return GetArchName(m_arch); }
    wxString GetEndiannessName() const
        { return GetEndiannessName(m_endian); }




    void SetOSVersion(int major, int minor)
        { m_osVersionMajor=major; m_osVersionMinor=minor; }
    void SetToolkitVersion(int major, int minor)
        { m_tkVersionMajor=major; m_tkVersionMinor=minor; }

    void SetOperatingSystemId(wxOperatingSystemId n)
        { m_os = n; }
    void SetPortId(wxPortId n)
        { m_port = n; }
    void SetArchitecture(wxArchitecture n)
        { m_arch = n; }
    void SetEndianness(wxEndianness n)
        { m_endian = n; }




    bool IsOk() const
    {
        return m_osVersionMajor != -1 && m_osVersionMinor != -1 &&
               m_os != wxOS_UNKNOWN &&
               m_tkVersionMajor != -1 && m_tkVersionMinor != -1 &&
               m_port != wxPORT_UNKNOWN &&
               m_arch != wxARCH_INVALID && m_endian != wxENDIAN_INVALID;
    }


protected:
    static bool DoCheckVersion(int majorCur, int minorCur, int major, int minor)
    {
        return majorCur > major || (majorCur == major && minorCur >= minor);
    }

    void InitForCurrentPlatform();







    int m_osVersionMajor,
        m_osVersionMinor;


    wxOperatingSystemId m_os;







    int m_tkVersionMajor, m_tkVersionMinor;


    wxPortId m_port;


    bool m_usingUniversal;






    wxArchitecture m_arch;


    wxEndianness m_endian;
};
# 35 "/usr/include/wx-2.8/wx/utils.h" 2
# 49 "/usr/include/wx-2.8/wx/utils.h"
class wxProcess;
class wxFrame;
class wxWindow;
class wxWindowList;
# 66 "/usr/include/wx-2.8/wx/utils.h"
    typedef wxLongLong wxMemorySize;
# 90 "/usr/include/wx-2.8/wx/utils.h"
 void wxBell();





 wxString wxGetOsDescription();


 wxOperatingSystemId wxGetOsVersion(int *majorVsn = (int *) __null,
                                                    int *minorVsn = (int *) __null);


 bool wxIsPlatformLittleEndian();


 bool wxIsPlatform64Bit();


 wxString wxNow();


 const wxChar *wxGetInstallPrefix();

 wxString wxGetDataDir();
# 134 "/usr/include/wx-2.8/wx/utils.h"
class wxPlatform
{
public:
    wxPlatform() { Init(); }
    wxPlatform(const wxPlatform& platform) { Copy(platform); }
    void operator = (const wxPlatform& platform) { Copy(platform); }
    void Copy(const wxPlatform& platform);


    wxPlatform(int defValue) { Init(); m_longValue = (long)defValue; }
    wxPlatform(long defValue) { Init(); m_longValue = defValue; }
    wxPlatform(const wxString& defValue) { Init(); m_stringValue = defValue; }
    wxPlatform(double defValue) { Init(); m_doubleValue = defValue; }

    static wxPlatform If(int platform, long value);
    static wxPlatform IfNot(int platform, long value);
    wxPlatform& ElseIf(int platform, long value);
    wxPlatform& ElseIfNot(int platform, long value);
    wxPlatform& Else(long value);

    static wxPlatform If(int platform, int value) { return If(platform, (long)value); }
    static wxPlatform IfNot(int platform, int value) { return IfNot(platform, (long)value); }
    wxPlatform& ElseIf(int platform, int value) { return ElseIf(platform, (long) value); }
    wxPlatform& ElseIfNot(int platform, int value) { return ElseIfNot(platform, (long) value); }
    wxPlatform& Else(int value) { return Else((long) value); }

    static wxPlatform If(int platform, double value);
    static wxPlatform IfNot(int platform, double value);
    wxPlatform& ElseIf(int platform, double value);
    wxPlatform& ElseIfNot(int platform, double value);
    wxPlatform& Else(double value);

    static wxPlatform If(int platform, const wxString& value);
    static wxPlatform IfNot(int platform, const wxString& value);
    wxPlatform& ElseIf(int platform, const wxString& value);
    wxPlatform& ElseIfNot(int platform, const wxString& value);
    wxPlatform& Else(const wxString& value);

    long GetInteger() const { return m_longValue; }
    const wxString& GetString() const { return m_stringValue; }
    double GetDouble() const { return m_doubleValue; }

    operator int() const { return (int) GetInteger(); }
    operator long() const { return GetInteger(); }
    operator double() const { return GetDouble(); }
    operator const wxString() const { return GetString(); }
    operator const wxChar*() const { return (const wxChar*) GetString(); }

    static void AddPlatform(int platform);
    static bool Is(int platform);
    static void ClearPlatforms();

private:

    void Init() { m_longValue = 0; m_doubleValue = 0.0; }

    long m_longValue;
    double m_doubleValue;
    wxString m_stringValue;
    static wxArrayInt* sm_customPlatforms;
};


inline bool wxPlatformIs(int platform) { return wxPlatform::Is(platform); }






 bool wxGetKeyState(wxKeyCode key);





 bool wxSetDetectableAutoRepeat( bool flag );




class wxMouseState
{
public:
    wxMouseState()
        : m_x(0), m_y(0),
          m_leftDown(false), m_middleDown(false), m_rightDown(false),
          m_controlDown(false), m_shiftDown(false), m_altDown(false),
          m_metaDown(false)
    {}

    wxCoord GetX() { return m_x; }
    wxCoord GetY() { return m_y; }

    bool LeftDown() { return m_leftDown; }
    bool MiddleDown() { return m_middleDown; }
    bool RightDown() { return m_rightDown; }


    bool LeftIsDown() { return m_leftDown; }
    bool MiddleIsDown() { return m_middleDown; }
    bool RightIsDown() { return m_rightDown; }


    bool ControlDown() { return m_controlDown; }
    bool ShiftDown() { return m_shiftDown; }
    bool AltDown() { return m_altDown; }
    bool MetaDown() { return m_metaDown; }
    bool CmdDown()
    {



        return ControlDown();

    }

    void SetX(wxCoord x) { m_x = x; }
    void SetY(wxCoord y) { m_y = y; }

    void SetLeftDown(bool down) { m_leftDown = down; }
    void SetMiddleDown(bool down) { m_middleDown = down; }
    void SetRightDown(bool down) { m_rightDown = down; }

    void SetControlDown(bool down) { m_controlDown = down; }
    void SetShiftDown(bool down) { m_shiftDown = down; }
    void SetAltDown(bool down) { m_altDown = down; }
    void SetMetaDown(bool down) { m_metaDown = down; }

private:
    wxCoord m_x;
    wxCoord m_y;

    bool m_leftDown : 1;
    bool m_middleDown : 1;
    bool m_rightDown : 1;

    bool m_controlDown : 1;
    bool m_shiftDown : 1;
    bool m_altDown : 1;
    bool m_metaDown : 1;
};



 wxMouseState wxGetMouseState();







 long wxNewId();


 void wxRegisterId(long id);


 long wxGetCurrentId();
# 319 "/usr/include/wx-2.8/wx/utils.h"
 int wxHexToDec(const wxString& buf);


 void wxDecToHex(int dec, wxChar *buf);
 wxString wxDecToHex(int dec);
# 332 "/usr/include/wx-2.8/wx/utils.h"
enum
{

    wxEXEC_ASYNC = 0,


    wxEXEC_SYNC = 1,



    wxEXEC_NOHIDE = 2,



    wxEXEC_MAKE_GROUP_LEADER = 4,




    wxEXEC_NODISABLE = 8
};






 long wxExecute(wxChar **argv, int flags = wxEXEC_ASYNC,
                           wxProcess *process = (wxProcess *) __null);
 long wxExecute(const wxString& command, int flags = wxEXEC_ASYNC,
                           wxProcess *process = (wxProcess *) __null);



 long wxExecute(const wxString& command,
                                wxArrayString& output,
                                int flags = 0);


 long wxExecute(const wxString& command,
                                wxArrayString& output,
                                wxArrayString& error,
                                int flags = 0);
# 383 "/usr/include/wx-2.8/wx/utils.h"
enum wxSignal
{
    wxSIGNONE = 0,
    wxSIGHUP,
    wxSIGINT,
    wxSIGQUIT,
    wxSIGILL,
    wxSIGTRAP,
    wxSIGABRT,
    wxSIGIOT = wxSIGABRT,
    wxSIGEMT,
    wxSIGFPE,
    wxSIGKILL,
    wxSIGBUS,
    wxSIGSEGV,
    wxSIGSYS,
    wxSIGPIPE,
    wxSIGALRM,
    wxSIGTERM


};

enum wxKillError
{
    wxKILL_OK,
    wxKILL_BAD_SIGNAL,
    wxKILL_ACCESS_DENIED,
    wxKILL_NO_PROCESS,
    wxKILL_ERROR
};

enum wxKillFlags
{
    wxKILL_NOCHILDREN = 0,
    wxKILL_CHILDREN = 1
};

enum wxShutdownFlags
{
    wxSHUTDOWN_POWEROFF,
    wxSHUTDOWN_REBOOT
};


 bool wxShutdown(wxShutdownFlags wFlags);





 int wxKill(long pid,
                       wxSignal sig = wxSIGTERM,
                       wxKillError *rc = __null,
                       int flags = wxKILL_NOCHILDREN);



 bool wxShell(const wxString& command = wxEmptyString);



 bool wxShell(const wxString& command, wxArrayString& output);


 void wxSleep(int nSecs);


 void wxMilliSleep(unsigned long milliseconds);


 void wxMicroSleep(unsigned long microseconds);


 void wxUsleep(unsigned long milliseconds) __attribute__ ((deprecated));


 unsigned long wxGetProcessId();


 wxMemorySize wxGetFreeMemory();




 bool wxHandleFatalExceptions(bool doit = true);




enum
{
    wxBROWSER_NEW_WINDOW = 1
};


 bool wxLaunchDefaultBrowser(const wxString& url, int flags = 0);







 bool wxGetEnv(const wxString& var, wxString *value);


 bool wxSetEnv(const wxString& var, const wxChar *value);


inline bool wxUnsetEnv(const wxString& var) { return wxSetEnv(var, __null); }
# 502 "/usr/include/wx-2.8/wx/utils.h"
 bool wxGetEmailAddress(wxChar *buf, int maxSize);
 wxString wxGetEmailAddress();


 bool wxGetHostName(wxChar *buf, int maxSize);
 wxString wxGetHostName();


 wxString wxGetFullHostName();
 bool wxGetFullHostName(wxChar *buf, int maxSize);


 bool wxGetUserId(wxChar *buf, int maxSize);
 wxString wxGetUserId();


 bool wxGetUserName(wxChar *buf, int maxSize);
 wxString wxGetUserName();


 wxString wxGetHomeDir();
 const wxChar* wxGetHomeDir(wxString *pstr);




 const wxWCharBuffer wxGetUserHome(const wxString& user = wxEmptyString);





    typedef wxLongLong wxDiskspaceSize_t;





 bool wxGetDiskSpace(const wxString& path,
                                     wxDiskspaceSize_t *pTotal = __null,
                                     wxDiskspaceSize_t *pFree = __null);
# 551 "/usr/include/wx-2.8/wx/utils.h"
enum
{

    wxStrip_Mnemonics = 1,


    wxStrip_Accel = 2,


    wxStrip_All = wxStrip_Mnemonics | wxStrip_Accel
};


 wxString
wxStripMenuCodes(const wxString& str, int flags = wxStrip_All);



 wxChar* wxStripMenuCodes(const wxChar *in, wxChar *out = __null) __attribute__ ((deprecated));




class wxAcceleratorEntry;


 wxAcceleratorEntry *wxGetAccelFromString(const wxString& label) __attribute__ ((deprecated));
# 589 "/usr/include/wx-2.8/wx/utils.h"
 int wxFindMenuItemId(wxFrame *frame, const wxString& menuString, const wxString& itemString);



 wxWindow* wxGenericFindWindowAtPoint(const wxPoint& pt);
 wxWindow* wxFindWindowAtPoint(const wxPoint& pt);






 wxWindow* wxFindWindowByLabel(const wxString& title, wxWindow *parent = (wxWindow *) __null);




 wxWindow* wxFindWindowByName(const wxString& name, wxWindow *parent = (wxWindow *) __null);






 bool wxSafeYield(wxWindow *win = __null, bool onlyIfNeeded = false);


 void wxEnableTopLevelWindows(bool enable = true);



 bool wxCheckForInterrupt(wxWindow *wnd);


 void wxFlushEvents();



class wxWindowDisabler
{
public:
    wxWindowDisabler(wxWindow *winToSkip = (wxWindow *)__null);
    ~wxWindowDisabler();

private:
    wxWindowList *m_winDisabled;

    private: wxWindowDisabler(const wxWindowDisabler&); wxWindowDisabler& operator=(const wxWindowDisabler&);
};






 void wxBeginBusyCursor(const wxCursor *cursor = wxStockGDI::GetCursor(wxStockGDI::CURSOR_HOURGLASS));


 void wxEndBusyCursor();


 bool wxIsBusy();


class wxBusyCursor
{
public:
    wxBusyCursor(const wxCursor* cursor = wxStockGDI::GetCursor(wxStockGDI::CURSOR_HOURGLASS))
        { wxBeginBusyCursor(cursor); }
    ~wxBusyCursor()
        { wxEndBusyCursor(); }






    static const wxCursor &GetStoredCursor();
    static const wxCursor GetBusyCursor();
};
# 687 "/usr/include/wx-2.8/wx/utils.h"
void wxGetMousePosition( int* x, int* y );
# 701 "/usr/include/wx-2.8/wx/utils.h"
    void *wxGetDisplay();
# 735 "/usr/include/wx-2.8/wx/utils.h"
 bool wxYield();




 bool wxYieldIfNeeded();
# 42 "/usr/include/wx-2.8/wx/cursor.h" 2
# 60 "/usr/include/wx-2.8/wx/cursor.h"
class wxBusyCursorSuspender
{
public:
    wxBusyCursorSuspender()
    {
        if( wxIsBusy() )
        {
            wxSetCursor( wxBusyCursor::GetStoredCursor() );
        }
    }
    ~wxBusyCursorSuspender()
    {
        if( wxIsBusy() )
        {
            wxSetCursor( wxBusyCursor::GetBusyCursor() );
        }
    }
};
# 23 "/usr/include/wx-2.8/wx/event.h" 2


# 1 "/usr/include/wx-2.8/wx/thread.h" 1
# 34 "/usr/include/wx-2.8/wx/thread.h"
enum wxMutexError
{
    wxMUTEX_NO_ERROR = 0,
    wxMUTEX_INVALID,
    wxMUTEX_DEAD_LOCK,
    wxMUTEX_BUSY,
    wxMUTEX_UNLOCKED,
    wxMUTEX_MISC_ERROR
};

enum wxCondError
{
    wxCOND_NO_ERROR = 0,
    wxCOND_INVALID,
    wxCOND_TIMEOUT,
    wxCOND_MISC_ERROR
};

enum wxSemaError
{
    wxSEMA_NO_ERROR = 0,
    wxSEMA_INVALID,
    wxSEMA_BUSY,
    wxSEMA_TIMEOUT,
    wxSEMA_OVERFLOW,
    wxSEMA_MISC_ERROR
};

enum wxThreadError
{
    wxTHREAD_NO_ERROR = 0,
    wxTHREAD_NO_RESOURCE,
    wxTHREAD_RUNNING,
    wxTHREAD_NOT_RUNNING,
    wxTHREAD_KILLED,
    wxTHREAD_MISC_ERROR
};

enum wxThreadKind
{
    wxTHREAD_DETACHED,
    wxTHREAD_JOINABLE
};


enum
{
    WXTHREAD_MIN_PRIORITY = 0u,
    WXTHREAD_DEFAULT_PRIORITY = 50u,
    WXTHREAD_MAX_PRIORITY = 100u
};
# 102 "/usr/include/wx-2.8/wx/thread.h"
enum wxMutexType
{

    wxMUTEX_DEFAULT,


    wxMUTEX_RECURSIVE
};


class wxThreadHelper;
class wxConditionInternal;
class wxMutexInternal;
class wxSemaphoreInternal;
class wxThreadInternal;
# 127 "/usr/include/wx-2.8/wx/thread.h"
class wxMutex
{
public:




    wxMutex(wxMutexType mutexType = wxMUTEX_DEFAULT);


    ~wxMutex();


    bool IsOk() const;
# 150 "/usr/include/wx-2.8/wx/thread.h"
    wxMutexError Lock();



    wxMutexError TryLock();


    wxMutexError Unlock();

protected:
    wxMutexInternal *m_internal;

    friend class wxConditionInternal;

    private: wxMutex(const wxMutex&); wxMutex& operator=(const wxMutex&);
};




class wxMutexLocker
{
public:

    wxMutexLocker(wxMutex& mutex)
        : m_isOk(false), m_mutex(mutex)
        { m_isOk = ( m_mutex.Lock() == wxMUTEX_NO_ERROR ); }


    bool IsOk() const
        { return m_isOk; }


    ~wxMutexLocker()
        { if ( IsOk() ) m_mutex.Unlock(); }

private:

    wxMutexLocker(const wxMutexLocker&);
    wxMutexLocker& operator=(const wxMutexLocker&);

    bool m_isOk;
    wxMutex& m_mutex;
};
# 219 "/usr/include/wx-2.8/wx/thread.h"
class wxCriticalSection
{
public:

    inline wxCriticalSection();
    inline ~wxCriticalSection();


    inline void Enter();


    inline void Leave();

private:

    wxMutex m_mutex;
# 263 "/usr/include/wx-2.8/wx/thread.h"
    private: wxCriticalSection(const wxCriticalSection&); wxCriticalSection& operator=(const wxCriticalSection&);
};



    inline wxCriticalSection::wxCriticalSection() { }
    inline wxCriticalSection::~wxCriticalSection() { }

    inline void wxCriticalSection::Enter() { (void)m_mutex.Lock(); }
    inline void wxCriticalSection::Leave() { (void)m_mutex.Unlock(); }







class wxCriticalSectionLocker
{
public:
    wxCriticalSectionLocker(wxCriticalSection& cs)
        : m_critsect(cs)
    {
        m_critsect.Enter();
    }

    ~wxCriticalSectionLocker()
    {
        m_critsect.Leave();
    }

private:
    wxCriticalSection& m_critsect;

    private: wxCriticalSectionLocker(const wxCriticalSectionLocker&); wxCriticalSectionLocker& operator=(const wxCriticalSectionLocker&);
};






class wxCondition
{
public:


    wxCondition(wxMutex& mutex);


    ~wxCondition();


    bool IsOk() const;







    wxCondError Wait();
# 333 "/usr/include/wx-2.8/wx/thread.h"
    wxCondError WaitTimeout(unsigned long milliseconds);







    wxCondError Signal();







    wxCondError Broadcast();




    bool Wait(unsigned long milliseconds) __attribute__ ((deprecated));


private:
    wxConditionInternal *m_internal;

    private: wxCondition(const wxCondition&); wxCondition& operator=(const wxCondition&);
};


    inline bool wxCondition::Wait(unsigned long milliseconds)
        { return WaitTimeout(milliseconds) == wxCOND_NO_ERROR; }







class wxSemaphore
{
public:


    wxSemaphore( int initialcount = 0, int maxcount = 0 );


    ~wxSemaphore();


    bool IsOk() const;




    wxSemaError Wait();



    wxSemaError TryWait();



    wxSemaError WaitTimeout(unsigned long milliseconds);


    wxSemaError Post();

private:
    wxSemaphoreInternal *m_internal;

    private: wxSemaphore(const wxSemaphore&); wxSemaphore& operator=(const wxSemaphore&);
};
# 425 "/usr/include/wx-2.8/wx/thread.h"
   typedef unsigned long wxThreadIdType;


class wxThread
{
public:

    typedef void *ExitCode;







    static wxThread *This();


    static bool IsMain();


    static void Yield();




    static void Sleep(unsigned long milliseconds);





    static int GetCPUCount();




   static wxThreadIdType GetCurrentId();
# 471 "/usr/include/wx-2.8/wx/thread.h"
    static bool SetConcurrency(size_t level);



    wxThread(wxThreadKind kind = wxTHREAD_DETACHED);
# 485 "/usr/include/wx-2.8/wx/thread.h"
    wxThreadError Create(unsigned int stackSize = 0);




    wxThreadError Run();
# 502 "/usr/include/wx-2.8/wx/thread.h"
    wxThreadError Delete(ExitCode *rc = (ExitCode *)__null);





    ExitCode Wait();
# 518 "/usr/include/wx-2.8/wx/thread.h"
    wxThreadError Kill();



    wxThreadError Pause();


    wxThreadError Resume();





    void SetPriority(unsigned int prio);


    unsigned int GetPriority() const;



    bool IsAlive() const;

    bool IsRunning() const;

    bool IsPaused() const;


    bool IsDetached() const { return m_isDetached; }



    wxThreadIdType GetId() const;




    virtual void OnExit() { }




    virtual bool TestDestroy();



    virtual ~wxThread();

protected:

    void Exit(ExitCode exitcode = 0);



    virtual void *Entry() = 0;

private:

    wxThread(const wxThread&);
    wxThread& operator=(const wxThread&);

    friend class wxThreadInternal;


    wxThreadInternal *m_internal;


    wxCriticalSection m_critsect;


    bool m_isDetached;
};




class wxThreadHelperThread : public wxThread
{
public:


    wxThreadHelperThread(wxThreadHelper& owner)
        : wxThread(wxTHREAD_JOINABLE), m_owner(owner)
        { }

protected:

    virtual void *Entry();

private:

    wxThreadHelper& m_owner;


    wxThreadHelperThread(const wxThreadHelperThread&);
    wxThreadHelperThread& operator=(const wxThreadHelperThread&);
};







class wxThreadHelper
{
private:
    void KillThread()
    {
        if ( m_thread )
        {
            m_thread->Kill();
            delete m_thread;
        }
    }

public:

    wxThreadHelper() : m_thread(__null) { }


    virtual ~wxThreadHelper() { KillThread(); }



    wxThreadError Create(unsigned int stackSize = 0)
    {
        KillThread();

        m_thread = new wxThreadHelperThread(*this);

        return m_thread->Create(stackSize);
    }



    virtual void *Entry() = 0;


    wxThread *GetThread() const { return m_thread; }

protected:
    wxThread *m_thread;
};


inline void *wxThreadHelperThread::Entry()
{
    return m_owner.Entry();
}






void wxMutexGuiEnter();
void wxMutexGuiLeave();
# 686 "/usr/include/wx-2.8/wx/thread.h"
inline bool wxIsMainThread() { return wxThread::IsMain(); }
# 730 "/usr/include/wx-2.8/wx/thread.h"
class wxMutexGuiLocker
{
public:
    wxMutexGuiLocker() { wxMutexGuiEnter(); }
   ~wxMutexGuiLocker() { wxMutexGuiLeave(); }
};
# 26 "/usr/include/wx-2.8/wx/event.h" 2







class wxList;


    class wxDC;
    class wxMenu;
    class wxWindow;
    class wxWindowBase;


class wxEvtHandler;





typedef int wxEventType;
# 110 "/usr/include/wx-2.8/wx/event.h"
extern wxEventType wxNewEventType();




# 123 "/usr/include/wx-2.8/wx/event.h"
    extern const wxEventType wxEVT_NULL;
    extern const wxEventType wxEVT_FIRST;
    extern const wxEventType wxEVT_USER_FIRST;


    extern const wxEventType wxEVT_COMMAND_BUTTON_CLICKED;
    extern const wxEventType wxEVT_COMMAND_CHECKBOX_CLICKED;
    extern const wxEventType wxEVT_COMMAND_CHOICE_SELECTED;
    extern const wxEventType wxEVT_COMMAND_LISTBOX_SELECTED;
    extern const wxEventType wxEVT_COMMAND_LISTBOX_DOUBLECLICKED;
    extern const wxEventType wxEVT_COMMAND_CHECKLISTBOX_TOGGLED;







    extern const wxEventType wxEVT_COMMAND_MENU_SELECTED;
    extern const wxEventType wxEVT_COMMAND_SLIDER_UPDATED;
    extern const wxEventType wxEVT_COMMAND_RADIOBOX_SELECTED;
    extern const wxEventType wxEVT_COMMAND_RADIOBUTTON_SELECTED;




    extern const wxEventType wxEVT_COMMAND_SCROLLBAR_UPDATED;
    extern const wxEventType wxEVT_COMMAND_VLBOX_SELECTED;
    extern const wxEventType wxEVT_COMMAND_COMBOBOX_SELECTED;
    extern const wxEventType wxEVT_COMMAND_TOOL_RCLICKED;
    extern const wxEventType wxEVT_COMMAND_TOOL_ENTER;
    extern const wxEventType wxEVT_COMMAND_SPINCTRL_UPDATED;


    extern const wxEventType wxEVT_SOCKET;
    extern const wxEventType wxEVT_TIMER;


    extern const wxEventType wxEVT_LEFT_DOWN;
    extern const wxEventType wxEVT_LEFT_UP;
    extern const wxEventType wxEVT_MIDDLE_DOWN;
    extern const wxEventType wxEVT_MIDDLE_UP;
    extern const wxEventType wxEVT_RIGHT_DOWN;
    extern const wxEventType wxEVT_RIGHT_UP;
    extern const wxEventType wxEVT_MOTION;
    extern const wxEventType wxEVT_ENTER_WINDOW;
    extern const wxEventType wxEVT_LEAVE_WINDOW;
    extern const wxEventType wxEVT_LEFT_DCLICK;
    extern const wxEventType wxEVT_MIDDLE_DCLICK;
    extern const wxEventType wxEVT_RIGHT_DCLICK;
    extern const wxEventType wxEVT_SET_FOCUS;
    extern const wxEventType wxEVT_KILL_FOCUS;
    extern const wxEventType wxEVT_CHILD_FOCUS;
    extern const wxEventType wxEVT_MOUSEWHEEL;


    extern const wxEventType wxEVT_NC_LEFT_DOWN;
    extern const wxEventType wxEVT_NC_LEFT_UP;
    extern const wxEventType wxEVT_NC_MIDDLE_DOWN;
    extern const wxEventType wxEVT_NC_MIDDLE_UP;
    extern const wxEventType wxEVT_NC_RIGHT_DOWN;
    extern const wxEventType wxEVT_NC_RIGHT_UP;
    extern const wxEventType wxEVT_NC_MOTION;
    extern const wxEventType wxEVT_NC_ENTER_WINDOW;
    extern const wxEventType wxEVT_NC_LEAVE_WINDOW;
    extern const wxEventType wxEVT_NC_LEFT_DCLICK;
    extern const wxEventType wxEVT_NC_MIDDLE_DCLICK;
    extern const wxEventType wxEVT_NC_RIGHT_DCLICK;


    extern const wxEventType wxEVT_CHAR;
    extern const wxEventType wxEVT_CHAR_HOOK;
    extern const wxEventType wxEVT_NAVIGATION_KEY;
    extern const wxEventType wxEVT_KEY_DOWN;
    extern const wxEventType wxEVT_KEY_UP;




    extern const wxEventType wxEVT_SET_CURSOR;


    extern const wxEventType wxEVT_SCROLL_TOP;
    extern const wxEventType wxEVT_SCROLL_BOTTOM;
    extern const wxEventType wxEVT_SCROLL_LINEUP;
    extern const wxEventType wxEVT_SCROLL_LINEDOWN;
    extern const wxEventType wxEVT_SCROLL_PAGEUP;
    extern const wxEventType wxEVT_SCROLL_PAGEDOWN;
    extern const wxEventType wxEVT_SCROLL_THUMBTRACK;
    extern const wxEventType wxEVT_SCROLL_THUMBRELEASE;
    extern const wxEventType wxEVT_SCROLL_CHANGED;


    extern const wxEventType wxEVT_SCROLLWIN_TOP;
    extern const wxEventType wxEVT_SCROLLWIN_BOTTOM;
    extern const wxEventType wxEVT_SCROLLWIN_LINEUP;
    extern const wxEventType wxEVT_SCROLLWIN_LINEDOWN;
    extern const wxEventType wxEVT_SCROLLWIN_PAGEUP;
    extern const wxEventType wxEVT_SCROLLWIN_PAGEDOWN;
    extern const wxEventType wxEVT_SCROLLWIN_THUMBTRACK;
    extern const wxEventType wxEVT_SCROLLWIN_THUMBRELEASE;


    extern const wxEventType wxEVT_SIZE;
    extern const wxEventType wxEVT_MOVE;
    extern const wxEventType wxEVT_CLOSE_WINDOW;
    extern const wxEventType wxEVT_END_SESSION;
    extern const wxEventType wxEVT_QUERY_END_SESSION;
    extern const wxEventType wxEVT_ACTIVATE_APP;

    extern const wxEventType wxEVT_ACTIVATE;
    extern const wxEventType wxEVT_CREATE;
    extern const wxEventType wxEVT_DESTROY;
    extern const wxEventType wxEVT_SHOW;
    extern const wxEventType wxEVT_ICONIZE;
    extern const wxEventType wxEVT_MAXIMIZE;
    extern const wxEventType wxEVT_MOUSE_CAPTURE_CHANGED;
    extern const wxEventType wxEVT_MOUSE_CAPTURE_LOST;
    extern const wxEventType wxEVT_PAINT;
    extern const wxEventType wxEVT_ERASE_BACKGROUND;
    extern const wxEventType wxEVT_NC_PAINT;
    extern const wxEventType wxEVT_PAINT_ICON;
    extern const wxEventType wxEVT_MENU_OPEN;
    extern const wxEventType wxEVT_MENU_CLOSE;
    extern const wxEventType wxEVT_MENU_HIGHLIGHT;
    extern const wxEventType wxEVT_CONTEXT_MENU;
    extern const wxEventType wxEVT_SYS_COLOUR_CHANGED;
    extern const wxEventType wxEVT_DISPLAY_CHANGED;
    extern const wxEventType wxEVT_SETTING_CHANGED;
    extern const wxEventType wxEVT_QUERY_NEW_PALETTE;
    extern const wxEventType wxEVT_PALETTE_CHANGED;
    extern const wxEventType wxEVT_JOY_BUTTON_DOWN;
    extern const wxEventType wxEVT_JOY_BUTTON_UP;
    extern const wxEventType wxEVT_JOY_MOVE;
    extern const wxEventType wxEVT_JOY_ZMOVE;
    extern const wxEventType wxEVT_DROP_FILES;
    extern const wxEventType wxEVT_DRAW_ITEM;
    extern const wxEventType wxEVT_MEASURE_ITEM;
    extern const wxEventType wxEVT_COMPARE_ITEM;
    extern const wxEventType wxEVT_INIT_DIALOG;
    extern const wxEventType wxEVT_IDLE;
    extern const wxEventType wxEVT_UPDATE_UI;
    extern const wxEventType wxEVT_SIZING;
    extern const wxEventType wxEVT_MOVING;
    extern const wxEventType wxEVT_HIBERNATE;



    extern const wxEventType wxEVT_COMMAND_TEXT_COPY;
    extern const wxEventType wxEVT_COMMAND_TEXT_CUT;
    extern const wxEventType wxEVT_COMMAND_TEXT_PASTE;



    extern const wxEventType wxEVT_COMMAND_LEFT_CLICK;
    extern const wxEventType wxEVT_COMMAND_LEFT_DCLICK;
    extern const wxEventType wxEVT_COMMAND_RIGHT_CLICK;
    extern const wxEventType wxEVT_COMMAND_RIGHT_DCLICK;
    extern const wxEventType wxEVT_COMMAND_SET_FOCUS;
    extern const wxEventType wxEVT_COMMAND_KILL_FOCUS;
    extern const wxEventType wxEVT_COMMAND_ENTER;


    extern const wxEventType wxEVT_HELP;
    extern const wxEventType wxEVT_DETAILED_HELP;


# 303 "/usr/include/wx-2.8/wx/event.h"
    extern const wxEventType wxEVT_COMMAND_TEXT_UPDATED;




enum Propagation_state
{

    wxEVENT_PROPAGATE_NONE = 0,


    wxEVENT_PROPAGATE_MAX = 2147483647
};
# 329 "/usr/include/wx-2.8/wx/event.h"
class wxEvent : public wxObject
{
private:
    wxEvent& operator=(const wxEvent&);

protected:
    wxEvent(const wxEvent&);

public:
    wxEvent(int winid = 0, wxEventType commandType = wxEVT_NULL );

    void SetEventType(wxEventType typ) { m_eventType = typ; }
    wxEventType GetEventType() const { return m_eventType; }
    wxObject *GetEventObject() const { return m_eventObject; }
    void SetEventObject(wxObject *obj) { m_eventObject = obj; }
    long GetTimestamp() const { return m_timeStamp; }
    void SetTimestamp(long ts = 0) { m_timeStamp = ts; }
    int GetId() const { return m_id; }
    void SetId(int Id) { m_id = Id; }





    void Skip(bool skip = true) { m_skipped = skip; }
    bool GetSkipped() const { return m_skipped; }




    virtual wxEvent *Clone() const = 0;



    bool IsCommandEvent() const { return m_isCommandEvent; }


    bool ShouldPropagate() const
        { return m_propagationLevel != wxEVENT_PROPAGATE_NONE; }



    int StopPropagation()
    {
        int propagationLevel = m_propagationLevel;
        m_propagationLevel = wxEVENT_PROPAGATE_NONE;
        return propagationLevel;
    }



    void ResumePropagation(int propagationLevel)
    {
        m_propagationLevel = propagationLevel;
    }




protected:

    wxObject* m_eventObject;
    wxEventType m_eventType;
    long m_timeStamp;
    int m_id;

public:

    wxObject* m_callbackUserData;

protected:





    int m_propagationLevel;




protected:

    bool m_skipped;
    bool m_isCommandEvent;

private:

    friend class wxPropagateOnce;

    public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const;
};




class wxPropagationDisabler
{
public:
    wxPropagationDisabler(wxEvent& event) : m_event(event)
    {
        m_propagationLevelOld = m_event.StopPropagation();
    }

    ~wxPropagationDisabler()
    {
        m_event.ResumePropagation(m_propagationLevelOld);
    }

private:
    wxEvent& m_event;
    int m_propagationLevelOld;

    private: wxPropagationDisabler(const wxPropagationDisabler&); wxPropagationDisabler& operator=(const wxPropagationDisabler&);
};




class wxPropagateOnce
{
public:
    wxPropagateOnce(wxEvent& event) : m_event(event)
    {
        ;


        m_event.m_propagationLevel--;
    }

    ~wxPropagateOnce()
    {
        m_event.m_propagationLevel++;
    }

private:
    wxEvent& m_event;

    private: wxPropagateOnce(const wxPropagateOnce&); wxPropagateOnce& operator=(const wxPropagateOnce&);
};
# 512 "/usr/include/wx-2.8/wx/event.h"
class wxCommandEvent : public wxEvent
{
public:
    wxCommandEvent(wxEventType commandType = wxEVT_NULL, int winid = 0);

    wxCommandEvent(const wxCommandEvent& event)
        : wxEvent(event),



          m_cmdString(event.m_cmdString),
          m_commandInt(event.m_commandInt),
          m_extraLong(event.m_extraLong),
          m_clientData(event.m_clientData),
          m_clientObject(event.m_clientObject)
        { }


    void SetClientData(void* clientData) { m_clientData = clientData; }
    void *GetClientData() const { return m_clientData; }


    void SetClientObject(wxClientData* clientObject) { m_clientObject = clientObject; }
    wxClientData *GetClientObject() const { return m_clientObject; }


    int GetSelection() const { return m_commandInt; }


    void SetString(const wxString& s) { m_cmdString = s; }
    wxString GetString() const;


    bool IsChecked() const { return m_commandInt != 0; }


    bool IsSelection() const { return (m_extraLong != 0); }

    void SetExtraLong(long extraLong) { m_extraLong = extraLong; }
    long GetExtraLong() const { return m_extraLong; }

    void SetInt(int i) { m_commandInt = i; }
    int GetInt() const { return m_commandInt; }

    virtual wxEvent *Clone() const { return new wxCommandEvent(*this); }





protected:

    wxString m_cmdString;
    int m_commandInt;
    long m_extraLong;
    void* m_clientData;
    wxClientData* m_clientObject;

private:
    private: wxCommandEvent& operator=(const wxCommandEvent&); public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};
# 593 "/usr/include/wx-2.8/wx/event.h"
class wxNotifyEvent : public wxCommandEvent
{
public:
    wxNotifyEvent(wxEventType commandType = wxEVT_NULL, int winid = 0)
        : wxCommandEvent(commandType, winid)
        { m_bAllow = true; }

    wxNotifyEvent(const wxNotifyEvent& event)
        : wxCommandEvent(event)
        { m_bAllow = event.m_bAllow; }


    void Veto() { m_bAllow = false; }


    void Allow() { m_bAllow = true; }


    bool IsAllowed() const { return m_bAllow; }

    virtual wxEvent *Clone() const { return new wxNotifyEvent(*this); }

private:
    bool m_bAllow;

private:
    private: wxNotifyEvent& operator=(const wxNotifyEvent&); public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};
# 636 "/usr/include/wx-2.8/wx/event.h"
class wxScrollEvent : public wxCommandEvent
{
public:
    wxScrollEvent(wxEventType commandType = wxEVT_NULL,
                  int winid = 0, int pos = 0, int orient = 0);

    int GetOrientation() const { return (int) m_extraLong; }
    int GetPosition() const { return m_commandInt; }
    void SetOrientation(int orient) { m_extraLong = (long) orient; }
    void SetPosition(int pos) { m_commandInt = pos; }

    virtual wxEvent *Clone() const { return new wxScrollEvent(*this); }

private:
    private: wxScrollEvent& operator=(const wxScrollEvent&); public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};
# 666 "/usr/include/wx-2.8/wx/event.h"
class wxScrollWinEvent : public wxEvent
{
public:
    wxScrollWinEvent(wxEventType commandType = wxEVT_NULL,
                     int pos = 0, int orient = 0);
    wxScrollWinEvent(const wxScrollWinEvent & event) : wxEvent(event)
        { m_commandInt = event.m_commandInt;
            m_extraLong = event.m_extraLong; }

    int GetOrientation() const { return (int) m_extraLong; }
    int GetPosition() const { return m_commandInt; }
    void SetOrientation(int orient) { m_extraLong = (long) orient; }
    void SetPosition(int pos) { m_commandInt = pos; }

    virtual wxEvent *Clone() const { return new wxScrollWinEvent(*this); }




protected:

    int m_commandInt;
    long m_extraLong;

private:
    private: wxScrollWinEvent& operator=(const wxScrollWinEvent&); public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};
# 724 "/usr/include/wx-2.8/wx/event.h"
enum
{
    wxMOUSE_BTN_ANY = -1,
    wxMOUSE_BTN_NONE = 0,
    wxMOUSE_BTN_LEFT = 1,
    wxMOUSE_BTN_MIDDLE = 2,
    wxMOUSE_BTN_RIGHT = 3
};

class wxMouseEvent : public wxEvent
{
public:
    wxMouseEvent(wxEventType mouseType = wxEVT_NULL);
    wxMouseEvent(const wxMouseEvent& event) : wxEvent(event)
        { Assign(event); }


    bool IsButton() const { return Button(wxMOUSE_BTN_ANY); }


    bool ButtonDown(int but = wxMOUSE_BTN_ANY) const;


    bool ButtonDClick(int but = wxMOUSE_BTN_ANY) const;


    bool ButtonUp(int but = wxMOUSE_BTN_ANY) const;


    bool Button(int but) const;


    bool ButtonIsDown(int but) const;


    int GetButton() const;


    bool ControlDown() const { return m_controlDown; }
    bool MetaDown() const { return m_metaDown; }
    bool AltDown() const { return m_altDown; }
    bool ShiftDown() const { return m_shiftDown; }
    bool CmdDown() const
    {



        return ControlDown();

    }


    bool LeftDown() const { return (m_eventType == wxEVT_LEFT_DOWN); }
    bool MiddleDown() const { return (m_eventType == wxEVT_MIDDLE_DOWN); }
    bool RightDown() const { return (m_eventType == wxEVT_RIGHT_DOWN); }

    bool LeftUp() const { return (m_eventType == wxEVT_LEFT_UP); }
    bool MiddleUp() const { return (m_eventType == wxEVT_MIDDLE_UP); }
    bool RightUp() const { return (m_eventType == wxEVT_RIGHT_UP); }

    bool LeftDClick() const { return (m_eventType == wxEVT_LEFT_DCLICK); }
    bool MiddleDClick() const { return (m_eventType == wxEVT_MIDDLE_DCLICK); }
    bool RightDClick() const { return (m_eventType == wxEVT_RIGHT_DCLICK); }



    bool LeftIsDown() const { return m_leftDown; }
    bool MiddleIsDown() const { return m_middleDown; }
    bool RightIsDown() const { return m_rightDown; }


    bool Dragging() const
    {
        return (m_eventType == wxEVT_MOTION) && ButtonIsDown(wxMOUSE_BTN_ANY);
    }


    bool Moving() const
    {
        return (m_eventType == wxEVT_MOTION) && !ButtonIsDown(wxMOUSE_BTN_ANY);
    }


    bool Entering() const { return (m_eventType == wxEVT_ENTER_WINDOW); }


    bool Leaving() const { return (m_eventType == wxEVT_LEAVE_WINDOW); }


    void GetPosition(wxCoord *xpos, wxCoord *ypos) const
    {
        if (xpos)
            *xpos = m_x;
        if (ypos)
            *ypos = m_y;
    }

    void GetPosition(long *xpos, long *ypos) const
    {
        if (xpos)
            *xpos = (long)m_x;
        if (ypos)
            *ypos = (long)m_y;
    }


    wxPoint GetPosition() const { return wxPoint(m_x, m_y); }


    wxPoint GetLogicalPosition(const wxDC& dc) const;


    wxCoord GetX() const { return m_x; }


    wxCoord GetY() const { return m_y; }
# 848 "/usr/include/wx-2.8/wx/event.h"
    int GetWheelRotation() const { return m_wheelRotation; }




    int GetWheelDelta() const { return m_wheelDelta; }



    int GetLinesPerAction() const { return m_linesPerAction; }


    bool IsPageScroll() const { return ((unsigned int)m_linesPerAction == (2147483647 * 2U + 1U)); }

    virtual wxEvent *Clone() const { return new wxMouseEvent(*this); }

    wxMouseEvent& operator=(const wxMouseEvent& event) { Assign(event); return *this; }

public:
    wxCoord m_x, m_y;

    bool m_leftDown;
    bool m_middleDown;
    bool m_rightDown;

    bool m_controlDown;
    bool m_shiftDown;
    bool m_altDown;
    bool m_metaDown;

    int m_wheelRotation;
    int m_wheelDelta;
    int m_linesPerAction;

protected:
    void Assign(const wxMouseEvent& evt);

private:
    public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};







class wxSetCursorEvent : public wxEvent
{
public:
    wxSetCursorEvent(wxCoord x = 0, wxCoord y = 0)
        : wxEvent(0, wxEVT_SET_CURSOR),
          m_x(x), m_y(y), m_cursor()
        { }

    wxSetCursorEvent(const wxSetCursorEvent & event)
        : wxEvent(event),
          m_x(event.m_x),
          m_y(event.m_y),
          m_cursor(event.m_cursor)
        { }

    wxCoord GetX() const { return m_x; }
    wxCoord GetY() const { return m_y; }

    void SetCursor(const wxCursor& cursor) { m_cursor = cursor; }
    const wxCursor& GetCursor() const { return m_cursor; }
    bool HasCursor() const { return m_cursor.Ok(); }

    virtual wxEvent *Clone() const { return new wxSetCursorEvent(*this); }

private:
    wxCoord m_x, m_y;
    wxCursor m_cursor;

private:
    private: wxSetCursorEvent& operator=(const wxSetCursorEvent&); public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};
# 937 "/usr/include/wx-2.8/wx/event.h"
class wxKeyEvent : public wxEvent
{
public:
    wxKeyEvent(wxEventType keyType = wxEVT_NULL);
    wxKeyEvent(const wxKeyEvent& evt);




    int GetModifiers() const
    {
        return (m_controlDown ? wxMOD_CONTROL : 0) |
               (m_shiftDown ? wxMOD_SHIFT : 0) |
               (m_metaDown ? wxMOD_META : 0) |
               (m_altDown ? wxMOD_ALT : 0);
    }


    bool ControlDown() const { return m_controlDown; }
    bool ShiftDown() const { return m_shiftDown; }
    bool MetaDown() const { return m_metaDown; }
    bool AltDown() const { return m_altDown; }






    bool CmdDown() const
    {



        return ControlDown();

    }




    bool HasModifiers() const { return ControlDown() || AltDown(); }


    int GetKeyCode() const { return (int)m_keyCode; }



    wxChar GetUnicodeKey() const { return m_uniChar; }



    wxUint32 GetRawKeyCode() const { return m_rawCode; }


    wxUint32 GetRawKeyFlags() const { return m_rawFlags; }


    void GetPosition(wxCoord *xpos, wxCoord *ypos) const
    {
        if (xpos) *xpos = m_x;
        if (ypos) *ypos = m_y;
    }

    void GetPosition(long *xpos, long *ypos) const
    {
        if (xpos) *xpos = (long)m_x;
        if (ypos) *ypos = (long)m_y;
    }

    wxPoint GetPosition() const
        { return wxPoint(m_x, m_y); }


    wxCoord GetX() const { return m_x; }


    wxCoord GetY() const { return m_y; }



    long KeyCode() const __attribute__ ((deprecated));


    virtual wxEvent *Clone() const { return new wxKeyEvent(*this); }



    wxKeyEvent& operator=(const wxKeyEvent& evt)
    {
        m_x = evt.m_x;
        m_y = evt.m_y;

        m_keyCode = evt.m_keyCode;

        m_controlDown = evt.m_controlDown;
        m_shiftDown = evt.m_shiftDown;
        m_altDown = evt.m_altDown;
        m_metaDown = evt.m_metaDown;
        m_scanCode = evt.m_scanCode;
        m_rawCode = evt.m_rawCode;
        m_rawFlags = evt.m_rawFlags;

        m_uniChar = evt.m_uniChar;


        return *this;
    }

public:
    wxCoord m_x, m_y;

    long m_keyCode;


    bool m_controlDown;
    bool m_shiftDown;
    bool m_altDown;
    bool m_metaDown;


    bool m_scanCode;




    wxChar m_uniChar;




    wxUint32 m_rawCode;
    wxUint32 m_rawFlags;

private:
    public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};






class wxSizeEvent : public wxEvent
{
public:
    wxSizeEvent() : wxEvent(0, wxEVT_SIZE)
        { }
    wxSizeEvent(const wxSize& sz, int winid = 0)
        : wxEvent(winid, wxEVT_SIZE),
          m_size(sz)
        { }
    wxSizeEvent(const wxSizeEvent & event)
        : wxEvent(event),
          m_size(event.m_size), m_rect(event.m_rect)
        { }
    wxSizeEvent(const wxRect& rect, int id = 0)
        : m_size(rect.GetSize()), m_rect(rect)
        { m_eventType = wxEVT_SIZING; m_id = id; }

    wxSize GetSize() const { return m_size; }
    wxRect GetRect() const { return m_rect; }
    void SetRect(const wxRect& rect) { m_rect = rect; }

    virtual wxEvent *Clone() const { return new wxSizeEvent(*this); }

public:

    wxSize m_size;
    wxRect m_rect;

private:
    private: wxSizeEvent& operator=(const wxSizeEvent&); public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};







class wxMoveEvent : public wxEvent
{
public:
    wxMoveEvent()
        : wxEvent(0, wxEVT_MOVE)
        { }
    wxMoveEvent(const wxPoint& pos, int winid = 0)
        : wxEvent(winid, wxEVT_MOVE),
          m_pos(pos)
        { }
    wxMoveEvent(const wxMoveEvent& event)
        : wxEvent(event),
          m_pos(event.m_pos)
    { }
    wxMoveEvent(const wxRect& rect, int id = 0)
        : m_pos(rect.GetPosition()), m_rect(rect)
        { m_eventType = wxEVT_MOVING; m_id = id; }

    wxPoint GetPosition() const { return m_pos; }
    void SetPosition(const wxPoint& pos) { m_pos = pos; }
    wxRect GetRect() const { return m_rect; }
    void SetRect(const wxRect& rect) { m_rect = rect; }

    virtual wxEvent *Clone() const { return new wxMoveEvent(*this); }




protected:

    wxPoint m_pos;
    wxRect m_rect;

private:
    private: wxMoveEvent& operator=(const wxMoveEvent&); public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};
# 1166 "/usr/include/wx-2.8/wx/event.h"
class wxPaintEvent : public wxEvent
{
public:
    wxPaintEvent(int Id = 0)
        : wxEvent(Id, wxEVT_PAINT)
    {




    }
# 1193 "/usr/include/wx-2.8/wx/event.h"
    virtual wxEvent *Clone() const { return new wxPaintEvent(*this); }

private:
    private: wxPaintEvent& operator=(const wxPaintEvent&); public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};

class wxNcPaintEvent : public wxEvent
{
public:
    wxNcPaintEvent(int winid = 0)
        : wxEvent(winid, wxEVT_NC_PAINT)
        { }

    virtual wxEvent *Clone() const { return new wxNcPaintEvent(*this); }

private:
    private: wxNcPaintEvent& operator=(const wxNcPaintEvent&); public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};






class wxEraseEvent : public wxEvent
{
public:
    wxEraseEvent(int Id = 0, wxDC *dc = (wxDC *) __null)
        : wxEvent(Id, wxEVT_ERASE_BACKGROUND),
          m_dc(dc)
        { }

    wxEraseEvent(const wxEraseEvent& event)
        : wxEvent(event),
          m_dc(event.m_dc)
        { }

    wxDC *GetDC() const { return m_dc; }

    virtual wxEvent *Clone() const { return new wxEraseEvent(*this); }




protected:

    wxDC *m_dc;

private:
    private: wxEraseEvent& operator=(const wxEraseEvent&); public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};







class wxFocusEvent : public wxEvent
{
public:
    wxFocusEvent(wxEventType type = wxEVT_NULL, int winid = 0)
        : wxEvent(winid, type)
        { m_win = __null; }

    wxFocusEvent(const wxFocusEvent& event)
        : wxEvent(event)
        { m_win = event.m_win; }




    wxWindow *GetWindow() const { return m_win; }
    void SetWindow(wxWindow *win) { m_win = win; }

    virtual wxEvent *Clone() const { return new wxFocusEvent(*this); }

private:
    wxWindow *m_win;

private:
    private: wxFocusEvent& operator=(const wxFocusEvent&); public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};



class wxChildFocusEvent : public wxCommandEvent
{
public:
    wxChildFocusEvent(wxWindow *win = __null);

    wxWindow *GetWindow() const { return (wxWindow *)GetEventObject(); }

    virtual wxEvent *Clone() const { return new wxChildFocusEvent(*this); }

private:
    private: wxChildFocusEvent& operator=(const wxChildFocusEvent&); public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};
# 1299 "/usr/include/wx-2.8/wx/event.h"
class wxActivateEvent : public wxEvent
{
public:
    wxActivateEvent(wxEventType type = wxEVT_NULL, bool active = true, int Id = 0)
        : wxEvent(Id, type)
        { m_active = active; }
    wxActivateEvent(const wxActivateEvent& event)
        : wxEvent(event)
    { m_active = event.m_active; }

    bool GetActive() const { return m_active; }

    virtual wxEvent *Clone() const { return new wxActivateEvent(*this); }

private:
    bool m_active;

private:
    private: wxActivateEvent& operator=(const wxActivateEvent&); public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};






class wxInitDialogEvent : public wxEvent
{
public:
    wxInitDialogEvent(int Id = 0)
        : wxEvent(Id, wxEVT_INIT_DIALOG)
        { }

    virtual wxEvent *Clone() const { return new wxInitDialogEvent(*this); }

private:
    private: wxInitDialogEvent& operator=(const wxInitDialogEvent&); public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};
# 1345 "/usr/include/wx-2.8/wx/event.h"
class wxMenuEvent : public wxEvent
{
public:
    wxMenuEvent(wxEventType type = wxEVT_NULL, int winid = 0, wxMenu* menu = __null)
        : wxEvent(winid, type)
        { m_menuId = winid; m_menu = menu; }
    wxMenuEvent(const wxMenuEvent & event)
        : wxEvent(event)
    { m_menuId = event.m_menuId; m_menu = event.m_menu; }


    int GetMenuId() const { return m_menuId; }


    bool IsPopup() const { return m_menuId == wxID_ANY; }


    wxMenu* GetMenu() const { return m_menu; }

    virtual wxEvent *Clone() const { return new wxMenuEvent(*this); }

private:
    int m_menuId;
    wxMenu* m_menu;

    private: wxMenuEvent& operator=(const wxMenuEvent&); public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};
# 1380 "/usr/include/wx-2.8/wx/event.h"
class wxCloseEvent : public wxEvent
{
public:
    wxCloseEvent(wxEventType type = wxEVT_NULL, int winid = 0)
        : wxEvent(winid, type),
          m_loggingOff(true),
          m_veto(false),
          m_canVeto(true) {}

    wxCloseEvent(const wxCloseEvent & event)
        : wxEvent(event),
        m_loggingOff(event.m_loggingOff),
        m_veto(event.m_veto),
        m_canVeto(event.m_canVeto) {}

    void SetLoggingOff(bool logOff) { m_loggingOff = logOff; }
    bool GetLoggingOff() const
    {


        ;


        return m_loggingOff;
    }

    void Veto(bool veto = true)
    {

        if ( m_canVeto ) ; else { ; return; } typedef int wxDummyCheckInt;


        m_veto = veto;
    }
    void SetCanVeto(bool canVeto) { m_canVeto = canVeto; }
    bool CanVeto() const { return m_canVeto; }
    bool GetVeto() const { return m_canVeto && m_veto; }

    virtual wxEvent *Clone() const { return new wxCloseEvent(*this); }

protected:
    bool m_loggingOff,
         m_veto,
         m_canVeto;

private:
    private: wxCloseEvent& operator=(const wxCloseEvent&); public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};





class wxShowEvent : public wxEvent
{
public:
    wxShowEvent(int winid = 0, bool show = false)
        : wxEvent(winid, wxEVT_SHOW)
        { m_show = show; }
    wxShowEvent(const wxShowEvent & event)
        : wxEvent(event)
    { m_show = event.m_show; }

    void SetShow(bool show) { m_show = show; }
    bool GetShow() const { return m_show; }

    bool IsShown() const { return GetShow(); }


    virtual wxEvent *Clone() const { return new wxShowEvent(*this); }

protected:
    bool m_show;

private:
    private: wxShowEvent& operator=(const wxShowEvent&); public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};





class wxIconizeEvent : public wxEvent
{
public:
    wxIconizeEvent(int winid = 0, bool iconized = true)
        : wxEvent(winid, wxEVT_ICONIZE)
        { m_iconized = iconized; }
    wxIconizeEvent(const wxIconizeEvent & event)
        : wxEvent(event)
    { m_iconized = event.m_iconized; }


    bool Iconized() const { return m_iconized; }

    bool IsIconized() const { return Iconized(); }

    virtual wxEvent *Clone() const { return new wxIconizeEvent(*this); }

protected:
    bool m_iconized;

private:
    private: wxIconizeEvent& operator=(const wxIconizeEvent&); public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};




class wxMaximizeEvent : public wxEvent
{
public:
    wxMaximizeEvent(int winid = 0)
        : wxEvent(winid, wxEVT_MAXIMIZE)
        { }

    virtual wxEvent *Clone() const { return new wxMaximizeEvent(*this); }

private:
    private: wxMaximizeEvent& operator=(const wxMaximizeEvent&); public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};
# 1511 "/usr/include/wx-2.8/wx/event.h"
enum
{
    wxJOYSTICK1,
    wxJOYSTICK2
};


enum
{
    wxJOY_BUTTON_ANY = -1,
    wxJOY_BUTTON1 = 1,
    wxJOY_BUTTON2 = 2,
    wxJOY_BUTTON3 = 4,
    wxJOY_BUTTON4 = 8
};

class wxJoystickEvent : public wxEvent
{



protected:

    wxPoint m_pos;
    int m_zPosition;
    int m_buttonChange;
    int m_buttonState;
    int m_joyStick;

public:
    wxJoystickEvent(wxEventType type = wxEVT_NULL,
                    int state = 0,
                    int joystick = wxJOYSTICK1,
                    int change = 0)
        : wxEvent(0, type),
          m_pos(),
          m_zPosition(0),
          m_buttonChange(change),
          m_buttonState(state),
          m_joyStick(joystick)
    {
    }
    wxJoystickEvent(const wxJoystickEvent & event)
        : wxEvent(event),
          m_pos(event.m_pos),
          m_zPosition(event.m_zPosition),
          m_buttonChange(event.m_buttonChange),
          m_buttonState(event.m_buttonState),
          m_joyStick(event.m_joyStick)
    { }

    wxPoint GetPosition() const { return m_pos; }
    int GetZPosition() const { return m_zPosition; }
    int GetButtonState() const { return m_buttonState; }
    int GetButtonChange() const { return m_buttonChange; }
    int GetJoystick() const { return m_joyStick; }

    void SetJoystick(int stick) { m_joyStick = stick; }
    void SetButtonState(int state) { m_buttonState = state; }
    void SetButtonChange(int change) { m_buttonChange = change; }
    void SetPosition(const wxPoint& pos) { m_pos = pos; }
    void SetZPosition(int zPos) { m_zPosition = zPos; }


    bool IsButton() const { return ((GetEventType() == wxEVT_JOY_BUTTON_DOWN) ||
            (GetEventType() == wxEVT_JOY_BUTTON_UP)); }


    bool IsMove() const { return (GetEventType() == wxEVT_JOY_MOVE); }


    bool IsZMove() const { return (GetEventType() == wxEVT_JOY_ZMOVE); }


    bool ButtonDown(int but = wxJOY_BUTTON_ANY) const
    { return ((GetEventType() == wxEVT_JOY_BUTTON_DOWN) &&
            ((but == wxJOY_BUTTON_ANY) || (but == m_buttonChange))); }


    bool ButtonUp(int but = wxJOY_BUTTON_ANY) const
    { return ((GetEventType() == wxEVT_JOY_BUTTON_UP) &&
            ((but == wxJOY_BUTTON_ANY) || (but == m_buttonChange))); }


    bool ButtonIsDown(int but = wxJOY_BUTTON_ANY) const
    { return (((but == wxJOY_BUTTON_ANY) && (m_buttonState != 0)) ||
            ((m_buttonState & but) == but)); }

    virtual wxEvent *Clone() const { return new wxJoystickEvent(*this); }

private:
    private: wxJoystickEvent& operator=(const wxJoystickEvent&); public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};






class wxDropFilesEvent : public wxEvent
{
public:
    int m_noFiles;
    wxPoint m_pos;
    wxString* m_files;

    wxDropFilesEvent(wxEventType type = wxEVT_NULL,
                     int noFiles = 0,
                     wxString *files = (wxString *) __null)
        : wxEvent(0, type),
          m_noFiles(noFiles),
          m_pos(),
          m_files(files)
        { }


    wxDropFilesEvent(const wxDropFilesEvent& other)
        : wxEvent(other),
          m_noFiles(other.m_noFiles),
          m_pos(other.m_pos),
          m_files(__null)
    {
        m_files = new wxString[m_noFiles];
        for ( int n = 0; n < m_noFiles; n++ )
        {
            m_files[n] = other.m_files[n];
        }
    }

    virtual ~wxDropFilesEvent()
    {
        delete [] m_files;
    }

    wxPoint GetPosition() const { return m_pos; }
    int GetNumberOfFiles() const { return m_noFiles; }
    wxString *GetFiles() const { return m_files; }

    virtual wxEvent *Clone() const { return new wxDropFilesEvent(*this); }

private:
    private: wxDropFilesEvent& operator=(const wxDropFilesEvent&); public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};
# 1664 "/usr/include/wx-2.8/wx/event.h"
enum wxUpdateUIMode
{

    wxUPDATE_UI_PROCESS_ALL,



    wxUPDATE_UI_PROCESS_SPECIFIED
};

class wxUpdateUIEvent : public wxCommandEvent
{
public:
    wxUpdateUIEvent(wxWindowID commandId = 0)
        : wxCommandEvent(wxEVT_UPDATE_UI, commandId)
    {
        m_checked =
        m_enabled =
        m_shown =
        m_setEnabled =
        m_setShown =
        m_setText =
        m_setChecked = false;
    }
    wxUpdateUIEvent(const wxUpdateUIEvent & event)
        : wxCommandEvent(event),
          m_checked(event.m_checked),
          m_enabled(event.m_enabled),
          m_shown(event.m_shown),
          m_setEnabled(event.m_setEnabled),
          m_setShown(event.m_setShown),
          m_setText(event.m_setText),
          m_setChecked(event.m_setChecked),
          m_text(event.m_text)
    { }

    bool GetChecked() const { return m_checked; }
    bool GetEnabled() const { return m_enabled; }
    bool GetShown() const { return m_shown; }
    wxString GetText() const { return m_text; }
    bool GetSetText() const { return m_setText; }
    bool GetSetChecked() const { return m_setChecked; }
    bool GetSetEnabled() const { return m_setEnabled; }
    bool GetSetShown() const { return m_setShown; }

    void Check(bool check) { m_checked = check; m_setChecked = true; }
    void Enable(bool enable) { m_enabled = enable; m_setEnabled = true; }
    void Show(bool show) { m_shown = show; m_setShown = true; }
    void SetText(const wxString& text) { m_text = text; m_setText = true; }



    static void SetUpdateInterval(long updateInterval) { sm_updateInterval = updateInterval; }


    static long GetUpdateInterval() { return sm_updateInterval; }


    static bool CanUpdate(wxWindowBase *win);



    static void ResetUpdateTime();




    static void SetMode(wxUpdateUIMode mode) { sm_updateMode = mode; }


    static wxUpdateUIMode GetMode() { return sm_updateMode; }

    virtual wxEvent *Clone() const { return new wxUpdateUIEvent(*this); }

protected:
    bool m_checked;
    bool m_enabled;
    bool m_shown;
    bool m_setEnabled;
    bool m_setShown;
    bool m_setText;
    bool m_setChecked;
    wxString m_text;

    static wxLongLong sm_lastUpdate;

    static long sm_updateInterval;
    static wxUpdateUIMode sm_updateMode;

private:
    private: wxUpdateUIEvent& operator=(const wxUpdateUIEvent&); public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};






class wxSysColourChangedEvent : public wxEvent
{
public:
    wxSysColourChangedEvent()
        : wxEvent(0, wxEVT_SYS_COLOUR_CHANGED)
        { }

    virtual wxEvent *Clone() const { return new wxSysColourChangedEvent(*this); }

private:
    private: wxSysColourChangedEvent& operator=(const wxSysColourChangedEvent&); public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};







class wxMouseCaptureChangedEvent : public wxEvent
{
public:
    wxMouseCaptureChangedEvent(wxWindowID winid = 0, wxWindow* gainedCapture = __null)
        : wxEvent(winid, wxEVT_MOUSE_CAPTURE_CHANGED),
          m_gainedCapture(gainedCapture)
        { }

    wxMouseCaptureChangedEvent(const wxMouseCaptureChangedEvent& event)
        : wxEvent(event),
          m_gainedCapture(event.m_gainedCapture)
        { }

    virtual wxEvent *Clone() const { return new wxMouseCaptureChangedEvent(*this); }

    wxWindow* GetCapturedWindow() const { return m_gainedCapture; }

private:
    wxWindow* m_gainedCapture;

    private: wxMouseCaptureChangedEvent& operator=(const wxMouseCaptureChangedEvent&); public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};
# 1811 "/usr/include/wx-2.8/wx/event.h"
class wxMouseCaptureLostEvent : public wxEvent
{
public:
    wxMouseCaptureLostEvent(wxWindowID winid = 0)
        : wxEvent(winid, wxEVT_MOUSE_CAPTURE_LOST)
    {}

    wxMouseCaptureLostEvent(const wxMouseCaptureLostEvent& event)
        : wxEvent(event)
    {}

    virtual wxEvent *Clone() const { return new wxMouseCaptureLostEvent(*this); }

    private: wxMouseCaptureLostEvent& operator=(const wxMouseCaptureLostEvent&); public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};




class wxDisplayChangedEvent : public wxEvent
{
private:
    private: wxDisplayChangedEvent& operator=(const wxDisplayChangedEvent&); public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();

public:
    wxDisplayChangedEvent()
        : wxEvent(0, wxEVT_DISPLAY_CHANGED)
        { }

    virtual wxEvent *Clone() const { return new wxDisplayChangedEvent(*this); }
};





class wxPaletteChangedEvent : public wxEvent
{
public:
    wxPaletteChangedEvent(wxWindowID winid = 0)
        : wxEvent(winid, wxEVT_PALETTE_CHANGED),
          m_changedWindow((wxWindow *) __null)
        { }

    wxPaletteChangedEvent(const wxPaletteChangedEvent& event)
        : wxEvent(event),
          m_changedWindow(event.m_changedWindow)
        { }

    void SetChangedWindow(wxWindow* win) { m_changedWindow = win; }
    wxWindow* GetChangedWindow() const { return m_changedWindow; }

    virtual wxEvent *Clone() const { return new wxPaletteChangedEvent(*this); }

protected:
    wxWindow* m_changedWindow;

private:
    private: wxPaletteChangedEvent& operator=(const wxPaletteChangedEvent&); public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};






class wxQueryNewPaletteEvent : public wxEvent
{
public:
    wxQueryNewPaletteEvent(wxWindowID winid = 0)
        : wxEvent(winid, wxEVT_QUERY_NEW_PALETTE),
          m_paletteRealized(false)
        { }
    wxQueryNewPaletteEvent(const wxQueryNewPaletteEvent & event)
        : wxEvent(event),
        m_paletteRealized(event.m_paletteRealized)
    { }


    void SetPaletteRealized(bool realized) { m_paletteRealized = realized; }
    bool GetPaletteRealized() const { return m_paletteRealized; }

    virtual wxEvent *Clone() const { return new wxQueryNewPaletteEvent(*this); }

protected:
    bool m_paletteRealized;

private:
    private: wxQueryNewPaletteEvent& operator=(const wxQueryNewPaletteEvent&); public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};






class wxNavigationKeyEvent : public wxEvent
{
public:
    wxNavigationKeyEvent()
        : wxEvent(0, wxEVT_NAVIGATION_KEY),
          m_flags(IsForward | FromTab),
          m_focus((wxWindow *)__null)
        {
            m_propagationLevel = wxEVENT_PROPAGATE_NONE;
        }

    wxNavigationKeyEvent(const wxNavigationKeyEvent& event)
        : wxEvent(event),
          m_flags(event.m_flags),
          m_focus(event.m_focus)
        { }


    bool GetDirection() const
        { return (m_flags & IsForward) != 0; }
    void SetDirection(bool bForward)
        { if ( bForward ) m_flags |= IsForward; else m_flags &= ~IsForward; }



    bool IsWindowChange() const
        { return (m_flags & WinChange) != 0; }
    void SetWindowChange(bool bIs)
        { if ( bIs ) m_flags |= WinChange; else m_flags &= ~WinChange; }



    bool IsFromTab() const
        { return (m_flags & FromTab) != 0; }
    void SetFromTab(bool bIs)
        { if ( bIs ) m_flags |= FromTab; else m_flags &= ~FromTab; }



    wxWindow* GetCurrentFocus() const { return m_focus; }
    void SetCurrentFocus(wxWindow *win) { m_focus = win; }


    void SetFlags(long flags) { m_flags = flags; }

    virtual wxEvent *Clone() const { return new wxNavigationKeyEvent(*this); }

    enum
    {
        IsBackward = 0x0000,
        IsForward = 0x0001,
        WinChange = 0x0002,
        FromTab = 0x0004
    };

    long m_flags;
    wxWindow *m_focus;

private:
    private: wxNavigationKeyEvent& operator=(const wxNavigationKeyEvent&); public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};
# 1979 "/usr/include/wx-2.8/wx/event.h"
class wxWindowCreateEvent : public wxCommandEvent
{
public:
    wxWindowCreateEvent(wxWindow *win = __null);

    wxWindow *GetWindow() const { return (wxWindow *)GetEventObject(); }

    virtual wxEvent *Clone() const { return new wxWindowCreateEvent(*this); }

private:
    private: wxWindowCreateEvent& operator=(const wxWindowCreateEvent&); public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};

class wxWindowDestroyEvent : public wxCommandEvent
{
public:
    wxWindowDestroyEvent(wxWindow *win = __null);

    wxWindow *GetWindow() const { return (wxWindow *)GetEventObject(); }

    virtual wxEvent *Clone() const { return new wxWindowDestroyEvent(*this); }

private:
    private: wxWindowDestroyEvent& operator=(const wxWindowDestroyEvent&); public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};







class wxHelpEvent : public wxCommandEvent
{
public:

    enum Origin
    {
        Origin_Unknown,
        Origin_Keyboard,
        Origin_HelpButton
    };

    wxHelpEvent(wxEventType type = wxEVT_NULL,
                wxWindowID winid = 0,
                const wxPoint& pt = wxDefaultPosition,
                Origin origin = Origin_Unknown)
        : wxCommandEvent(type, winid),
          m_pos(pt),
          m_origin(GuessOrigin(origin))
    { }
    wxHelpEvent(const wxHelpEvent & event)
        : wxCommandEvent(event),
          m_pos(event.m_pos),
          m_target(event.m_target),
          m_link(event.m_link),
          m_origin(event.m_origin)
    { }


    const wxPoint& GetPosition() const { return m_pos; }
    void SetPosition(const wxPoint& pos) { m_pos = pos; }


    const wxString& GetLink() const { return m_link; }
    void SetLink(const wxString& link) { m_link = link; }


    const wxString& GetTarget() const { return m_target; }
    void SetTarget(const wxString& target) { m_target = target; }

    virtual wxEvent *Clone() const { return new wxHelpEvent(*this); }


    Origin GetOrigin() const { return m_origin; }
    void SetOrigin(Origin origin) { m_origin = origin; }

protected:
    wxPoint m_pos;
    wxString m_target;
    wxString m_link;
    Origin m_origin;



    static Origin GuessOrigin(Origin origin);

private:
    private: wxHelpEvent& operator=(const wxHelpEvent&); public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};
# 2081 "/usr/include/wx-2.8/wx/event.h"
class wxClipboardTextEvent : public wxCommandEvent
{
public:
    wxClipboardTextEvent(wxEventType type = wxEVT_NULL,
                     wxWindowID winid = 0)
        : wxCommandEvent(type, winid)
    { }
    wxClipboardTextEvent(const wxClipboardTextEvent & event)
        : wxCommandEvent(event)
    { }

    virtual wxEvent *Clone() const { return new wxClipboardTextEvent(*this); }

private:
    private: wxClipboardTextEvent& operator=(const wxClipboardTextEvent&); public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};
# 2106 "/usr/include/wx-2.8/wx/event.h"
class wxContextMenuEvent : public wxCommandEvent
{
public:
    wxContextMenuEvent(wxEventType type = wxEVT_NULL,
                       wxWindowID winid = 0,
                       const wxPoint& pt = wxDefaultPosition)
        : wxCommandEvent(type, winid),
          m_pos(pt)
    { }
    wxContextMenuEvent(const wxContextMenuEvent & event)
        : wxCommandEvent(event),
        m_pos(event.m_pos)
    { }


    const wxPoint& GetPosition() const { return m_pos; }
    void SetPosition(const wxPoint& pos) { m_pos = pos; }

    virtual wxEvent *Clone() const { return new wxContextMenuEvent(*this); }

protected:
    wxPoint m_pos;

private:
    private: wxContextMenuEvent& operator=(const wxContextMenuEvent&); public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};
# 2142 "/usr/include/wx-2.8/wx/event.h"
enum wxIdleMode
{

    wxIDLE_PROCESS_ALL,



    wxIDLE_PROCESS_SPECIFIED
};

class wxIdleEvent : public wxEvent
{
public:
    wxIdleEvent()
        : wxEvent(0, wxEVT_IDLE),
          m_requestMore(false)
        { }
    wxIdleEvent(const wxIdleEvent & event)
        : wxEvent(event),
          m_requestMore(event.m_requestMore)
    { }

    void RequestMore(bool needMore = true) { m_requestMore = needMore; }
    bool MoreRequested() const { return m_requestMore; }

    virtual wxEvent *Clone() const { return new wxIdleEvent(*this); }




    static void SetMode(wxIdleMode mode) { sm_idleMode = mode; }


    static wxIdleMode GetMode() { return sm_idleMode; }


    static bool CanSend(wxWindow* win);

protected:
    bool m_requestMore;
    static wxIdleMode sm_idleMode;

private:
    private: wxIdleEvent& operator=(const wxIdleEvent&); public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};
# 2208 "/usr/include/wx-2.8/wx/event.h"
typedef void (wxObject::*wxObjectEventFunction)(wxEvent&);
# 2231 "/usr/include/wx-2.8/wx/event.h"
struct wxEventTableEntryBase
{
private:
    wxEventTableEntryBase& operator=(const wxEventTableEntryBase& event);

public:
    wxEventTableEntryBase(int winid, int idLast,
                          wxObjectEventFunction fn, wxObject *data)
        : m_id(winid),
          m_lastId(idLast),
          m_fn(fn),
          m_callbackUserData(data)
    { }

    wxEventTableEntryBase(const wxEventTableEntryBase& event)
        : m_id(event.m_id),
          m_lastId(event.m_lastId),
          m_fn(event.m_fn),
          m_callbackUserData(event.m_callbackUserData)
    { }



    int m_id,
        m_lastId;


    wxObjectEventFunction m_fn;


    wxObject* m_callbackUserData;
};


struct wxEventTableEntry : public wxEventTableEntryBase
{
    wxEventTableEntry(const int& evType, int winid, int idLast,
                      wxObjectEventFunction fn, wxObject *data)
        : wxEventTableEntryBase(winid, idLast, fn, data),
        m_eventType(evType)
    { }







    const int& m_eventType;

private:
    wxEventTableEntry& operator=(const wxEventTableEntry&);
};


struct wxDynamicEventTableEntry : public wxEventTableEntryBase
{
    wxDynamicEventTableEntry(int evType, int winid, int idLast,
                             wxObjectEventFunction fn, wxObject *data, wxEvtHandler* eventSink)
        : wxEventTableEntryBase(winid, idLast, fn, data),
          m_eventType(evType),
          m_eventSink(eventSink)
    { }




    int m_eventType;




    wxEvtHandler* m_eventSink;

    private: wxDynamicEventTableEntry(const wxDynamicEventTableEntry&); wxDynamicEventTableEntry& operator=(const wxDynamicEventTableEntry&);
};







struct wxEventTable
{
    const wxEventTable *baseTable;
    const wxEventTableEntry *entries;
};





typedef const wxEventTableEntry* _wxArraywxEventTableEntryPointerArray; struct wxAssert_wxEventTableEntryPointerArray { unsigned int TypeTooBigToBeStoredInwxBaseArrayPtrVoid: sizeof(_wxArraywxEventTableEntryPointerArray) <= sizeof(wxBaseArrayPtrVoid::base_type); }; typedef int ( *CMPFUNC_wxArraywxEventTableEntryPointerArray)(_wxArraywxEventTableEntryPointerArray *pItem1, _wxArraywxEventTableEntryPointerArray *pItem2); class wxEventTableEntryPointerArray : public wxBaseArrayPtrVoid { public: wxEventTableEntryPointerArray() { } ~wxEventTableEntryPointerArray() { } wxEventTableEntryPointerArray& operator=(const wxEventTableEntryPointerArray& src) { wxBaseArrayPtrVoid* temp = (wxBaseArrayPtrVoid*) this; (*temp) = ((const wxBaseArrayPtrVoid&)src); return *this; } _wxArraywxEventTableEntryPointerArray& operator[](size_t uiIndex) const { return (_wxArraywxEventTableEntryPointerArray&)(wxBaseArrayPtrVoid::operator[](uiIndex)); } _wxArraywxEventTableEntryPointerArray& Item(size_t uiIndex) const { return (_wxArraywxEventTableEntryPointerArray&)(wxBaseArrayPtrVoid::operator[](uiIndex)); } _wxArraywxEventTableEntryPointerArray& Last() const { return (_wxArraywxEventTableEntryPointerArray&)(wxBaseArrayPtrVoid::operator[](Count() - 1)); } int Index(_wxArraywxEventTableEntryPointerArray lItem, bool bFromEnd = false) const { return wxBaseArrayPtrVoid::Index((base_type)lItem, bFromEnd); } void Add(_wxArraywxEventTableEntryPointerArray lItem, size_t nInsert = 1) { wxBaseArrayPtrVoid::Add((base_type)lItem, nInsert); } void Insert(_wxArraywxEventTableEntryPointerArray lItem, size_t uiIndex, size_t nInsert = 1) { wxBaseArrayPtrVoid::Insert((base_type)lItem, uiIndex, nInsert) ; } void RemoveAt(size_t uiIndex, size_t nRemove = 1) { wxBaseArrayPtrVoid::RemoveAt(uiIndex, nRemove); } void Remove(_wxArraywxEventTableEntryPointerArray lItem) { int iIndex = Index(lItem); if ( iIndex != (-1) ) ; else { ; return; } typedef int wxDummyCheckInt; wxBaseArrayPtrVoid::RemoveAt((size_t)iIndex); } void Sort(CMPFUNC_wxArraywxEventTableEntryPointerArray fCmp) { wxBaseArrayPtrVoid::Sort((CMPFUNC)fCmp); } private: typedef wxBaseArrayPtrVoid::iterator biterator; typedef wxBaseArrayPtrVoid::const_iterator bconst_iterator; typedef wxBaseArrayPtrVoid::value_type bvalue_type; typedef wxBaseArrayPtrVoid::const_reference bconst_reference; public: typedef _wxArraywxEventTableEntryPointerArray value_type; typedef value_type* pointer; typedef const value_type* const_pointer; typedef value_type* iterator; typedef const value_type* const_iterator; typedef value_type& reference; typedef const value_type& const_reference; typedef wxBaseArrayPtrVoid::difference_type difference_type; typedef wxBaseArrayPtrVoid::size_type size_type; class reverse_iterator { typedef _wxArraywxEventTableEntryPointerArray value_type; typedef value_type& reference; typedef value_type* pointer; typedef reverse_iterator itor; friend inline itor operator+(int o, const itor& it) { return it.m_ptr - o; } friend inline itor operator+(const itor& it, int o) { return it.m_ptr - o; } friend inline itor operator-(const itor& it, int o) { return it.m_ptr + o; } friend inline difference_type operator-(const itor& i1, const itor& i2) { return i1.m_ptr - i2.m_ptr; } public: pointer m_ptr; reverse_iterator() : m_ptr(__null) { } reverse_iterator(pointer ptr) : m_ptr(ptr) { } reverse_iterator(const itor& it) : m_ptr(it.m_ptr) { } reference operator*() const { return *m_ptr; } itor& operator++() { --m_ptr; return *this; } const itor operator++(int) { reverse_iterator tmp = *this; --m_ptr; return tmp; } itor& operator--() { ++m_ptr; return *this; } const itor operator--(int) { itor tmp = *this; ++m_ptr; return tmp; } bool operator ==(const itor& it) const { return m_ptr == it.m_ptr; } bool operator !=(const itor& it) const { return m_ptr != it.m_ptr; } }; class const_reverse_iterator { typedef _wxArraywxEventTableEntryPointerArray value_type; typedef const value_type& reference; typedef const value_type* pointer; typedef const_reverse_iterator itor; friend inline itor operator+(int o, const itor& it) { return it.m_ptr - o; } friend inline itor operator+(const itor& it, int o) { return it.m_ptr - o; } friend inline itor operator-(const itor& it, int o) { return it.m_ptr + o; } friend inline difference_type operator-(const itor& i1, const itor& i2) { return i1.m_ptr - i2.m_ptr; } public: pointer m_ptr; const_reverse_iterator() : m_ptr(__null) { } const_reverse_iterator(pointer ptr) : m_ptr(ptr) { } const_reverse_iterator(const itor& it) : m_ptr(it.m_ptr) { } const_reverse_iterator(const reverse_iterator& it) : m_ptr(it.m_ptr) { } reference operator*() const { return *m_ptr; } itor& operator++() { --m_ptr; return *this; } const itor operator++(int) { itor tmp = *this; --m_ptr; return tmp; } itor& operator--() { ++m_ptr; return *this; } const itor operator--(int) { itor tmp = *this; ++m_ptr; return tmp; } bool operator ==(const itor& it) const { return m_ptr == it.m_ptr; } bool operator !=(const itor& it) const { return m_ptr != it.m_ptr; } }; wxEventTableEntryPointerArray(size_type n, const_reference v) { assign(n, v); } wxEventTableEntryPointerArray(const_iterator first, const_iterator last) { assign(first, last); } void assign(const_iterator first, const_iterator last) { wxBaseArrayPtrVoid::assign((bconst_iterator)first, (bconst_iterator)last); } void assign(size_type n, const_reference v) { wxBaseArrayPtrVoid::assign(n, (bconst_reference)v); } reference back() { return *(end() - 1); } const_reference back() const { return *(end() - 1); } iterator begin() { return (iterator)wxBaseArrayPtrVoid::begin(); } const_iterator begin() const { return (const_iterator)wxBaseArrayPtrVoid::begin(); } size_type capacity() const { return wxBaseArrayPtrVoid::capacity(); } iterator end() { return (iterator)wxBaseArrayPtrVoid::end(); } const_iterator end() const { return (const_iterator)wxBaseArrayPtrVoid::end(); } iterator erase(iterator first, iterator last) { return (iterator)wxBaseArrayPtrVoid::erase((biterator)first, (biterator)last); } iterator erase(iterator it) { return (iterator)wxBaseArrayPtrVoid::erase((biterator)it); } reference front() { return *begin(); } const_reference front() const { return *begin(); } void insert(iterator it, size_type n, const_reference v) { wxBaseArrayPtrVoid::insert((biterator)it, n, (bconst_reference)v); } iterator insert(iterator it, const_reference v = value_type()) { return (iterator)wxBaseArrayPtrVoid::insert((biterator)it, (bconst_reference)v); } void insert(iterator it, const_iterator first, const_iterator last) { wxBaseArrayPtrVoid::insert((biterator)it, (bconst_iterator)first, (bconst_iterator)last); } void pop_back() { wxBaseArrayPtrVoid::pop_back(); } void push_back(const_reference v) { wxBaseArrayPtrVoid::push_back((bconst_reference)v); } reverse_iterator rbegin() { return reverse_iterator(end() - 1); } const_reverse_iterator rbegin() const; reverse_iterator rend() { return reverse_iterator(begin() - 1); } const_reverse_iterator rend() const; void reserve(size_type n) { wxBaseArrayPtrVoid::reserve(n); } void resize(size_type n, value_type v = value_type()) { wxBaseArrayPtrVoid::resize(n, v); } };

class wxEventHashTable
{
private:

    struct EventTypeTable
    {
        wxEventType eventType;
        wxEventTableEntryPointerArray eventEntryTable;
    };
    typedef EventTypeTable* EventTypeTablePointer;

public:




    wxEventHashTable(const wxEventTable &table);

    ~wxEventHashTable();



    bool HandleEvent(wxEvent &event, wxEvtHandler *self);


    void Clear();


    static void ClearAll();

    static void ReconstructAll();

protected:

    void InitHashTable();

    void AddEntry(const wxEventTableEntry &entry);

    void AllocEventTypeTable(size_t size);


    void GrowEventTypeTable();

protected:
    const wxEventTable &m_table;
    bool m_rebuildHash;

    size_t m_size;
    EventTypeTablePointer *m_eventTypeTable;

    static wxEventHashTable* sm_first;
    wxEventHashTable* m_previous;
    wxEventHashTable* m_next;

    private: wxEventHashTable(const wxEventHashTable&); wxEventHashTable& operator=(const wxEventHashTable&);
};





class wxEvtHandler : public wxObject
{
public:
    wxEvtHandler();
    virtual ~wxEvtHandler();

    wxEvtHandler *GetNextHandler() const { return m_nextHandler; }
    wxEvtHandler *GetPreviousHandler() const { return m_previousHandler; }
    void SetNextHandler(wxEvtHandler *handler) { m_nextHandler = handler; }
    void SetPreviousHandler(wxEvtHandler *handler) { m_previousHandler = handler; }

    void SetEvtHandlerEnabled(bool enabled) { m_enabled = enabled; }
    bool GetEvtHandlerEnabled() const { return m_enabled; }


    virtual bool ProcessEvent(wxEvent& event);


    void AddPendingEvent(wxEvent& event);

    void ProcessPendingEvents();


    bool ProcessThreadEvent(wxEvent& event);




    void Connect(int winid,
                 int lastId,
                 int eventType,
                 wxObjectEventFunction func,
                 wxObject *userData = (wxObject *) __null,
                 wxEvtHandler *eventSink = (wxEvtHandler *) __null);


    void Connect(int winid,
                 int eventType,
                 wxObjectEventFunction func,
                 wxObject *userData = (wxObject *) __null,
                 wxEvtHandler *eventSink = (wxEvtHandler *) __null)
        { Connect(winid, wxID_ANY, eventType, func, userData, eventSink); }


    void Connect(int eventType,
                 wxObjectEventFunction func,
                 wxObject *userData = (wxObject *) __null,
                 wxEvtHandler *eventSink = (wxEvtHandler *) __null)
        { Connect(wxID_ANY, wxID_ANY, eventType, func, userData, eventSink); }

    bool Disconnect(int winid,
                    int lastId,
                    wxEventType eventType,
                    wxObjectEventFunction func = __null,
                    wxObject *userData = (wxObject *) __null,
                    wxEvtHandler *eventSink = (wxEvtHandler *) __null);

    bool Disconnect(int winid = wxID_ANY,
                    wxEventType eventType = wxEVT_NULL,
                    wxObjectEventFunction func = __null,
                    wxObject *userData = (wxObject *) __null,
                    wxEvtHandler *eventSink = (wxEvtHandler *) __null)
        { return Disconnect(winid, wxID_ANY, eventType, func, userData, eventSink); }

    bool Disconnect(wxEventType eventType,
                    wxObjectEventFunction func,
                    wxObject *userData = (wxObject *) __null,
                    wxEvtHandler *eventSink = (wxEvtHandler *) __null)
        { return Disconnect(wxID_ANY, eventType, func, userData, eventSink); }

    wxList* GetDynamicEventTable() const { return m_dynamicEvents ; }


    void SetClientObject( wxClientData *data ) { DoSetClientObject(data); }
    wxClientData *GetClientObject() const { return DoGetClientObject(); }

    void SetClientData( void *data ) { DoSetClientData(data); }
    void *GetClientData() const { return DoGetClientData(); }






    static bool ProcessEventIfMatches(const wxEventTableEntryBase& tableEntry,
                                      wxEvtHandler *handler,
                                      wxEvent& event);


    virtual bool SearchEventTable(wxEventTable& table, wxEvent& event);
    bool SearchDynamicEventTable( wxEvent& event );


    void ClearEventLocker();



    void ClearEventHashTable() { GetEventHashTable().Clear(); }

private:
    static const wxEventTableEntry sm_eventTableEntries[];

protected:
# 2501 "/usr/include/wx-2.8/wx/event.h"
    virtual bool TryValidator(wxEvent& ) { return false; }





    virtual bool TryParent(wxEvent& event);


    static const wxEventTable sm_eventTable;
    virtual const wxEventTable *GetEventTable() const;

    static wxEventHashTable sm_eventHashTable;
    virtual wxEventHashTable& GetEventHashTable() const;

    wxEvtHandler* m_nextHandler;
    wxEvtHandler* m_previousHandler;
    wxList* m_dynamicEvents;
    wxList* m_pendingEvents;
# 2528 "/usr/include/wx-2.8/wx/event.h"
    const wxCriticalSection& Lock() const { return *m_eventsLocker; }
    wxCriticalSection& Lock() { return *m_eventsLocker; }

    wxCriticalSection* m_eventsLocker;




    bool m_enabled;







    union
    {
        wxClientData *m_clientObject;
        void *m_clientData;
    };


    wxClientDataType m_clientDataType;


    virtual void DoSetClientObject( wxClientData *data );
    virtual wxClientData *DoGetClientObject() const;

    virtual void DoSetClientData( void *data );
    virtual void *DoGetClientData() const;

private:
    private: wxEvtHandler(const wxEvtHandler&); wxEvtHandler& operator=(const wxEvtHandler&); public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};



inline void wxPostEvent(wxEvtHandler *dest, wxEvent& event)
{
    if ( dest ) ; else { ; return; } typedef int wxDummyCheckInt;

    dest->AddPendingEvent(event);
}

typedef void (wxEvtHandler::*wxEventFunction)(wxEvent&);






typedef void (wxEvtHandler::*wxCommandEventFunction)(wxCommandEvent&);
typedef void (wxEvtHandler::*wxScrollEventFunction)(wxScrollEvent&);
typedef void (wxEvtHandler::*wxScrollWinEventFunction)(wxScrollWinEvent&);
typedef void (wxEvtHandler::*wxSizeEventFunction)(wxSizeEvent&);
typedef void (wxEvtHandler::*wxMoveEventFunction)(wxMoveEvent&);
typedef void (wxEvtHandler::*wxPaintEventFunction)(wxPaintEvent&);
typedef void (wxEvtHandler::*wxNcPaintEventFunction)(wxNcPaintEvent&);
typedef void (wxEvtHandler::*wxEraseEventFunction)(wxEraseEvent&);
typedef void (wxEvtHandler::*wxMouseEventFunction)(wxMouseEvent&);
typedef void (wxEvtHandler::*wxCharEventFunction)(wxKeyEvent&);
typedef void (wxEvtHandler::*wxFocusEventFunction)(wxFocusEvent&);
typedef void (wxEvtHandler::*wxChildFocusEventFunction)(wxChildFocusEvent&);
typedef void (wxEvtHandler::*wxActivateEventFunction)(wxActivateEvent&);
typedef void (wxEvtHandler::*wxMenuEventFunction)(wxMenuEvent&);
typedef void (wxEvtHandler::*wxJoystickEventFunction)(wxJoystickEvent&);
typedef void (wxEvtHandler::*wxDropFilesEventFunction)(wxDropFilesEvent&);
typedef void (wxEvtHandler::*wxInitDialogEventFunction)(wxInitDialogEvent&);
typedef void (wxEvtHandler::*wxSysColourChangedEventFunction)(wxSysColourChangedEvent&);
typedef void (wxEvtHandler::*wxDisplayChangedEventFunction)(wxDisplayChangedEvent&);
typedef void (wxEvtHandler::*wxUpdateUIEventFunction)(wxUpdateUIEvent&);
typedef void (wxEvtHandler::*wxIdleEventFunction)(wxIdleEvent&);
typedef void (wxEvtHandler::*wxCloseEventFunction)(wxCloseEvent&);
typedef void (wxEvtHandler::*wxShowEventFunction)(wxShowEvent&);
typedef void (wxEvtHandler::*wxIconizeEventFunction)(wxIconizeEvent&);
typedef void (wxEvtHandler::*wxMaximizeEventFunction)(wxMaximizeEvent&);
typedef void (wxEvtHandler::*wxNavigationKeyEventFunction)(wxNavigationKeyEvent&);
typedef void (wxEvtHandler::*wxPaletteChangedEventFunction)(wxPaletteChangedEvent&);
typedef void (wxEvtHandler::*wxQueryNewPaletteEventFunction)(wxQueryNewPaletteEvent&);
typedef void (wxEvtHandler::*wxWindowCreateEventFunction)(wxWindowCreateEvent&);
typedef void (wxEvtHandler::*wxWindowDestroyEventFunction)(wxWindowDestroyEvent&);
typedef void (wxEvtHandler::*wxSetCursorEventFunction)(wxSetCursorEvent&);
typedef void (wxEvtHandler::*wxNotifyEventFunction)(wxNotifyEvent&);
typedef void (wxEvtHandler::*wxHelpEventFunction)(wxHelpEvent&);
typedef void (wxEvtHandler::*wxContextMenuEventFunction)(wxContextMenuEvent&);
typedef void (wxEvtHandler::*wxMouseCaptureChangedEventFunction)(wxMouseCaptureChangedEvent&);
typedef void (wxEvtHandler::*wxMouseCaptureLostEventFunction)(wxMouseCaptureLostEvent&);
typedef void (wxEvtHandler::*wxClipboardTextEventFunction)(wxClipboardTextEvent&);
# 3104 "/usr/include/wx-2.8/wx/event.h"
extern wxList *wxPendingEvents;

    extern wxCriticalSection *wxPendingEventsLocker;
# 3117 "/usr/include/wx-2.8/wx/event.h"
 wxWindow* wxFindFocusDescendant(wxWindow* ancestor);
# 26 "/usr/include/wx-2.8/wx/wx.h" 2
# 1 "/usr/include/wx-2.8/wx/app.h" 1
# 21 "/usr/include/wx-2.8/wx/app.h"
# 1 "/usr/include/wx-2.8/wx/build.h" 1
# 22 "/usr/include/wx-2.8/wx/app.h" 2
# 1 "/usr/include/wx-2.8/wx/init.h" 1
# 30 "/usr/include/wx-2.8/wx/init.h"
extern bool wxEntryStart(int& argc, wxChar **argv);



extern void wxEntryCleanup();
# 46 "/usr/include/wx-2.8/wx/init.h"
extern int wxEntry(int& argc, wxChar **argv);




extern bool wxEntryStart(int& argc, char **argv);
extern int wxEntry(int& argc, char **argv);
# 64 "/usr/include/wx-2.8/wx/init.h"
extern bool wxInitialize(int argc = 0, wxChar **argv = __null);

extern bool wxInitialize(int argc, char **argv);




extern void wxUninitialize();



class wxInitializer
{
public:

    wxInitializer(int argc = 0, wxChar **argv = __null)
    {
        m_ok = wxInitialize(argc, argv);
    }


    wxInitializer(int argc, char **argv)
    {
        m_ok = wxInitialize(argc, argv);
    }



    bool IsOk() const { return m_ok; }


    operator bool() const { return m_ok; }


    ~wxInitializer() { if ( m_ok ) wxUninitialize(); }

private:
    bool m_ok;
};
# 23 "/usr/include/wx-2.8/wx/app.h" 2


class wxAppConsole;
class wxAppTraits;
class wxCmdLineParser;
class wxLog;
class wxMessageOutput;


    class wxEventLoop;
    struct wxVideoMode;







typedef wxAppConsole* (*wxAppInitializerFunction)();





enum
{
    wxPRINT_WINDOWS = 1,
    wxPRINT_POSTSCRIPT = 2
};





class wxAppConsole : public wxEvtHandler
{
public:

    wxAppConsole();
    virtual ~wxAppConsole();
# 73 "/usr/include/wx-2.8/wx/app.h"
    virtual bool Initialize(int& argc, wxChar **argv);


    virtual bool CallOnInit() { return OnInit(); }





    virtual bool OnInit();


    virtual bool OnInitGui() { return true; }



    virtual int OnRun() = 0;



    virtual int OnExit();




    virtual void CleanUp();







    virtual void OnFatalException() { }


    virtual void Exit();
# 120 "/usr/include/wx-2.8/wx/app.h"
    wxString GetAppName() const
    {
        return m_appName.empty() ? m_className : m_appName;
    }
    void SetAppName(const wxString& name) { m_appName = name; }


    wxString GetClassName() const { return m_className; }
    void SetClassName(const wxString& name) { m_className = name; }


    const wxString& GetVendorName() const { return m_vendorName; }
    void SetVendorName(const wxString& name) { m_vendorName = name; }
# 149 "/usr/include/wx-2.8/wx/app.h"
    virtual void OnInitCmdLine(wxCmdLineParser& parser);




    virtual bool OnCmdLineParsed(wxCmdLineParser& parser);



    virtual bool OnCmdLineHelp(wxCmdLineParser& parser);



    virtual bool OnCmdLineError(wxCmdLineParser& parser);
# 174 "/usr/include/wx-2.8/wx/app.h"
    wxAppTraits *GetTraits();
# 204 "/usr/include/wx-2.8/wx/app.h"
    virtual int FilterEvent(wxEvent& event);







    virtual void HandleEvent(wxEvtHandler *handler,
                             wxEventFunction func,
                             wxEvent& event) const;





    virtual void OnUnhandledException() { }






    virtual void ProcessPendingEvents();


    virtual bool Yield(bool = false) { return true; }


    virtual void WakeUpIdle() { }



    static bool IsMainLoopRunning() { return false; }
# 268 "/usr/include/wx-2.8/wx/app.h"
    static bool CheckBuildOptions(const char *optionsSignature,
                                  const char *componentName);
# 278 "/usr/include/wx-2.8/wx/app.h"
    static void SetInitializerFunction(wxAppInitializerFunction fn)
        { ms_appInitFn = fn; }
    static wxAppInitializerFunction GetInitializerFunction()
        { return ms_appInitFn; }





    static wxAppConsole *GetInstance() { return ms_appInstance; }
    static void SetInstance(wxAppConsole *app) { ms_appInstance = app; }



    int argc;
    wxChar **argv;

protected:


    virtual wxAppTraits *CreateTraits();



    static wxAppInitializerFunction ms_appInitFn;


    static wxAppConsole *ms_appInstance;



    wxString m_vendorName,
             m_appName,
             m_className;



    wxAppTraits *m_traits;




    private: wxAppConsole(const wxAppConsole&); wxAppConsole& operator=(const wxAppConsole&);
};







class wxAppBase : public wxAppConsole
{
public:
    wxAppBase();
    virtual ~wxAppBase();







    virtual bool Initialize(int& argc, wxChar **argv);





    virtual bool OnInitGui();
# 356 "/usr/include/wx-2.8/wx/app.h"
    virtual int OnRun();


    virtual int OnExit();




    virtual void CleanUp();







    static bool IsMainLoopRunning()
    {
        wxAppBase *app = static_cast<wxAppBase *>(GetInstance());
        return app && app->m_mainLoop != __null;
    }


    virtual int MainLoop();


    virtual void Exit();



    virtual void ExitMainLoop();


    virtual bool Pending();





    virtual bool Dispatch();
# 406 "/usr/include/wx-2.8/wx/app.h"
    virtual bool Yield(bool onlyIfNeeded = false) = 0;






    virtual bool ProcessIdle();



    virtual bool SendIdleEvents(wxWindow* win, wxIdleEvent& event);







    virtual bool OnExceptionInMainLoop();







    virtual bool IsActive() const { return m_isActive; }


    void SetTopWindow(wxWindow *win) { m_topWindow = win; }




    virtual wxWindow *GetTopWindow() const;






    void SetExitOnFrameDelete(bool flag)
        { m_exitOnFrameDelete = flag ? Yes : No; }
    bool GetExitOnFrameDelete() const
        { return m_exitOnFrameDelete == Yes; }







    virtual wxVideoMode GetDisplayMode() const;



    virtual bool SetDisplayMode(const wxVideoMode& ) { return true; }


    void SetUseBestVisual( bool flag, bool forceTrueColour = false )
        { m_useBestVisual = flag; m_forceTrueColour = forceTrueColour; }
    bool GetUseBestVisual() const { return m_useBestVisual; }





    virtual void SetPrintMode(int ) { }
    int GetPrintMode() const { return wxPRINT_POSTSCRIPT; }



    virtual wxLayoutDirection GetLayoutDirection() const;






    virtual bool OnCmdLineParsed(wxCmdLineParser& parser);
    virtual void OnInitCmdLine(wxCmdLineParser& parser);
# 496 "/usr/include/wx-2.8/wx/app.h"
    virtual void SetActive(bool isActive, wxWindow *lastFocus);





    bool Initialized() __attribute__ ((deprecated));



    void OnIdle(wxIdleEvent& event);


protected:

    void DeletePendingObjects();


    virtual wxAppTraits *CreateTraits();




    wxEventLoop *m_mainLoop;


    wxWindow *m_topWindow;





    enum
    {
        Later = -1,
        No,
        Yes
    } m_exitOnFrameDelete;



    bool m_useBestVisual;

    bool m_forceTrueColour;


    bool m_isActive;


    private: wxAppBase(const wxAppBase&); wxAppBase& operator=(const wxAppBase&);
};


    inline bool wxAppBase::Initialized() { return true; }
# 570 "/usr/include/wx-2.8/wx/app.h"
# 1 "/usr/include/wx-2.8/wx/gtk/app.h" 1
# 17 "/usr/include/wx-2.8/wx/gtk/app.h"
class wxApp;
class wxLog;





class wxApp: public wxAppBase
{
public:
    wxApp();
    virtual ~wxApp();





    virtual bool OnInitGui();


    virtual bool Yield(bool onlyIfNeeded = 0);
    virtual void WakeUpIdle();

    virtual bool Initialize(int& argc, wxChar **argv);
    virtual void CleanUp();

    static bool InitialzeVisual();
# 55 "/usr/include/wx-2.8/wx/gtk/app.h"
    guint m_idleTag;

    void SuspendIdleCallback();



    void *m_glVisualInfo;
    void *m_glFBCInfo;


    GdkVisual *GetGdkVisual();

private:





    public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
    private: static const wxEventTableEntry sm_eventTableEntries[]; protected: static const wxEventTable sm_eventTable; virtual const wxEventTable* GetEventTable() const; static wxEventHashTable sm_eventHashTable; virtual wxEventHashTable& GetEventHashTable() const;
};
# 571 "/usr/include/wx-2.8/wx/app.h" 2
# 610 "/usr/include/wx-2.8/wx/app.h"
extern void wxExit();
# 623 "/usr/include/wx-2.8/wx/app.h"
extern void wxWakeUpIdle();
# 633 "/usr/include/wx-2.8/wx/app.h"
class wxAppInitializer
{
public:
    wxAppInitializer(wxAppInitializerFunction fn)
        { wxApp::SetInitializerFunction(fn); }
};
# 705 "/usr/include/wx-2.8/wx/app.h"
extern wxAppConsole *wxCreateApp();
extern wxAppInitializer wxTheAppInitializer;
# 27 "/usr/include/wx-2.8/wx/wx.h" 2

# 1 "/usr/include/wx-2.8/wx/stream.h" 1
# 24 "/usr/include/wx-2.8/wx/stream.h"
class wxStreamBase;
class wxInputStream;
class wxOutputStream;

typedef wxInputStream& (*__wxInputManip)(wxInputStream&);
typedef wxOutputStream& (*__wxOutputManip)(wxOutputStream&);

 wxOutputStream& wxEndL(wxOutputStream& o_stream);





enum wxStreamError
{
    wxSTREAM_NO_ERROR = 0,
    wxSTREAM_EOF,
    wxSTREAM_WRITE_ERROR,
    wxSTREAM_READ_ERROR
};

const int wxEOF = -1;
# 55 "/usr/include/wx-2.8/wx/stream.h"
class wxStreamBase
{
public:
    wxStreamBase();
    virtual ~wxStreamBase();


    wxStreamError GetLastError() const { return m_lasterror; }
    virtual bool IsOk() const { return GetLastError() == wxSTREAM_NO_ERROR; }
    bool operator!() const { return !IsOk(); }


    void Reset() { m_lasterror = wxSTREAM_NO_ERROR; }


    virtual size_t GetSize() const;
    virtual wxFileOffset GetLength() const { return wxInvalidOffset; }


    virtual bool IsSeekable() const { return false; }

protected:
    virtual wxFileOffset OnSysSeek(wxFileOffset seek, wxSeekMode mode);
    virtual wxFileOffset OnSysTell() const;

    size_t m_lastcount;
    wxStreamError m_lasterror;

    friend class wxStreamBuffer;

    private: wxStreamBase(const wxStreamBase&); wxStreamBase& operator=(const wxStreamBase&);
};





class wxInputStream : public wxStreamBase
{
public:

    wxInputStream();
    virtual ~wxInputStream();
# 109 "/usr/include/wx-2.8/wx/stream.h"
    virtual char Peek();





    int GetC();
# 128 "/usr/include/wx-2.8/wx/stream.h"
    virtual wxInputStream& Read(void *buffer, size_t size);



    wxInputStream& Read(wxOutputStream& streamOut);
# 143 "/usr/include/wx-2.8/wx/stream.h"
    virtual size_t LastRead() const { return wxStreamBase::m_lastcount; }



    virtual bool CanRead() const;





    virtual bool Eof() const;
# 163 "/usr/include/wx-2.8/wx/stream.h"
    size_t Ungetch(const void *buffer, size_t size);




    bool Ungetch(char c);
# 178 "/usr/include/wx-2.8/wx/stream.h"
    virtual wxFileOffset SeekI(wxFileOffset pos, wxSeekMode mode = wxFromStart);


    virtual wxFileOffset TellI() const;





    wxInputStream& operator>>(wxOutputStream& out) { return Read(out); }
    wxInputStream& operator>>(__wxInputManip func) { return func(*this); }

protected:





    virtual size_t OnSysRead(void *buffer, size_t size) = 0;





    char *AllocSpaceWBack(size_t sizeNeeded);



    size_t GetWBack(void *buf, size_t size);


    char *m_wback;


    size_t m_wbacksize;


    size_t m_wbackcur;

    friend class wxStreamBuffer;

    private: wxInputStream(const wxInputStream&); wxInputStream& operator=(const wxInputStream&);
};





class wxOutputStream : public wxStreamBase
{
public:
    wxOutputStream();
    virtual ~wxOutputStream();

    void PutC(char c);
    virtual wxOutputStream& Write(const void *buffer, size_t size);
    wxOutputStream& Write(wxInputStream& stream_in);

    virtual wxFileOffset SeekO(wxFileOffset pos, wxSeekMode mode = wxFromStart);
    virtual wxFileOffset TellO() const;

    virtual size_t LastWrite() const { return wxStreamBase::m_lastcount; }

    virtual void Sync();
    virtual bool Close() { return true; }

    wxOutputStream& operator<<(wxInputStream& out) { return Write(out); }
    wxOutputStream& operator<<( __wxOutputManip func) { return func(*this); }

protected:


    virtual size_t OnSysWrite(const void *buffer, size_t bufsize);

    friend class wxStreamBuffer;

    private: wxOutputStream(const wxOutputStream&); wxOutputStream& operator=(const wxOutputStream&);
};
# 265 "/usr/include/wx-2.8/wx/stream.h"
class wxCountingOutputStream : public wxOutputStream
{
public:
    wxCountingOutputStream();

    wxFileOffset GetLength() const;
    bool Ok() const { return IsOk(); }
    bool IsOk() const { return true; }

protected:
    virtual size_t OnSysWrite(const void *buffer, size_t size);
    virtual wxFileOffset OnSysSeek(wxFileOffset pos, wxSeekMode mode);
    virtual wxFileOffset OnSysTell() const;

    size_t m_currentPos;

    private: wxCountingOutputStream(const wxCountingOutputStream&); wxCountingOutputStream& operator=(const wxCountingOutputStream&);
};





class wxFilterInputStream : public wxInputStream
{
public:
    wxFilterInputStream();
    wxFilterInputStream(wxInputStream& stream);
    wxFilterInputStream(wxInputStream *stream);
    virtual ~wxFilterInputStream();

    char Peek() { return m_parent_i_stream->Peek(); }

    wxFileOffset GetLength() const { return m_parent_i_stream->GetLength(); }

    wxInputStream *GetFilterInputStream() const { return m_parent_i_stream; }

protected:
    wxInputStream *m_parent_i_stream;
    bool m_owns;

    private: wxFilterInputStream(const wxFilterInputStream&); wxFilterInputStream& operator=(const wxFilterInputStream&);
};

class wxFilterOutputStream : public wxOutputStream
{
public:
    wxFilterOutputStream();
    wxFilterOutputStream(wxOutputStream& stream);
    wxFilterOutputStream(wxOutputStream *stream);
    virtual ~wxFilterOutputStream();

    wxFileOffset GetLength() const { return m_parent_o_stream->GetLength(); }

    wxOutputStream *GetFilterOutputStream() const { return m_parent_o_stream; }

    bool Close();

protected:
    wxOutputStream *m_parent_o_stream;
    bool m_owns;

    private: wxFilterOutputStream(const wxFilterOutputStream&); wxFilterOutputStream& operator=(const wxFilterOutputStream&);
};

enum wxStreamProtocolType
{
    wxSTREAM_PROTOCOL,
    wxSTREAM_MIMETYPE,
    wxSTREAM_ENCODING,
    wxSTREAM_FILEEXT
};

void wxUseFilterClasses();

class wxFilterClassFactoryBase : public wxObject
{
public:
    virtual ~wxFilterClassFactoryBase() { }

    wxString GetProtocol() const { return wxString(*GetProtocols()); }
    wxString PopExtension(const wxString& location) const;

    virtual const wxChar * const *GetProtocols(wxStreamProtocolType type
                                               = wxSTREAM_PROTOCOL) const = 0;

    bool CanHandle(const wxChar *protocol,
                   wxStreamProtocolType type
                   = wxSTREAM_PROTOCOL) const;

protected:
    wxString::size_type FindExtension(const wxChar *location) const;

    public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const;
};

class wxFilterClassFactory : public wxFilterClassFactoryBase
{
public:
    virtual ~wxFilterClassFactory() { }

    virtual wxFilterInputStream *NewStream(wxInputStream& stream) const = 0;
    virtual wxFilterOutputStream *NewStream(wxOutputStream& stream) const = 0;
    virtual wxFilterInputStream *NewStream(wxInputStream *stream) const = 0;
    virtual wxFilterOutputStream *NewStream(wxOutputStream *stream) const = 0;

    static const wxFilterClassFactory *Find(const wxChar *protocol,
                                            wxStreamProtocolType type
                                            = wxSTREAM_PROTOCOL);

    static const wxFilterClassFactory *GetFirst();
    const wxFilterClassFactory *GetNext() const { return m_next; }

    void PushFront() { Remove(); m_next = sm_first; sm_first = this; }
    void Remove();

protected:
    wxFilterClassFactory() : m_next(this) { }

    wxFilterClassFactory& operator=(const wxFilterClassFactory&)
        { return *this; }

private:
    static wxFilterClassFactory *sm_first;
    wxFilterClassFactory *m_next;

    public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const;
};
# 403 "/usr/include/wx-2.8/wx/stream.h"
class wxStreamBuffer
{
public:
    enum BufMode
    {
        read,
        write,
        read_write
    };

    wxStreamBuffer(wxStreamBase& stream, BufMode mode);
    wxStreamBuffer(const wxStreamBuffer& buf);
    virtual ~wxStreamBuffer();


    virtual size_t Read(void *buffer, size_t size);
    size_t Read(wxStreamBuffer *buf);
    virtual size_t Write(const void *buffer, size_t size);
    size_t Write(wxStreamBuffer *buf);

    virtual char Peek();
    virtual char GetChar();
    virtual void PutChar(char c);
    virtual wxFileOffset Tell() const;
    virtual wxFileOffset Seek(wxFileOffset pos, wxSeekMode mode);


    void ResetBuffer();



    void SetBufferIO(void *start, void *end, bool takeOwnership = false);
    void SetBufferIO(void *start, size_t len, bool takeOwnership = false);
    void SetBufferIO(size_t bufsize);
    void *GetBufferStart() const { return m_buffer_start; }
    void *GetBufferEnd() const { return m_buffer_end; }
    void *GetBufferPos() const { return m_buffer_pos; }
    size_t GetBufferSize() const { return m_buffer_size; }
    size_t GetIntPosition() const { return m_buffer_pos - m_buffer_start; }
    void SetIntPosition(size_t pos) { m_buffer_pos = m_buffer_start + pos; }
    size_t GetLastAccess() const { return m_buffer_end - m_buffer_start; }
    size_t GetBytesLeft() const { return m_buffer_end - m_buffer_pos; }

    void Fixed(bool fixed) { m_fixed = fixed; }
    void Flushable(bool f) { m_flushable = f; }

    bool FlushBuffer();
    bool FillBuffer();
    size_t GetDataLeft();


    wxStreamBase *GetStream() const { return m_stream; }
    bool HasBuffer() const { return m_buffer_size != 0; }

    bool IsFixed() const { return m_fixed; }
    bool IsFlushable() const { return m_flushable; }


    wxInputStream *GetInputStream() const;
    wxOutputStream *GetOutputStream() const;



    wxStreamBase *Stream() __attribute__ ((deprecated));




    wxStreamBuffer(BufMode mode);

protected:
    void GetFromBuffer(void *buffer, size_t size);
    void PutToBuffer(const void *buffer, size_t size);


    void SetError(wxStreamError err);


    void Init();


    void InitBuffer();


    void FreeBuffer();



    char *m_buffer_start,
         *m_buffer_end,
         *m_buffer_pos;



    size_t m_buffer_size;


    wxStreamBase *m_stream;


    BufMode m_mode;


    bool m_destroybuf,
         m_fixed,
         m_flushable;

private:





    wxStreamBuffer& operator=(const wxStreamBuffer&);
};





class wxBufferedInputStream : public wxFilterInputStream
{
public:

    wxBufferedInputStream(wxInputStream& stream,
                          wxStreamBuffer *buffer = __null);
    virtual ~wxBufferedInputStream();

    char Peek();
    wxInputStream& Read(void *buffer, size_t size);


    wxFileOffset SeekI(wxFileOffset pos, wxSeekMode mode = wxFromStart);
    wxFileOffset TellI() const;
    bool IsSeekable() const { return m_parent_i_stream->IsSeekable(); }


    void SetInputStreamBuffer(wxStreamBuffer *buffer);
    wxStreamBuffer *GetInputStreamBuffer() const { return m_i_streambuf; }



    wxStreamBuffer *InputStreamBuffer() const __attribute__ ((deprecated));


protected:
    virtual size_t OnSysRead(void *buffer, size_t bufsize);
    virtual wxFileOffset OnSysSeek(wxFileOffset seek, wxSeekMode mode);
    virtual wxFileOffset OnSysTell() const;

    wxStreamBuffer *m_i_streambuf;

    private: wxBufferedInputStream(const wxBufferedInputStream&); wxBufferedInputStream& operator=(const wxBufferedInputStream&);
};





class wxBufferedOutputStream : public wxFilterOutputStream
{
public:

    wxBufferedOutputStream(wxOutputStream& stream,
                           wxStreamBuffer *buffer = __null);
    virtual ~wxBufferedOutputStream();

    wxOutputStream& Write(const void *buffer, size_t size);


    wxFileOffset SeekO(wxFileOffset pos, wxSeekMode mode = wxFromStart);
    wxFileOffset TellO() const;
    bool IsSeekable() const { return m_parent_o_stream->IsSeekable(); }

    void Sync();
    bool Close();

    wxFileOffset GetLength() const;


    void SetOutputStreamBuffer(wxStreamBuffer *buffer);
    wxStreamBuffer *GetOutputStreamBuffer() const { return m_o_streambuf; }



    wxStreamBuffer *OutputStreamBuffer() const __attribute__ ((deprecated));


protected:
    virtual size_t OnSysWrite(const void *buffer, size_t bufsize);
    virtual wxFileOffset OnSysSeek(wxFileOffset seek, wxSeekMode mode);
    virtual wxFileOffset OnSysTell() const;

    wxStreamBuffer *m_o_streambuf;

    private: wxBufferedOutputStream(const wxBufferedOutputStream&); wxBufferedOutputStream& operator=(const wxBufferedOutputStream&);
};


    inline wxStreamBase *wxStreamBuffer::Stream() { return m_stream; }
    inline wxStreamBuffer *wxBufferedInputStream::InputStreamBuffer() const { return m_i_streambuf; }
    inline wxStreamBuffer *wxBufferedOutputStream::OutputStreamBuffer() const { return m_o_streambuf; }
# 29 "/usr/include/wx-2.8/wx/wx.h" 2


# 1 "/usr/include/wx-2.8/wx/stopwatch.h" 1
# 23 "/usr/include/wx-2.8/wx/stopwatch.h"
class wxStopWatch
{
public:

    wxStopWatch() { m_pauseCount = 0; Start(); }


    void Start(long t0 = 0);


    void Pause()
    {
        if ( m_pauseCount++ == 0 )
            m_pause = GetElapsedTime();
    }


    void Resume()
    {
        ;


        if ( --m_pauseCount == 0 )
            Start(m_pause);
    }


    long Time() const;

protected:

    long GetElapsedTime() const;

private:

    wxLongLong m_t0;


    long m_pause;


    int m_pauseCount;
};







    void wxStartTimer() __attribute__ ((deprecated));



    long wxGetElapsedTime(bool resetTimer = true) __attribute__ ((deprecated));
# 86 "/usr/include/wx-2.8/wx/stopwatch.h"
extern long wxGetLocalTime();


extern long wxGetUTCTime();


    typedef wxLongLong wxMilliClock_t;





extern wxMilliClock_t wxGetLocalTimeMillis();
# 32 "/usr/include/wx-2.8/wx/wx.h" 2
# 1 "/usr/include/wx-2.8/wx/module.h" 1
# 20 "/usr/include/wx-2.8/wx/module.h"
class wxModule;
typedef wxModule _WX_LIST_ITEM_TYPE_wxModuleList; typedef int (*wxSortFuncFor_wxModuleList)(const wxModule **, const wxModule **); class wxwxModuleListNode : public wxNodeBase { public: wxwxModuleListNode(wxListBase *list = (wxListBase *)__null, wxwxModuleListNode *previous = (wxwxModuleListNode *)__null, wxwxModuleListNode *next = (wxwxModuleListNode *)__null, wxModule *data = (wxModule *)__null, const wxListKey& key = wxDefaultListKey) : wxNodeBase(list, previous, next, data, key) { } wxwxModuleListNode *GetNext() const { return (wxwxModuleListNode *)wxNodeBase::GetNext(); } wxwxModuleListNode *GetPrevious() const { return (wxwxModuleListNode *)wxNodeBase::GetPrevious(); } wxModule *GetData() const { return (wxModule *)wxNodeBase::GetData(); } void SetData(wxModule *data) { wxNodeBase::SetData(data); } protected: virtual void DeleteData(); private: wxwxModuleListNode(const wxwxModuleListNode&); wxwxModuleListNode& operator=(const wxwxModuleListNode&); }; class wxModuleList : public wxListBase { public: typedef wxwxModuleListNode Node; class compatibility_iterator { public: compatibility_iterator(Node *ptr = __null) : m_ptr(ptr) { } Node *operator->() const { return m_ptr; } operator Node *() const { return m_ptr; } private: Node *m_ptr; }; wxModuleList(wxKeyType keyType = wxKEY_NONE) : wxListBase(keyType) { } wxModuleList(const wxModuleList& list) : wxListBase(list.GetKeyType()) { Assign(list); } wxModuleList(size_t count, wxModule *elements[]) : wxListBase(count, (void **)elements) { } wxModuleList& operator=(const wxModuleList& list) { Assign(list); return *this; } wxwxModuleListNode *GetFirst() const { return (wxwxModuleListNode *)wxListBase::GetFirst(); } wxwxModuleListNode *GetLast() const { return (wxwxModuleListNode *)wxListBase::GetLast(); } wxwxModuleListNode *Item(size_t index) const { return (wxwxModuleListNode *)wxListBase::Item(index); } wxModule *operator[](size_t index) const { wxwxModuleListNode *node = Item(index); return node ? (wxModule*)(node->GetData()) : (wxModule*)__null; } wxwxModuleListNode *Append(wxModule *object) { return (wxwxModuleListNode *)wxListBase::Append(object); } wxwxModuleListNode *Insert(wxModule *object) { return (wxwxModuleListNode *)Insert((wxwxModuleListNode*)__null, object); } wxwxModuleListNode *Insert(size_t pos, wxModule *object) { return (wxwxModuleListNode *)wxListBase::Insert(pos, object); } wxwxModuleListNode *Insert(wxwxModuleListNode *prev, wxModule *object) { return (wxwxModuleListNode *)wxListBase::Insert(prev, object); } wxwxModuleListNode *Append(long key, void *object) { return (wxwxModuleListNode *)wxListBase::Append(key, object); } wxwxModuleListNode *Append(const wxChar *key, void *object) { return (wxwxModuleListNode *)wxListBase::Append(key, object); } wxwxModuleListNode *DetachNode(wxwxModuleListNode *node) { return (wxwxModuleListNode *)wxListBase::DetachNode(node); } bool DeleteNode(wxwxModuleListNode *node) { return wxListBase::DeleteNode(node); } bool DeleteObject(wxModule *object) { return wxListBase::DeleteObject(object); } void Erase(wxwxModuleListNode *it) { DeleteNode(it); } wxwxModuleListNode *Find(const wxModule *object) const { return (wxwxModuleListNode *)wxListBase::Find(object); } virtual wxwxModuleListNode *Find(const wxListKey& key) const { return (wxwxModuleListNode *)wxListBase::Find(key); } int IndexOf(wxModule *object) const { return wxListBase::IndexOf(object); } void Sort(wxSortCompareFunction func) { wxListBase::Sort(func); } void Sort(wxSortFuncFor_wxModuleList func) { Sort((wxSortCompareFunction)func); } protected: virtual wxNodeBase *CreateNode(wxNodeBase *prev, wxNodeBase *next, void *data, const wxListKey& key = wxDefaultListKey) { return new wxwxModuleListNode(this, (wxwxModuleListNode *)prev, (wxwxModuleListNode *)next, (wxModule *)data, key); } public: typedef size_t size_type; typedef int difference_type; typedef wxModule* value_type; typedef wxModule* base_value_type; typedef value_type& reference; typedef const value_type& const_reference; typedef base_value_type& base_reference; typedef const base_value_type& const_base_reference; class iterator { typedef wxModuleList list; public: typedef wxwxModuleListNode Node; typedef iterator itor; typedef wxModule* value_type; typedef value_type* ptr_type; typedef value_type& reference; Node* m_node; Node* m_init; public: typedef reference reference_type; typedef ptr_type pointer_type; iterator(Node* node, Node* init) : m_node(node), m_init(init) {} iterator() : m_node(__null), m_init(__null) { } reference_type operator*() const { return *(pointer_type)m_node->GetDataPtr(); } itor& operator++() { m_node = m_node->GetNext(); return *this; } const itor operator++(int) { itor tmp = *this; m_node = m_node->GetNext(); return tmp; } itor& operator--() { m_node = m_node ? m_node->GetPrevious() : m_init; return *this; } const itor operator--(int) { itor tmp = *this; m_node = m_node ? m_node->GetPrevious() : m_init; return tmp; } bool operator!=(const itor& it) const { return it.m_node != m_node; } bool operator==(const itor& it) const { return it.m_node == m_node; } }; class const_iterator { typedef wxModuleList list; public: typedef wxwxModuleListNode Node; typedef wxModule* value_type; typedef const value_type& const_reference; typedef const_iterator itor; typedef value_type* ptr_type; Node* m_node; Node* m_init; public: typedef const_reference reference_type; typedef const ptr_type pointer_type; const_iterator(Node* node, Node* init) : m_node(node), m_init(init) { } const_iterator() : m_node(__null), m_init(__null) { } const_iterator(const iterator& it) : m_node(it.m_node), m_init(it.m_init) { } reference_type operator*() const { return *(pointer_type)m_node->GetDataPtr(); } itor& operator++() { m_node = m_node->GetNext(); return *this; } const itor operator++(int) { itor tmp = *this; m_node = m_node->GetNext(); return tmp; } itor& operator--() { m_node = m_node ? m_node->GetPrevious() : m_init; return *this; } const itor operator--(int) { itor tmp = *this; m_node = m_node ? m_node->GetPrevious() : m_init; return tmp; } bool operator!=(const itor& it) const { return it.m_node != m_node; } bool operator==(const itor& it) const { return it.m_node == m_node; } }; class reverse_iterator { typedef wxModuleList list; public: typedef wxwxModuleListNode Node; typedef wxModule* value_type; typedef reverse_iterator itor; typedef value_type* ptr_type; typedef value_type& reference; Node* m_node; Node* m_init; public: typedef reference reference_type; typedef ptr_type pointer_type; reverse_iterator(Node* node, Node* init) : m_node(node), m_init(init) { } reverse_iterator() : m_node(__null), m_init(__null) { } reference_type operator*() const { return *(pointer_type)m_node->GetDataPtr(); } itor& operator++() { m_node = m_node->GetPrevious(); return *this; } const itor operator++(int) { itor tmp = *this; m_node = m_node->GetPrevious(); return tmp; } itor& operator--() { m_node = m_node ? m_node->GetNext() : m_init; return *this; } const itor operator--(int) { itor tmp = *this; m_node = m_node ? m_node->GetNext() : m_init; return tmp; } bool operator!=(const itor& it) const { return it.m_node != m_node; } bool operator==(const itor& it) const { return it.m_node == m_node; } }; class const_reverse_iterator { typedef wxModuleList list; public: typedef wxwxModuleListNode Node; typedef wxModule* value_type; typedef const_reverse_iterator itor; typedef value_type* ptr_type; typedef const value_type& const_reference; Node* m_node; Node* m_init; public: typedef const_reference reference_type; typedef const ptr_type pointer_type; const_reverse_iterator(Node* node, Node* init) : m_node(node), m_init(init) { } const_reverse_iterator() : m_node(__null), m_init(__null) { } const_reverse_iterator(const reverse_iterator& it) : m_node(it.m_node), m_init(it.m_init) { } reference_type operator*() const { return *(pointer_type)m_node->GetDataPtr(); } itor& operator++() { m_node = m_node->GetPrevious(); return *this; } const itor operator++(int) { itor tmp = *this; m_node = m_node->GetPrevious(); return tmp; } itor& operator--() { m_node = m_node ? m_node->GetNext() : m_init; return *this;} const itor operator--(int) { itor tmp = *this; m_node = m_node ? m_node->GetNext() : m_init; return tmp; } bool operator!=(const itor& it) const { return it.m_node != m_node; } bool operator==(const itor& it) const { return it.m_node == m_node; } }; explicit wxModuleList(size_type n, const_reference v = value_type()) { assign(n, v); } wxModuleList(const const_iterator& first, const const_iterator& last) { assign(first, last); } iterator begin() { return iterator(GetFirst(), GetLast()); } const_iterator begin() const { return const_iterator(GetFirst(), GetLast()); } iterator end() { return iterator(__null, GetLast()); } const_iterator end() const { return const_iterator(__null, GetLast()); } reverse_iterator rbegin() { return reverse_iterator(GetLast(), GetFirst()); } const_reverse_iterator rbegin() const { return const_reverse_iterator(GetLast(), GetFirst()); } reverse_iterator rend() { return reverse_iterator(__null, GetFirst()); } const_reverse_iterator rend() const { return const_reverse_iterator(__null, GetFirst()); } void resize(size_type n, value_type v = value_type()) { while (n < size()) pop_back(); while (n > size()) push_back(v); } size_type size() const { return GetCount(); } size_type max_size() const { return 2147483647; } bool empty() const { return IsEmpty(); } reference front() { return *begin(); } const_reference front() const { return *begin(); } reference back() { iterator tmp = end(); return *--tmp; } const_reference back() const { const_iterator tmp = end(); return *--tmp; } void push_front(const_reference v = value_type()) { Insert(GetFirst(), (const_base_reference)v); } void pop_front() { DeleteNode(GetFirst()); } void push_back(const_reference v = value_type()) { Append((const_base_reference)v); } void pop_back() { DeleteNode(GetLast()); } void assign(const_iterator first, const const_iterator& last) { clear(); for(; first != last; ++first) Append((const_base_reference)*first); } void assign(size_type n, const_reference v = value_type()) { clear(); for(size_type i = 0; i < n; ++i) Append((const_base_reference)v); } iterator insert(const iterator& it, const_reference v = value_type()) { if ( it == end() ) Append((const_base_reference)v); else Insert(it.m_node, (const_base_reference)v); iterator itprev(it); return itprev--; } void insert(const iterator& it, size_type n, const_reference v = value_type()) { for(size_type i = 0; i < n; ++i) insert(it, v); } void insert(const iterator& it, const_iterator first, const const_iterator& last) { for(; first != last; ++first) insert(it, *first); } iterator erase(const iterator& it) { iterator next = iterator(it.m_node->GetNext(), GetLast()); DeleteNode(it.m_node); return next; } iterator erase(const iterator& first, const iterator& last) { iterator next = last; if ( next != end() ) ++next; DeleteNodes(first.m_node, last.m_node); return next; } void clear() { Clear(); } void splice(const iterator& it, wxModuleList& l, const iterator& first, const iterator& last) { insert(it, first, last); l.erase(first, last); } void splice(const iterator& it, wxModuleList& l) { splice(it, l, l.begin(), l.end() ); } void splice(const iterator& it, wxModuleList& l, const iterator& first) { if ( it != first ) { insert(it, *first); l.erase(first); } } void remove(const_reference v) { DeleteObject((const_base_reference)v); } void reverse() { Reverse(); } };


typedef wxClassInfo * _wxArraywxArrayClassInfo; struct wxAssert_wxArrayClassInfo { unsigned int TypeTooBigToBeStoredInwxBaseArrayPtrVoid: sizeof(_wxArraywxArrayClassInfo) <= sizeof(wxBaseArrayPtrVoid::base_type); }; typedef int ( *CMPFUNC_wxArraywxArrayClassInfo)(_wxArraywxArrayClassInfo *pItem1, _wxArraywxArrayClassInfo *pItem2); class wxArrayClassInfo : public wxBaseArrayPtrVoid { public: wxArrayClassInfo() { } ~wxArrayClassInfo() { } wxArrayClassInfo& operator=(const wxArrayClassInfo& src) { wxBaseArrayPtrVoid* temp = (wxBaseArrayPtrVoid*) this; (*temp) = ((const wxBaseArrayPtrVoid&)src); return *this; } _wxArraywxArrayClassInfo& operator[](size_t uiIndex) const { return (_wxArraywxArrayClassInfo&)(wxBaseArrayPtrVoid::operator[](uiIndex)); } _wxArraywxArrayClassInfo& Item(size_t uiIndex) const { return (_wxArraywxArrayClassInfo&)(wxBaseArrayPtrVoid::operator[](uiIndex)); } _wxArraywxArrayClassInfo& Last() const { return (_wxArraywxArrayClassInfo&)(wxBaseArrayPtrVoid::operator[](Count() - 1)); } int Index(_wxArraywxArrayClassInfo lItem, bool bFromEnd = false) const { return wxBaseArrayPtrVoid::Index((base_type)lItem, bFromEnd); } void Add(_wxArraywxArrayClassInfo lItem, size_t nInsert = 1) { wxBaseArrayPtrVoid::Add((base_type)lItem, nInsert); } void Insert(_wxArraywxArrayClassInfo lItem, size_t uiIndex, size_t nInsert = 1) { wxBaseArrayPtrVoid::Insert((base_type)lItem, uiIndex, nInsert) ; } void RemoveAt(size_t uiIndex, size_t nRemove = 1) { wxBaseArrayPtrVoid::RemoveAt(uiIndex, nRemove); } void Remove(_wxArraywxArrayClassInfo lItem) { int iIndex = Index(lItem); if ( iIndex != (-1) ) ; else { ; return; } typedef int wxDummyCheckInt; wxBaseArrayPtrVoid::RemoveAt((size_t)iIndex); } void Sort(CMPFUNC_wxArraywxArrayClassInfo fCmp) { wxBaseArrayPtrVoid::Sort((CMPFUNC)fCmp); } private: typedef wxBaseArrayPtrVoid::iterator biterator; typedef wxBaseArrayPtrVoid::const_iterator bconst_iterator; typedef wxBaseArrayPtrVoid::value_type bvalue_type; typedef wxBaseArrayPtrVoid::const_reference bconst_reference; public: typedef _wxArraywxArrayClassInfo value_type; typedef value_type* pointer; typedef const value_type* const_pointer; typedef value_type* iterator; typedef const value_type* const_iterator; typedef value_type& reference; typedef const value_type& const_reference; typedef wxBaseArrayPtrVoid::difference_type difference_type; typedef wxBaseArrayPtrVoid::size_type size_type; class reverse_iterator { typedef _wxArraywxArrayClassInfo value_type; typedef value_type& reference; typedef value_type* pointer; typedef reverse_iterator itor; friend inline itor operator+(int o, const itor& it) { return it.m_ptr - o; } friend inline itor operator+(const itor& it, int o) { return it.m_ptr - o; } friend inline itor operator-(const itor& it, int o) { return it.m_ptr + o; } friend inline difference_type operator-(const itor& i1, const itor& i2) { return i1.m_ptr - i2.m_ptr; } public: pointer m_ptr; reverse_iterator() : m_ptr(__null) { } reverse_iterator(pointer ptr) : m_ptr(ptr) { } reverse_iterator(const itor& it) : m_ptr(it.m_ptr) { } reference operator*() const { return *m_ptr; } itor& operator++() { --m_ptr; return *this; } const itor operator++(int) { reverse_iterator tmp = *this; --m_ptr; return tmp; } itor& operator--() { ++m_ptr; return *this; } const itor operator--(int) { itor tmp = *this; ++m_ptr; return tmp; } bool operator ==(const itor& it) const { return m_ptr == it.m_ptr; } bool operator !=(const itor& it) const { return m_ptr != it.m_ptr; } }; class const_reverse_iterator { typedef _wxArraywxArrayClassInfo value_type; typedef const value_type& reference; typedef const value_type* pointer; typedef const_reverse_iterator itor; friend inline itor operator+(int o, const itor& it) { return it.m_ptr - o; } friend inline itor operator+(const itor& it, int o) { return it.m_ptr - o; } friend inline itor operator-(const itor& it, int o) { return it.m_ptr + o; } friend inline difference_type operator-(const itor& i1, const itor& i2) { return i1.m_ptr - i2.m_ptr; } public: pointer m_ptr; const_reverse_iterator() : m_ptr(__null) { } const_reverse_iterator(pointer ptr) : m_ptr(ptr) { } const_reverse_iterator(const itor& it) : m_ptr(it.m_ptr) { } const_reverse_iterator(const reverse_iterator& it) : m_ptr(it.m_ptr) { } reference operator*() const { return *m_ptr; } itor& operator++() { --m_ptr; return *this; } const itor operator++(int) { itor tmp = *this; --m_ptr; return tmp; } itor& operator--() { ++m_ptr; return *this; } const itor operator--(int) { itor tmp = *this; ++m_ptr; return tmp; } bool operator ==(const itor& it) const { return m_ptr == it.m_ptr; } bool operator !=(const itor& it) const { return m_ptr != it.m_ptr; } }; wxArrayClassInfo(size_type n, const_reference v) { assign(n, v); } wxArrayClassInfo(const_iterator first, const_iterator last) { assign(first, last); } void assign(const_iterator first, const_iterator last) { wxBaseArrayPtrVoid::assign((bconst_iterator)first, (bconst_iterator)last); } void assign(size_type n, const_reference v) { wxBaseArrayPtrVoid::assign(n, (bconst_reference)v); } reference back() { return *(end() - 1); } const_reference back() const { return *(end() - 1); } iterator begin() { return (iterator)wxBaseArrayPtrVoid::begin(); } const_iterator begin() const { return (const_iterator)wxBaseArrayPtrVoid::begin(); } size_type capacity() const { return wxBaseArrayPtrVoid::capacity(); } iterator end() { return (iterator)wxBaseArrayPtrVoid::end(); } const_iterator end() const { return (const_iterator)wxBaseArrayPtrVoid::end(); } iterator erase(iterator first, iterator last) { return (iterator)wxBaseArrayPtrVoid::erase((biterator)first, (biterator)last); } iterator erase(iterator it) { return (iterator)wxBaseArrayPtrVoid::erase((biterator)it); } reference front() { return *begin(); } const_reference front() const { return *begin(); } void insert(iterator it, size_type n, const_reference v) { wxBaseArrayPtrVoid::insert((biterator)it, n, (bconst_reference)v); } iterator insert(iterator it, const_reference v = value_type()) { return (iterator)wxBaseArrayPtrVoid::insert((biterator)it, (bconst_reference)v); } void insert(iterator it, const_iterator first, const_iterator last) { wxBaseArrayPtrVoid::insert((biterator)it, (bconst_iterator)first, (bconst_iterator)last); } void pop_back() { wxBaseArrayPtrVoid::pop_back(); } void push_back(const_reference v) { wxBaseArrayPtrVoid::push_back((bconst_reference)v); } reverse_iterator rbegin() { return reverse_iterator(end() - 1); } const_reverse_iterator rbegin() const; reverse_iterator rend() { return reverse_iterator(begin() - 1); } const_reverse_iterator rend() const; void reserve(size_type n) { wxBaseArrayPtrVoid::reserve(n); } void resize(size_type n, value_type v = value_type()) { wxBaseArrayPtrVoid::resize(n, v); } };






class wxModule : public wxObject
{
public:
    wxModule() {}
    virtual ~wxModule() {}




    bool Init() { return OnInit(); }
    void Exit() { OnExit(); }





    virtual bool OnInit() = 0;




    virtual void OnExit() = 0;

    static void RegisterModule(wxModule *module);
    static void RegisterModules();
    static bool InitializeModules();
    static void CleanUpModules() { DoCleanUpModules(m_modules); }



    static void UnregisterModule(wxModule *module);

protected:
    static wxModuleList m_modules;




    void AddDependency(wxClassInfo *dep)
    {
        if ( dep ) ; else { ; return; } typedef int wxDummyCheckInt;

        m_dependencies.Add(dep);
    }

private:


    static bool
    DoInitializeModule(wxModule *module, wxModuleList &initializedModules);




    static void DoCleanUpModules(const wxModuleList& modules);



    wxArrayClassInfo m_dependencies;


    enum
    {
        State_Registered,
        State_Initializing,
        State_Initialized
    } m_state;


    public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};
# 33 "/usr/include/wx-2.8/wx/wx.h" 2



# 1 "/usr/include/wx-2.8/wx/window.h" 1
# 24 "/usr/include/wx-2.8/wx/window.h"
# 1 "/usr/include/wx-2.8/wx/font.h" 1
# 21 "/usr/include/wx-2.8/wx/font.h"
# 1 "/usr/include/wx-2.8/wx/gdiobj.h" 1
# 23 "/usr/include/wx-2.8/wx/gdiobj.h"
class wxGDIRefData: public wxObjectRefData { };





class wxGDIObject: public wxObject
{
public:
    bool IsNull() const { return m_refData == __null; }
# 47 "/usr/include/wx-2.8/wx/gdiobj.h"
    public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};
# 22 "/usr/include/wx-2.8/wx/font.h" 2





class wxFontData;
class wxFontBase;
class wxFont;
class wxSize;
# 40 "/usr/include/wx-2.8/wx/font.h"
enum wxFontFamily
{
    wxFONTFAMILY_DEFAULT = wxDEFAULT,
    wxFONTFAMILY_DECORATIVE = wxDECORATIVE,
    wxFONTFAMILY_ROMAN = wxROMAN,
    wxFONTFAMILY_SCRIPT = wxSCRIPT,
    wxFONTFAMILY_SWISS = wxSWISS,
    wxFONTFAMILY_MODERN = wxMODERN,
    wxFONTFAMILY_TELETYPE = wxTELETYPE,
    wxFONTFAMILY_MAX,
    wxFONTFAMILY_UNKNOWN = wxFONTFAMILY_MAX
};


enum wxFontStyle
{
    wxFONTSTYLE_NORMAL = wxNORMAL,
    wxFONTSTYLE_ITALIC = wxITALIC,
    wxFONTSTYLE_SLANT = wxSLANT,
    wxFONTSTYLE_MAX
};


enum wxFontWeight
{
    wxFONTWEIGHT_NORMAL = wxNORMAL,
    wxFONTWEIGHT_LIGHT = wxLIGHT,
    wxFONTWEIGHT_BOLD = wxBOLD,
    wxFONTWEIGHT_MAX
};


enum
{

    wxFONTFLAG_DEFAULT = 0,


    wxFONTFLAG_ITALIC = 1 << 0,
    wxFONTFLAG_SLANT = 1 << 1,


    wxFONTFLAG_LIGHT = 1 << 2,
    wxFONTFLAG_BOLD = 1 << 3,


    wxFONTFLAG_ANTIALIASED = 1 << 4,
    wxFONTFLAG_NOT_ANTIALIASED = 1 << 5,


    wxFONTFLAG_UNDERLINED = 1 << 6,
    wxFONTFLAG_STRIKETHROUGH = 1 << 7,


    wxFONTFLAG_MASK = wxFONTFLAG_ITALIC |
                      wxFONTFLAG_SLANT |
                      wxFONTFLAG_LIGHT |
                      wxFONTFLAG_BOLD |
                      wxFONTFLAG_ANTIALIASED |
                      wxFONTFLAG_NOT_ANTIALIASED |
                      wxFONTFLAG_UNDERLINED |
                      wxFONTFLAG_STRIKETHROUGH
};





class wxNativeFontInfo;

class wxFontBase : public wxGDIObject
{
public:

    virtual ~wxFontBase();


    static wxFont *New(
        int pointSize,
        int family,
        int style,
        int weight,
        bool underlined = false,
        const wxString& face = wxEmptyString,
        wxFontEncoding encoding = wxFONTENCODING_DEFAULT);



    static wxFont *New(int pointSize,
                       wxFontFamily family,
                       int flags = wxFONTFLAG_DEFAULT,
                       const wxString& face = wxEmptyString,
                       wxFontEncoding encoding = wxFONTENCODING_DEFAULT);


    static wxFont *New(
        const wxSize& pixelSize,
        int family,
        int style,
        int weight,
        bool underlined = false,
        const wxString& face = wxEmptyString,
        wxFontEncoding encoding = wxFONTENCODING_DEFAULT);



    static wxFont *New(const wxSize& pixelSize,
                       wxFontFamily family,
                       int flags = wxFONTFLAG_DEFAULT,
                       const wxString& face = wxEmptyString,
                       wxFontEncoding encoding = wxFONTENCODING_DEFAULT);


    static wxFont *New(const wxNativeFontInfo& nativeFontDesc);


    static wxFont *New(const wxString& strNativeFontDesc);


    bool Ok() const { return IsOk(); }
    bool IsOk() const { return m_refData != __null; }


    bool operator == (const wxFont& font) const;
    bool operator != (const wxFont& font) const;


    virtual int GetPointSize() const = 0;
    virtual wxSize GetPixelSize() const;
    virtual bool IsUsingSizeInPixels() const;
    virtual int GetFamily() const = 0;
    virtual int GetStyle() const = 0;
    virtual int GetWeight() const = 0;
    virtual bool GetUnderlined() const = 0;
    virtual wxString GetFaceName() const = 0;
    virtual wxFontEncoding GetEncoding() const = 0;
    virtual const wxNativeFontInfo *GetNativeFontInfo() const = 0;

    virtual bool IsFixedWidth() const;

    wxString GetNativeFontInfoDesc() const;
    wxString GetNativeFontInfoUserDesc() const;


    virtual void SetPointSize( int pointSize ) = 0;
    virtual void SetPixelSize( const wxSize& pixelSize );
    virtual void SetFamily( int family ) = 0;
    virtual void SetStyle( int style ) = 0;
    virtual void SetWeight( int weight ) = 0;
    virtual void SetUnderlined( bool underlined ) = 0;
    virtual void SetEncoding(wxFontEncoding encoding) = 0;
    virtual bool SetFaceName( const wxString& faceName );
    void SetNativeFontInfo(const wxNativeFontInfo& info)
        { DoSetNativeFontInfo(info); }

    bool SetNativeFontInfo(const wxString& info);
    bool SetNativeFontInfoUserDesc(const wxString& info);



    wxString GetFamilyString() const;
    wxString GetStyleString() const;
    wxString GetWeightString() const;


    virtual void SetNoAntiAliasing( bool = true ) { }
    virtual bool GetNoAntiAliasing() const { return false; }



    static wxFontEncoding GetDefaultEncoding() { return ms_encodingDefault; }
    static void SetDefaultEncoding(wxFontEncoding encoding);

protected:

    virtual void DoSetNativeFontInfo(const wxNativeFontInfo& info);

private:




    static wxFontEncoding ms_encodingDefault;
};
# 233 "/usr/include/wx-2.8/wx/font.h"
# 1 "/usr/include/wx-2.8/wx/gtk/font.h" 1
# 17 "/usr/include/wx-2.8/wx/gtk/font.h"
class wxFont : public wxFontBase
{
public:
    wxFont() { }


    wxFont(const wxString& fontname)
    {
        Create(fontname);
    }

    wxFont(const wxNativeFontInfo& info);

    wxFont(int size,
           int family,
           int style,
           int weight,
           bool underlined = false,
           const wxString& face = wxEmptyString,
           wxFontEncoding encoding = wxFONTENCODING_DEFAULT)
    {
        (void)Create(size, family, style, weight, underlined, face, encoding);
    }

    bool Create(int size,
                int family,
                int style,
                int weight,
                bool underlined = false,
                const wxString& face = wxEmptyString,
                wxFontEncoding encoding = wxFONTENCODING_DEFAULT);


    bool Create(const wxString& fontname);

    virtual ~wxFont();


    virtual int GetPointSize() const;
    virtual int GetFamily() const;
    virtual int GetStyle() const;
    virtual int GetWeight() const;
    virtual wxString GetFaceName() const;
    virtual bool GetUnderlined() const;
    virtual wxFontEncoding GetEncoding() const;
    virtual const wxNativeFontInfo *GetNativeFontInfo() const;
    virtual bool IsFixedWidth() const;

    virtual void SetPointSize( int pointSize );
    virtual void SetFamily( int family );
    virtual void SetStyle( int style );
    virtual void SetWeight( int weight );
    virtual bool SetFaceName( const wxString& faceName );
    virtual void SetUnderlined( bool underlined );
    virtual void SetEncoding(wxFontEncoding encoding);

    virtual void SetNoAntiAliasing( bool no = true );
    virtual bool GetNoAntiAliasing() const ;


    void Unshare();



protected:
    virtual void DoSetNativeFontInfo( const wxNativeFontInfo& info );


    void Init();

    virtual wxObjectRefData* CreateRefData() const;
    virtual wxObjectRefData* CloneRefData(const wxObjectRefData* data) const;

private:
    public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};
# 234 "/usr/include/wx-2.8/wx/font.h" 2
# 25 "/usr/include/wx-2.8/wx/window.h" 2
# 1 "/usr/include/wx-2.8/wx/colour.h" 1
# 19 "/usr/include/wx-2.8/wx/colour.h"
class wxColour;
# 40 "/usr/include/wx-2.8/wx/colour.h"
const unsigned char wxALPHA_TRANSPARENT = 0;
const unsigned char wxALPHA_OPAQUE = 0xff;






# 1 "/usr/include/wx-2.8/wx/variant.h" 1
# 26 "/usr/include/wx-2.8/wx/variant.h"
# 1 "/usr/include/wx-2.8/wx/datetime.h" 1
# 26 "/usr/include/wx-2.8/wx/datetime.h"
# 1 "/usr/lib/gcc/i686-linux-gnu/4.4.5/include-fixed/limits.h" 1 3 4
# 27 "/usr/include/wx-2.8/wx/datetime.h" 2



class wxDateTime;
class wxTimeSpan;
class wxDateSpan;
# 128 "/usr/include/wx-2.8/wx/datetime.h"
class wxDateTime;

extern const wxChar* wxDefaultDateTimeFormat;
extern const wxChar* wxDefaultTimeSpanFormat;
extern const wxDateTime wxDefaultDateTime;







class wxDateTime
{
public:
# 151 "/usr/include/wx-2.8/wx/datetime.h"
    typedef unsigned short wxDateTime_t;





    enum TZ
    {

        Local,






        GMT_12, GMT_11, GMT_10, GMT_9, GMT_8, GMT_7,
        GMT_6, GMT_5, GMT_4, GMT_3, GMT_2, GMT_1,
        GMT0,
        GMT1, GMT2, GMT3, GMT4, GMT5, GMT6,
        GMT7, GMT8, GMT9, GMT10, GMT11, GMT12, GMT13,






        WET = GMT0,
        WEST = GMT1,
        CET = GMT1,
        CEST = GMT2,
        EET = GMT2,
        EEST = GMT3,
        MSK = GMT3,
        MSD = GMT4,


        AST = GMT_4,
        ADT = GMT_3,
        EST = GMT_5,
        EDT = GMT_4,
        CST = GMT_6,
        CDT = GMT_5,
        MST = GMT_7,
        MDT = GMT_6,
        PST = GMT_8,
        PDT = GMT_7,
        HST = GMT_10,
        AKST = GMT_9,
        AKDT = GMT_8,



        A_WST = GMT8,
        A_CST = GMT13 + 1,
        A_EST = GMT10,
        A_ESST = GMT11,


        NZST = GMT12,
        NZDT = GMT13,





        UTC = GMT0
    };





    enum Calendar
    {
        Gregorian,
        Julian


    };
# 241 "/usr/include/wx-2.8/wx/datetime.h"
    enum GregorianAdoption
    {
        Gr_Unknown,
        Gr_Standard,

        Gr_Alaska,
        Gr_Albania,

        Gr_Austria = Gr_Unknown,
        Gr_Austria_Brixen,
        Gr_Austria_Salzburg = Gr_Austria_Brixen,
        Gr_Austria_Tyrol = Gr_Austria_Brixen,
        Gr_Austria_Carinthia,
        Gr_Austria_Styria = Gr_Austria_Carinthia,

        Gr_Belgium,

        Gr_Bulgaria = Gr_Unknown,
        Gr_Bulgaria_1,
        Gr_Bulgaria_2,
        Gr_Bulgaria_3,

        Gr_Canada = Gr_Unknown,


        Gr_China = Gr_Unknown,
        Gr_China_1,
        Gr_China_2,

        Gr_Czechoslovakia,
        Gr_Denmark,
        Gr_Egypt,
        Gr_Estonia,
        Gr_Finland,

        Gr_France,
        Gr_France_Alsace,
        Gr_France_Lorraine,
        Gr_France_Strasbourg,

        Gr_Germany = Gr_Unknown,
        Gr_Germany_Catholic,
        Gr_Germany_Prussia,
        Gr_Germany_Protestant,

        Gr_GreatBritain,

        Gr_Greece,
        Gr_Hungary,
        Gr_Ireland = Gr_GreatBritain,
        Gr_Italy = Gr_Standard,

        Gr_Japan = Gr_Unknown,
        Gr_Japan_1,
        Gr_Japan_2,
        Gr_Japan_3,

        Gr_Latvia,
        Gr_Lithuania,
        Gr_Luxemburg,
        Gr_Netherlands = Gr_Belgium,






        Gr_Netherlands_Groningen,
        Gr_Netherlands_Gelderland,
        Gr_Netherlands_Utrecht,
        Gr_Netherlands_Friesland,

        Gr_Norway = Gr_Denmark,
        Gr_Poland = Gr_Standard,
        Gr_Portugal = Gr_Standard,
        Gr_Romania,
        Gr_Russia,
        Gr_Scotland = Gr_GreatBritain,
        Gr_Spain = Gr_Standard,
# 338 "/usr/include/wx-2.8/wx/datetime.h"
        Gr_Sweden = Gr_Finland,

        Gr_Switzerland = Gr_Unknown,
        Gr_Switzerland_Catholic,
        Gr_Switzerland_Protestant,

        Gr_Turkey,
        Gr_USA = Gr_GreatBritain,
        Gr_Wales = Gr_GreatBritain,
        Gr_Yugoslavia
    };
# 361 "/usr/include/wx-2.8/wx/datetime.h"
    enum Country
    {
        Country_Unknown,
        Country_Default,







        Country_WesternEurope_Start,
        Country_EEC = Country_WesternEurope_Start,
        France,
        Germany,
        UK,
        Country_WesternEurope_End = UK,

        Russia,
        USA
    };

    enum Month
    {
        Jan, Feb, Mar, Apr, May, Jun, Jul, Aug, Sep, Oct, Nov, Dec, Inv_Month
    };


    enum WeekDay
    {
        Sun, Mon, Tue, Wed, Thu, Fri, Sat, Inv_WeekDay
    };


    enum Year
    {
        Inv_Year = (-32767 - 1)
    };


    enum NameFlags
    {
        Name_Full = 0x01,
        Name_Abbr = 0x02
    };


    enum WeekFlags
    {
        Default_First,
        Monday_First,
        Sunday_First
    };






    class TimeZone
    {
    public:
        TimeZone(TZ tz);



        TimeZone(wxDateTime_t offset = 0) { m_offset = offset; }



        static TimeZone Make(long offset)
        {
            TimeZone tz;
            tz.m_offset = offset;
            return tz;
        }


        long GetOffset() const { return m_offset; }

    private:

        long m_offset;
    };
# 453 "/usr/include/wx-2.8/wx/datetime.h"
    struct Tm
    {
        wxDateTime_t msec, sec, min, hour, mday;
        Month mon;
        int year;


        Tm();


        Tm(const struct tm& tm, const TimeZone& tz);


        bool IsValid() const;


        WeekDay GetWeekDay()
        {
            if ( wday == Inv_WeekDay )
                ComputeWeekDay();

            return (WeekDay)wday;
        }


        void AddMonths(int monDiff);


        void AddDays(int dayDiff);

    private:

        void ComputeWeekDay();


        TimeZone m_tz;



        wxDateTime_t wday, yday;
    };





    static void SetCountry(Country country);

    static Country GetCountry();



    static bool IsWestEuropeanCountry(Country country = Country_Default);


    static int GetCurrentYear(Calendar cal = Gregorian);





    static int ConvertYearToBC(int year);


    static Month GetCurrentMonth(Calendar cal = Gregorian);


    static bool IsLeapYear(int year = Inv_Year, Calendar cal = Gregorian);


    static int GetCentury(int year);



    static wxDateTime_t GetNumberOfDays(int year, Calendar cal = Gregorian);



    static wxDateTime_t GetNumberOfDays(Month month,
                                        int year = Inv_Year,
                                        Calendar cal = Gregorian);



    static wxString GetMonthName(Month month,
                                 NameFlags flags = Name_Full);



    static wxString GetWeekDayName(WeekDay weekday,
                                   NameFlags flags = Name_Full);


    static void GetAmPmStrings(wxString *am, wxString *pm);


    static bool IsDSTApplicable(int year = Inv_Year,
                                Country country = Country_Default);




    static wxDateTime GetBeginDST(int year = Inv_Year,
                                  Country country = Country_Default);



    static wxDateTime GetEndDST(int year = Inv_Year,
                                Country country = Country_Default);


    static inline wxDateTime Now();



    static wxDateTime UNow();



    static inline wxDateTime Today();







    wxDateTime() { m_time = wxLongLong((wxInt32)(2147483647 * 2U + 1U), (2147483647 * 2U + 1U)); }




    inline wxDateTime(time_t timet);


    inline wxDateTime(const struct tm& tm);

    inline wxDateTime(const Tm& tm);


    inline wxDateTime(double jdn);


    inline wxDateTime(wxDateTime_t hour,
                      wxDateTime_t minute = 0,
                      wxDateTime_t second = 0,
                      wxDateTime_t millisec = 0);

    inline wxDateTime(wxDateTime_t day,
                      Month month,
                      int year = Inv_Year,
                      wxDateTime_t hour = 0,
                      wxDateTime_t minute = 0,
                      wxDateTime_t second = 0,
                      wxDateTime_t millisec = 0);
# 619 "/usr/include/wx-2.8/wx/datetime.h"
    inline wxDateTime& SetToCurrent();




    inline wxDateTime& Set(time_t timet);



    wxDateTime& Set(const struct tm& tm);


    inline wxDateTime& Set(const Tm& tm);


    wxDateTime& Set(double jdn);


    wxDateTime& Set(wxDateTime_t hour,
                    wxDateTime_t minute = 0,
                    wxDateTime_t second = 0,
                    wxDateTime_t millisec = 0);



    wxDateTime& Set(wxDateTime_t day,
                    Month month,
                    int year = Inv_Year,
                    wxDateTime_t hour = 0,
                    wxDateTime_t minute = 0,
                    wxDateTime_t second = 0,
                    wxDateTime_t millisec = 0);


    wxDateTime& ResetTime();




    wxDateTime GetDateOnly() const;






    wxDateTime& SetYear(int year);

    wxDateTime& SetMonth(Month month);

    wxDateTime& SetDay(wxDateTime_t day);

    wxDateTime& SetHour(wxDateTime_t hour);

    wxDateTime& SetMinute(wxDateTime_t minute);

    wxDateTime& SetSecond(wxDateTime_t second);

    wxDateTime& SetMillisecond(wxDateTime_t millisecond);


    wxDateTime& operator=(time_t timet) { return Set(timet); }


    wxDateTime& operator=(const struct tm& tm) { return Set(tm); }


    wxDateTime& operator=(const Tm& tm) { return Set(tm); }
# 696 "/usr/include/wx-2.8/wx/datetime.h"
    wxDateTime& SetToWeekDayInSameWeek(WeekDay weekday,
                                       WeekFlags flags = Monday_First);
    inline wxDateTime GetWeekDayInSameWeek(WeekDay weekday,
                                           WeekFlags flags = Monday_First) const;


    wxDateTime& SetToNextWeekDay(WeekDay weekday);
    inline wxDateTime GetNextWeekDay(WeekDay weekday) const;


    wxDateTime& SetToPrevWeekDay(WeekDay weekday);
    inline wxDateTime GetPrevWeekDay(WeekDay weekday) const;





    bool SetToWeekDay(WeekDay weekday,
                      int n = 1,
                      Month month = Inv_Month,
                      int year = Inv_Year);
    inline wxDateTime GetWeekDay(WeekDay weekday,
                                 int n = 1,
                                 Month month = Inv_Month,
                                 int year = Inv_Year) const;


    inline bool SetToLastWeekDay(WeekDay weekday,
                                 Month month = Inv_Month,
                                 int year = Inv_Year);
    inline wxDateTime GetLastWeekDay(WeekDay weekday,
                                     Month month = Inv_Month,
                                     int year = Inv_Year);
# 737 "/usr/include/wx-2.8/wx/datetime.h"
    bool SetToTheWeek(wxDateTime_t numWeek, WeekDay weekday = Mon, WeekFlags flags = Monday_First) __attribute__ ((deprecated));


    wxDateTime GetWeek(wxDateTime_t numWeek, WeekDay weekday = Mon, WeekFlags flags = Monday_First) const __attribute__ ((deprecated));






    static wxDateTime SetToWeekOfYear(int year,
                                      wxDateTime_t numWeek,
                                      WeekDay weekday = Mon);



    wxDateTime& SetToLastMonthDay(Month month = Inv_Month,
                                  int year = Inv_Year);
    inline wxDateTime GetLastMonthDay(Month month = Inv_Month,
                                      int year = Inv_Year) const;


    wxDateTime& SetToYearDay(wxDateTime_t yday);
    inline wxDateTime GetYearDay(wxDateTime_t yday) const;
# 786 "/usr/include/wx-2.8/wx/datetime.h"
    double GetJulianDayNumber() const;
    double GetJDN() const { return GetJulianDayNumber(); }




    double GetModifiedJulianDayNumber() const { return GetJDN() - 2400000.5; }
    double GetMJD() const { return GetModifiedJulianDayNumber(); }


    double GetRataDie() const;
# 815 "/usr/include/wx-2.8/wx/datetime.h"
    inline wxDateTime ToTimezone(const TimeZone& tz, bool noDST = false) const;
    wxDateTime& MakeTimezone(const TimeZone& tz, bool noDST = false);



    inline wxDateTime FromTimezone(const TimeZone& tz, bool noDST = false) const;
    wxDateTime& MakeFromTimezone(const TimeZone& tz, bool noDST = false);


    wxDateTime ToUTC(bool noDST = false) const { return ToTimezone(UTC, noDST); }
    wxDateTime& MakeUTC(bool noDST = false) { return MakeTimezone(UTC, noDST); }

    wxDateTime ToGMT(bool noDST = false) const { return ToUTC(noDST); }
    wxDateTime& MakeGMT(bool noDST = false) { return MakeUTC(noDST); }

    wxDateTime FromUTC(bool noDST = false) const
        { return FromTimezone(UTC, noDST); }
    wxDateTime& MakeFromUTC(bool noDST = false)
        { return MakeFromTimezone(UTC, noDST); }






    int IsDST(Country country = Country_Default) const;
# 851 "/usr/include/wx-2.8/wx/datetime.h"
    inline bool IsValid() const { return m_time != wxDefaultDateTime.m_time; }






    Tm GetTm(const TimeZone& tz = Local) const;



    inline time_t GetTicks() const;


    int GetCentury(const TimeZone& tz = Local) const
            { return GetCentury(GetYear(tz)); }

    int GetYear(const TimeZone& tz = Local) const
            { return GetTm(tz).year; }

    Month GetMonth(const TimeZone& tz = Local) const
            { return (Month)GetTm(tz).mon; }

    wxDateTime_t GetDay(const TimeZone& tz = Local) const
            { return GetTm(tz).mday; }

    WeekDay GetWeekDay(const TimeZone& tz = Local) const
            { return GetTm(tz).GetWeekDay(); }

    wxDateTime_t GetHour(const TimeZone& tz = Local) const
            { return GetTm(tz).hour; }

    wxDateTime_t GetMinute(const TimeZone& tz = Local) const
            { return GetTm(tz).min; }

    wxDateTime_t GetSecond(const TimeZone& tz = Local) const
            { return GetTm(tz).sec; }

    wxDateTime_t GetMillisecond(const TimeZone& tz = Local) const
            { return GetTm(tz).msec; }


    wxDateTime_t GetDayOfYear(const TimeZone& tz = Local) const;


    wxDateTime_t GetWeekOfYear(WeekFlags flags = Monday_First,
                               const TimeZone& tz = Local) const;


    wxDateTime_t GetWeekOfMonth(WeekFlags flags = Monday_First,
                                const TimeZone& tz = Local) const;



    bool IsWorkDay(Country country = Country_Default) const;







    bool IsGregorianDate(GregorianAdoption country = Gr_Standard) const;





    wxDateTime& SetFromDOS(unsigned long ddt);


    unsigned long GetAsDOS() const;





    inline bool IsEqualTo(const wxDateTime& datetime) const;


    inline bool IsEarlierThan(const wxDateTime& datetime) const;


    inline bool IsLaterThan(const wxDateTime& datetime) const;


    inline bool IsStrictlyBetween(const wxDateTime& t1,
                                  const wxDateTime& t2) const;


    inline bool IsBetween(const wxDateTime& t1, const wxDateTime& t2) const;


    inline bool IsSameDate(const wxDateTime& dt) const;


    inline bool IsSameTime(const wxDateTime& dt) const;


    inline bool IsEqualUpTo(const wxDateTime& dt, const wxTimeSpan& ts) const;

    inline bool operator<(const wxDateTime& dt) const
    {
        ;
        return GetValue() < dt.GetValue();
    }

    inline bool operator<=(const wxDateTime& dt) const
    {
        ;
        return GetValue() <= dt.GetValue();
    }

    inline bool operator>(const wxDateTime& dt) const
    {
        ;
        return GetValue() > dt.GetValue();
    }

    inline bool operator>=(const wxDateTime& dt) const
    {
        ;
        return GetValue() >= dt.GetValue();
    }

    inline bool operator==(const wxDateTime& dt) const
    {
        ;
        return GetValue() == dt.GetValue();
    }

    inline bool operator!=(const wxDateTime& dt) const
    {
        ;
        return GetValue() != dt.GetValue();
    }





    inline wxDateTime Add(const wxTimeSpan& diff) const;

    inline wxDateTime& Add(const wxTimeSpan& diff);

    inline wxDateTime& operator+=(const wxTimeSpan& diff);
    inline wxDateTime operator+(const wxTimeSpan& ts) const
    {
        wxDateTime dt(*this);
        dt.Add(ts);
        return dt;
    }


    inline wxDateTime Subtract(const wxTimeSpan& diff) const;

    inline wxDateTime& Subtract(const wxTimeSpan& diff);

    inline wxDateTime& operator-=(const wxTimeSpan& diff);
    inline wxDateTime operator-(const wxTimeSpan& ts) const
    {
        wxDateTime dt(*this);
        dt.Subtract(ts);
        return dt;
    }


    inline wxDateTime Add(const wxDateSpan& diff) const;

    wxDateTime& Add(const wxDateSpan& diff);

    inline wxDateTime& operator+=(const wxDateSpan& diff);
    inline wxDateTime operator+(const wxDateSpan& ds) const
    {
        wxDateTime dt(*this);
        dt.Add(ds);
        return dt;
    }


    inline wxDateTime Subtract(const wxDateSpan& diff) const;

    inline wxDateTime& Subtract(const wxDateSpan& diff);

    inline wxDateTime& operator-=(const wxDateSpan& diff);
    inline wxDateTime operator-(const wxDateSpan& ds) const
    {
        wxDateTime dt(*this);
        dt.Subtract(ds);
        return dt;
    }


    inline wxTimeSpan Subtract(const wxDateTime& dt) const;
    inline wxTimeSpan operator-(const wxDateTime& dt2) const;
# 1054 "/usr/include/wx-2.8/wx/datetime.h"
    const wxChar *ParseRfc822Date(const wxChar* date);




    const wxChar *ParseFormat(const wxChar *date,
                              const wxChar *format = wxDefaultDateTimeFormat,
                              const wxDateTime& dateDef = wxDefaultDateTime);


    const wxChar *ParseDateTime(const wxChar *datetime);


    const wxChar *ParseDate(const wxChar *date);

    const wxChar *ParseTime(const wxChar *time);





    wxString Format(const wxChar *format = wxDefaultDateTimeFormat,
                    const TimeZone& tz = Local) const;

    wxString FormatDate() const { return Format(L"%x"); }

    wxString FormatTime() const { return Format(L"%X"); }


    wxString FormatISODate() const { return Format(L"%Y-%m-%d"); }


    wxString FormatISOTime() const { return Format(L"%H:%M:%S"); }





    wxDateTime(const wxLongLong& time) { m_time = time; }


    inline wxLongLong GetValue() const;


    static time_t GetTimeNow() { return time((time_t *)__null); }


    static struct tm *GetTmNow()
    {
        static struct tm l_CurrentTime;
        return GetTmNow(&l_CurrentTime);
    }


    static struct tm *GetTmNow(struct tm *tmstruct);

private:



    static Country ms_country;




    static const long TIME_T_FACTOR;



    inline bool IsInStdRange() const;




    wxLongLong m_time;
};







class wxTimeSpan
{
public:




    static wxTimeSpan Milliseconds(wxLongLong ms) { return wxTimeSpan(0, 0, 0, ms); }
    static wxTimeSpan Millisecond() { return Milliseconds(1); }


    static wxTimeSpan Seconds(wxLongLong sec) { return wxTimeSpan(0, 0, sec); }
    static wxTimeSpan Second() { return Seconds(1); }


    static wxTimeSpan Minutes(long min) { return wxTimeSpan(0, min, 0 ); }
    static wxTimeSpan Minute() { return Minutes(1); }


    static wxTimeSpan Hours(long hours) { return wxTimeSpan(hours, 0, 0); }
    static wxTimeSpan Hour() { return Hours(1); }


    static wxTimeSpan Days(long days) { return Hours(24 * days); }
    static wxTimeSpan Day() { return Days(1); }


    static wxTimeSpan Weeks(long days) { return Days(7 * days); }
    static wxTimeSpan Week() { return Weeks(1); }


    wxTimeSpan() { }




    inline wxTimeSpan(long hours,
                      long minutes = 0,
                      wxLongLong seconds = 0,
                      wxLongLong milliseconds = 0);
# 1186 "/usr/include/wx-2.8/wx/datetime.h"
    inline wxTimeSpan Add(const wxTimeSpan& diff) const;

    inline wxTimeSpan& Add(const wxTimeSpan& diff);

    wxTimeSpan& operator+=(const wxTimeSpan& diff) { return Add(diff); }
    inline wxTimeSpan operator+(const wxTimeSpan& ts) const
    {
        return wxTimeSpan(GetValue() + ts.GetValue());
    }


    inline wxTimeSpan Subtract(const wxTimeSpan& diff) const;

    inline wxTimeSpan& Subtract(const wxTimeSpan& diff);

    wxTimeSpan& operator-=(const wxTimeSpan& diff) { return Subtract(diff); }
    inline wxTimeSpan operator-(const wxTimeSpan& ts)
    {
        return wxTimeSpan(GetValue() - ts.GetValue());
    }


    inline wxTimeSpan Multiply(int n) const;

    inline wxTimeSpan& Multiply(int n);

    wxTimeSpan& operator*=(int n) { return Multiply(n); }
    inline wxTimeSpan operator*(int n) const
    {
        return wxTimeSpan(*this).Multiply(n);
    }


    wxTimeSpan Negate() const { return wxTimeSpan(-GetValue()); }

    wxTimeSpan& Neg() { m_diff = -GetValue(); return *this; }

    wxTimeSpan& operator-() { return Neg(); }



    inline wxTimeSpan Abs() const;
# 1236 "/usr/include/wx-2.8/wx/datetime.h"
    bool IsNull() const { return m_diff == 0l; }

    bool operator!() const { return !IsNull(); }


    bool IsPositive() const { return m_diff > 0l; }


    bool IsNegative() const { return m_diff < 0l; }


    inline bool IsEqualTo(const wxTimeSpan& ts) const;



    inline bool IsLongerThan(const wxTimeSpan& ts) const;



    bool IsShorterThan(const wxTimeSpan& t) const { return !IsLongerThan(t); }

    inline bool operator<(const wxTimeSpan &ts) const
    {
        return GetValue() < ts.GetValue();
    }

    inline bool operator<=(const wxTimeSpan &ts) const
    {
        return GetValue() <= ts.GetValue();
    }

    inline bool operator>(const wxTimeSpan &ts) const
    {
        return GetValue() > ts.GetValue();
    }

    inline bool operator>=(const wxTimeSpan &ts) const
    {
        return GetValue() >= ts.GetValue();
    }

    inline bool operator==(const wxTimeSpan &ts) const
    {
        return GetValue() == ts.GetValue();
    }

    inline bool operator!=(const wxTimeSpan &ts) const
    {
        return GetValue() != ts.GetValue();
    }





    inline int GetWeeks() const;

    inline int GetDays() const;

    inline int GetHours() const;

    inline int GetMinutes() const;

    inline wxLongLong GetSeconds() const;

    wxLongLong GetMilliseconds() const { return m_diff; }
# 1312 "/usr/include/wx-2.8/wx/datetime.h"
    wxString Format(const wxChar *format = wxDefaultTimeSpanFormat) const;





    wxTimeSpan(const wxLongLong& diff) { m_diff = diff; }


    wxLongLong GetValue() const { return m_diff; }

private:

    wxLongLong m_diff;
};
# 1363 "/usr/include/wx-2.8/wx/datetime.h"
class wxDateSpan
{
public:




    wxDateSpan(int years = 0, int months = 0, int weeks = 0, int days = 0)
    {
        m_years = years;
        m_months = months;
        m_weeks = weeks;
        m_days = days;
    }


    static wxDateSpan Days(int days) { return wxDateSpan(0, 0, 0, days); }
    static wxDateSpan Day() { return Days(1); }


    static wxDateSpan Weeks(int weeks) { return wxDateSpan(0, 0, weeks, 0); }
    static wxDateSpan Week() { return Weeks(1); }


    static wxDateSpan Months(int mon) { return wxDateSpan(0, mon, 0, 0); }
    static wxDateSpan Month() { return Months(1); }


    static wxDateSpan Years(int years) { return wxDateSpan(years, 0, 0, 0); }
    static wxDateSpan Year() { return Years(1); }
# 1402 "/usr/include/wx-2.8/wx/datetime.h"
    wxDateSpan& SetYears(int n) { m_years = n; return *this; }

    wxDateSpan& SetMonths(int n) { m_months = n; return *this; }

    wxDateSpan& SetWeeks(int n) { m_weeks = n; return *this; }

    wxDateSpan& SetDays(int n) { m_days = n; return *this; }


    int GetYears() const { return m_years; }

    int GetMonths() const { return m_months; }

    int GetWeeks() const { return m_weeks; }

    int GetDays() const { return m_days; }

    int GetTotalDays() const { return 7*m_weeks + m_days; }





    inline wxDateSpan Add(const wxDateSpan& other) const;

    inline wxDateSpan& Add(const wxDateSpan& other);

    inline wxDateSpan& operator+=(const wxDateSpan& other);
    inline wxDateSpan operator+(const wxDateSpan& ds) const
    {
        return wxDateSpan(GetYears() + ds.GetYears(),
                          GetMonths() + ds.GetMonths(),
                          GetWeeks() + ds.GetWeeks(),
                          GetDays() + ds.GetDays());
    }


    inline wxDateSpan Subtract(const wxDateSpan& other) const;

    inline wxDateSpan& Subtract(const wxDateSpan& other);

    inline wxDateSpan& operator-=(const wxDateSpan& other);
    inline wxDateSpan operator-(const wxDateSpan& ds) const
    {
        return wxDateSpan(GetYears() - ds.GetYears(),
                          GetMonths() - ds.GetMonths(),
                          GetWeeks() - ds.GetWeeks(),
                          GetDays() - ds.GetDays());
    }


    inline wxDateSpan Negate() const;

    inline wxDateSpan& Neg();

    wxDateSpan& operator-() { return Neg(); }


    inline wxDateSpan Multiply(int factor) const;

    inline wxDateSpan& Multiply(int factor);

    inline wxDateSpan& operator*=(int factor) { return Multiply(factor); }
    inline wxDateSpan operator*(int n) const
    {
        return wxDateSpan(*this).Multiply(n);
    }


    inline bool operator==(const wxDateSpan& ds) const
    {
        return GetYears() == ds.GetYears() &&
               GetMonths() == ds.GetMonths() &&
               GetTotalDays() == ds.GetTotalDays();
    }

    inline bool operator!=(const wxDateSpan& ds) const
    {
        return !(*this == ds);
    }

private:
    int m_years,
        m_months,
        m_weeks,
        m_days;
};





typedef wxDateTime _wxObjArraywxDateTimeArray; typedef int ( *CMPFUNC_wxObjArraywxDateTimeArray)(_wxObjArraywxDateTimeArray **pItem1, _wxObjArraywxDateTimeArray **pItem2); class wxDateTimeArray : protected wxArrayPtrVoid { typedef int ( *CMPFUNCwxArrayPtrVoid)(void **pItem1, void **pItem2); typedef wxArrayPtrVoid base_array; public: wxDateTimeArray() { } wxDateTimeArray(const wxDateTimeArray& src); wxDateTimeArray& operator=(const wxDateTimeArray& src); ~wxDateTimeArray(); void Alloc(size_t count) { reserve(count); } size_t GetCount() const { return base_array::size(); } size_t size() const { return base_array::size(); } bool IsEmpty() const { return base_array::empty(); } bool empty() const { return base_array::empty(); } size_t Count() const { return base_array::size(); } void Shrink() { wxArrayPtrVoid::Shrink(); } _wxObjArraywxDateTimeArray& operator[](size_t uiIndex) const { return *(_wxObjArraywxDateTimeArray*)wxArrayPtrVoid::operator[](uiIndex); } _wxObjArraywxDateTimeArray& Item(size_t uiIndex) const { return *(_wxObjArraywxDateTimeArray*)wxArrayPtrVoid::operator[](uiIndex); } _wxObjArraywxDateTimeArray& Last() const { return *(_wxObjArraywxDateTimeArray*)(wxArrayPtrVoid::operator[](size() - 1)); } int Index(const _wxObjArraywxDateTimeArray& lItem, bool bFromEnd = false) const; void Add(const _wxObjArraywxDateTimeArray& lItem, size_t nInsert = 1); void Add(const _wxObjArraywxDateTimeArray* pItem) { wxArrayPtrVoid::push_back((_wxObjArraywxDateTimeArray*)pItem); } void push_back(const _wxObjArraywxDateTimeArray* pItem) { wxArrayPtrVoid::push_back((_wxObjArraywxDateTimeArray*)pItem); } void push_back(const _wxObjArraywxDateTimeArray& lItem) { Add(lItem); } void Insert(const _wxObjArraywxDateTimeArray& lItem, size_t uiIndex, size_t nInsert = 1); void Insert(const _wxObjArraywxDateTimeArray* pItem, size_t uiIndex) { wxArrayPtrVoid::insert(begin() + uiIndex, (_wxObjArraywxDateTimeArray*)pItem); } void Empty() { DoEmpty(); wxArrayPtrVoid::clear(); } void Clear() { DoEmpty(); wxArrayPtrVoid::clear(); } _wxObjArraywxDateTimeArray* Detach(size_t uiIndex) { _wxObjArraywxDateTimeArray* p = (_wxObjArraywxDateTimeArray*)wxArrayPtrVoid::operator[](uiIndex); wxArrayPtrVoid::erase(begin() + uiIndex); return p; } void RemoveAt(size_t uiIndex, size_t nRemove = 1); void Sort(CMPFUNC_wxObjArraywxDateTimeArray fCmp) { wxArrayPtrVoid::Sort((CMPFUNCwxArrayPtrVoid)fCmp); } private: void DoEmpty(); void DoCopy(const wxDateTimeArray& src); };
# 1505 "/usr/include/wx-2.8/wx/datetime.h"
class wxDateTimeHolidayAuthority;
typedef wxDateTimeHolidayAuthority * _wxArraywxHolidayAuthoritiesArray; struct wxAssert_wxHolidayAuthoritiesArray { unsigned int TypeTooBigToBeStoredInwxBaseArrayPtrVoid: sizeof(_wxArraywxHolidayAuthoritiesArray) <= sizeof(wxBaseArrayPtrVoid::base_type); }; typedef int ( *CMPFUNC_wxArraywxHolidayAuthoritiesArray)(_wxArraywxHolidayAuthoritiesArray *pItem1, _wxArraywxHolidayAuthoritiesArray *pItem2); class wxHolidayAuthoritiesArray : public wxBaseArrayPtrVoid { public: wxHolidayAuthoritiesArray() { } ~wxHolidayAuthoritiesArray() { } wxHolidayAuthoritiesArray& operator=(const wxHolidayAuthoritiesArray& src) { wxBaseArrayPtrVoid* temp = (wxBaseArrayPtrVoid*) this; (*temp) = ((const wxBaseArrayPtrVoid&)src); return *this; } _wxArraywxHolidayAuthoritiesArray& operator[](size_t uiIndex) const { return (_wxArraywxHolidayAuthoritiesArray&)(wxBaseArrayPtrVoid::operator[](uiIndex)); } _wxArraywxHolidayAuthoritiesArray& Item(size_t uiIndex) const { return (_wxArraywxHolidayAuthoritiesArray&)(wxBaseArrayPtrVoid::operator[](uiIndex)); } _wxArraywxHolidayAuthoritiesArray& Last() const { return (_wxArraywxHolidayAuthoritiesArray&)(wxBaseArrayPtrVoid::operator[](Count() - 1)); } int Index(_wxArraywxHolidayAuthoritiesArray lItem, bool bFromEnd = false) const { return wxBaseArrayPtrVoid::Index((base_type)lItem, bFromEnd); } void Add(_wxArraywxHolidayAuthoritiesArray lItem, size_t nInsert = 1) { wxBaseArrayPtrVoid::Add((base_type)lItem, nInsert); } void Insert(_wxArraywxHolidayAuthoritiesArray lItem, size_t uiIndex, size_t nInsert = 1) { wxBaseArrayPtrVoid::Insert((base_type)lItem, uiIndex, nInsert) ; } void RemoveAt(size_t uiIndex, size_t nRemove = 1) { wxBaseArrayPtrVoid::RemoveAt(uiIndex, nRemove); } void Remove(_wxArraywxHolidayAuthoritiesArray lItem) { int iIndex = Index(lItem); if ( iIndex != (-1) ) ; else { ; return; } typedef int wxDummyCheckInt; wxBaseArrayPtrVoid::RemoveAt((size_t)iIndex); } void Sort(CMPFUNC_wxArraywxHolidayAuthoritiesArray fCmp) { wxBaseArrayPtrVoid::Sort((CMPFUNC)fCmp); } private: typedef wxBaseArrayPtrVoid::iterator biterator; typedef wxBaseArrayPtrVoid::const_iterator bconst_iterator; typedef wxBaseArrayPtrVoid::value_type bvalue_type; typedef wxBaseArrayPtrVoid::const_reference bconst_reference; public: typedef _wxArraywxHolidayAuthoritiesArray value_type; typedef value_type* pointer; typedef const value_type* const_pointer; typedef value_type* iterator; typedef const value_type* const_iterator; typedef value_type& reference; typedef const value_type& const_reference; typedef wxBaseArrayPtrVoid::difference_type difference_type; typedef wxBaseArrayPtrVoid::size_type size_type; class reverse_iterator { typedef _wxArraywxHolidayAuthoritiesArray value_type; typedef value_type& reference; typedef value_type* pointer; typedef reverse_iterator itor; friend inline itor operator+(int o, const itor& it) { return it.m_ptr - o; } friend inline itor operator+(const itor& it, int o) { return it.m_ptr - o; } friend inline itor operator-(const itor& it, int o) { return it.m_ptr + o; } friend inline difference_type operator-(const itor& i1, const itor& i2) { return i1.m_ptr - i2.m_ptr; } public: pointer m_ptr; reverse_iterator() : m_ptr(__null) { } reverse_iterator(pointer ptr) : m_ptr(ptr) { } reverse_iterator(const itor& it) : m_ptr(it.m_ptr) { } reference operator*() const { return *m_ptr; } itor& operator++() { --m_ptr; return *this; } const itor operator++(int) { reverse_iterator tmp = *this; --m_ptr; return tmp; } itor& operator--() { ++m_ptr; return *this; } const itor operator--(int) { itor tmp = *this; ++m_ptr; return tmp; } bool operator ==(const itor& it) const { return m_ptr == it.m_ptr; } bool operator !=(const itor& it) const { return m_ptr != it.m_ptr; } }; class const_reverse_iterator { typedef _wxArraywxHolidayAuthoritiesArray value_type; typedef const value_type& reference; typedef const value_type* pointer; typedef const_reverse_iterator itor; friend inline itor operator+(int o, const itor& it) { return it.m_ptr - o; } friend inline itor operator+(const itor& it, int o) { return it.m_ptr - o; } friend inline itor operator-(const itor& it, int o) { return it.m_ptr + o; } friend inline difference_type operator-(const itor& i1, const itor& i2) { return i1.m_ptr - i2.m_ptr; } public: pointer m_ptr; const_reverse_iterator() : m_ptr(__null) { } const_reverse_iterator(pointer ptr) : m_ptr(ptr) { } const_reverse_iterator(const itor& it) : m_ptr(it.m_ptr) { } const_reverse_iterator(const reverse_iterator& it) : m_ptr(it.m_ptr) { } reference operator*() const { return *m_ptr; } itor& operator++() { --m_ptr; return *this; } const itor operator++(int) { itor tmp = *this; --m_ptr; return tmp; } itor& operator--() { ++m_ptr; return *this; } const itor operator--(int) { itor tmp = *this; ++m_ptr; return tmp; } bool operator ==(const itor& it) const { return m_ptr == it.m_ptr; } bool operator !=(const itor& it) const { return m_ptr != it.m_ptr; } }; wxHolidayAuthoritiesArray(size_type n, const_reference v) { assign(n, v); } wxHolidayAuthoritiesArray(const_iterator first, const_iterator last) { assign(first, last); } void assign(const_iterator first, const_iterator last) { wxBaseArrayPtrVoid::assign((bconst_iterator)first, (bconst_iterator)last); } void assign(size_type n, const_reference v) { wxBaseArrayPtrVoid::assign(n, (bconst_reference)v); } reference back() { return *(end() - 1); } const_reference back() const { return *(end() - 1); } iterator begin() { return (iterator)wxBaseArrayPtrVoid::begin(); } const_iterator begin() const { return (const_iterator)wxBaseArrayPtrVoid::begin(); } size_type capacity() const { return wxBaseArrayPtrVoid::capacity(); } iterator end() { return (iterator)wxBaseArrayPtrVoid::end(); } const_iterator end() const { return (const_iterator)wxBaseArrayPtrVoid::end(); } iterator erase(iterator first, iterator last) { return (iterator)wxBaseArrayPtrVoid::erase((biterator)first, (biterator)last); } iterator erase(iterator it) { return (iterator)wxBaseArrayPtrVoid::erase((biterator)it); } reference front() { return *begin(); } const_reference front() const { return *begin(); } void insert(iterator it, size_type n, const_reference v) { wxBaseArrayPtrVoid::insert((biterator)it, n, (bconst_reference)v); } iterator insert(iterator it, const_reference v = value_type()) { return (iterator)wxBaseArrayPtrVoid::insert((biterator)it, (bconst_reference)v); } void insert(iterator it, const_iterator first, const_iterator last) { wxBaseArrayPtrVoid::insert((biterator)it, (bconst_iterator)first, (bconst_iterator)last); } void pop_back() { wxBaseArrayPtrVoid::pop_back(); } void push_back(const_reference v) { wxBaseArrayPtrVoid::push_back((bconst_reference)v); } reverse_iterator rbegin() { return reverse_iterator(end() - 1); } const_reverse_iterator rbegin() const; reverse_iterator rend() { return reverse_iterator(begin() - 1); } const_reverse_iterator rend() const; void reserve(size_type n) { wxBaseArrayPtrVoid::reserve(n); } void resize(size_type n, value_type v = value_type()) { wxBaseArrayPtrVoid::resize(n, v); } };



class wxDateTimeHolidaysModule;
class wxDateTimeHolidayAuthority
{
friend class wxDateTimeHolidaysModule;
public:

    static bool IsHoliday(const wxDateTime& dt);



    static size_t GetHolidaysInRange(const wxDateTime& dtStart,
                                     const wxDateTime& dtEnd,
                                     wxDateTimeArray& holidays);


    static void ClearAllAuthorities();



    static void AddAuthority(wxDateTimeHolidayAuthority *auth);


    virtual ~wxDateTimeHolidayAuthority();

protected:

    virtual bool DoIsHoliday(const wxDateTime& dt) const = 0;
# 1546 "/usr/include/wx-2.8/wx/datetime.h"
    virtual size_t DoGetHolidaysInRange(const wxDateTime& dtStart,
                                        const wxDateTime& dtEnd,
                                        wxDateTimeArray& holidays) const = 0;

private:

    static wxHolidayAuthoritiesArray ms_authorities;
};


class wxDateTimeWorkDays : public wxDateTimeHolidayAuthority
{
protected:
    virtual bool DoIsHoliday(const wxDateTime& dt) const;
    virtual size_t DoGetHolidaysInRange(const wxDateTime& dtStart,
                                        const wxDateTime& dtEnd,
                                        wxDateTimeArray& holidays) const;
};
# 1588 "/usr/include/wx-2.8/wx/datetime.h"
inline bool wxDateTime::IsInStdRange() const
{
    return m_time >= 0l && (m_time / TIME_T_FACTOR) < 2147483647L;
}


inline wxDateTime wxDateTime::Now()
{
    struct tm tmstruct;
    return wxDateTime(*GetTmNow(&tmstruct));
}


inline wxDateTime wxDateTime::Today()
{
    wxDateTime dt(Now());
    dt.ResetTime();

    return dt;
}


inline wxDateTime& wxDateTime::Set(time_t timet)
{

    m_time = timet - 0 ;
    m_time *= TIME_T_FACTOR;

    return *this;
}


inline wxDateTime& wxDateTime::SetToCurrent()
{
    *this = Now();
    return *this;
}


inline wxDateTime::wxDateTime(time_t timet)
{
    Set(timet);
}


inline wxDateTime::wxDateTime(const struct tm& tm)
{
    Set(tm);
}

inline wxDateTime::wxDateTime(const Tm& tm)
{
    Set(tm);
}

inline wxDateTime::wxDateTime(double jdn)
{
    Set(jdn);
}

inline wxDateTime& wxDateTime::Set(const Tm& tm)
{
    ;

    return Set(tm.mday, (Month)tm.mon, tm.year,
               tm.hour, tm.min, tm.sec, tm.msec);
}

inline wxDateTime::wxDateTime(wxDateTime_t hour,
                              wxDateTime_t minute,
                              wxDateTime_t second,
                              wxDateTime_t millisec)
{
    Set(hour, minute, second, millisec);
}

inline wxDateTime::wxDateTime(wxDateTime_t day,
                              Month month,
                              int year,
                              wxDateTime_t hour,
                              wxDateTime_t minute,
                              wxDateTime_t second,
                              wxDateTime_t millisec)
{
    Set(day, month, year, hour, minute, second, millisec);
}





inline wxLongLong wxDateTime::GetValue() const
{
    ;

    return m_time;
}

inline time_t wxDateTime::GetTicks() const
{
    ;
    if ( !IsInStdRange() )
    {
        return (time_t)-1;
    }

    return (time_t)((m_time / (long)TIME_T_FACTOR).ToLong()) + 0;
}

inline bool wxDateTime::SetToLastWeekDay(WeekDay weekday,
                                         Month month,
                                         int year)
{
    return SetToWeekDay(weekday, -1, month, year);
}

inline wxDateTime
wxDateTime::GetWeekDayInSameWeek(WeekDay weekday,
                                 WeekFlags ) const
{
    return wxDateTime(*this).SetToWeekDayInSameWeek(weekday);
}

inline wxDateTime wxDateTime::GetNextWeekDay(WeekDay weekday) const
{
    return wxDateTime(*this).SetToNextWeekDay(weekday);
}

inline wxDateTime wxDateTime::GetPrevWeekDay(WeekDay weekday) const
{
    return wxDateTime(*this).SetToPrevWeekDay(weekday);
}

inline wxDateTime wxDateTime::GetWeekDay(WeekDay weekday,
                                         int n,
                                         Month month,
                                         int year) const
{
    wxDateTime dt(*this);

    return dt.SetToWeekDay(weekday, n, month, year) ? dt : wxDefaultDateTime;
}

inline wxDateTime wxDateTime::GetLastWeekDay(WeekDay weekday,
                                             Month month,
                                             int year)
{
    wxDateTime dt(*this);

    return dt.SetToLastWeekDay(weekday, month, year) ? dt : wxDefaultDateTime;
}

inline wxDateTime wxDateTime::GetLastMonthDay(Month month, int year) const
{
    return wxDateTime(*this).SetToLastMonthDay(month, year);
}

inline wxDateTime wxDateTime::GetYearDay(wxDateTime_t yday) const
{
    return wxDateTime(*this).SetToYearDay(yday);
}





inline bool wxDateTime::IsEqualTo(const wxDateTime& datetime) const
{
    ;

    return m_time == datetime.m_time;
}

inline bool wxDateTime::IsEarlierThan(const wxDateTime& datetime) const
{
    ;

    return m_time < datetime.m_time;
}

inline bool wxDateTime::IsLaterThan(const wxDateTime& datetime) const
{
    ;

    return m_time > datetime.m_time;
}

inline bool wxDateTime::IsStrictlyBetween(const wxDateTime& t1,
                                          const wxDateTime& t2) const
{

    return IsLaterThan(t1) && IsEarlierThan(t2);
}

inline bool wxDateTime::IsBetween(const wxDateTime& t1,
                                  const wxDateTime& t2) const
{

    return IsEqualTo(t1) || IsEqualTo(t2) || IsStrictlyBetween(t1, t2);
}

inline bool wxDateTime::IsSameDate(const wxDateTime& dt) const
{
    Tm tm1 = GetTm(),
       tm2 = dt.GetTm();

    return tm1.year == tm2.year &&
           tm1.mon == tm2.mon &&
           tm1.mday == tm2.mday;
}

inline bool wxDateTime::IsSameTime(const wxDateTime& dt) const
{





    Tm tm1 = GetTm(),
       tm2 = dt.GetTm();

    return tm1.hour == tm2.hour &&
           tm1.min == tm2.min &&
           tm1.sec == tm2.sec &&
           tm1.msec == tm2.msec;
}

inline bool wxDateTime::IsEqualUpTo(const wxDateTime& dt,
                                    const wxTimeSpan& ts) const
{
    return IsBetween(dt.Subtract(ts), dt.Add(ts));
}





inline wxDateTime wxDateTime::Add(const wxTimeSpan& diff) const
{
    ;

    return wxDateTime(m_time + diff.GetValue());
}

inline wxDateTime& wxDateTime::Add(const wxTimeSpan& diff)
{
    ;

    m_time += diff.GetValue();

    return *this;
}

inline wxDateTime& wxDateTime::operator+=(const wxTimeSpan& diff)
{
    return Add(diff);
}

inline wxDateTime wxDateTime::Subtract(const wxTimeSpan& diff) const
{
    ;

    return wxDateTime(m_time - diff.GetValue());
}

inline wxDateTime& wxDateTime::Subtract(const wxTimeSpan& diff)
{
    ;

    m_time -= diff.GetValue();

    return *this;
}

inline wxDateTime& wxDateTime::operator-=(const wxTimeSpan& diff)
{
    return Subtract(diff);
}

inline wxTimeSpan wxDateTime::Subtract(const wxDateTime& datetime) const
{
    ;

    return wxTimeSpan(GetValue() - datetime.GetValue());
}

inline wxTimeSpan wxDateTime::operator-(const wxDateTime& dt2) const
{
    return this->Subtract(dt2);
}

inline wxDateTime wxDateTime::Add(const wxDateSpan& diff) const
{
    return wxDateTime(*this).Add(diff);
}

inline wxDateTime& wxDateTime::Subtract(const wxDateSpan& diff)
{
    return Add(diff.Negate());
}

inline wxDateTime wxDateTime::Subtract(const wxDateSpan& diff) const
{
    return wxDateTime(*this).Subtract(diff);
}

inline wxDateTime& wxDateTime::operator-=(const wxDateSpan& diff)
{
    return Subtract(diff);
}

inline wxDateTime& wxDateTime::operator+=(const wxDateSpan& diff)
{
    return Add(diff);
}





inline wxDateTime
wxDateTime::ToTimezone(const wxDateTime::TimeZone& tz, bool noDST) const
{
    return wxDateTime(*this).MakeTimezone(tz, noDST);
}

inline wxDateTime
wxDateTime::FromTimezone(const wxDateTime::TimeZone& tz, bool noDST) const
{
    return wxDateTime(*this).MakeFromTimezone(tz, noDST);
}





inline wxTimeSpan::wxTimeSpan(long hours,
                              long minutes,
                              wxLongLong seconds,
                              wxLongLong milliseconds)
{

    m_diff = hours;
    m_diff *= 60l;
    m_diff += minutes;
    m_diff *= 60l;
    m_diff += seconds;
    m_diff *= 1000l;
    m_diff += milliseconds;
}





inline wxLongLong wxTimeSpan::GetSeconds() const
{
    return m_diff / 1000l;
}

inline int wxTimeSpan::GetMinutes() const
{


    return (int)((GetSeconds() / 60l).GetLo());
}

inline int wxTimeSpan::GetHours() const
{
    return GetMinutes() / 60;
}

inline int wxTimeSpan::GetDays() const
{
    return GetHours() / 24;
}

inline int wxTimeSpan::GetWeeks() const
{
    return GetDays() / 7;
}





inline wxTimeSpan wxTimeSpan::Add(const wxTimeSpan& diff) const
{
    return wxTimeSpan(m_diff + diff.GetValue());
}

inline wxTimeSpan& wxTimeSpan::Add(const wxTimeSpan& diff)
{
    m_diff += diff.GetValue();

    return *this;
}

inline wxTimeSpan wxTimeSpan::Subtract(const wxTimeSpan& diff) const
{
    return wxTimeSpan(m_diff - diff.GetValue());
}

inline wxTimeSpan& wxTimeSpan::Subtract(const wxTimeSpan& diff)
{
    m_diff -= diff.GetValue();

    return *this;
}

inline wxTimeSpan& wxTimeSpan::Multiply(int n)
{
    m_diff *= (long)n;

    return *this;
}

inline wxTimeSpan wxTimeSpan::Multiply(int n) const
{
    return wxTimeSpan(m_diff * (long)n);
}

inline wxTimeSpan wxTimeSpan::Abs() const
{
    return wxTimeSpan(GetValue().Abs());
}

inline bool wxTimeSpan::IsEqualTo(const wxTimeSpan& ts) const
{
    return GetValue() == ts.GetValue();
}

inline bool wxTimeSpan::IsLongerThan(const wxTimeSpan& ts) const
{
    return GetValue().Abs() > ts.GetValue().Abs();
}





inline wxDateSpan& wxDateSpan::operator+=(const wxDateSpan& other)
{
    m_years += other.m_years;
    m_months += other.m_months;
    m_weeks += other.m_weeks;
    m_days += other.m_days;

    return *this;
}

inline wxDateSpan& wxDateSpan::Add(const wxDateSpan& other)
{
    return *this += other;
}

inline wxDateSpan wxDateSpan::Add(const wxDateSpan& other) const
{
    wxDateSpan ds(*this);
    ds.Add(other);
    return ds;
}

inline wxDateSpan& wxDateSpan::Multiply(int factor)
{
    m_years *= factor;
    m_months *= factor;
    m_weeks *= factor;
    m_days *= factor;

    return *this;
}

inline wxDateSpan wxDateSpan::Multiply(int factor) const
{
    wxDateSpan ds(*this);
    ds.Multiply(factor);
    return ds;
}

inline wxDateSpan wxDateSpan::Negate() const
{
    return wxDateSpan(-m_years, -m_months, -m_weeks, -m_days);
}

inline wxDateSpan& wxDateSpan::Neg()
{
    m_years = -m_years;
    m_months = -m_months;
    m_weeks = -m_weeks;
    m_days = -m_days;

    return *this;
}

inline wxDateSpan& wxDateSpan::operator-=(const wxDateSpan& other)
{
    return *this += other.Negate();
}

inline wxDateSpan& wxDateSpan::Subtract(const wxDateSpan& other)
{
    return *this -= other;
}

inline wxDateSpan wxDateSpan::Subtract(const wxDateSpan& other) const
{
    wxDateSpan ds(*this);
    ds.Subtract(other);
    return ds;
}
# 2112 "/usr/include/wx-2.8/wx/datetime.h"
wxTimeSpan operator*(int n, const wxTimeSpan& ts);





wxDateSpan operator*(int n, const wxDateSpan& ds);
# 2130 "/usr/include/wx-2.8/wx/datetime.h"
 void wxNextMonth(wxDateTime::Month& m);
 void wxPrevMonth(wxDateTime::Month& m);
 void wxNextWDay(wxDateTime::WeekDay& wd);
 void wxPrevWDay(wxDateTime::WeekDay& wd);
# 27 "/usr/include/wx-2.8/wx/variant.h" 2






# 1 "/usr/include/wx-2.8/wx/iosfwrap.h" 1
# 34 "/usr/include/wx-2.8/wx/variant.h" 2
# 62 "/usr/include/wx-2.8/wx/variant.h"
class wxVariantData: public wxObject
{
    friend class wxVariant;
public:
    wxVariantData()
        : wxObject(), m_count(1)
    { }


    virtual bool Eq(wxVariantData& data) const = 0;


    virtual bool Write(std:: ostream& ) const { return false; }

    virtual bool Write(wxString& ) const { return false; }

    virtual bool Read(std:: istream& ) { return false; }

    virtual bool Read(wxString& ) { return false; }

    virtual wxString GetType() const = 0;

    virtual wxClassInfo* GetValueClassInfo() { return __null; }

    void IncRef() { m_count++; }
    void DecRef()
    {
        if ( --m_count == 0 )
            delete this;
    }

    int GetRefCount() const { return m_count; }

protected:



    virtual ~wxVariantData() { }

private:
    int m_count;

private:
    public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const;
};






class wxVariant: public wxObject
{
public:
    wxVariant();

    wxVariant(const wxVariant& variant);
    wxVariant(wxVariantData* data, const wxString& name = wxEmptyString);
    virtual ~wxVariant();


    void operator= (const wxVariant& variant);



    void operator= (wxVariantData* variantData);

    bool operator== (const wxVariant& variant) const;
    bool operator!= (const wxVariant& variant) const;


    inline void SetName(const wxString& name) { m_name = name; }
    inline const wxString& GetName() const { return m_name; }


    bool IsNull() const;



    wxVariantData* GetData() const { return m_data; }
    void SetData(wxVariantData* data) ;


    void Ref(const wxVariant& clone);


    void UnRef();


    void MakeNull();


    void Clear();



    wxString GetType() const;

    bool IsType(const wxString& type) const;
    bool IsValueKindOf(const wxClassInfo* type) const;


    wxString MakeString() const;


    wxVariant(double val, const wxString& name = wxEmptyString);
    bool operator== (double value) const;
    bool operator!= (double value) const;
    void operator= (double value) ;
    inline operator double () const { return GetDouble(); }
    inline double GetReal() const { return GetDouble(); }
    double GetDouble() const;


    wxVariant(long val, const wxString& name = wxEmptyString);
    wxVariant(int val, const wxString& name = wxEmptyString);
    wxVariant(short val, const wxString& name = wxEmptyString);
    bool operator== (long value) const;
    bool operator!= (long value) const;
    void operator= (long value) ;
    inline operator long () const { return GetLong(); }
    inline long GetInteger() const { return GetLong(); }
    long GetLong() const;



    wxVariant(bool val, const wxString& name = wxEmptyString);
    bool operator== (bool value) const;
    bool operator!= (bool value) const;
    void operator= (bool value) ;
    inline operator bool () const { return GetBool(); }
    bool GetBool() const ;




    wxVariant(const wxDateTime& val, const wxString& name = wxEmptyString);





    bool operator== (const wxDateTime& value) const;
    bool operator!= (const wxDateTime& value) const;
    void operator= (const wxDateTime& value) ;





    inline operator wxDateTime () const { return GetDateTime(); }
    wxDateTime GetDateTime() const;



    wxVariant(const wxString& val, const wxString& name = wxEmptyString);
    wxVariant(const wxChar* val, const wxString& name = wxEmptyString);
    bool operator== (const wxString& value) const;
    bool operator!= (const wxString& value) const;
    void operator= (const wxString& value) ;
    void operator= (const wxChar* value) ;
    inline operator wxString () const { return MakeString(); }
    wxString GetString() const;


    wxVariant(wxChar val, const wxString& name = wxEmptyString);
    bool operator== (wxChar value) const;
    bool operator!= (wxChar value) const;
    void operator= (wxChar value) ;
    inline operator wxChar () const { return GetChar(); }
    wxChar GetChar() const ;


    wxVariant(const wxArrayString& val, const wxString& name = wxEmptyString);
    bool operator== (const wxArrayString& value) const;
    bool operator!= (const wxArrayString& value) const;
    void operator= (const wxArrayString& value);
    inline operator wxArrayString () const { return GetArrayString(); }
    wxArrayString GetArrayString() const;


    wxVariant(void* ptr, const wxString& name = wxEmptyString);
    bool operator== (void* value) const;
    bool operator!= (void* value) const;
    void operator= (void* value);
    inline operator void* () const { return GetVoidPtr(); }
    void* GetVoidPtr() const;


    wxVariant(wxObject* ptr, const wxString& name = wxEmptyString);
    bool operator== (wxObject* value) const;
    bool operator!= (wxObject* value) const;
    void operator= (wxObject* value);
    wxObject* GetWxObjectPtr() const;
# 270 "/usr/include/wx-2.8/wx/variant.h"
    wxVariant(const wxList& val, const wxString& name = wxEmptyString);
    bool operator== (const wxList& value) const;
    bool operator!= (const wxList& value) const;
    void operator= (const wxList& value) ;

    wxVariant operator[] (size_t idx) const;
    wxVariant& operator[] (size_t idx) ;
    wxList& GetList() const ;


    size_t GetCount() const;


    void NullList();


    void Append(const wxVariant& value);


    void Insert(const wxVariant& value);


    bool Member(const wxVariant& value) const;


    bool Delete(size_t item);


    void ClearList();

public:

    bool Convert(long* value) const;
    bool Convert(bool* value) const;
    bool Convert(double* value) const;
    bool Convert(wxString* value) const;
    bool Convert(wxChar* value) const;

    bool Convert(wxDateTime* value) const;



protected:
    wxVariantData* m_data;
    wxString m_name;

private:
    public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};
# 419 "/usr/include/wx-2.8/wx/variant.h"
extern wxVariant wxNullVariant;
# 49 "/usr/include/wx-2.8/wx/colour.h" 2
 wxColour& operator << ( wxColour &object, const wxVariant &variant ); wxVariant& operator << ( wxVariant &variant, const wxColour &object );







class wxColourBase : public wxGDIObject
{
public:

    typedef unsigned char ChannelType;

    wxColourBase() {}
    virtual ~wxColourBase() {}





    void Set(ChannelType red,
             ChannelType green,
             ChannelType blue,
             ChannelType alpha = wxALPHA_OPAQUE)
        { InitRGBA(red,green,blue, alpha); }


    bool Set(const wxChar *str)
        { return FromString(str); }

    bool Set(const wxString &str)
        { return FromString(str); }

    void Set(unsigned long colRGB)
    {


        Set((ChannelType)(0xFF & colRGB),
            (ChannelType)(0xFF & (colRGB >> 8)),
            (ChannelType)(0xFF & (colRGB >> 16)));
    }






    virtual bool Ok() const { return IsOk(); }
    virtual bool IsOk() const = 0;

    virtual ChannelType Red() const = 0;
    virtual ChannelType Green() const = 0;
    virtual ChannelType Blue() const = 0;
    virtual ChannelType Alpha() const
        { return wxALPHA_OPAQUE ; }


    virtual wxString GetAsString(long flags = 1 | 2) const;







    static wxColour CreateByName(const wxString& name) __attribute__ ((deprecated));
    void InitFromName(const wxString& col) __attribute__ ((deprecated));


protected:
    virtual void
    InitRGBA(ChannelType r, ChannelType g, ChannelType b, ChannelType a) = 0;

    virtual bool FromString(const wxChar *s);
};
# 135 "/usr/include/wx-2.8/wx/colour.h"
# 1 "/usr/include/wx-2.8/wx/gtk/colour.h" 1
# 17 "/usr/include/wx-2.8/wx/gtk/colour.h"
class wxColour : public wxColourBase
{
public:




    wxColour() {}
    wxColour( ChannelType red, ChannelType green, ChannelType blue, ChannelType alpha = wxALPHA_OPAQUE ) { Set(red, green, blue, alpha); } wxColour( unsigned long colRGB ) { Set(colRGB); } wxColour(const wxString &colourName) { Set(colourName); } wxColour(const wxChar *colourName) { Set(colourName); }
    wxColour(const GdkColor& gdkColor);

    virtual ~wxColour();

    bool Ok() const { return IsOk(); }
    bool IsOk() const { return m_refData != __null; }

    bool operator == ( const wxColour& col ) const;
    bool operator != ( const wxColour& col ) const { return !(*this == col); }

    unsigned char Red() const;
    unsigned char Green() const;
    unsigned char Blue() const;
    unsigned char Alpha() const;


    void CalcPixel( GdkColormap *cmap );
    int GetPixel() const;

    const GdkColor *GetColor() const;






protected:
    virtual void
    InitRGBA(unsigned char r, unsigned char g, unsigned char b, unsigned char a);

    virtual bool FromString(const wxChar *str);

private:
    public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};
# 136 "/usr/include/wx-2.8/wx/colour.h" 2
# 26 "/usr/include/wx-2.8/wx/window.h" 2
# 1 "/usr/include/wx-2.8/wx/region.h" 1
# 18 "/usr/include/wx-2.8/wx/region.h"
class wxBitmap;
class wxColour;
class wxRegion;






enum wxRegionContain
{
    wxOutRegion = 0,
    wxPartRegion = 1,
    wxInRegion = 2
};



enum wxRegionOp
{

    wxRGN_AND,


    wxRGN_COPY,


    wxRGN_DIFF,


    wxRGN_OR,


    wxRGN_XOR
};





class wxRegionBase : public wxGDIObject
{
public:
# 78 "/usr/include/wx-2.8/wx/region.h"
    bool operator==(const wxRegion& region) const { return IsEqual(region); }
    bool operator!=(const wxRegion& region) const { return !(*this == region); }





    bool Ok() const { return IsOk(); }
    bool IsOk() const { return m_refData != __null; }


    virtual bool IsEmpty() const = 0;
    bool Empty() const { return IsEmpty(); }


    bool IsEqual(const wxRegion& region) const;


    bool GetBox(wxCoord& x, wxCoord& y, wxCoord& w, wxCoord& h) const
        { return DoGetBox(x, y, w, h); }
    wxRect GetBox() const
    {
        wxCoord x, y, w, h;
        return DoGetBox(x, y, w, h) ? wxRect(x, y, w, h) : wxRect();
    }


    wxRegionContain Contains(wxCoord x, wxCoord y) const
        { return DoContainsPoint(x, y); }
    wxRegionContain Contains(const wxPoint& pt) const
        { return DoContainsPoint(pt.x, pt.y); }
    wxRegionContain Contains(wxCoord x, wxCoord y, wxCoord w, wxCoord h) const
        { return DoContainsRect(wxRect(x, y, w, h)); }
    wxRegionContain Contains(const wxRect& rect) const
        { return DoContainsRect(rect); }





    virtual void Clear() = 0;


    bool Offset(wxCoord x, wxCoord y)
        { return DoOffset(x, y); }
    bool Offset(const wxPoint& pt)
        { return DoOffset(pt.x, pt.y); }


    bool Union(wxCoord x, wxCoord y, wxCoord w, wxCoord h)
        { return DoUnionWithRect(wxRect(x, y, w, h)); }
    bool Union(const wxRect& rect)
        { return DoUnionWithRect(rect); }
    bool Union(const wxRegion& region)
        { return DoUnionWithRegion(region); }







    bool Union(const wxBitmap& bmp);
    bool Union(const wxBitmap& bmp, const wxColour& transp, int tolerance = 0);



    bool Intersect(wxCoord x, wxCoord y, wxCoord w, wxCoord h);
    bool Intersect(const wxRect& rect);
    bool Intersect(const wxRegion& region)
        { return DoIntersect(region); }



    bool Subtract(wxCoord x, wxCoord y, wxCoord w, wxCoord h);
    bool Subtract(const wxRect& rect);
    bool Subtract(const wxRegion& region)
        { return DoSubtract(region); }


    bool Xor(wxCoord x, wxCoord y, wxCoord w, wxCoord h);
    bool Xor(const wxRect& rect);
    bool Xor(const wxRegion& region)
        { return DoXor(region); }




    wxBitmap ConvertToBitmap() const;

protected:
    virtual bool DoIsEqual(const wxRegion& region) const = 0;
    virtual bool DoGetBox(wxCoord& x, wxCoord& y, wxCoord& w, wxCoord& h) const = 0;
    virtual wxRegionContain DoContainsPoint(wxCoord x, wxCoord y) const = 0;
    virtual wxRegionContain DoContainsRect(const wxRect& rect) const = 0;

    virtual bool DoOffset(wxCoord x, wxCoord y) = 0;

    virtual bool DoUnionWithRect(const wxRect& rect) = 0;
    virtual bool DoUnionWithRegion(const wxRegion& region) = 0;

    virtual bool DoIntersect(const wxRegion& region) = 0;
    virtual bool DoSubtract(const wxRegion& region) = 0;
    virtual bool DoXor(const wxRegion& region) = 0;
};
# 224 "/usr/include/wx-2.8/wx/region.h"
# 1 "/usr/include/wx-2.8/wx/gtk/region.h" 1
# 17 "/usr/include/wx-2.8/wx/gtk/region.h"
class wxRegion : public wxRegionBase
{
public:
    wxRegion() { }

    wxRegion( wxCoord x, wxCoord y, wxCoord w, wxCoord h )
    {
        InitRect(x, y, w, h);
    }

    wxRegion( const wxPoint& topLeft, const wxPoint& bottomRight )
    {
        InitRect(topLeft.x, topLeft.y,
                 bottomRight.x - topLeft.x, bottomRight.y - topLeft.y);
    }

    wxRegion( const wxRect& rect )
    {
        InitRect(rect.x, rect.y, rect.width, rect.height);
    }

    wxRegion( size_t n, const wxPoint *points, int fillStyle = wxODDEVEN_RULE );

    wxRegion( const wxBitmap& bmp)
    {
        Union(bmp);
    }
    wxRegion( const wxBitmap& bmp,
              const wxColour& transColour, int tolerance = 0)
    {
        Union(bmp, transColour, tolerance);
    }

    virtual ~wxRegion();


    virtual void Clear();
    virtual bool IsEmpty() const;

public:


    wxRegion( GdkRegion *region );

    GdkRegion *GetRegion() const;

protected:

    virtual wxObjectRefData *CreateRefData() const;
    virtual wxObjectRefData *CloneRefData(const wxObjectRefData *data) const;


    virtual bool DoIsEqual(const wxRegion& region) const;
    virtual bool DoGetBox(wxCoord& x, wxCoord& y, wxCoord& w, wxCoord& h) const;
    virtual wxRegionContain DoContainsPoint(wxCoord x, wxCoord y) const;
    virtual wxRegionContain DoContainsRect(const wxRect& rect) const;

    virtual bool DoOffset(wxCoord x, wxCoord y);
    virtual bool DoUnionWithRect(const wxRect& rect);
    virtual bool DoUnionWithRegion(const wxRegion& region);
    virtual bool DoIntersect(const wxRegion& region);
    virtual bool DoSubtract(const wxRegion& region);
    virtual bool DoXor(const wxRegion& region);


    void InitRect(wxCoord x, wxCoord y, wxCoord w, wxCoord h);

private:
    public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};





class wxRegionIterator: public wxObject
{
public:
    wxRegionIterator();
    wxRegionIterator(const wxRegion& region);
    wxRegionIterator(const wxRegionIterator& ri) : wxObject(ri) { Init(); *this = ri; }
    ~wxRegionIterator();

    wxRegionIterator& operator=(const wxRegionIterator& ri);

    void Reset() { m_current = 0u; }
    void Reset(const wxRegion& region);

    bool HaveRects() const;
    operator bool () const { return HaveRects(); }

    wxRegionIterator& operator ++ ();
    wxRegionIterator operator ++ (int);

    wxCoord GetX() const;
    wxCoord GetY() const;
    wxCoord GetW() const;
    wxCoord GetWidth() const { return GetW(); }
    wxCoord GetH() const;
    wxCoord GetHeight() const { return GetH(); }
    wxRect GetRect() const;

private:
    void Init();
    void CreateRects( const wxRegion& r );

    size_t m_current;
    wxRegion m_region;

    wxRect *m_rects;
    size_t m_numRects;

private:
    public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};
# 225 "/usr/include/wx-2.8/wx/region.h" 2
# 249 "/usr/include/wx-2.8/wx/region.h"
inline bool wxRegionBase::Intersect(const wxRect& rect)
{
    return DoIntersect(wxRegion(rect));
}

inline bool wxRegionBase::Subtract(const wxRect& rect)
{
    return DoSubtract(wxRegion(rect));
}

inline bool wxRegionBase::Xor(const wxRect& rect)
{
    return DoXor(wxRegion(rect));
}




inline bool wxRegionBase::Intersect(wxCoord x, wxCoord y, wxCoord w, wxCoord h)
{
    return Intersect(wxRect(x, y, w, h));
}

inline bool wxRegionBase::Subtract(wxCoord x, wxCoord y, wxCoord w, wxCoord h)
{
    return Subtract(wxRect(x, y, w, h));
}

inline bool wxRegionBase::Xor(wxCoord x, wxCoord y, wxCoord w, wxCoord h)
{
    return Xor(wxRect(x, y, w, h));
}
# 27 "/usr/include/wx-2.8/wx/window.h" 2



# 1 "/usr/include/wx-2.8/wx/validate.h" 1
# 21 "/usr/include/wx-2.8/wx/validate.h"
class wxWindow;
class wxWindowBase;
# 36 "/usr/include/wx-2.8/wx/validate.h"
class wxValidator : public wxEvtHandler
{
public:
    wxValidator();
    virtual ~wxValidator();





    virtual wxObject *Clone() const
        { return (wxValidator *)__null; }
    bool Copy(const wxValidator& val)
        { m_validatorWindow = val.m_validatorWindow; return true; }



    virtual bool Validate(wxWindow *) { return false; }


    virtual bool TransferToWindow() { return false; }


    virtual bool TransferFromWindow() { return false; }


    wxWindow *GetWindow() const { return (wxWindow *)m_validatorWindow; }
    void SetWindow(wxWindowBase *win) { m_validatorWindow = win; }



    static bool IsSilent() { return ms_isSilent; }
    static void SetBellOnError(bool doIt = true) { ms_isSilent = doIt; }

protected:
    wxWindowBase *m_validatorWindow;

private:
    static bool ms_isSilent;

    public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
    private: wxValidator(const wxValidator&); wxValidator& operator=(const wxValidator&);
};

extern const wxValidator wxDefaultValidator;
# 31 "/usr/include/wx-2.8/wx/window.h" 2


# 1 "/usr/include/wx-2.8/wx/palette.h" 1
# 23 "/usr/include/wx-2.8/wx/palette.h"
class wxPaletteBase: public wxGDIObject
{
public:
    virtual ~wxPaletteBase() { }

    virtual bool Ok() const { return IsOk(); }
    virtual bool IsOk() const = 0;
    virtual int GetColoursCount() const { ; return 0; }
};
# 40 "/usr/include/wx-2.8/wx/palette.h"
# 1 "/usr/include/wx-2.8/wx/generic/paletteg.h" 1
# 24 "/usr/include/wx-2.8/wx/generic/paletteg.h"
class wxPalette;





class wxPalette: public wxPaletteBase
{
public:
    wxPalette();
    wxPalette( int n, const unsigned char *red, const unsigned char *green, const unsigned char *blue );
    virtual ~wxPalette();
    virtual bool Ok() const { return IsOk(); }
    virtual bool IsOk() const;

    bool Create( int n, const unsigned char *red, const unsigned char *green, const unsigned char *blue);
    int GetPixel( unsigned char red, unsigned char green, unsigned char blue ) const;
    bool GetRGB( int pixel, unsigned char *red, unsigned char *green, unsigned char *blue ) const;

    virtual int GetColoursCount() const;

private:
    public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};
# 41 "/usr/include/wx-2.8/wx/palette.h" 2
# 34 "/usr/include/wx-2.8/wx/window.h" 2



# 1 "/usr/include/wx-2.8/wx/accel.h" 1
# 21 "/usr/include/wx-2.8/wx/accel.h"
class wxAcceleratorTable;
class wxMenuItem;
class wxKeyEvent;






enum
{
    wxACCEL_NORMAL = 0x0000,
    wxACCEL_ALT = 0x0001,
    wxACCEL_CTRL = 0x0002,
    wxACCEL_SHIFT = 0x0004,



    wxACCEL_CMD = wxACCEL_CTRL

};





class wxAcceleratorEntry
{
public:
    wxAcceleratorEntry(int flags = 0, int keyCode = 0, int cmd = 0,
                       wxMenuItem *item = __null)
        : m_flags(flags)
        , m_keyCode(keyCode)
        , m_command(cmd)
        , m_item(item)
        { }

    wxAcceleratorEntry(const wxAcceleratorEntry& entry)
        : m_flags(entry.m_flags)
        , m_keyCode(entry.m_keyCode)
        , m_command(entry.m_command)
        , m_item(entry.m_item)
        { }



    static wxAcceleratorEntry *Create(const wxString& str);

    wxAcceleratorEntry& operator=(const wxAcceleratorEntry& entry)
    {
        Set(entry.m_flags, entry.m_keyCode, entry.m_command, entry.m_item);
        return *this;
    }

    void Set(int flags, int keyCode, int cmd, wxMenuItem *item = __null)
    {
        m_flags = flags;
        m_keyCode = keyCode;
        m_command = cmd;
        m_item = item;
    }

    void SetMenuItem(wxMenuItem *item) { m_item = item; }

    int GetFlags() const { return m_flags; }
    int GetKeyCode() const { return m_keyCode; }
    int GetCommand() const { return m_command; }

    wxMenuItem *GetMenuItem() const { return m_item; }

    bool operator==(const wxAcceleratorEntry& entry) const
    {
        return m_flags == entry.m_flags &&
               m_keyCode == entry.m_keyCode &&
               m_command == entry.m_command &&
               m_item == entry.m_item;
    }

    bool operator!=(const wxAcceleratorEntry& entry) const
        { return !(*this == entry); }






    bool IsOk() const
    {
        return m_flags != 0 &&
               m_keyCode != 0;
    }
# 120 "/usr/include/wx-2.8/wx/accel.h"
    wxString ToString() const;



    bool FromString(const wxString& str);


private:

    static bool ParseAccel(const wxString& str, int *flags, int *keycode);


    int m_flags;
    int m_keyCode;
    int m_command;


    wxMenuItem *m_item;


    friend class wxMenu;
};
# 155 "/usr/include/wx-2.8/wx/accel.h"
# 1 "/usr/include/wx-2.8/wx/gtk/accel.h" 1
# 15 "/usr/include/wx-2.8/wx/gtk/accel.h"
# 1 "/usr/include/wx-2.8/wx/generic/accel.h" 1
# 13 "/usr/include/wx-2.8/wx/generic/accel.h"
class wxKeyEvent;





class wxAcceleratorTable : public wxObject
{
public:
    wxAcceleratorTable();
    wxAcceleratorTable(int n, const wxAcceleratorEntry entries[]);
    virtual ~wxAcceleratorTable();

    bool Ok() const { return IsOk(); }
    bool IsOk() const;

    void Add(const wxAcceleratorEntry& entry);
    void Remove(const wxAcceleratorEntry& entry);




    wxMenuItem *GetMenuItem(const wxKeyEvent& event) const;
    int GetCommand(const wxKeyEvent& event) const;

    const wxAcceleratorEntry *GetEntry(const wxKeyEvent& event) const;

protected:

    virtual wxObjectRefData *CreateRefData() const;
    virtual wxObjectRefData *CloneRefData(const wxObjectRefData *data) const;

private:
    public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};
# 15 "/usr/include/wx-2.8/wx/gtk/accel.h" 2
# 156 "/usr/include/wx-2.8/wx/accel.h" 2
# 166 "/usr/include/wx-2.8/wx/accel.h"
extern wxAcceleratorTable wxNullAcceleratorTable;
# 38 "/usr/include/wx-2.8/wx/window.h" 2
# 56 "/usr/include/wx-2.8/wx/window.h"
class wxCaret;
class wxControl;
class wxCursor;
class wxDC;
class wxDropTarget;
class wxItemResource;
class wxLayoutConstraints;
class wxResourceTable;
class wxSizer;
class wxToolTip;
class wxWindowBase;
class wxWindow;
class wxScrollHelper;
# 79 "/usr/include/wx-2.8/wx/window.h"
struct wxVisualAttributes
{

    wxFont font;


    wxColour colFg;



    wxColour colBg;
};



enum wxWindowVariant
{
    wxWINDOW_VARIANT_NORMAL,
    wxWINDOW_VARIANT_SMALL,
    wxWINDOW_VARIANT_MINI,
    wxWINDOW_VARIANT_LARGE,
    wxWINDOW_VARIANT_MAX
};
# 111 "/usr/include/wx-2.8/wx/window.h"
typedef int (*wxSortFuncFor_wxWindowList)(const wxWindow **, const wxWindow **); class wxWindowListNode : public wxNodeBase { public: wxWindowListNode(wxListBase *list = (wxListBase *)__null, wxWindowListNode *previous = (wxWindowListNode *)__null, wxWindowListNode *next = (wxWindowListNode *)__null, wxWindow *data = (wxWindow *)__null, const wxListKey& key = wxDefaultListKey) : wxNodeBase(list, previous, next, data, key) { } wxWindowListNode *GetNext() const { return (wxWindowListNode *)wxNodeBase::GetNext(); } wxWindowListNode *GetPrevious() const { return (wxWindowListNode *)wxNodeBase::GetPrevious(); } wxWindow *GetData() const { return (wxWindow *)wxNodeBase::GetData(); } void SetData(wxWindow *data) { wxNodeBase::SetData(data); } protected: virtual void DeleteData(); private: wxWindowListNode(const wxWindowListNode&); wxWindowListNode& operator=(const wxWindowListNode&); }; class wxWindowList : public wxListBase { public: typedef wxWindowListNode Node; class compatibility_iterator { public: compatibility_iterator(Node *ptr = __null) : m_ptr(ptr) { } Node *operator->() const { return m_ptr; } operator Node *() const { return m_ptr; } private: Node *m_ptr; }; wxWindowList(wxKeyType keyType = wxKEY_NONE) : wxListBase(keyType) { } wxWindowList(const wxWindowList& list) : wxListBase(list.GetKeyType()) { Assign(list); } wxWindowList(size_t count, wxWindow *elements[]) : wxListBase(count, (void **)elements) { } wxWindowList& operator=(const wxWindowList& list) { Assign(list); return *this; } wxWindowListNode *GetFirst() const { return (wxWindowListNode *)wxListBase::GetFirst(); } wxWindowListNode *GetLast() const { return (wxWindowListNode *)wxListBase::GetLast(); } wxWindowListNode *Item(size_t index) const { return (wxWindowListNode *)wxListBase::Item(index); } wxWindow *operator[](size_t index) const { wxWindowListNode *node = Item(index); return node ? (wxWindow*)(node->GetData()) : (wxWindow*)__null; } wxWindowListNode *Append(wxWindowBase *object) { return (wxWindowListNode *)wxListBase::Append(object); } wxWindowListNode *Insert(wxWindowBase *object) { return (wxWindowListNode *)Insert((wxWindowListNode*)__null, object); } wxWindowListNode *Insert(size_t pos, wxWindowBase *object) { return (wxWindowListNode *)wxListBase::Insert(pos, object); } wxWindowListNode *Insert(wxWindowListNode *prev, wxWindowBase *object) { return (wxWindowListNode *)wxListBase::Insert(prev, object); } wxWindowListNode *Append(long key, void *object) { return (wxWindowListNode *)wxListBase::Append(key, object); } wxWindowListNode *Append(const wxChar *key, void *object) { return (wxWindowListNode *)wxListBase::Append(key, object); } wxWindowListNode *DetachNode(wxWindowListNode *node) { return (wxWindowListNode *)wxListBase::DetachNode(node); } bool DeleteNode(wxWindowListNode *node) { return wxListBase::DeleteNode(node); } bool DeleteObject(wxWindowBase *object) { return wxListBase::DeleteObject(object); } void Erase(wxWindowListNode *it) { DeleteNode(it); } wxWindowListNode *Find(const wxWindowBase *object) const { return (wxWindowListNode *)wxListBase::Find(object); } virtual wxWindowListNode *Find(const wxListKey& key) const { return (wxWindowListNode *)wxListBase::Find(key); } int IndexOf(wxWindowBase *object) const { return wxListBase::IndexOf(object); } void Sort(wxSortCompareFunction func) { wxListBase::Sort(func); } void Sort(wxSortFuncFor_wxWindowList func) { Sort((wxSortCompareFunction)func); } protected: virtual wxNodeBase *CreateNode(wxNodeBase *prev, wxNodeBase *next, void *data, const wxListKey& key = wxDefaultListKey) { return new wxWindowListNode(this, (wxWindowListNode *)prev, (wxWindowListNode *)next, (wxWindow *)data, key); } public: typedef size_t size_type; typedef int difference_type; typedef wxWindow* value_type; typedef wxWindowBase* base_value_type; typedef value_type& reference; typedef const value_type& const_reference; typedef base_value_type& base_reference; typedef const base_value_type& const_base_reference; class iterator { typedef wxWindowList list; public: typedef wxWindowListNode Node; typedef iterator itor; typedef wxWindow* value_type; typedef value_type* ptr_type; typedef value_type& reference; Node* m_node; Node* m_init; public: typedef reference reference_type; typedef ptr_type pointer_type; iterator(Node* node, Node* init) : m_node(node), m_init(init) {} iterator() : m_node(__null), m_init(__null) { } reference_type operator*() const { return *(pointer_type)m_node->GetDataPtr(); } itor& operator++() { m_node = m_node->GetNext(); return *this; } const itor operator++(int) { itor tmp = *this; m_node = m_node->GetNext(); return tmp; } itor& operator--() { m_node = m_node ? m_node->GetPrevious() : m_init; return *this; } const itor operator--(int) { itor tmp = *this; m_node = m_node ? m_node->GetPrevious() : m_init; return tmp; } bool operator!=(const itor& it) const { return it.m_node != m_node; } bool operator==(const itor& it) const { return it.m_node == m_node; } }; class const_iterator { typedef wxWindowList list; public: typedef wxWindowListNode Node; typedef wxWindow* value_type; typedef const value_type& const_reference; typedef const_iterator itor; typedef value_type* ptr_type; Node* m_node; Node* m_init; public: typedef const_reference reference_type; typedef const ptr_type pointer_type; const_iterator(Node* node, Node* init) : m_node(node), m_init(init) { } const_iterator() : m_node(__null), m_init(__null) { } const_iterator(const iterator& it) : m_node(it.m_node), m_init(it.m_init) { } reference_type operator*() const { return *(pointer_type)m_node->GetDataPtr(); } itor& operator++() { m_node = m_node->GetNext(); return *this; } const itor operator++(int) { itor tmp = *this; m_node = m_node->GetNext(); return tmp; } itor& operator--() { m_node = m_node ? m_node->GetPrevious() : m_init; return *this; } const itor operator--(int) { itor tmp = *this; m_node = m_node ? m_node->GetPrevious() : m_init; return tmp; } bool operator!=(const itor& it) const { return it.m_node != m_node; } bool operator==(const itor& it) const { return it.m_node == m_node; } }; class reverse_iterator { typedef wxWindowList list; public: typedef wxWindowListNode Node; typedef wxWindow* value_type; typedef reverse_iterator itor; typedef value_type* ptr_type; typedef value_type& reference; Node* m_node; Node* m_init; public: typedef reference reference_type; typedef ptr_type pointer_type; reverse_iterator(Node* node, Node* init) : m_node(node), m_init(init) { } reverse_iterator() : m_node(__null), m_init(__null) { } reference_type operator*() const { return *(pointer_type)m_node->GetDataPtr(); } itor& operator++() { m_node = m_node->GetPrevious(); return *this; } const itor operator++(int) { itor tmp = *this; m_node = m_node->GetPrevious(); return tmp; } itor& operator--() { m_node = m_node ? m_node->GetNext() : m_init; return *this; } const itor operator--(int) { itor tmp = *this; m_node = m_node ? m_node->GetNext() : m_init; return tmp; } bool operator!=(const itor& it) const { return it.m_node != m_node; } bool operator==(const itor& it) const { return it.m_node == m_node; } }; class const_reverse_iterator { typedef wxWindowList list; public: typedef wxWindowListNode Node; typedef wxWindow* value_type; typedef const_reverse_iterator itor; typedef value_type* ptr_type; typedef const value_type& const_reference; Node* m_node; Node* m_init; public: typedef const_reference reference_type; typedef const ptr_type pointer_type; const_reverse_iterator(Node* node, Node* init) : m_node(node), m_init(init) { } const_reverse_iterator() : m_node(__null), m_init(__null) { } const_reverse_iterator(const reverse_iterator& it) : m_node(it.m_node), m_init(it.m_init) { } reference_type operator*() const { return *(pointer_type)m_node->GetDataPtr(); } itor& operator++() { m_node = m_node->GetPrevious(); return *this; } const itor operator++(int) { itor tmp = *this; m_node = m_node->GetPrevious(); return tmp; } itor& operator--() { m_node = m_node ? m_node->GetNext() : m_init; return *this;} const itor operator--(int) { itor tmp = *this; m_node = m_node ? m_node->GetNext() : m_init; return tmp; } bool operator!=(const itor& it) const { return it.m_node != m_node; } bool operator==(const itor& it) const { return it.m_node == m_node; } }; explicit wxWindowList(size_type n, const_reference v = value_type()) { assign(n, v); } wxWindowList(const const_iterator& first, const const_iterator& last) { assign(first, last); } iterator begin() { return iterator(GetFirst(), GetLast()); } const_iterator begin() const { return const_iterator(GetFirst(), GetLast()); } iterator end() { return iterator(__null, GetLast()); } const_iterator end() const { return const_iterator(__null, GetLast()); } reverse_iterator rbegin() { return reverse_iterator(GetLast(), GetFirst()); } const_reverse_iterator rbegin() const { return const_reverse_iterator(GetLast(), GetFirst()); } reverse_iterator rend() { return reverse_iterator(__null, GetFirst()); } const_reverse_iterator rend() const { return const_reverse_iterator(__null, GetFirst()); } void resize(size_type n, value_type v = value_type()) { while (n < size()) pop_back(); while (n > size()) push_back(v); } size_type size() const { return GetCount(); } size_type max_size() const { return 2147483647; } bool empty() const { return IsEmpty(); } reference front() { return *begin(); } const_reference front() const { return *begin(); } reference back() { iterator tmp = end(); return *--tmp; } const_reference back() const { const_iterator tmp = end(); return *--tmp; } void push_front(const_reference v = value_type()) { Insert(GetFirst(), (const_base_reference)v); } void pop_front() { DeleteNode(GetFirst()); } void push_back(const_reference v = value_type()) { Append((const_base_reference)v); } void pop_back() { DeleteNode(GetLast()); } void assign(const_iterator first, const const_iterator& last) { clear(); for(; first != last; ++first) Append((const_base_reference)*first); } void assign(size_type n, const_reference v = value_type()) { clear(); for(size_type i = 0; i < n; ++i) Append((const_base_reference)v); } iterator insert(const iterator& it, const_reference v = value_type()) { if ( it == end() ) Append((const_base_reference)v); else Insert(it.m_node, (const_base_reference)v); iterator itprev(it); return itprev--; } void insert(const iterator& it, size_type n, const_reference v = value_type()) { for(size_type i = 0; i < n; ++i) insert(it, v); } void insert(const iterator& it, const_iterator first, const const_iterator& last) { for(; first != last; ++first) insert(it, *first); } iterator erase(const iterator& it) { iterator next = iterator(it.m_node->GetNext(), GetLast()); DeleteNode(it.m_node); return next; } iterator erase(const iterator& first, const iterator& last) { iterator next = last; if ( next != end() ) ++next; DeleteNodes(first.m_node, last.m_node); return next; } void clear() { Clear(); } void splice(const iterator& it, wxWindowList& l, const iterator& first, const iterator& last) { insert(it, first, last); l.erase(first, last); } void splice(const iterator& it, wxWindowList& l) { splice(it, l, l.begin(), l.end() ); } void splice(const iterator& it, wxWindowList& l, const iterator& first) { if ( it != first ) { insert(it, *first); l.erase(first); } } void remove(const_reference v) { DeleteObject((const_base_reference)v); } void reverse() { Reverse(); } };





extern wxWindowList wxTopLevelWindows;
extern wxList wxPendingDelete;
# 131 "/usr/include/wx-2.8/wx/window.h"
class wxWindowBase : public wxEvtHandler
{
public:





    wxWindowBase() ;


    bool CreateBase(wxWindowBase *parent,
                    wxWindowID winid,
                    const wxPoint& pos = wxDefaultPosition,
                    const wxSize& size = wxDefaultSize,
                    long style = 0,
                    const wxValidator& validator = wxDefaultValidator,
                    const wxString& name = wxPanelNameStr);

    virtual ~wxWindowBase();






    bool Close( bool force = false );






    virtual bool Destroy();

    bool DestroyChildren();


    bool IsBeingDeleted() const { return m_isBeingDeleted; }







    virtual void SetLabel(const wxString& label) = 0;
    virtual wxString GetLabel() const = 0;



    virtual void SetName( const wxString &name ) { m_windowName = name; }
    virtual wxString GetName() const { return m_windowName; }



    void SetWindowVariant(wxWindowVariant variant);
    wxWindowVariant GetWindowVariant() const { return m_windowVariant; }




    void SetId( wxWindowID winid ) { m_windowId = winid; }
    wxWindowID GetId() const { return m_windowId; }



    virtual wxLayoutDirection GetLayoutDirection() const
        { return wxLayout_Default; }
    virtual void SetLayoutDirection(wxLayoutDirection )
        { }



    virtual wxCoord AdjustForLayoutDirection(wxCoord x,
                                             wxCoord width,
                                             wxCoord widthTotal) const;



    static int NewControlId() { return --ms_lastControlId; }


    static int NextControlId(int winid) { return winid - 1; }


    static int PrevControlId(int winid) { return winid + 1; }





    void SetSize( int x, int y, int width, int height,
                  int sizeFlags = (0x0001|0x0002) )
        { DoSetSize(x, y, width, height, sizeFlags); }

    void SetSize( int width, int height )
        { DoSetSize( wxDefaultCoord, wxDefaultCoord, width, height, 0x0000 ); }

    void SetSize( const wxSize& size )
        { SetSize( size.x, size.y); }

    void SetSize(const wxRect& rect, int sizeFlags = (0x0001|0x0002))
        { DoSetSize(rect.x, rect.y, rect.width, rect.height, sizeFlags); }

    void Move(int x, int y, int flags = 0x0000)
        { DoSetSize(x, y, wxDefaultCoord, wxDefaultCoord, flags); }

    void Move(const wxPoint& pt, int flags = 0x0000)
        { Move(pt.x, pt.y, flags); }

    void SetPosition(const wxPoint& pt) { Move(pt); }


    virtual void Raise() = 0;
    virtual void Lower() = 0;


    void SetClientSize( int width, int height )
        { DoSetClientSize(width, height); }

    void SetClientSize( const wxSize& size )
        { DoSetClientSize(size.x, size.y); }

    void SetClientSize(const wxRect& rect)
        { SetClientSize( rect.width, rect.height ); }





    void GetPosition( int *x, int *y ) const { DoGetPosition(x, y); }
    wxPoint GetPosition() const
    {
        int x, y;
        DoGetPosition(&x, &y);

        return wxPoint(x, y);
    }


    void GetScreenPosition(int *x, int *y) const { DoGetScreenPosition(x, y); }
    wxPoint GetScreenPosition() const
    {
        int x, y;
        DoGetScreenPosition(&x, &y);

        return wxPoint(x, y);
    }


    void GetSize( int *w, int *h ) const { DoGetSize(w, h); }
    wxSize GetSize() const
    {
        int w, h;
        DoGetSize(& w, & h);
        return wxSize(w, h);
    }

    void GetClientSize( int *w, int *h ) const { DoGetClientSize(w, h); }
    wxSize GetClientSize() const
    {
        int w, h;
        DoGetClientSize(&w, &h);

        return wxSize(w, h);
    }


    wxRect GetRect() const
    {
        int x, y, w, h;
        GetPosition(&x, &y);
        GetSize(&w, &h);

        return wxRect(x, y, w, h);
    }

    wxRect GetScreenRect() const
    {
        int x, y, w, h;
        GetScreenPosition(&x, &y);
        GetSize(&w, &h);

        return wxRect(x, y, w, h);
    }




    virtual wxPoint GetClientAreaOrigin() const;


    wxRect GetClientRect() const
    {
        return wxRect(GetClientAreaOrigin(), GetClientSize());
    }



    wxSize ClientToWindowSize(const wxSize& size) const;
    wxSize WindowToClientSize(const wxSize& size) const;





    wxSize GetBestSize() const
    {
        if (m_bestSizeCache.IsFullySpecified())
            return m_bestSizeCache;
        return DoGetBestSize();
    }
    void GetBestSize(int *w, int *h) const
    {
        wxSize s = GetBestSize();
        if ( w )
            *w = s.x;
        if ( h )
            *h = s.y;
    }

    void SetScrollHelper( wxScrollHelper *sh ) { m_scrollHelper = sh; }
    wxScrollHelper *GetScrollHelper() { return m_scrollHelper; }



    void InvalidateBestSize();
    void CacheBestSize(const wxSize& size) const
        { const_cast<wxWindowBase *>(this)->m_bestSizeCache = size; }





    wxSize GetEffectiveMinSize() const;
    wxSize GetBestFittingSize() const __attribute__ ((deprecated));
    wxSize GetAdjustedMinSize() const __attribute__ ((deprecated));



    void SetInitialSize(const wxSize& size=wxDefaultSize);
    void SetBestFittingSize(const wxSize& size=wxDefaultSize) __attribute__ ((deprecated));





    void Centre(int dir = wxBOTH) { DoCentre(dir); }
    void Center(int dir = wxBOTH) { DoCentre(dir); }


    void CentreOnParent(int dir = wxBOTH) { DoCentre(dir); }
    void CenterOnParent(int dir = wxBOTH) { CentreOnParent(dir); }


    virtual void Fit();


    virtual void FitInside();
# 399 "/usr/include/wx-2.8/wx/window.h"
    virtual void SetSizeHints( int minW, int minH,
                               int maxW = wxDefaultCoord, int maxH = wxDefaultCoord,
                               int incW = wxDefaultCoord, int incH = wxDefaultCoord )
    { DoSetSizeHints(minW, minH, maxW, maxH, incW, incH); }

    void SetSizeHints( const wxSize& minSize,
                       const wxSize& maxSize=wxDefaultSize,
                       const wxSize& incSize=wxDefaultSize)
    { DoSetSizeHints(minSize.x, minSize.y, maxSize.x, maxSize.y, incSize.x, incSize.y); }

    virtual void DoSetSizeHints( int minW, int minH,
                                 int maxW, int maxH,
                                 int incW, int incH );




    virtual void SetVirtualSizeHints( int minW, int minH,
                                      int maxW = wxDefaultCoord, int maxH = wxDefaultCoord );
    void SetVirtualSizeHints( const wxSize& minSize,
                              const wxSize& maxSize=wxDefaultSize)
    {
        SetVirtualSizeHints(minSize.x, minSize.y, maxSize.x, maxSize.y);
    }





    virtual void SetMinSize(const wxSize& minSize) { m_minWidth = minSize.x; m_minHeight = minSize.y; }
    virtual void SetMaxSize(const wxSize& maxSize) { m_maxWidth = maxSize.x; m_maxHeight = maxSize.y; }




    virtual wxSize GetMinSize() const { return wxSize(m_minWidth, m_minHeight); }
    virtual wxSize GetMaxSize() const { return wxSize(m_maxWidth, m_maxHeight); }


    int GetMinWidth() const { return GetMinSize().x; }
    int GetMinHeight() const { return GetMinSize().y; }
    int GetMaxWidth() const { return GetMaxSize().x; }
    int GetMaxHeight() const { return GetMaxSize().y; }
# 450 "/usr/include/wx-2.8/wx/window.h"
    void SetVirtualSize( const wxSize &size ) { DoSetVirtualSize( size.x, size.y ); }
    void SetVirtualSize( int x, int y ) { DoSetVirtualSize( x, y ); }

    wxSize GetVirtualSize() const { return DoGetVirtualSize(); }
    void GetVirtualSize( int *x, int *y ) const
    {
        wxSize s( DoGetVirtualSize() );

        if( x )
            *x = s.GetWidth();
        if( y )
            *y = s.GetHeight();
    }





    virtual void DoSetVirtualSize( int x, int y );
    virtual wxSize DoGetVirtualSize() const;




    virtual wxSize GetBestVirtualSize() const
    {
        wxSize client( GetClientSize() );
        wxSize best( GetBestSize() );

        return wxSize( (((client.x) > (best.x)) ? (client.x) : (best.x)), (((client.y) > (best.y)) ? (client.y) : (best.y)) );
    }



    virtual wxSize GetWindowBorderSize() const;







    virtual bool Show( bool show = true );
    bool Hide() { return Show(false); }


    virtual bool Enable( bool enable = true );
    bool Disable() { return Enable(false); }

    virtual bool IsShown() const { return m_isShown; }
    virtual bool IsEnabled() const { return m_isEnabled; }



    virtual bool IsShownOnScreen() const;



    virtual void SetWindowStyleFlag( long style ) { m_windowStyle = style; }
    virtual long GetWindowStyleFlag() const { return m_windowStyle; }


    void SetWindowStyle( long style ) { SetWindowStyleFlag(style); }
    long GetWindowStyle() const { return GetWindowStyleFlag(); }


    bool HasFlag(int flag) const { return (m_windowStyle & flag) != 0; }
    virtual bool IsRetained() const { return HasFlag(0x00000000); }



    bool ToggleWindowStyle(int flag);



    virtual void SetExtraStyle(long exStyle) { m_exStyle = exStyle; }
    long GetExtraStyle() const { return m_exStyle; }


    virtual void MakeModal(bool modal = true);





    virtual void SetThemeEnabled(bool enableTheme) { m_themeEnabled = enableTheme; }
    virtual bool GetThemeEnabled() const { return m_themeEnabled; }






    virtual void SetFocus() = 0;


    virtual void SetFocusFromKbd() { SetFocus(); }


    static wxWindow *FindFocus();

    static wxWindow *DoFindFocus() ;


    virtual bool AcceptsFocus() const { return IsShown() && IsEnabled(); }




    virtual bool AcceptsFocusFromKeyboard() const { return AcceptsFocus(); }


    virtual bool Navigate(int flags = wxNavigationKeyEvent::IsForward);



    void MoveBeforeInTabOrder(wxWindow *win)
        { DoMoveInTabOrder(win, MoveBefore); }
    void MoveAfterInTabOrder(wxWindow *win)
        { DoMoveInTabOrder(win, MoveAfter); }






    const wxWindowList& GetChildren() const { return m_children; }
    wxWindowList& GetChildren() { return m_children; }


    const wxWindowList& GetWindowChildren() const { return GetChildren() ; }




    wxWindow *GetPrevSibling() const { return DoGetSibling(MoveBefore); }
    wxWindow *GetNextSibling() const { return DoGetSibling(MoveAfter); }



    wxWindow *GetParent() const { return m_parent; }
    inline wxWindow *GetGrandParent() const;


    virtual bool IsTopLevel() const;


    void SetParent( wxWindowBase *parent ) { m_parent = (wxWindow *)parent; }


    virtual bool Reparent( wxWindowBase *newParent );


    virtual void AddChild( wxWindowBase *child );
    virtual void RemoveChild( wxWindowBase *child );






    wxWindow *FindWindow(long winid) const;
    wxWindow *FindWindow(const wxString& name) const;


    static wxWindow *FindWindowById( long winid, const wxWindow *parent = __null );
    static wxWindow *FindWindowByName( const wxString& name,
                                       const wxWindow *parent = __null );
    static wxWindow *FindWindowByLabel( const wxString& label,
                                        const wxWindow *parent = __null );





    wxEvtHandler *GetEventHandler() const { return m_eventHandler; }



    void SetEventHandler( wxEvtHandler *handler ) { m_eventHandler = handler; }



    void PushEventHandler( wxEvtHandler *handler );
    wxEvtHandler *PopEventHandler( bool deleteHandler = false );






    bool RemoveEventHandler(wxEvtHandler *handler);







    virtual void SetValidator( const wxValidator &validator );
    virtual wxValidator *GetValidator() { return m_windowValidator; }







    virtual bool Validate();


    virtual bool TransferDataToWindow();
    virtual bool TransferDataFromWindow();

    virtual void InitDialog();




    virtual void SetAcceleratorTable( const wxAcceleratorTable& accel )
        { m_acceleratorTable = accel; }
    wxAcceleratorTable *GetAcceleratorTable()
        { return &m_acceleratorTable; }
# 688 "/usr/include/wx-2.8/wx/window.h"
    wxPoint ConvertPixelsToDialog( const wxPoint& pt );
    wxPoint ConvertDialogToPixels( const wxPoint& pt );
    wxSize ConvertPixelsToDialog( const wxSize& sz )
    {
        wxPoint pt(ConvertPixelsToDialog(wxPoint(sz.x, sz.y)));

        return wxSize(pt.x, pt.y);
    }

    wxSize ConvertDialogToPixels( const wxSize& sz )
    {
        wxPoint pt(ConvertDialogToPixels(wxPoint(sz.x, sz.y)));

        return wxSize(pt.x, pt.y);
    }





    virtual void WarpPointer(int x, int y) = 0;





    void CaptureMouse();
    void ReleaseMouse();


    static wxWindow *GetCapture();


    virtual bool HasCapture() const
        { return (wxWindow *)this == GetCapture(); }






    virtual void Refresh( bool eraseBackground = true,
                          const wxRect *rect = (const wxRect *) __null ) = 0;


    void RefreshRect(const wxRect& rect, bool eraseBackground = true)
    {
        Refresh(eraseBackground, &rect);
    }


    virtual void Update() { }


    virtual void ClearBackground();


    virtual void Freeze() { }


    virtual void Thaw() { }


    virtual bool IsFrozen() const { return false; }


    virtual void PrepareDC( wxDC & ) { }


    virtual bool IsDoubleBuffered() const { return false; }



    const wxRegion& GetUpdateRegion() const { return m_updateRegion; }
    wxRegion& GetUpdateRegion() { return m_updateRegion; }


    wxRect GetUpdateClientRect() const;



    virtual bool DoIsExposed( int x, int y ) const;
    virtual bool DoIsExposed( int x, int y, int w, int h ) const;

    bool IsExposed( int x, int y ) const
        { return DoIsExposed(x, y); }
    bool IsExposed( int x, int y, int w, int h ) const
    { return DoIsExposed(x, y, w, h); }
    bool IsExposed( const wxPoint& pt ) const
        { return DoIsExposed(pt.x, pt.y); }
    bool IsExposed( const wxRect& rect ) const
        { return DoIsExposed(rect.x, rect.y, rect.width, rect.height); }
# 791 "/usr/include/wx-2.8/wx/window.h"
    virtual wxVisualAttributes GetDefaultAttributes() const
    {
        return GetClassDefaultAttributes(GetWindowVariant());
    }

    static wxVisualAttributes
    GetClassDefaultAttributes(wxWindowVariant variant = wxWINDOW_VARIANT_NORMAL);





    virtual bool SetBackgroundColour(const wxColour& colour);
    void SetOwnBackgroundColour(const wxColour& colour)
    {
        if ( SetBackgroundColour(colour) )
            m_inheritBgCol = false;
    }
    wxColour GetBackgroundColour() const;
    bool InheritsBackgroundColour() const
    {
        return m_inheritBgCol;
    }
    bool UseBgCol() const
    {
        return m_hasBgCol;
    }

    virtual bool SetForegroundColour(const wxColour& colour);
    void SetOwnForegroundColour(const wxColour& colour)
    {
        if ( SetForegroundColour(colour) )
            m_inheritFgCol = false;
    }
    wxColour GetForegroundColour() const;



    virtual bool SetBackgroundStyle(wxBackgroundStyle style) { m_backgroundStyle = style; return true; }
    virtual wxBackgroundStyle GetBackgroundStyle() const { return m_backgroundStyle; }




    virtual bool HasTransparentBackground() { return false; }



    virtual bool SetFont(const wxFont& font) = 0;
    void SetOwnFont(const wxFont& font)
    {
        if ( SetFont(font) )
            m_inheritFont = false;
    }
    wxFont GetFont() const;



    virtual bool SetCursor( const wxCursor &cursor );
    const wxCursor& GetCursor() const { return m_cursor; }



    void SetCaret(wxCaret *caret);

    wxCaret *GetCaret() const { return m_caret; }



    virtual int GetCharHeight() const = 0;
    virtual int GetCharWidth() const = 0;



    virtual void GetTextExtent(const wxString& string,
                               int *x, int *y,
                               int *descent = (int *) __null,
                               int *externalLeading = (int *) __null,
                               const wxFont *theFont = (const wxFont *) __null)
                               const = 0;





    void ClientToScreen( int *x, int *y ) const
        { DoClientToScreen(x, y); }
    void ScreenToClient( int *x, int *y ) const
        { DoScreenToClient(x, y); }


    wxPoint ClientToScreen(const wxPoint& pt) const
    {
        int x = pt.x, y = pt.y;
        DoClientToScreen(&x, &y);

        return wxPoint(x, y);
    }

    wxPoint ScreenToClient(const wxPoint& pt) const
    {
        int x = pt.x, y = pt.y;
        DoScreenToClient(&x, &y);

        return wxPoint(x, y);
    }


    wxHitTest HitTest(wxCoord x, wxCoord y) const
        { return DoHitTest(x, y); }

    wxHitTest HitTest(const wxPoint& pt) const
        { return DoHitTest(pt.x, pt.y); }







    wxBorder GetBorder(long flags) const;


    wxBorder GetBorder() const { return GetBorder(GetWindowStyleFlag()); }


    virtual void UpdateWindowUI(long flags = wxUPDATE_UI_NONE);


    virtual void DoUpdateWindowUI(wxUpdateUIEvent& event) ;


    bool PopupMenu(wxMenu *menu, const wxPoint& pos = wxDefaultPosition)
        { return DoPopupMenu(menu, pos.x, pos.y); }
    bool PopupMenu(wxMenu *menu, int x, int y)
        { return DoPopupMenu(menu, x, y); }



    virtual bool HasMultiplePages() const { return false; }






    bool HasScrollbar(int orient) const
    {
        return (m_windowStyle &
                (orient == wxHORIZONTAL ? 0x40000000 : 0x80000000)) != 0;
    }


    virtual void SetScrollbar( int orient,
                               int pos,
                               int thumbvisible,
                               int range,
                               bool refresh = true ) = 0;
    virtual void SetScrollPos( int orient, int pos, bool refresh = true ) = 0;
    virtual int GetScrollPos( int orient ) const = 0;
    virtual int GetScrollThumb( int orient ) const = 0;
    virtual int GetScrollRange( int orient ) const = 0;


    virtual void ScrollWindow( int dx, int dy,
                               const wxRect* rect = (wxRect *) __null ) = 0;




    virtual bool ScrollLines(int ) { return false; }
    virtual bool ScrollPages(int ) { return false; }


    bool LineUp() { return ScrollLines(-1); }
    bool LineDown() { return ScrollLines(1); }
    bool PageUp() { return ScrollPages(-1); }
    bool PageDown() { return ScrollPages(1); }
# 977 "/usr/include/wx-2.8/wx/window.h"
    void SetHelpText(const wxString& text);


    void SetHelpTextForId(const wxString& text);




    virtual wxString GetHelpTextAtPoint(const wxPoint& pt,
                                        wxHelpEvent::Origin origin) const;

    wxString GetHelpText() const
    {
        return GetHelpTextAtPoint(wxDefaultPosition, wxHelpEvent::Origin_Unknown);
    }
# 1004 "/usr/include/wx-2.8/wx/window.h"
    void SetToolTip( const wxString &tip );

    void SetToolTip( wxToolTip *tip ) { DoSetToolTip(tip); }


    void UnsetToolTip() { SetToolTip(__null); }


    wxToolTip* GetToolTip() const { return m_tooltip; }
    wxString GetToolTipText() const ;
# 1028 "/usr/include/wx-2.8/wx/window.h"
    virtual void SetDropTarget( wxDropTarget *dropTarget ) = 0;
    virtual wxDropTarget *GetDropTarget() const { return m_dropTarget; }




    void DragAcceptFiles(bool accept);
# 1044 "/usr/include/wx-2.8/wx/window.h"
    void SetConstraints( wxLayoutConstraints *constraints );
    wxLayoutConstraints *GetConstraints() const { return m_constraints; }


    void UnsetConstraints(wxLayoutConstraints *c);
    wxWindowList *GetConstraintsInvolvedIn() const
        { return m_constraintsInvolvedIn; }
    void AddConstraintReference(wxWindowBase *otherWin);
    void RemoveConstraintReference(wxWindowBase *otherWin);
    void DeleteRelatedConstraints();
    void ResetConstraints();


    virtual void SetConstraintSizes(bool recurse = true);
    virtual bool LayoutPhase1(int *noChanges);
    virtual bool LayoutPhase2(int *noChanges);
    virtual bool DoPhase(int phase);


    virtual void SetSizeConstraint(int x, int y, int w, int h);
    virtual void MoveConstraint(int x, int y);
    virtual void GetSizeConstraint(int *w, int *h) const ;
    virtual void GetClientSizeConstraint(int *w, int *h) const ;
    virtual void GetPositionConstraint(int *x, int *y) const ;






    void SetAutoLayout( bool autoLayout ) { m_autoLayout = autoLayout; }
    bool GetAutoLayout() const { return m_autoLayout; }


    virtual bool Layout();


    void SetSizer(wxSizer *sizer, bool deleteOld = true );
    void SetSizerAndFit( wxSizer *sizer, bool deleteOld = true );

    wxSizer *GetSizer() const { return m_windowSizer; }


    void SetContainingSizer(wxSizer* sizer);
    wxSizer *GetContainingSizer() const { return m_containingSizer; }
# 1108 "/usr/include/wx-2.8/wx/window.h"
    virtual bool SetTransparent(wxByte ) { return false; }
    virtual bool CanSetTransparent() { return false; }






    void OnSysColourChanged( wxSysColourChangedEvent& event );
    void OnInitDialog( wxInitDialogEvent &event );
    void OnMiddleClick( wxMouseEvent& event );

    void OnHelp(wxHelpEvent& event);




        virtual void OnInternalIdle() {}







    virtual WXWidget GetHandle() const = 0;

    virtual void AssociateHandle(WXWidget ) { }

    virtual void DissociateHandle() { }




    wxPalette GetPalette() const { return m_palette; }



    void SetPalette(const wxPalette& pal);


    bool HasCustomPalette() const { return m_hasCustomPalette; }


    wxWindow *GetAncestorWithCustomPalette() const;





    virtual void InheritAttributes();






    virtual bool ShouldInheritColours() const { return false; }

protected:

    virtual bool TryValidator(wxEvent& event);
    virtual bool TryParent(wxEvent& event);

    enum MoveKind
    {
        MoveBefore,
        MoveAfter
    };



    wxWindow *DoGetSibling(MoveKind order) const;



    virtual void DoMoveInTabOrder(wxWindow *win, MoveKind move);



    void SatisfyConstraints();



    void SendDestroyEvent();




    virtual wxWindow *GetMainWindowOfCompositeControl()
        { return (wxWindow*)this; }



    wxWindowID m_windowId;



    wxWindow *m_parent;
    wxWindowList m_children;



    int m_minWidth,
                         m_minHeight,
                         m_maxWidth,
                         m_maxHeight;



    wxEvtHandler *m_eventHandler;



    wxValidator *m_windowValidator;



    wxDropTarget *m_dropTarget;



    wxCursor m_cursor;
    wxFont m_font;
    wxColour m_backgroundColour,
                         m_foregroundColour;


    wxCaret *m_caret;



    wxRegion m_updateRegion;




    wxAcceleratorTable m_acceleratorTable;




    wxToolTip *m_tooltip;





    wxLayoutConstraints *m_constraints;


    wxWindowList *m_constraintsInvolvedIn;



    wxSizer *m_windowSizer;


    wxSizer *m_containingSizer;


    bool m_autoLayout:1;


    bool m_isShown:1;
    bool m_isEnabled:1;
    bool m_isBeingDeleted:1;


    bool m_hasBgCol:1;
    bool m_hasFgCol:1;
    bool m_hasFont:1;


    bool m_inheritBgCol:1;
    bool m_inheritFgCol:1;
    bool m_inheritFont:1;


    long m_windowStyle,
                         m_exStyle;
    wxString m_windowName;
    bool m_themeEnabled;
    wxBackgroundStyle m_backgroundStyle;

    wxPalette m_palette;
    bool m_hasCustomPalette;







    wxSize m_virtualSize;

    wxScrollHelper *m_scrollHelper;

    int m_minVirtualWidth;
    int m_minVirtualHeight;
    int m_maxVirtualWidth;
    int m_maxVirtualHeight;

    wxWindowVariant m_windowVariant ;



    virtual wxBorder GetDefaultBorder() const;



    static int WidthDefault(int w) { return w == wxDefaultCoord ? 20 : w; }
    static int HeightDefault(int h) { return h == wxDefaultCoord ? 20 : h; }




    wxSize m_bestSizeCache;

    void SetBestSize(const wxSize& size) __attribute__ ((deprecated));
    virtual void SetInitialBestSize(const wxSize& size) __attribute__ ((deprecated));
# 1345 "/usr/include/wx-2.8/wx/window.h"
    virtual void DoClientToScreen( int *x, int *y ) const = 0;
    virtual void DoScreenToClient( int *x, int *y ) const = 0;

    virtual wxHitTest DoHitTest(wxCoord x, wxCoord y) const;


    virtual void DoCaptureMouse() = 0;
    virtual void DoReleaseMouse() = 0;


    virtual void DoGetPosition(int *x, int *y) const = 0;
    virtual void DoGetScreenPosition(int *x, int *y) const;
    virtual void DoGetSize(int *width, int *height) const = 0;
    virtual void DoGetClientSize(int *width, int *height) const = 0;




    virtual wxSize DoGetBestSize() const;




    virtual wxSize GetWindowSizeForVirtualSize(const wxSize& size) const
    {
        return size;
    }




    virtual void DoSetSize(int x, int y,
                           int width, int height,
                           int sizeFlags = (0x0001|0x0002)) = 0;


    virtual void DoSetClientSize(int width, int height) = 0;
# 1391 "/usr/include/wx-2.8/wx/window.h"
    virtual void DoMoveWindow(int x, int y, int width, int height) = 0;




    virtual void DoCentre(int dir);


    virtual void DoSetToolTip( wxToolTip *tip );



    virtual bool DoPopupMenu(wxMenu *menu, int x, int y) = 0;





    virtual void AdjustForParentClientOrigin(int& x, int& y,
                                             int sizeFlags = 0) const;


    virtual void DoSetWindowVariant( wxWindowVariant variant ) ;



    static void NotifyCaptureLost();

private:

    static int ms_lastControlId;


    static struct wxWindowNext *ms_winCaptureNext;

    static wxWindow *ms_winCaptureCurrent;

    static bool ms_winCaptureChanging;

    public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const;
    private: wxWindowBase(const wxWindowBase&); wxWindowBase& operator=(const wxWindowBase&);
    private: static const wxEventTableEntry sm_eventTableEntries[]; protected: static const wxEventTable sm_eventTable; virtual const wxEventTable* GetEventTable() const; static wxEventHashTable sm_eventHashTable; virtual wxEventHashTable& GetEventHashTable() const;
};




inline wxSize wxWindowBase::GetBestFittingSize() const
{
    return GetEffectiveMinSize();
}

inline void wxWindowBase::SetBestFittingSize(const wxSize& size)
{
    SetInitialSize(size);
}

inline void wxWindowBase::SetBestSize(const wxSize& size)
{
    SetInitialSize(size);
}

inline void wxWindowBase::SetInitialBestSize(const wxSize& size)
{
    SetInitialSize(size);
}
# 1486 "/usr/include/wx-2.8/wx/window.h"
# 1 "/usr/include/wx-2.8/wx/gtk/window.h" 1
# 17 "/usr/include/wx-2.8/wx/gtk/window.h"
struct wxGtkIMData;

typedef GdkWindow * _wxArraywxArrayGdkWindows; struct wxAssert_wxArrayGdkWindows { unsigned int TypeTooBigToBeStoredInwxBaseArrayPtrVoid: sizeof(_wxArraywxArrayGdkWindows) <= sizeof(wxBaseArrayPtrVoid::base_type); }; typedef int ( *CMPFUNC_wxArraywxArrayGdkWindows)(_wxArraywxArrayGdkWindows *pItem1, _wxArraywxArrayGdkWindows *pItem2); class wxArrayGdkWindows : public wxBaseArrayPtrVoid { public: wxArrayGdkWindows() { } ~wxArrayGdkWindows() { } wxArrayGdkWindows& operator=(const wxArrayGdkWindows& src) { wxBaseArrayPtrVoid* temp = (wxBaseArrayPtrVoid*) this; (*temp) = ((const wxBaseArrayPtrVoid&)src); return *this; } _wxArraywxArrayGdkWindows& operator[](size_t uiIndex) const { return (_wxArraywxArrayGdkWindows&)(wxBaseArrayPtrVoid::operator[](uiIndex)); } _wxArraywxArrayGdkWindows& Item(size_t uiIndex) const { return (_wxArraywxArrayGdkWindows&)(wxBaseArrayPtrVoid::operator[](uiIndex)); } _wxArraywxArrayGdkWindows& Last() const { return (_wxArraywxArrayGdkWindows&)(wxBaseArrayPtrVoid::operator[](Count() - 1)); } int Index(_wxArraywxArrayGdkWindows lItem, bool bFromEnd = false) const { return wxBaseArrayPtrVoid::Index((base_type)lItem, bFromEnd); } void Add(_wxArraywxArrayGdkWindows lItem, size_t nInsert = 1) { wxBaseArrayPtrVoid::Add((base_type)lItem, nInsert); } void Insert(_wxArraywxArrayGdkWindows lItem, size_t uiIndex, size_t nInsert = 1) { wxBaseArrayPtrVoid::Insert((base_type)lItem, uiIndex, nInsert) ; } void RemoveAt(size_t uiIndex, size_t nRemove = 1) { wxBaseArrayPtrVoid::RemoveAt(uiIndex, nRemove); } void Remove(_wxArraywxArrayGdkWindows lItem) { int iIndex = Index(lItem); if ( iIndex != (-1) ) ; else { ; return; } typedef int wxDummyCheckInt; wxBaseArrayPtrVoid::RemoveAt((size_t)iIndex); } void Sort(CMPFUNC_wxArraywxArrayGdkWindows fCmp) { wxBaseArrayPtrVoid::Sort((CMPFUNC)fCmp); } private: typedef wxBaseArrayPtrVoid::iterator biterator; typedef wxBaseArrayPtrVoid::const_iterator bconst_iterator; typedef wxBaseArrayPtrVoid::value_type bvalue_type; typedef wxBaseArrayPtrVoid::const_reference bconst_reference; public: typedef _wxArraywxArrayGdkWindows value_type; typedef value_type* pointer; typedef const value_type* const_pointer; typedef value_type* iterator; typedef const value_type* const_iterator; typedef value_type& reference; typedef const value_type& const_reference; typedef wxBaseArrayPtrVoid::difference_type difference_type; typedef wxBaseArrayPtrVoid::size_type size_type; class reverse_iterator { typedef _wxArraywxArrayGdkWindows value_type; typedef value_type& reference; typedef value_type* pointer; typedef reverse_iterator itor; friend inline itor operator+(int o, const itor& it) { return it.m_ptr - o; } friend inline itor operator+(const itor& it, int o) { return it.m_ptr - o; } friend inline itor operator-(const itor& it, int o) { return it.m_ptr + o; } friend inline difference_type operator-(const itor& i1, const itor& i2) { return i1.m_ptr - i2.m_ptr; } public: pointer m_ptr; reverse_iterator() : m_ptr(__null) { } reverse_iterator(pointer ptr) : m_ptr(ptr) { } reverse_iterator(const itor& it) : m_ptr(it.m_ptr) { } reference operator*() const { return *m_ptr; } itor& operator++() { --m_ptr; return *this; } const itor operator++(int) { reverse_iterator tmp = *this; --m_ptr; return tmp; } itor& operator--() { ++m_ptr; return *this; } const itor operator--(int) { itor tmp = *this; ++m_ptr; return tmp; } bool operator ==(const itor& it) const { return m_ptr == it.m_ptr; } bool operator !=(const itor& it) const { return m_ptr != it.m_ptr; } }; class const_reverse_iterator { typedef _wxArraywxArrayGdkWindows value_type; typedef const value_type& reference; typedef const value_type* pointer; typedef const_reverse_iterator itor; friend inline itor operator+(int o, const itor& it) { return it.m_ptr - o; } friend inline itor operator+(const itor& it, int o) { return it.m_ptr - o; } friend inline itor operator-(const itor& it, int o) { return it.m_ptr + o; } friend inline difference_type operator-(const itor& i1, const itor& i2) { return i1.m_ptr - i2.m_ptr; } public: pointer m_ptr; const_reverse_iterator() : m_ptr(__null) { } const_reverse_iterator(pointer ptr) : m_ptr(ptr) { } const_reverse_iterator(const itor& it) : m_ptr(it.m_ptr) { } const_reverse_iterator(const reverse_iterator& it) : m_ptr(it.m_ptr) { } reference operator*() const { return *m_ptr; } itor& operator++() { --m_ptr; return *this; } const itor operator++(int) { itor tmp = *this; --m_ptr; return tmp; } itor& operator--() { ++m_ptr; return *this; } const itor operator--(int) { itor tmp = *this; ++m_ptr; return tmp; } bool operator ==(const itor& it) const { return m_ptr == it.m_ptr; } bool operator !=(const itor& it) const { return m_ptr != it.m_ptr; } }; wxArrayGdkWindows(size_type n, const_reference v) { assign(n, v); } wxArrayGdkWindows(const_iterator first, const_iterator last) { assign(first, last); } void assign(const_iterator first, const_iterator last) { wxBaseArrayPtrVoid::assign((bconst_iterator)first, (bconst_iterator)last); } void assign(size_type n, const_reference v) { wxBaseArrayPtrVoid::assign(n, (bconst_reference)v); } reference back() { return *(end() - 1); } const_reference back() const { return *(end() - 1); } iterator begin() { return (iterator)wxBaseArrayPtrVoid::begin(); } const_iterator begin() const { return (const_iterator)wxBaseArrayPtrVoid::begin(); } size_type capacity() const { return wxBaseArrayPtrVoid::capacity(); } iterator end() { return (iterator)wxBaseArrayPtrVoid::end(); } const_iterator end() const { return (const_iterator)wxBaseArrayPtrVoid::end(); } iterator erase(iterator first, iterator last) { return (iterator)wxBaseArrayPtrVoid::erase((biterator)first, (biterator)last); } iterator erase(iterator it) { return (iterator)wxBaseArrayPtrVoid::erase((biterator)it); } reference front() { return *begin(); } const_reference front() const { return *begin(); } void insert(iterator it, size_type n, const_reference v) { wxBaseArrayPtrVoid::insert((biterator)it, n, (bconst_reference)v); } iterator insert(iterator it, const_reference v = value_type()) { return (iterator)wxBaseArrayPtrVoid::insert((biterator)it, (bconst_reference)v); } void insert(iterator it, const_iterator first, const_iterator last) { wxBaseArrayPtrVoid::insert((biterator)it, (bconst_iterator)first, (bconst_iterator)last); } void pop_back() { wxBaseArrayPtrVoid::pop_back(); } void push_back(const_reference v) { wxBaseArrayPtrVoid::push_back((bconst_reference)v); } reverse_iterator rbegin() { return reverse_iterator(end() - 1); } const_reverse_iterator rbegin() const; reverse_iterator rend() { return reverse_iterator(begin() - 1); } const_reverse_iterator rend() const; void reserve(size_type n) { wxBaseArrayPtrVoid::reserve(n); } void resize(size_type n, value_type v = value_type()) { wxBaseArrayPtrVoid::resize(n, v); } };





class wxWindow;
typedef void (*wxInsertChildFunction)( wxWindow*, wxWindow* );





class wxWindow : public wxWindowBase
{
public:


    wxWindow();
    wxWindow(wxWindow *parent,
                wxWindowID id,
                const wxPoint& pos = wxDefaultPosition,
                const wxSize& size = wxDefaultSize,
                long style = 0,
                const wxString& name = wxPanelNameStr);
    bool Create(wxWindow *parent,
                wxWindowID id,
                const wxPoint& pos = wxDefaultPosition,
                const wxSize& size = wxDefaultSize,
                long style = 0,
                const wxString& name = wxPanelNameStr);
    virtual ~wxWindow();




    virtual void SetLabel(const wxString& ) { }
    virtual wxString GetLabel() const { return wxEmptyString; }

    virtual bool Destroy();

    virtual void Raise();
    virtual void Lower();

    virtual bool Show( bool show = true );
    virtual bool Enable( bool enable = true );

    virtual void SetWindowStyleFlag( long style );

    virtual bool IsRetained() const;

    virtual void SetFocus();
    virtual bool AcceptsFocus() const;

    virtual bool Reparent( wxWindowBase *newParent );

    virtual void WarpPointer(int x, int y);

    virtual void Refresh( bool eraseBackground = true,
                          const wxRect *rect = (const wxRect *) __null );
    virtual void Update();
    virtual void ClearBackground();

    virtual bool SetBackgroundColour( const wxColour &colour );
    virtual bool SetForegroundColour( const wxColour &colour );
    virtual bool SetCursor( const wxCursor &cursor );
    virtual bool SetFont( const wxFont &font );

    virtual bool SetBackgroundStyle(wxBackgroundStyle style) ;

    virtual int GetCharHeight() const;
    virtual int GetCharWidth() const;
    virtual void GetTextExtent(const wxString& string,
                               int *x, int *y,
                               int *descent = (int *) __null,
                               int *externalLeading = (int *) __null,
                               const wxFont *theFont = (const wxFont *) __null)
                               const;

    virtual void SetScrollbar( int orient, int pos, int thumbVisible,
                               int range, bool refresh = true );
    virtual void SetScrollPos( int orient, int pos, bool refresh = true );
    virtual int GetScrollPos( int orient ) const;
    virtual int GetScrollThumb( int orient ) const;
    virtual int GetScrollRange( int orient ) const;
    virtual void ScrollWindow( int dx, int dy,
                               const wxRect* rect = (wxRect *) __null );
    virtual bool ScrollLines(int lines);
    virtual bool ScrollPages(int pages);


    virtual void SetDropTarget( wxDropTarget *dropTarget );


    virtual void AddChild( wxWindowBase *child );
    virtual void RemoveChild( wxWindowBase *child );

    virtual void SetLayoutDirection(wxLayoutDirection dir);
    virtual wxLayoutDirection GetLayoutDirection() const;
    virtual wxCoord AdjustForLayoutDirection(wxCoord x,
                                             wxCoord width,
                                             wxCoord widthTotal) const;

    virtual bool DoIsExposed( int x, int y ) const;
    virtual bool DoIsExposed( int x, int y, int w, int h ) const;


    void SetDoubleBuffered(bool on);
    virtual bool IsDoubleBuffered() const;




    virtual WXWidget GetHandle() const { return m_widget; }



    virtual void OnInternalIdle();


    void GtkUpdate();


    void OnIdle(wxIdleEvent& ) {}




    virtual void OnParentEnable( bool ) {}


    bool PreCreation( wxWindow *parent, const wxPoint &pos, const wxSize &size );
    void PostCreation();




    void DoAddChild(wxWindow *child);






    void GtkSendPaintEvents();







    virtual GtkWidget* GetConnectWidget();
    void ConnectWidget( GtkWidget *widget );




    int GTKCallbackCommonPrologue(struct _GdkEventAny *event) const;





    virtual bool GTKProcessEvent(wxEvent& event) const;


    static wxLayoutDirection GTKGetLayout(GtkWidget *widget);
    static void GTKSetLayout(GtkWidget *widget, wxLayoutDirection dir);

protected:




    virtual bool GTKWidgetNeedsMnemonic() const;
    virtual void GTKWidgetDoSetMnemonic(GtkWidget* w);
# 204 "/usr/include/wx-2.8/wx/gtk/window.h"
    virtual GdkWindow *GTKGetWindow(wxArrayGdkWindows& windows) const;


    bool GTKIsOwnWindow(GdkWindow *window) const;





    bool GTKSetDelayedFocusIfNeeded();

public:

    PangoContext *GtkGetPangoDefaultContext();


    virtual void ApplyToolTip( GtkTooltips *tips, const wxChar *tip );





    void GtkUpdateSize() { m_sizeSet = false; }





    void GtkShowOnIdle() { m_showOnIdle = true; }


    bool GtkShowFromOnIdle();


    virtual void FixUpMouseEvent(GtkWidget * ,
                                 wxCoord& ,
                                 wxCoord& ) { }


    virtual bool IsTransparentForMouse() const { return false; }


    virtual bool IsRadioButton() const { return false; }


    wxEventType GetScrollEventType(GtkRange* range);

    void BlockScrollEvent();
    void UnblockScrollEvent();


    int m_x, m_y;
    int m_width, m_height;
    int m_oldClientWidth,m_oldClientHeight;


    GtkWidget *m_widget;
    GtkWidget *m_wxwindow;


    GtkWidget *m_focusWidget;

    wxGtkIMData *m_imData;



    enum ScrollDir { ScrollDir_Horz, ScrollDir_Vert, ScrollDir_Max };


    GtkRange* m_scrollBar[ScrollDir_Max];


    double m_scrollPos[ScrollDir_Max];



    bool m_blockValueChanged[ScrollDir_Max];



    static ScrollDir ScrollDirFromOrient(int orient)
    {
        return orient == wxVERTICAL ? ScrollDir_Vert : ScrollDir_Horz;
    }


    static int OrientFromScrollDir(ScrollDir dir)
    {
        return dir == ScrollDir_Horz ? wxHORIZONTAL : wxVERTICAL;
    }


    ScrollDir ScrollDirFromRange(GtkRange *range) const;



    bool m_needParent:1;
    bool m_noExpose:1;
    bool m_nativeSizeEvent:1;
    bool m_hasScrolling:1;
    bool m_hasVMT:1;
    bool m_sizeSet:1;
    bool m_resizing:1;
    bool m_acceptsFocus:1;
    bool m_hasFocus:1;
    bool m_isScrolling:1;
    bool m_clipPaintRegion:1;
    wxRegion m_nativeUpdateRegion;
    bool m_dirtyTabOrder:1;

    bool m_needsStyleChange:1;

    bool m_mouseButtonDown:1;
    bool m_blockScrollEvent:1;

    bool m_showOnIdle:1;




    wxInsertChildFunction m_insertCallback;

protected:

    virtual void DoClientToScreen( int *x, int *y ) const;
    virtual void DoScreenToClient( int *x, int *y ) const;
    virtual void DoGetPosition( int *x, int *y ) const;
    virtual void DoGetSize( int *width, int *height ) const;
    virtual void DoGetClientSize( int *width, int *height ) const;
    virtual void DoSetSize(int x, int y,
                           int width, int height,
                           int sizeFlags = (0x0001|0x0002));
    virtual void DoSetClientSize(int width, int height);
    virtual void DoMoveWindow(int x, int y, int width, int height);


    virtual bool DoPopupMenu( wxMenu *menu, int x, int y );


    virtual void DoCaptureMouse();
    virtual void DoReleaseMouse();


    virtual void DoSetToolTip( wxToolTip *tip );



    void Init();

    virtual void DoMoveInTabOrder(wxWindow *win, MoveKind move);


    void RealizeTabOrder();






    GtkRcStyle *CreateWidgetStyle(bool forceStyle = false);


    virtual void ApplyWidgetStyle(bool forceStyle = false);



    virtual void DoApplyWidgetStyle(GtkRcStyle *style);


    static void GtkScrolledWindowSetBorder(GtkWidget* w, int style);





    void GTKUpdateCursor();

private:
    enum ScrollUnit { ScrollUnit_Line, ScrollUnit_Page, ScrollUnit_Max };






    bool DoScrollByUnits(ScrollDir dir, ScrollUnit unit, int units);


    public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
    private: wxWindow(const wxWindow&); wxWindow& operator=(const wxWindow&);
};

extern wxWindow *wxFindFocusedChild(wxWindow *win);
# 1487 "/usr/include/wx-2.8/wx/window.h" 2
# 1545 "/usr/include/wx-2.8/wx/window.h"
inline wxWindow *wxWindowBase::GetGrandParent() const
{
    return m_parent ? m_parent->GetParent() : (wxWindow *)__null;
}







extern wxWindow* wxFindWindowAtPointer(wxPoint& pt);


extern wxPoint wxGetMousePosition();


extern wxWindow *wxGetActiveWindow();


 wxWindow* wxGetTopLevelParent(wxWindow *win);



    int NewControlId() __attribute__ ((deprecated));
    inline int NewControlId() { return wxWindowBase::NewControlId(); }
# 37 "/usr/include/wx-2.8/wx/wx.h" 2
# 1 "/usr/include/wx-2.8/wx/containr.h" 1
# 16 "/usr/include/wx-2.8/wx/containr.h"
class wxFocusEvent;
class wxNavigationKeyEvent;
class wxWindow;
class wxWindowBase;
# 34 "/usr/include/wx-2.8/wx/containr.h"
class wxControlContainer
{
public:

    wxControlContainer(wxWindow *winParent = __null);
    void SetContainerWindow(wxWindow *winParent) { m_winParent = winParent; }


    void HandleOnNavigationKey(wxNavigationKeyEvent& event);
    void HandleOnFocus(wxFocusEvent& event);
    void HandleOnWindowDestroy(wxWindowBase *child);



    bool DoSetFocus();


    bool AcceptsFocus() const;



    void SetLastFocus(wxWindow *win);

protected:

    bool SetFocusToChild();


    wxWindow *m_winParent;


    wxWindow *m_winLastFocused;


    bool m_inSetFocus;

    private: wxControlContainer(const wxControlContainer&); wxControlContainer& operator=(const wxControlContainer&);
};


extern bool wxSetFocusToChild(wxWindow *win, wxWindow **child);
# 38 "/usr/include/wx-2.8/wx/wx.h" 2
# 1 "/usr/include/wx-2.8/wx/panel.h" 1
# 15 "/usr/include/wx-2.8/wx/panel.h"
# 1 "/usr/include/wx-2.8/wx/generic/panelg.h" 1
# 22 "/usr/include/wx-2.8/wx/generic/panelg.h"
class wxControlContainer;

extern const wxChar wxPanelNameStr[];





class wxPanel : public wxWindow
{
public:
    wxPanel() { Init(); }



    wxPanel(wxWindow *parent,
            int x, int y, int width, int height,
            long style = 0x00080000 | wxBORDER_NONE,
            const wxString& name = wxPanelNameStr)
    {
        Init();

        Create(parent, wxID_ANY, wxPoint(x, y), wxSize(width, height), style, name);
    }


    wxPanel(wxWindow *parent,
            wxWindowID winid = wxID_ANY,
            const wxPoint& pos = wxDefaultPosition,
            const wxSize& size = wxDefaultSize,
            long style = 0x00080000 | wxBORDER_NONE,
            const wxString& name = wxPanelNameStr)
    {
        Init();

        Create(parent, winid, pos, size, style, name);
    }


    bool Create(wxWindow *parent,
                wxWindowID winid = wxID_ANY,
                const wxPoint& pos = wxDefaultPosition,
                const wxSize& size = wxDefaultSize,
                long style = 0x00080000 | wxBORDER_NONE,
                const wxString& name = wxPanelNameStr);

    virtual ~wxPanel();





    void OnSize(wxSizeEvent& event);

    virtual void InitDialog();






    public: void OnNavigationKey(wxNavigationKeyEvent& event); void OnFocus(wxFocusEvent& event); virtual void OnChildFocus(wxChildFocusEvent& event); virtual void SetFocus(); virtual void SetFocusIgnoringChildren(); virtual void RemoveChild(wxWindowBase *child); virtual bool AcceptsFocus() const; protected: wxControlContainer m_container;

protected:

    void Init();

private:
    private: wxPanel(const wxPanel&); wxPanel& operator=(const wxPanel&); public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
    private: static const wxEventTableEntry sm_eventTableEntries[]; protected: static const wxEventTable sm_eventTable; virtual const wxEventTable* GetEventTable() const; static wxEventHashTable sm_eventHashTable; virtual wxEventHashTable& GetEventHashTable() const;
};
# 16 "/usr/include/wx-2.8/wx/panel.h" 2
# 39 "/usr/include/wx-2.8/wx/wx.h" 2
# 1 "/usr/include/wx-2.8/wx/toplevel.h" 1
# 22 "/usr/include/wx-2.8/wx/toplevel.h"
# 1 "/usr/include/wx-2.8/wx/iconbndl.h" 1
# 19 "/usr/include/wx-2.8/wx/iconbndl.h"
class wxIcon;
class wxString;

typedef wxIcon _wxObjArraywxIconArray; typedef int ( *CMPFUNC_wxObjArraywxIconArray)(_wxObjArraywxIconArray **pItem1, _wxObjArraywxIconArray **pItem2); class wxIconArray : protected wxArrayPtrVoid { typedef int ( *CMPFUNCwxArrayPtrVoid)(void **pItem1, void **pItem2); typedef wxArrayPtrVoid base_array; public: wxIconArray() { } wxIconArray(const wxIconArray& src); wxIconArray& operator=(const wxIconArray& src); ~wxIconArray(); void Alloc(size_t count) { reserve(count); } size_t GetCount() const { return base_array::size(); } size_t size() const { return base_array::size(); } bool IsEmpty() const { return base_array::empty(); } bool empty() const { return base_array::empty(); } size_t Count() const { return base_array::size(); } void Shrink() { wxArrayPtrVoid::Shrink(); } _wxObjArraywxIconArray& operator[](size_t uiIndex) const { return *(_wxObjArraywxIconArray*)wxArrayPtrVoid::operator[](uiIndex); } _wxObjArraywxIconArray& Item(size_t uiIndex) const { return *(_wxObjArraywxIconArray*)wxArrayPtrVoid::operator[](uiIndex); } _wxObjArraywxIconArray& Last() const { return *(_wxObjArraywxIconArray*)(wxArrayPtrVoid::operator[](size() - 1)); } int Index(const _wxObjArraywxIconArray& lItem, bool bFromEnd = false) const; void Add(const _wxObjArraywxIconArray& lItem, size_t nInsert = 1); void Add(const _wxObjArraywxIconArray* pItem) { wxArrayPtrVoid::push_back((_wxObjArraywxIconArray*)pItem); } void push_back(const _wxObjArraywxIconArray* pItem) { wxArrayPtrVoid::push_back((_wxObjArraywxIconArray*)pItem); } void push_back(const _wxObjArraywxIconArray& lItem) { Add(lItem); } void Insert(const _wxObjArraywxIconArray& lItem, size_t uiIndex, size_t nInsert = 1); void Insert(const _wxObjArraywxIconArray* pItem, size_t uiIndex) { wxArrayPtrVoid::insert(begin() + uiIndex, (_wxObjArraywxIconArray*)pItem); } void Empty() { DoEmpty(); wxArrayPtrVoid::clear(); } void Clear() { DoEmpty(); wxArrayPtrVoid::clear(); } _wxObjArraywxIconArray* Detach(size_t uiIndex) { _wxObjArraywxIconArray* p = (_wxObjArraywxIconArray*)wxArrayPtrVoid::operator[](uiIndex); wxArrayPtrVoid::erase(begin() + uiIndex); return p; } void RemoveAt(size_t uiIndex, size_t nRemove = 1); void Sort(CMPFUNC_wxObjArraywxIconArray fCmp) { wxArrayPtrVoid::Sort((CMPFUNCwxArrayPtrVoid)fCmp); } private: void DoEmpty(); void DoCopy(const wxIconArray& src); };




class wxIconBundle
{
public:

    wxIconBundle() : m_icons() {}

    wxIconBundle( const wxString& file, long type ) : m_icons()
        { AddIcon( file, type ); }

    wxIconBundle( const wxIcon& icon ) : m_icons()
        { AddIcon( icon ); }

    const wxIconBundle& operator =( const wxIconBundle& ic );
    wxIconBundle( const wxIconBundle& ic ) : m_icons()
        { *this = ic; }

    ~wxIconBundle() { DeleteIcons(); }




    void AddIcon( const wxString& file, long type );



    void AddIcon( const wxIcon& icon );




    const wxIcon& GetIcon( const wxSize& size ) const;

    const wxIcon& GetIcon( wxCoord size = wxDefaultCoord ) const
        { return GetIcon( wxSize( size, size ) ); }
private:

    void DeleteIcons();
public:
    wxIconArray m_icons;
};
# 23 "/usr/include/wx-2.8/wx/toplevel.h" 2


extern const wxChar wxFrameNameStr[];

class wxTopLevelWindowBase;
# 94 "/usr/include/wx-2.8/wx/toplevel.h"
enum
{
    wxFULLSCREEN_NOMENUBAR = 0x0001,
    wxFULLSCREEN_NOTOOLBAR = 0x0002,
    wxFULLSCREEN_NOSTATUSBAR = 0x0004,
    wxFULLSCREEN_NOBORDER = 0x0008,
    wxFULLSCREEN_NOCAPTION = 0x0010,

    wxFULLSCREEN_ALL = wxFULLSCREEN_NOMENUBAR | wxFULLSCREEN_NOTOOLBAR |
                               wxFULLSCREEN_NOSTATUSBAR | wxFULLSCREEN_NOBORDER |
                               wxFULLSCREEN_NOCAPTION
};


enum
{
    wxUSER_ATTENTION_INFO = 1,
    wxUSER_ATTENTION_ERROR = 2
};





class wxTopLevelWindowBase : public wxWindow
{
public:

    wxTopLevelWindowBase();
    virtual ~wxTopLevelWindowBase();





    virtual void Maximize(bool maximize = true) = 0;


    virtual void Restore() = 0;


    virtual void Iconize(bool iconize = true) = 0;


    virtual bool IsMaximized() const = 0;



    virtual bool IsAlwaysMaximized() const;


    virtual bool IsIconized() const = 0;


    const wxIcon& GetIcon() const { return m_icons.GetIcon( -1 ); }


    const wxIconBundle& GetIcons() const { return m_icons; }


    virtual void SetIcon(const wxIcon& icon) { m_icons = wxIconBundle( icon ); }


    virtual void SetIcons(const wxIconBundle& icons ) { m_icons = icons; }


    virtual bool ShowFullScreen(bool show, long style = wxFULLSCREEN_ALL) = 0;


    virtual bool IsFullScreen() const = 0;



    virtual void SetTitle(const wxString& title) = 0;
    virtual wxString GetTitle() const = 0;


    virtual bool EnableCloseButton(bool ) { return false; }




    virtual bool SetShape(const wxRegion& ) { return false; }



    virtual void RequestUserAttention(int flags = wxUSER_ATTENTION_INFO);


    virtual bool IsActive() { return wxGetTopLevelParent(FindFocus()) == this; }






    virtual bool ShouldPreventAppExit() const { return true; }
# 199 "/usr/include/wx-2.8/wx/toplevel.h"
    void CentreOnScreen(int dir = wxBOTH) { DoCentre(dir | 0x0002); }
    void CenterOnScreen(int dir = wxBOTH) { CentreOnScreen(dir); }
# 210 "/usr/include/wx-2.8/wx/toplevel.h"
    virtual void RemoveChild(wxWindowBase *child);


    wxWindow *GetDefaultItem() const
        { return m_winTmpDefault ? m_winTmpDefault : m_winDefault; }


    wxWindow *SetDefaultItem(wxWindow *win)
        { wxWindow *old = GetDefaultItem(); m_winDefault = win; return old; }


    wxWindow *GetTmpDefaultItem() const { return m_winTmpDefault; }



    wxWindow *SetTmpDefaultItem(wxWindow *win)
        { wxWindow *old = GetDefaultItem(); m_winTmpDefault = win; return old; }






    virtual bool Destroy();
    virtual bool IsTopLevel() const { return true; }
    virtual bool IsVisible() const { return IsShown(); }


    void OnCloseWindow(wxCloseEvent& event);
    void OnSize(wxSizeEvent& ) { DoLayout(); }


    virtual void GetRectForTopLevelChildren(int *x, int *y, int *w, int *h);



    void OnActivate(wxActivateEvent &) { }


    virtual void DoUpdateWindowUI(wxUpdateUIEvent& event) ;


    virtual void SetMinSize(const wxSize& minSize);
    virtual void SetMaxSize(const wxSize& maxSize);


    virtual void DoSetSizeHints( int minW, int minH,
                                 int maxW = wxDefaultCoord, int maxH = wxDefaultCoord,
                                 int incW = wxDefaultCoord, int incH = wxDefaultCoord );

protected:


    virtual void DoClientToScreen(int *x, int *y) const;
    virtual void DoScreenToClient(int *x, int *y) const;


    virtual void DoCentre(int dir);



    virtual void DoGetScreenPosition(int *x, int *y) const
    {
        DoGetPosition(x, y);
    }



    virtual bool IsOneOfBars(const wxWindow *) const
        { return false; }


    bool IsLastBeforeExit() const;


    bool SendIconizeEvent(bool iconized = true);



    void DoLayout();




    static wxSize GetDefaultSize();
    static int WidthDefault(int w) { return w == wxDefaultCoord ? GetDefaultSize().x : w; }
    static int HeightDefault(int h) { return h == wxDefaultCoord ? GetDefaultSize().y : h; }


    wxIconBundle m_icons;


    wxWindow *m_winDefault;


    wxWindow *m_winTmpDefault;

    private: wxTopLevelWindowBase(const wxTopLevelWindowBase&); wxTopLevelWindowBase& operator=(const wxTopLevelWindowBase&);
    private: static const wxEventTableEntry sm_eventTableEntries[]; protected: static const wxEventTable sm_eventTable; virtual const wxEventTable* GetEventTable() const; static wxEventHashTable sm_eventHashTable; virtual wxEventHashTable& GetEventHashTable() const;
};
# 320 "/usr/include/wx-2.8/wx/toplevel.h"
# 1 "/usr/include/wx-2.8/wx/gtk/toplevel.h" 1
# 17 "/usr/include/wx-2.8/wx/gtk/toplevel.h"
class wxTopLevelWindowGTK : public wxTopLevelWindowBase
{
public:

    wxTopLevelWindowGTK() { Init(); }
    wxTopLevelWindowGTK(wxWindow *parent,
                        wxWindowID id,
                        const wxString& title,
                        const wxPoint& pos = wxDefaultPosition,
                        const wxSize& size = wxDefaultSize,
                        long style = (0x0800 | 0x0040 | 0x0400 | 0x0200 | 0x1000 | 0x20000000 | 0x00400000),
                        const wxString& name = wxFrameNameStr)
    {
        Init();

        Create(parent, id, title, pos, size, style, name);
    }

    bool Create(wxWindow *parent,
                wxWindowID id,
                const wxString& title,
                const wxPoint& pos = wxDefaultPosition,
                const wxSize& size = wxDefaultSize,
                long style = (0x0800 | 0x0040 | 0x0400 | 0x0200 | 0x1000 | 0x20000000 | 0x00400000),
                const wxString& name = wxFrameNameStr);

    virtual ~wxTopLevelWindowGTK();


    virtual void Maximize(bool maximize = true);
    virtual bool IsMaximized() const;
    virtual void Iconize(bool iconize = true);
    virtual bool IsIconized() const;
    virtual void SetIcon(const wxIcon& icon);
    virtual void SetIcons(const wxIconBundle& icons);
    virtual void Restore();

    virtual bool EnableCloseButton(bool enable = true);

    virtual bool ShowFullScreen(bool show, long style = wxFULLSCREEN_ALL);
    virtual bool IsFullScreen() const { return m_fsIsShowing; };

    virtual bool SetShape(const wxRegion& region);

    virtual void RequestUserAttention(int flags = wxUSER_ATTENTION_INFO);

    virtual void SetWindowStyleFlag( long style );

    virtual bool Show(bool show = true);

    virtual void Raise();

    virtual bool IsActive();

    virtual void SetTitle( const wxString &title );
    virtual wxString GetTitle() const { return m_title; }

    virtual bool SetTransparent(wxByte alpha);
    virtual bool CanSetTransparent();



    virtual void AddGrab();
    virtual void RemoveGrab();
    virtual bool IsGrabbed() const { return m_grabbed; }





    virtual void GtkOnSize();
    virtual void OnInternalIdle();


    void SetIconizeState(bool iconic);

    int m_miniEdge,
                  m_miniTitle;
    GtkWidget *m_mainWidget;
    bool m_insertInClientArea;

    bool m_fsIsShowing;
    long m_fsSaveGdkFunc, m_fsSaveGdkDecor;
    long m_fsSaveFlag;
    wxRect m_fsSaveFrame;


    long m_gdkFunc,
                  m_gdkDecor;



    int m_urgency_hint;



    virtual void DoSetSizeHints( int minW, int minH,
                                 int maxW = wxDefaultCoord, int maxH = wxDefaultCoord,
                                 int incW = wxDefaultCoord, int incH = wxDefaultCoord );

protected:

    void Init();



    virtual void DoMoveWindow(int x, int y, int width, int height);


    virtual void DoSetSize(int x, int y,
                           int width, int height,
                           int sizeFlags = (0x0001|0x0002));

    virtual void DoSetClientSize(int width, int height);
    virtual void DoGetClientSize( int *width, int *height ) const;

    wxString m_title;


    bool m_isIconized;


    bool m_grabbed;
};
# 321 "/usr/include/wx-2.8/wx/toplevel.h" 2
# 352 "/usr/include/wx-2.8/wx/toplevel.h"
        class wxTopLevelWindow : public wxTopLevelWindowGTK
        {
        public:

            wxTopLevelWindow() { Init(); }
            wxTopLevelWindow(wxWindow *parent,
                       wxWindowID winid,
                       const wxString& title,
                       const wxPoint& pos = wxDefaultPosition,
                       const wxSize& size = wxDefaultSize,
                       long style = (0x0800 | 0x0040 | 0x0400 | 0x0200 | 0x1000 | 0x20000000 | 0x00400000),
                       const wxString& name = wxFrameNameStr)
            {
                Init();
                Create(parent, winid, title, pos, size, style, name);
            }

            private: wxTopLevelWindow(const wxTopLevelWindow&); wxTopLevelWindow& operator=(const wxTopLevelWindow&); public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
        };
# 40 "/usr/include/wx-2.8/wx/wx.h" 2
# 1 "/usr/include/wx-2.8/wx/frame.h" 1
# 22 "/usr/include/wx-2.8/wx/frame.h"
extern const wxChar wxStatusLineNameStr[];
extern const wxChar wxToolBarNameStr[];

class wxFrame;
class wxMenuBar;
class wxStatusBar;
class wxToolBar;
# 52 "/usr/include/wx-2.8/wx/frame.h"
class wxFrameBase : public wxTopLevelWindow
{
public:

    wxFrameBase();
    virtual ~wxFrameBase();

    wxFrame *New(wxWindow *parent,
                 wxWindowID winid,
                 const wxString& title,
                 const wxPoint& pos = wxDefaultPosition,
                 const wxSize& size = wxDefaultSize,
                 long style = (0x0800 | 0x0040 | 0x0400 | 0x0200 | 0x1000 | 0x20000000 | 0x00400000),
                 const wxString& name = wxFrameNameStr);






    virtual wxPoint GetClientAreaOrigin() const;



    virtual void SendSizeEvent();





    virtual void SetMenuBar(wxMenuBar *menubar);
    virtual wxMenuBar *GetMenuBar() const { return m_frameMenuBar; }



    bool ProcessCommand(int winid);





    virtual wxStatusBar* CreateStatusBar(int number = 1,
                                         long style = 0x0010|0x00010000,
                                         wxWindowID winid = 0,
                                         const wxString& name =
                                            wxStatusLineNameStr);

    virtual wxStatusBar *OnCreateStatusBar(int number,
                                           long style,
                                           wxWindowID winid,
                                           const wxString& name);

    virtual wxStatusBar *GetStatusBar() const { return m_frameStatusBar; }


    virtual void SetStatusBar(wxStatusBar *statBar);


    virtual void SetStatusText(const wxString &text, int number = 0);
    virtual void SetStatusWidths(int n, const int widths_field[]);
    void PushStatusText(const wxString &text, int number = 0);
    void PopStatusText(int number = 0);


    void SetStatusBarPane(int n) { m_statusBarPane = n; }
    int GetStatusBarPane() const { return m_statusBarPane; }







    virtual wxToolBar* CreateToolBar(long style = -1,
                                     wxWindowID winid = wxID_ANY,
                                     const wxString& name = wxToolBarNameStr);

    virtual wxToolBar *OnCreateToolBar(long style,
                                       wxWindowID winid,
                                       const wxString& name );


    virtual wxToolBar *GetToolBar() const { return m_frameToolBar; }
    virtual void SetToolBar(wxToolBar *toolbar);
# 144 "/usr/include/wx-2.8/wx/frame.h"
    void OnMenuOpen(wxMenuEvent& event);
    void OnMenuClose(wxMenuEvent& event);
    void OnMenuHighlight(wxMenuEvent& event);




    virtual void DoMenuUpdates(wxMenu* menu = __null);



    virtual void UpdateWindowUI(long flags = wxUPDATE_UI_NONE);


    virtual void OnInternalIdle();
# 174 "/usr/include/wx-2.8/wx/frame.h"
    virtual void DoGiveHelp(const wxString& text, bool show);


protected:





    void DeleteAllBars();


    virtual bool IsOneOfBars(const wxWindow *win) const;



    virtual void PositionMenuBar() { }



    virtual void DetachMenuBar();



    virtual void AttachMenuBar(wxMenuBar *menubar);

    wxMenuBar *m_frameMenuBar;




    wxString m_oldStatusText;





    virtual void PositionStatusBar() { }



    bool ShowMenuHelp(wxStatusBar *statbar, int helpid);

    wxStatusBar *m_frameStatusBar;



    int m_statusBarPane;




    virtual void PositionToolBar() { }

    wxToolBar *m_frameToolBar;



    private: static const wxEventTableEntry sm_eventTableEntries[]; protected: static const wxEventTable sm_eventTable; virtual const wxEventTable* GetEventTable() const; static wxEventHashTable sm_eventHashTable; virtual wxEventHashTable& GetEventHashTable() const;


    private: wxFrameBase(const wxFrameBase&); wxFrameBase& operator=(const wxFrameBase&);
};
# 247 "/usr/include/wx-2.8/wx/frame.h"
# 1 "/usr/include/wx-2.8/wx/gtk/frame.h" 1
# 17 "/usr/include/wx-2.8/wx/gtk/frame.h"
class wxMDIChildFrame;
class wxMDIClientWindow;
class wxMenu;
class wxMenuBar;
class wxToolBar;
class wxStatusBar;





class wxFrame : public wxFrameBase
{
public:

    wxFrame() { Init(); }
    wxFrame(wxWindow *parent,
               wxWindowID id,
               const wxString& title,
               const wxPoint& pos = wxDefaultPosition,
               const wxSize& size = wxDefaultSize,
               long style = (0x0800 | 0x0040 | 0x0400 | 0x0200 | 0x1000 | 0x20000000 | 0x00400000),
               const wxString& name = wxFrameNameStr)
    {
        Init();

        Create(parent, id, title, pos, size, style, name);
    }

    bool Create(wxWindow *parent,
                wxWindowID id,
                const wxString& title,
                const wxPoint& pos = wxDefaultPosition,
                const wxSize& size = wxDefaultSize,
                long style = (0x0800 | 0x0040 | 0x0400 | 0x0200 | 0x1000 | 0x20000000 | 0x00400000),
                const wxString& name = wxFrameNameStr);

    virtual ~wxFrame();


    virtual wxStatusBar* CreateStatusBar(int number = 1,
                                         long style = 0x0010|0x00010000,
                                         wxWindowID id = 0,
                                         const wxString& name = wxStatusLineNameStr);

    void SetStatusBar(wxStatusBar *statbar);



    virtual wxToolBar* CreateToolBar(long style = -1,
                                     wxWindowID id = -1,
                                     const wxString& name = wxToolBarNameStr);
    void SetToolBar(wxToolBar *toolbar);


    wxPoint GetClientAreaOrigin() const { return wxPoint(0, 0); }





    virtual void GtkOnSize();
    virtual void OnInternalIdle();

    bool m_menuBarDetached;
    int m_menuBarHeight;
    bool m_toolBarDetached;

protected:

    void Init();


    virtual void PositionStatusBar();



    virtual void DoSetClientSize(int width, int height);
    virtual void DoGetClientSize( int *width, int *height ) const;



    virtual void DetachMenuBar();
    virtual void AttachMenuBar(wxMenuBar *menubar);

public:

    void UpdateMenuBarSize();



    public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};
# 248 "/usr/include/wx-2.8/wx/frame.h" 2
# 41 "/usr/include/wx-2.8/wx/wx.h" 2



# 1 "/usr/include/wx-2.8/wx/bitmap.h" 1
# 23 "/usr/include/wx-2.8/wx/bitmap.h"
class wxBitmap;
class wxBitmapHandler;
class wxIcon;
class wxImage;
class wxMask;
class wxPalette;







 wxBitmap& operator << ( wxBitmap &object, const wxVariant &variant ); wxVariant& operator << ( wxVariant &variant, const wxBitmap &object );






class wxMaskBase : public wxObject
{
public:

    bool Create(const wxBitmap& bitmap, const wxColour& colour);



    bool Create(const wxBitmap& bitmap, int paletteIndex);



    bool Create(const wxBitmap& bitmap);

protected:

    virtual void FreeData() = 0;




    virtual bool InitFromColour(const wxBitmap& bitmap,
                                const wxColour& colour) = 0;
    virtual bool InitFromMonoBitmap(const wxBitmap& bitmap) = 0;
};
# 90 "/usr/include/wx-2.8/wx/bitmap.h"
class wxBitmapHandlerBase : public wxObject
{
public:
    wxBitmapHandlerBase() { m_type = wxBITMAP_TYPE_INVALID; }
    virtual ~wxBitmapHandlerBase() { }

    virtual bool Create(wxBitmap *bitmap, const void* data, long flags,
                        int width, int height, int depth = 1);
    virtual bool LoadFile(wxBitmap *bitmap, const wxString& name, long flags,
                          int desiredWidth, int desiredHeight);
    virtual bool SaveFile(const wxBitmap *bitmap, const wxString& name,
                          int type, const wxPalette *palette = __null);

    void SetName(const wxString& name) { m_name = name; }
    void SetExtension(const wxString& ext) { m_extension = ext; }
    void SetType(wxBitmapType type) { m_type = type; }
    const wxString& GetName() const { return m_name; }
    const wxString& GetExtension() const { return m_extension; }
    wxBitmapType GetType() const { return m_type; }

private:
    wxString m_name;
    wxString m_extension;
    wxBitmapType m_type;

    public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const;
};

class wxBitmapBase : public wxGDIObject
{
public:
# 136 "/usr/include/wx-2.8/wx/bitmap.h"
    virtual bool Ok() const { return IsOk(); }
    virtual bool IsOk() const = 0;

    virtual int GetHeight() const = 0;
    virtual int GetWidth() const = 0;
    virtual int GetDepth() const = 0;

    virtual wxImage ConvertToImage() const = 0;

    virtual wxMask *GetMask() const = 0;
    virtual void SetMask(wxMask *mask) = 0;

    virtual wxBitmap GetSubBitmap(const wxRect& rect) const = 0;

    virtual bool SaveFile(const wxString &name, wxBitmapType type,
                          const wxPalette *palette = (wxPalette *)__null) const = 0;
    virtual bool LoadFile(const wxString &name, wxBitmapType type) = 0;
# 163 "/usr/include/wx-2.8/wx/bitmap.h"
    virtual wxPalette *GetPalette() const = 0;
    virtual void SetPalette(const wxPalette& palette) = 0;



    virtual bool CopyFromIcon(const wxIcon& icon) = 0;


    virtual void SetHeight(int height) = 0;
    virtual void SetWidth(int width) = 0;
    virtual void SetDepth(int depth) = 0;


    static inline wxList& GetHandlers() { return sm_handlers; }
    static void AddHandler(wxBitmapHandlerBase *handler);
    static void InsertHandler(wxBitmapHandlerBase *handler);
    static bool RemoveHandler(const wxString& name);
    static wxBitmapHandler *FindHandler(const wxString& name);
    static wxBitmapHandler *FindHandler(const wxString& extension, wxBitmapType bitmapType);
    static wxBitmapHandler *FindHandler(wxBitmapType bitmapType);




    static void CleanUpHandlers();





    virtual wxColour QuantizeColour(const wxColour& colour) const
    {
        return colour;
    }

protected:
    static wxList sm_handlers;

    public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const;
};
# 213 "/usr/include/wx-2.8/wx/bitmap.h"
# 1 "/usr/include/wx-2.8/wx/gtk/bitmap.h" 1
# 13 "/usr/include/wx-2.8/wx/gtk/bitmap.h"
typedef struct _GdkPixbuf GdkPixbuf;
class wxPixelDataBase;





class wxMask: public wxObject
{
public:
    wxMask();
    wxMask( const wxBitmap& bitmap, const wxColour& colour );

    wxMask( const wxBitmap& bitmap, int paletteIndex );

    wxMask( const wxBitmap& bitmap );
    virtual ~wxMask();

    bool Create( const wxBitmap& bitmap, const wxColour& colour );

    bool Create( const wxBitmap& bitmap, int paletteIndex );

    bool Create( const wxBitmap& bitmap );


    GdkBitmap *m_bitmap;

    GdkBitmap *GetBitmap() const;

private:
    public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};





class wxBitmap: public wxBitmapBase
{
public:
    wxBitmap() { }
    wxBitmap( int width, int height, int depth = -1 );
    wxBitmap( const char bits[], int width, int height, int depth = 1 );
    wxBitmap( const char* const* bits );







    wxBitmap( const wxString &filename, wxBitmapType type = wxBITMAP_TYPE_XPM );
    wxBitmap( const wxImage& image, int depth = -1 ) { (void)CreateFromImage(image, depth); }
    virtual ~wxBitmap();
    bool Ok() const { return IsOk(); }
    bool IsOk() const;

    bool Create(int width, int height, int depth = -1);

    int GetHeight() const;
    int GetWidth() const;
    int GetDepth() const;

    wxImage ConvertToImage() const;


    virtual bool CopyFromIcon(const wxIcon& icon);

    wxMask *GetMask() const;
    void SetMask( wxMask *mask );

    wxBitmap GetSubBitmap( const wxRect& rect ) const;

    bool SaveFile(const wxString &name, wxBitmapType type,
                          const wxPalette *palette = (wxPalette *)__null) const;
    bool LoadFile(const wxString &name, wxBitmapType type = wxBITMAP_TYPE_XPM );


    wxPalette *GetPalette() const;
    void SetPalette(const wxPalette& palette);
    wxPalette *GetColourMap() const { return GetPalette(); };


    static void InitStandardHandlers();




    void SetHeight( int height );
    void SetWidth( int width );
    void SetDepth( int depth );
    void SetPixmap( GdkPixmap *pixmap );
    void SetPixbuf(GdkPixbuf* pixbuf, int depth = 0);

    GdkPixmap *GetPixmap() const;
    bool HasPixmap() const;
    bool HasPixbuf() const;
    GdkPixbuf *GetPixbuf() const;


    wxBitmap Rescale(int clipx, int clipy, int clipwidth, int clipheight, int width, int height) const;


    void *GetRawData(wxPixelDataBase& data, int bpp);
    void UngetRawData(wxPixelDataBase& data);

    bool HasAlpha() const;
    void UseAlpha();

protected:
    bool CreateFromImage(const wxImage& image, int depth);

    virtual wxObjectRefData* CreateRefData() const;
    virtual wxObjectRefData* CloneRefData(const wxObjectRefData* data) const;

private:

    bool CreateFromImageAsPixmap(const wxImage& image, int depth);
    bool CreateFromImageAsPixbuf(const wxImage& image);

    enum Representation
    {
        Pixmap,
        Pixbuf
    };


    void PurgeOtherRepresentations(Representation keep);

    friend class wxMemoryDC;
    friend class wxBitmapHandler;

private:
    public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};





class wxBitmapHandler: public wxBitmapHandlerBase
{
    public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const;
};
# 214 "/usr/include/wx-2.8/wx/bitmap.h" 2
# 45 "/usr/include/wx-2.8/wx/wx.h" 2
# 1 "/usr/include/wx-2.8/wx/image.h" 1
# 40 "/usr/include/wx-2.8/wx/image.h"
enum
{
    wxIMAGE_RESOLUTION_INCHES = 1,
    wxIMAGE_RESOLUTION_CM = 2
};


enum
{
    wxIMAGE_QUALITY_NORMAL = 0,
    wxIMAGE_QUALITY_HIGH = 1
};




const unsigned char wxIMAGE_ALPHA_TRANSPARENT = 0;
const unsigned char wxIMAGE_ALPHA_THRESHOLD = 0x80;
const unsigned char wxIMAGE_ALPHA_OPAQUE = 0xff;





class wxImageHandler;
class wxImage;
class wxPalette;







 wxImage& operator << ( wxImage &object, const wxVariant &variant ); wxVariant& operator << ( wxVariant &variant, const wxImage &object );






class wxImageHandler: public wxObject
{
public:
    wxImageHandler()
        : m_name(wxEmptyString), m_extension(wxEmptyString), m_mime(), m_type(0)
        { }


    virtual bool LoadFile( wxImage *image, wxInputStream& stream, bool verbose=true, int index=-1 );
    virtual bool SaveFile( wxImage *image, wxOutputStream& stream, bool verbose=true );

    virtual int GetImageCount( wxInputStream& stream );

    bool CanRead( wxInputStream& stream ) { return CallDoCanRead(stream); }
    bool CanRead( const wxString& name );


    void SetName(const wxString& name) { m_name = name; }
    void SetExtension(const wxString& ext) { m_extension = ext; }
    void SetType(long type) { m_type = type; }
    void SetMimeType(const wxString& type) { m_mime = type; }
    const wxString& GetName() const { return m_name; }
    const wxString& GetExtension() const { return m_extension; }
    long GetType() const { return m_type; }
    const wxString& GetMimeType() const { return m_mime; }

protected:

    virtual bool DoCanRead( wxInputStream& stream ) = 0;


    bool CallDoCanRead(wxInputStream& stream);


    wxString m_name;
    wxString m_extension;
    wxString m_mime;
    long m_type;

private:
    public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};





class wxImageHistogramEntry
{
public:
    wxImageHistogramEntry() { index = value = 0; }
    unsigned long index;
    unsigned long value;
};

class wxImageHistogramBase_wxImplementation_Pair { public: typedef unsigned long t1; typedef wxImageHistogramEntry t2; typedef const unsigned long const_t1; typedef const wxImageHistogramEntry const_t2; wxImageHistogramBase_wxImplementation_Pair( const const_t1& f, const const_t2& s ):first(t1(f)),second(t2(s)) {} t1 first; t2 second; }; class wxImageHistogramBase_wxImplementation_KeyEx { typedef unsigned long key_type; typedef wxImageHistogramBase_wxImplementation_Pair pair_type; typedef const key_type const_key_type; typedef const pair_type const_pair_type; typedef const_key_type& const_key_reference; typedef const_pair_type& const_pair_reference; public: wxImageHistogramBase_wxImplementation_KeyEx() { } const_key_reference operator()( const_pair_reference pair ) const { return pair.first; } wxImageHistogramBase_wxImplementation_KeyEx& operator=(const wxImageHistogramBase_wxImplementation_KeyEx&) { return *this; } }; class wxImageHistogramBase_wxImplementation_HashTable : protected _wxHashTableBase2 { public: typedef unsigned long key_type; typedef wxImageHistogramBase_wxImplementation_Pair value_type; typedef wxIntegerHash hasher; typedef wxIntegerEqual key_equal; typedef size_t size_type; typedef ptrdiff_t difference_type; typedef value_type* pointer; typedef const value_type* const_pointer; typedef value_type& reference; typedef const value_type& const_reference; typedef const unsigned long const_key_type; typedef const wxImageHistogramBase_wxImplementation_Pair const_mapped_type; public: struct Node; typedef wxImageHistogramBase_wxImplementation_KeyEx key_extractor; typedef wxImageHistogramBase_wxImplementation_HashTable Self; protected: Node** m_table; size_t m_tableBuckets; size_t m_items; hasher m_hasher; key_equal m_equals; key_extractor m_getKey; public: struct Node:public _wxHashTable_NodeBase { public: Node( const value_type& value ) : m_value( value ) {} Node* m_next() { return (Node*)this->m_nxt; } value_type m_value; }; class Iterator; friend class Iterator; protected: static void DeleteNode( _wxHashTable_NodeBase* node ) { delete (Node*)node; } public: class Iterator { public: Node* m_node; Self* m_ht; Iterator() : m_node(0), m_ht(0) {} Iterator( Node* node, const Self* ht ) : m_node(node), m_ht((Self*)ht) {} bool operator ==( const Iterator& it ) const { return m_node == it.m_node; } bool operator !=( const Iterator& it ) const { return m_node != it.m_node; } protected: Node* GetNextNode() { size_type bucket = GetBucketForNode(m_ht,m_node); for( size_type i = bucket + 1; i < m_ht->m_tableBuckets; ++i ) { if( m_ht->m_table[i] ) return m_ht->m_table[i]; } return 0; } void PlusPlus() { Node* next = m_node->m_next(); m_node = next ? next : GetNextNode(); } }; public: class iterator : public Iterator { public: iterator() : Iterator() {} iterator( Node* node, Self* ht ) : Iterator( node, ht ) {} iterator& operator++() { PlusPlus(); return *this; } iterator operator++(int) { iterator it=*this;PlusPlus();return it; } reference operator *() const { return m_node->m_value; } pointer operator ->() const { return &(m_node->m_value); } }; class const_iterator : public Iterator { public: const_iterator() : Iterator() {} const_iterator(iterator i) : Iterator(i) {} const_iterator( Node* node, const Self* ht ) : Iterator( node, (Self*)ht ) {} const_iterator& operator++() { PlusPlus();return *this; } const_iterator operator++(int) { const_iterator it=*this;PlusPlus();return it; } const_reference operator *() const { return m_node->m_value; } const_pointer operator ->() const { return &(m_node->m_value); } }; wxImageHistogramBase_wxImplementation_HashTable( size_type sz = 10, const hasher& hfun = hasher(), const key_equal& k_eq = key_equal(), const key_extractor& k_ex = key_extractor() ) : m_tableBuckets( GetNextPrime( (unsigned long) sz ) ), m_items( 0 ), m_hasher( hfun ), m_equals( k_eq ), m_getKey( k_ex ) { m_table = (Node**)AllocTable( m_tableBuckets ); } wxImageHistogramBase_wxImplementation_HashTable( const Self& ht ) : m_table( 0 ), m_tableBuckets( 0 ), m_items( ht.m_items ), m_hasher( ht.m_hasher ), m_equals( ht.m_equals ), m_getKey( ht.m_getKey ) { HashCopy( ht ); } const Self& operator=( const Self& ht ) { clear(); m_hasher = ht.m_hasher; m_equals = ht.m_equals; m_getKey = ht.m_getKey; m_items = ht.m_items; HashCopy( ht ); return *this; } ~wxImageHistogramBase_wxImplementation_HashTable() { clear(); FreeTable(m_table); } hasher hash_funct() { return m_hasher; } key_equal key_eq() { return m_equals; } void clear() { DeleteNodes( m_tableBuckets, (_wxHashTable_NodeBase**)m_table, DeleteNode ); m_items = 0; } size_type size() const { return m_items; } size_type max_size() const { return size_type(-1); } bool empty() const { return size() == 0; } const_iterator end() const { return const_iterator( 0, this ); } iterator end() { return iterator( 0, this ); } const_iterator begin() const { return const_iterator( (Node*)GetFirstNode( m_tableBuckets, (_wxHashTable_NodeBase**)m_table ), this ); } iterator begin() { return iterator( (Node*)GetFirstNode( m_tableBuckets, (_wxHashTable_NodeBase**)m_table ), this ); } size_type erase( const const_key_type& key ) { Node** node = GetNodePtr( key ); if( !node ) return 0; --m_items; Node* temp = (*node)->m_next(); delete *node; (*node) = temp; if( never_shrink( m_tableBuckets, m_items ) ) ResizeTable( GetPreviousPrime( (unsigned long) m_tableBuckets ) - 1 ); return 1; } protected: static size_type GetBucketForNode( Self* ht, Node* node ) { return ht->m_hasher( ht->m_getKey( node->m_value ) ) % ht->m_tableBuckets; } static Node* CopyNode( Node* node ) { return new Node( *node ); } Node* GetOrCreateNode( const value_type& value, bool& created ) { const const_key_type& key = m_getKey( value ); size_t bucket = m_hasher( key ) % m_tableBuckets; Node* node = m_table[bucket]; while( node ) { if( m_equals( m_getKey( node->m_value ), key ) ) { created = false; return node; } node = node->m_next(); } created = true; return CreateNode( value, bucket); } Node * CreateNode( const value_type& value, size_t bucket ) { Node* node = new Node( value ); node->m_nxt = m_table[bucket]; m_table[bucket] = node; ++m_items; if( grow_lf70( m_tableBuckets, m_items ) ) ResizeTable( m_tableBuckets ); return node; } void CreateNode( const value_type& value ) { CreateNode(value, m_hasher( m_getKey(value) ) % m_tableBuckets ); } Node** GetNodePtr( const const_key_type& key ) const { size_t bucket = m_hasher( key ) % m_tableBuckets; Node** node = &m_table[bucket]; while( *node ) { if( m_equals( m_getKey( (*node)->m_value ), key ) ) return node; node = (Node**)&(*node)->m_nxt; } return __null; } Node* GetNode( const const_key_type& key ) const { size_t bucket = m_hasher( key ) % m_tableBuckets; Node* node = m_table[bucket]; while( node ) { if( m_equals( m_getKey( node->m_value ), key ) ) return node; node = node->m_next(); } return 0; } void ResizeTable( size_t newSize ) { newSize = GetNextPrime( (unsigned long)newSize ); Node** srcTable = m_table; size_t srcBuckets = m_tableBuckets; m_table = (Node**)AllocTable( newSize ); m_tableBuckets = newSize; CopyHashTable( (_wxHashTable_NodeBase**)srcTable, srcBuckets, this, (_wxHashTable_NodeBase**)m_table, (BucketFromNode)GetBucketForNode, (ProcessNode)&DummyProcessNode ); FreeTable(srcTable); } void HashCopy( const Self& ht ) { ResizeTable( ht.size() ); CopyHashTable( (_wxHashTable_NodeBase**)ht.m_table, ht.m_tableBuckets, (_wxHashTableBase2*)this, (_wxHashTable_NodeBase**)m_table, (BucketFromNode)GetBucketForNode, (ProcessNode)CopyNode ); } }; class wxImageHistogramBase:public wxImageHistogramBase_wxImplementation_HashTable { public: typedef wxImageHistogramEntry mapped_type; class Insert_Result { public: typedef iterator t1; typedef bool t2; typedef const iterator const_t1; typedef const bool const_t2; Insert_Result( const const_t1& f, const const_t2& s ):first(t1(f)),second(t2(s)) {} t1 first; t2 second; }; explicit wxImageHistogramBase( size_type hint = 100, hasher hf = hasher(), key_equal eq = key_equal() ) : wxImageHistogramBase_wxImplementation_HashTable( hint, hf, eq, wxImageHistogramBase_wxImplementation_KeyEx() ) {} mapped_type& operator[]( const const_key_type& key ) { bool created; return GetOrCreateNode( wxImageHistogramBase_wxImplementation_Pair( key, mapped_type() ), created)->m_value.second; } const_iterator find( const const_key_type& key ) const { return const_iterator( GetNode( key ), this ); } iterator find( const const_key_type& key ) { return iterator( GetNode( key ), this ); } Insert_Result insert( const value_type& v ) { bool created; Node *node = GetOrCreateNode( wxImageHistogramBase_wxImplementation_Pair( v.first, v.second ), created); return Insert_Result(iterator(node, this), created); } size_type erase( const key_type& k ) { return wxImageHistogramBase_wxImplementation_HashTable::erase( k ); } void erase( const iterator& it ) { erase( it->first ); } void erase( const const_iterator& it ) { erase( it->first ); } size_type count( const const_key_type& key ) { return (size_type)(GetNode( key ) ? 1 : 0); } };



class wxImageHistogram : public wxImageHistogramBase
{
public:
    wxImageHistogram() : wxImageHistogramBase(256) { }


    static unsigned long MakeKey(unsigned char r,
                                 unsigned char g,
                                 unsigned char b)
    {
        return (r << 16) | (g << 8) | b;
    }






    bool FindFirstUnusedColour(unsigned char *r,
                               unsigned char *g,
                               unsigned char *b,
                               unsigned char startR = 1,
                               unsigned char startG = 0,
                               unsigned char startB = 0 ) const;
};





class wxImage: public wxObject
{
public:


    class RGBValue
    {
    public:
      RGBValue(unsigned char r=0, unsigned char g=0, unsigned char b=0)
        : red(r), green(g), blue(b) {}
        unsigned char red;
        unsigned char green;
        unsigned char blue;
    };


    class HSVValue
    {
    public:
        HSVValue(double h=0.0, double s=0.0, double v=0.0)
            : hue(h), saturation(s), value(v) {}
        double hue;
        double saturation;
        double value;
    };

    wxImage(){}
    wxImage( int width, int height, bool clear = true );
    wxImage( int width, int height, unsigned char* data, bool static_data = false );
    wxImage( int width, int height, unsigned char* data, unsigned char* alpha, bool static_data = false );
    wxImage( const wxString& name, long type = wxBITMAP_TYPE_ANY, int index = -1 );
    wxImage( const wxString& name, const wxString& mimetype, int index = -1 );
    wxImage( const char* const* xpmData );


    wxImage( wxInputStream& stream, long type = wxBITMAP_TYPE_ANY, int index = -1 );
    wxImage( wxInputStream& stream, const wxString& mimetype, int index = -1 );


    bool Create( int width, int height, bool clear = true );
    bool Create( int width, int height, unsigned char* data, bool static_data = false );
    bool Create( int width, int height, unsigned char* data, unsigned char* alpha, bool static_data = false );
    bool Create( const char* const* xpmData );





    void Destroy();



    wxImage Copy() const;


    wxImage GetSubImage( const wxRect& rect) const;





    wxImage Size( const wxSize& size, const wxPoint& pos,
                  int r = -1, int g = -1, int b = -1 ) const;



    void Paste( const wxImage &image, int x, int y );


    wxImage Scale( int width, int height, int quality = wxIMAGE_QUALITY_NORMAL ) const;


    wxImage ResampleBox(int width, int height) const;
    wxImage ResampleBicubic(int width, int height) const;


    wxImage Blur(int radius);
    wxImage BlurHorizontal(int radius);
    wxImage BlurVertical(int radius);

    wxImage ShrinkBy( int xFactor , int yFactor ) const ;


    wxImage& Rescale( int width, int height, int quality = wxIMAGE_QUALITY_NORMAL ) { return *this = Scale(width, height, quality); }


    wxImage& Resize( const wxSize& size, const wxPoint& pos,
                     int r = -1, int g = -1, int b = -1 ) { return *this = Size(size, pos, r, g, b); }



    wxImage Rotate(double angle, const wxPoint & centre_of_rotation,
                   bool interpolating = true, wxPoint * offset_after_rotation = (wxPoint*) __null) const;

    wxImage Rotate90( bool clockwise = true ) const;
    wxImage Mirror( bool horizontally = true ) const;


    void Replace( unsigned char r1, unsigned char g1, unsigned char b1,
                  unsigned char r2, unsigned char g2, unsigned char b2 );



    wxImage ConvertToGreyscale( double lr = 0.299, double lg = 0.587, double lb = 0.114 ) const;



    wxImage ConvertToMono( unsigned char r, unsigned char g, unsigned char b ) const;


    void SetRGB( int x, int y, unsigned char r, unsigned char g, unsigned char b );
    void SetRGB( const wxRect& rect, unsigned char r, unsigned char g, unsigned char b );
    unsigned char GetRed( int x, int y ) const;
    unsigned char GetGreen( int x, int y ) const;
    unsigned char GetBlue( int x, int y ) const;

    void SetAlpha(int x, int y, unsigned char alpha);
    unsigned char GetAlpha(int x, int y) const;



    bool FindFirstUnusedColour( unsigned char *r, unsigned char *g, unsigned char *b,
                                unsigned char startR = 1, unsigned char startG = 0,
                                unsigned char startB = 0 ) const;

    bool SetMaskFromImage(const wxImage & mask,
                          unsigned char mr, unsigned char mg, unsigned char mb);



    bool ConvertAlphaToMask(unsigned char threshold = wxIMAGE_ALPHA_THRESHOLD);
# 312 "/usr/include/wx-2.8/wx/image.h"
    bool ConvertColourToAlpha( unsigned char r, unsigned char g, unsigned char b );

    static bool CanRead( const wxString& name );
    static int GetImageCount( const wxString& name, long type = wxBITMAP_TYPE_ANY );
    virtual bool LoadFile( const wxString& name, long type = wxBITMAP_TYPE_ANY, int index = -1 );
    virtual bool LoadFile( const wxString& name, const wxString& mimetype, int index = -1 );


    static bool CanRead( wxInputStream& stream );
    static int GetImageCount( wxInputStream& stream, long type = wxBITMAP_TYPE_ANY );
    virtual bool LoadFile( wxInputStream& stream, long type = wxBITMAP_TYPE_ANY, int index = -1 );
    virtual bool LoadFile( wxInputStream& stream, const wxString& mimetype, int index = -1 );


    virtual bool SaveFile( const wxString& name ) const;
    virtual bool SaveFile( const wxString& name, int type ) const;
    virtual bool SaveFile( const wxString& name, const wxString& mimetype ) const;


    virtual bool SaveFile( wxOutputStream& stream, int type ) const;
    virtual bool SaveFile( wxOutputStream& stream, const wxString& mimetype ) const;


    bool Ok() const { return IsOk(); }
    bool IsOk() const;
    int GetWidth() const;
    int GetHeight() const;



    unsigned char *GetData() const;
    void SetData( unsigned char *data, bool static_data=false );
    void SetData( unsigned char *data, int new_width, int new_height, bool static_data=false );

    unsigned char *GetAlpha() const;
    bool HasAlpha() const { return GetAlpha() != __null; }
    void SetAlpha(unsigned char *alpha = __null, bool static_data=false);
    void InitAlpha();



    bool IsTransparent(int x, int y,
                       unsigned char threshold = wxIMAGE_ALPHA_THRESHOLD) const;


    void SetMaskColour( unsigned char r, unsigned char g, unsigned char b );


    bool GetOrFindMaskColour( unsigned char *r, unsigned char *g, unsigned char *b ) const;
    unsigned char GetMaskRed() const;
    unsigned char GetMaskGreen() const;
    unsigned char GetMaskBlue() const;
    void SetMask( bool mask = true );
    bool HasMask() const;



    bool HasPalette() const;
    const wxPalette& GetPalette() const;
    void SetPalette(const wxPalette& palette);



    void SetOption(const wxString& name, const wxString& value);
    void SetOption(const wxString& name, int value);
    wxString GetOption(const wxString& name) const;
    int GetOptionInt(const wxString& name) const;
    bool HasOption(const wxString& name) const;

    unsigned long CountColours( unsigned long stopafter = (unsigned long) -1 ) const;







    unsigned long ComputeHistogram( wxImageHistogram &h ) const;



    void RotateHue(double angle);

    static wxList& GetHandlers() { return sm_handlers; }
    static void AddHandler( wxImageHandler *handler );
    static void InsertHandler( wxImageHandler *handler );
    static bool RemoveHandler( const wxString& name );
    static wxImageHandler *FindHandler( const wxString& name );
    static wxImageHandler *FindHandler( const wxString& extension, long imageType );
    static wxImageHandler *FindHandler( long imageType );
    static wxImageHandler *FindHandlerMime( const wxString& mimetype );

    static wxString GetImageExtWildcard();

    static void CleanUpHandlers();
    static void InitStandardHandlers();

    static HSVValue RGBtoHSV(const RGBValue& rgb);
    static RGBValue HSVtoRGB(const HSVValue& hsv);


protected:
    static wxList sm_handlers;





    long XYToIndex(int x, int y) const;

    virtual wxObjectRefData* CreateRefData() const;
    virtual wxObjectRefData* CloneRefData(const wxObjectRefData* data) const;

private:
    friend class wxImageHandler;

    public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};


extern void wxInitAllImageHandlers();

extern wxImage wxNullImage;





# 1 "/usr/include/wx-2.8/wx/imagbmp.h" 1
# 13 "/usr/include/wx-2.8/wx/imagbmp.h"
# 1 "/usr/include/wx-2.8/wx/image.h" 1
# 14 "/usr/include/wx-2.8/wx/imagbmp.h" 2
# 32 "/usr/include/wx-2.8/wx/imagbmp.h"
enum
{
    wxBMP_24BPP = 24,

    wxBMP_8BPP = 8,
    wxBMP_8BPP_GREY = 9,
    wxBMP_8BPP_GRAY = wxBMP_8BPP_GREY,
    wxBMP_8BPP_RED = 10,
    wxBMP_8BPP_PALETTE = 11,
    wxBMP_4BPP = 4,
    wxBMP_1BPP = 1,
    wxBMP_1BPP_BW = 2
};





class wxBMPHandler : public wxImageHandler
{
public:
    wxBMPHandler()
    {
        m_name = L"Windows bitmap file";
        m_extension = L"bmp";
        m_type = wxBITMAP_TYPE_BMP;
        m_mime = L"image/x-bmp";
    }


    virtual bool SaveFile( wxImage *image, wxOutputStream& stream, bool verbose=true );
    virtual bool LoadFile( wxImage *image, wxInputStream& stream, bool verbose=true, int index=-1 );

protected:
    virtual bool DoCanRead( wxInputStream& stream );
    bool SaveDib(wxImage *image, wxOutputStream& stream, bool verbose,
                 bool IsBmp, bool IsMask);
    bool DoLoadDib(wxImage *image, int width, int height, int bpp, int ncolors,
                   int comp, wxFileOffset bmpOffset, wxInputStream& stream,
                   bool verbose, bool IsBmp, bool hasPalette);
    bool LoadDib(wxImage *image, wxInputStream& stream, bool verbose, bool IsBmp);


private:
     public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};






class wxICOHandler : public wxBMPHandler
{
public:
    wxICOHandler()
    {
        m_name = L"Windows icon file";
        m_extension = L"ico";
        m_type = wxBITMAP_TYPE_ICO;
        m_mime = L"image/x-ico";
    }


    virtual bool SaveFile( wxImage *image, wxOutputStream& stream, bool verbose=true );
    virtual bool LoadFile( wxImage *image, wxInputStream& stream, bool verbose=true, int index=-1 );
    virtual bool DoLoadFile( wxImage *image, wxInputStream& stream, bool verbose, int index );
    virtual int GetImageCount( wxInputStream& stream );
protected:
    virtual bool DoCanRead( wxInputStream& stream );


private:
    public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};






class wxCURHandler : public wxICOHandler
{
public:
    wxCURHandler()
    {
        m_name = L"Windows cursor file";
        m_extension = L"cur";
        m_type = wxBITMAP_TYPE_CUR;
        m_mime = L"image/x-cur";
    }





protected:

    virtual bool DoCanRead( wxInputStream& stream );


private:
    public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};




class wxANIHandler : public wxCURHandler
{
public:
    wxANIHandler()
    {
        m_name = L"Windows animated cursor file";
        m_extension = L"ani";
        m_type = wxBITMAP_TYPE_ANI;
        m_mime = L"image/x-ani";
    }



    virtual bool SaveFile( wxImage *, wxOutputStream& , bool ){return false ;}
    virtual bool LoadFile( wxImage *image, wxInputStream& stream, bool verbose=true, int index=-1 );
    virtual int GetImageCount( wxInputStream& stream );
protected:
    virtual bool DoCanRead( wxInputStream& stream );


private:
    public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};
# 441 "/usr/include/wx-2.8/wx/image.h" 2
# 1 "/usr/include/wx-2.8/wx/imagpng.h" 1
# 26 "/usr/include/wx-2.8/wx/imagpng.h"
enum
{
    wxPNG_TYPE_COLOUR = 0,
    wxPNG_TYPE_GREY = 2,
    wxPNG_TYPE_GREY_RED = 3
};

class wxPNGHandler: public wxImageHandler
{
public:
    inline wxPNGHandler()
    {
        m_name = L"PNG file";
        m_extension = L"png";
        m_type = wxBITMAP_TYPE_PNG;
        m_mime = L"image/png";
    }


    virtual bool LoadFile( wxImage *image, wxInputStream& stream, bool verbose=true, int index=-1 );
    virtual bool SaveFile( wxImage *image, wxOutputStream& stream, bool verbose=true );
protected:
    virtual bool DoCanRead( wxInputStream& stream );


private:
    public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};
# 442 "/usr/include/wx-2.8/wx/image.h" 2
# 1 "/usr/include/wx-2.8/wx/imaggif.h" 1
# 22 "/usr/include/wx-2.8/wx/imaggif.h"
class wxGIFHandler : public wxImageHandler
{
public:
    inline wxGIFHandler()
    {
        m_name = L"GIF file";
        m_extension = L"gif";
        m_type = wxBITMAP_TYPE_GIF;
        m_mime = L"image/gif";
    }


    virtual bool LoadFile( wxImage *image, wxInputStream& stream, bool verbose=true, int index=-1 );
    virtual bool SaveFile( wxImage *image, wxOutputStream& stream, bool verbose=true );
protected:
    virtual bool DoCanRead( wxInputStream& stream );


private:
    public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};
# 443 "/usr/include/wx-2.8/wx/image.h" 2
# 1 "/usr/include/wx-2.8/wx/imagpcx.h" 1
# 21 "/usr/include/wx-2.8/wx/imagpcx.h"
class wxPCXHandler : public wxImageHandler
{
public:
    inline wxPCXHandler()
    {
        m_name = L"PCX file";
        m_extension = L"pcx";
        m_type = wxBITMAP_TYPE_PCX;
        m_mime = L"image/pcx";
    }


    virtual bool LoadFile( wxImage *image, wxInputStream& stream, bool verbose=true, int index=-1 );
    virtual bool SaveFile( wxImage *image, wxOutputStream& stream, bool verbose=true );
protected:
    virtual bool DoCanRead( wxInputStream& stream );


private:
    public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};
# 444 "/usr/include/wx-2.8/wx/image.h" 2
# 1 "/usr/include/wx-2.8/wx/imagjpeg.h" 1
# 23 "/usr/include/wx-2.8/wx/imagjpeg.h"
class wxJPEGHandler: public wxImageHandler
{
public:
    inline wxJPEGHandler()
    {
        m_name = L"JPEG file";
        m_extension = L"jpg";
        m_type = wxBITMAP_TYPE_JPEG;
        m_mime = L"image/jpeg";
    }


    virtual bool LoadFile( wxImage *image, wxInputStream& stream, bool verbose=true, int index=-1 );
    virtual bool SaveFile( wxImage *image, wxOutputStream& stream, bool verbose=true );
protected:
    virtual bool DoCanRead( wxInputStream& stream );


private:
    public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};
# 445 "/usr/include/wx-2.8/wx/image.h" 2
# 1 "/usr/include/wx-2.8/wx/imagtga.h" 1
# 21 "/usr/include/wx-2.8/wx/imagtga.h"
class wxTGAHandler : public wxImageHandler
{
public:
    wxTGAHandler()
    {
        m_name = L"TGA file";
        m_extension = L"tga";
        m_type = wxBITMAP_TYPE_TGA;
        m_mime = L"image/tga";
    }


    virtual bool LoadFile(wxImage* image, wxInputStream& stream,
                            bool verbose = true, int index = -1);
    virtual bool SaveFile(wxImage* image, wxOutputStream& stream,
                             bool verbose = true);
protected:
    virtual bool DoCanRead(wxInputStream& stream);


    public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};
# 446 "/usr/include/wx-2.8/wx/image.h" 2
# 1 "/usr/include/wx-2.8/wx/imagtiff.h" 1
# 29 "/usr/include/wx-2.8/wx/imagtiff.h"
class wxTIFFHandler: public wxImageHandler
{
public:
    wxTIFFHandler();


    virtual bool LoadFile( wxImage *image, wxInputStream& stream, bool verbose=true, int index=-1 );
    virtual bool SaveFile( wxImage *image, wxOutputStream& stream, bool verbose=true );
    virtual int GetImageCount( wxInputStream& stream );
protected:
    virtual bool DoCanRead( wxInputStream& stream );


private:
    public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};
# 447 "/usr/include/wx-2.8/wx/image.h" 2
# 1 "/usr/include/wx-2.8/wx/imagpnm.h" 1
# 20 "/usr/include/wx-2.8/wx/imagpnm.h"
class wxPNMHandler : public wxImageHandler
{
public:
    inline wxPNMHandler()
    {
        m_name = L"PNM file";
        m_extension = L"pnm";
        m_type = wxBITMAP_TYPE_PNM;
        m_mime = L"image/pnm";
    }


    virtual bool LoadFile( wxImage *image, wxInputStream& stream, bool verbose=true, int index=-1 );
    virtual bool SaveFile( wxImage *image, wxOutputStream& stream, bool verbose=true );
protected:
    virtual bool DoCanRead( wxInputStream& stream );


private:
    public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};
# 448 "/usr/include/wx-2.8/wx/image.h" 2
# 1 "/usr/include/wx-2.8/wx/imagxpm.h" 1
# 20 "/usr/include/wx-2.8/wx/imagxpm.h"
class wxXPMHandler : public wxImageHandler
{
public:
    inline wxXPMHandler()
    {
        m_name = L"XPM file";
        m_extension = L"xpm";
        m_type = wxBITMAP_TYPE_XPM;
        m_mime = L"image/xpm";
    }


    virtual bool LoadFile( wxImage *image, wxInputStream& stream, bool verbose=true, int index=-1 );
    virtual bool SaveFile( wxImage *image, wxOutputStream& stream, bool verbose=true );
protected:
    virtual bool DoCanRead( wxInputStream& stream );


private:
    public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};
# 449 "/usr/include/wx-2.8/wx/image.h" 2
# 1 "/usr/include/wx-2.8/wx/imagiff.h" 1
# 450 "/usr/include/wx-2.8/wx/image.h" 2
# 46 "/usr/include/wx-2.8/wx/wx.h" 2


# 1 "/usr/include/wx-2.8/wx/dc.h" 1
# 26 "/usr/include/wx-2.8/wx/dc.h"
# 1 "/usr/include/wx-2.8/wx/brush.h" 1
# 20 "/usr/include/wx-2.8/wx/brush.h"
class wxBrushBase: public wxGDIObject
{
public:
    virtual ~wxBrushBase() { }

    virtual int GetStyle() const = 0;

    virtual bool IsHatch() const
        { return (GetStyle()>=wxFIRST_HATCH) && (GetStyle()<=wxLAST_HATCH); }
};
# 38 "/usr/include/wx-2.8/wx/brush.h"
# 1 "/usr/include/wx-2.8/wx/gtk/brush.h" 1
# 13 "/usr/include/wx-2.8/wx/gtk/brush.h"
class wxBitmap;
class wxColour;





class wxBrush: public wxBrushBase
{
public:
    wxBrush() { }

    wxBrush( const wxColour &colour, int style = wxSOLID );
    wxBrush( const wxBitmap &stippleBitmap );
    virtual ~wxBrush();

    bool Ok() const { return IsOk(); }
    bool IsOk() const { return m_refData != __null; }

    bool operator == ( const wxBrush& brush ) const;
    bool operator != (const wxBrush& brush) const { return !(*this == brush); }

    virtual int GetStyle() const;
    wxColour &GetColour() const;
    wxBitmap *GetStipple() const;

    void SetColour( const wxColour& col );
    void SetColour( unsigned char r, unsigned char g, unsigned char b );
    void SetStyle( int style );
    void SetStipple( const wxBitmap& stipple );

protected:

    virtual wxObjectRefData *CreateRefData() const;
    virtual wxObjectRefData *CloneRefData(const wxObjectRefData *data) const;

    public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};
# 39 "/usr/include/wx-2.8/wx/brush.h" 2
# 27 "/usr/include/wx-2.8/wx/dc.h" 2
# 1 "/usr/include/wx-2.8/wx/pen.h" 1
# 24 "/usr/include/wx-2.8/wx/pen.h"
# 1 "/usr/include/wx-2.8/wx/gtk/pen.h" 1
# 16 "/usr/include/wx-2.8/wx/gtk/pen.h"
typedef gint8 wxGTKDash;





class wxPen: public wxGDIObject
{
public:
    wxPen() { }

    wxPen( const wxColour &colour, int width = 1, int style = wxSOLID );
    virtual ~wxPen();

    bool Ok() const { return IsOk(); }
    bool IsOk() const { return m_refData != __null; }

    bool operator == ( const wxPen& pen ) const;
    bool operator != (const wxPen& pen) const { return !(*this == pen); }

    void SetColour( const wxColour &colour );
    void SetColour( unsigned char red, unsigned char green, unsigned char blue );
    void SetCap( int capStyle );
    void SetJoin( int joinStyle );
    void SetStyle( int style );
    void SetWidth( int width );
    void SetDashes( int number_of_dashes, const wxDash *dash );

    wxColour &GetColour() const;
    int GetCap() const;
    int GetJoin() const;
    int GetStyle() const;
    int GetWidth() const;
    int GetDashes(wxDash **ptr) const;
    int GetDashCount() const;
    wxDash* GetDash() const;

protected:

    virtual wxObjectRefData *CreateRefData() const;
    virtual wxObjectRefData *CloneRefData(const wxObjectRefData *data) const;

    public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};
# 25 "/usr/include/wx-2.8/wx/pen.h" 2
# 28 "/usr/include/wx-2.8/wx/dc.h" 2





class wxDC;
class wxDCBase;

class wxDrawObject
{
public:

    wxDrawObject()
        : m_isBBoxValid(false)
        , m_minX(0), m_minY(0), m_maxX(0), m_maxY(0)
    { }

    virtual ~wxDrawObject() { }

    virtual void Draw(wxDCBase&) const { }

    virtual void CalcBoundingBox(wxCoord x, wxCoord y)
    {
      if ( m_isBBoxValid )
      {
         if ( x < m_minX ) m_minX = x;
         if ( y < m_minY ) m_minY = y;
         if ( x > m_maxX ) m_maxX = x;
         if ( y > m_maxY ) m_maxY = y;
      }
      else
      {
         m_isBBoxValid = true;

         m_minX = x;
         m_minY = y;
         m_maxX = x;
         m_maxY = y;
      }
    }

    void ResetBoundingBox()
    {
        m_isBBoxValid = false;

        m_minX = m_maxX = m_minY = m_maxY = 0;
    }



    wxCoord MinX() const { return m_minX; }
    wxCoord MaxX() const { return m_maxX; }
    wxCoord MinY() const { return m_minY; }
    wxCoord MaxY() const { return m_maxY; }


    virtual int GetType()=0;

protected:

    bool m_isBBoxValid:1;

    wxCoord m_minX, m_minY, m_maxX, m_maxY;
};
# 101 "/usr/include/wx-2.8/wx/dc.h"
class wxDCBase : public wxObject
{
public:
    wxDCBase()
        : m_colour(wxColourDisplay())
        , m_ok(true)
        , m_clipping(false)
        , m_isInteractive(0)
        , m_isBBoxValid(false)
        , m_logicalOriginX(0), m_logicalOriginY(0)
        , m_deviceOriginX(0), m_deviceOriginY(0)
        , m_logicalScaleX(1.0), m_logicalScaleY(1.0)
        , m_userScaleX(1.0), m_userScaleY(1.0)
        , m_scaleX(1.0), m_scaleY(1.0)
        , m_signX(1), m_signY(1)
        , m_minX(0), m_minY(0), m_maxX(0), m_maxY(0)
        , m_clipX1(0), m_clipY1(0), m_clipX2(0), m_clipY2(0)
        , m_logicalFunction(wxCOPY)
        , m_backgroundMode(wxTRANSPARENT)
        , m_mappingMode(wxMM_TEXT)
        , m_pen()
        , m_brush()
        , m_backgroundBrush(*wxStockGDI::GetBrush(wxStockGDI::BRUSH_TRANSPARENT))
        , m_textForegroundColour(*wxStockGDI::GetColour(wxStockGDI::COLOUR_BLACK))
        , m_textBackgroundColour(*wxStockGDI::GetColour(wxStockGDI::COLOUR_WHITE))
        , m_font()

        , m_palette()
        , m_hasCustomPalette(false)

    {
        ResetBoundingBox();
        ResetClipping();
    }

    virtual ~wxDCBase() { }




    virtual void DrawObject(wxDrawObject* drawobject)
    {
        drawobject->Draw(*this);
        CalcBoundingBox(drawobject->MinX(),drawobject->MinY());
        CalcBoundingBox(drawobject->MaxX(),drawobject->MaxY());
    }

    bool FloodFill(wxCoord x, wxCoord y, const wxColour& col,
                   int style = wxFLOOD_SURFACE)
        { return DoFloodFill(x, y, col, style); }
    bool FloodFill(const wxPoint& pt, const wxColour& col,
                   int style = wxFLOOD_SURFACE)
        { return DoFloodFill(pt.x, pt.y, col, style); }



    void GradientFillConcentric(const wxRect& rect,
                                const wxColour& initialColour,
                                const wxColour& destColour)
        { GradientFillConcentric(rect, initialColour, destColour,
                                 wxPoint(rect.GetWidth() / 2,
                                         rect.GetHeight() / 2)); }

    void GradientFillConcentric(const wxRect& rect,
                                const wxColour& initialColour,
                                const wxColour& destColour,
                                const wxPoint& circleCenter)
        { DoGradientFillConcentric(rect, initialColour, destColour, circleCenter); }


    void GradientFillLinear(const wxRect& rect,
                            const wxColour& initialColour,
                            const wxColour& destColour,
                            wxDirection nDirection = wxEAST)
        { DoGradientFillLinear(rect, initialColour, destColour, nDirection); }

    bool GetPixel(wxCoord x, wxCoord y, wxColour *col) const
        { return DoGetPixel(x, y, col); }
    bool GetPixel(const wxPoint& pt, wxColour *col) const
        { return DoGetPixel(pt.x, pt.y, col); }

    void DrawLine(wxCoord x1, wxCoord y1, wxCoord x2, wxCoord y2)
        { DoDrawLine(x1, y1, x2, y2); }
    void DrawLine(const wxPoint& pt1, const wxPoint& pt2)
        { DoDrawLine(pt1.x, pt1.y, pt2.x, pt2.y); }

    void CrossHair(wxCoord x, wxCoord y)
        { DoCrossHair(x, y); }
    void CrossHair(const wxPoint& pt)
        { DoCrossHair(pt.x, pt.y); }

    void DrawArc(wxCoord x1, wxCoord y1, wxCoord x2, wxCoord y2,
                 wxCoord xc, wxCoord yc)
        { DoDrawArc(x1, y1, x2, y2, xc, yc); }
    void DrawArc(const wxPoint& pt1, const wxPoint& pt2, const wxPoint& centre)
        { DoDrawArc(pt1.x, pt1.y, pt2.x, pt2.y, centre.x, centre.y); }

    void DrawCheckMark(wxCoord x, wxCoord y,
                       wxCoord width, wxCoord height)
        { DoDrawCheckMark(x, y, width, height); }
    void DrawCheckMark(const wxRect& rect)
        { DoDrawCheckMark(rect.x, rect.y, rect.width, rect.height); }

    void DrawEllipticArc(wxCoord x, wxCoord y, wxCoord w, wxCoord h,
                         double sa, double ea)
        { DoDrawEllipticArc(x, y, w, h, sa, ea); }
    void DrawEllipticArc(const wxPoint& pt, const wxSize& sz,
                         double sa, double ea)
        { DoDrawEllipticArc(pt.x, pt.y, sz.x, sz.y, sa, ea); }

    void DrawPoint(wxCoord x, wxCoord y)
        { DoDrawPoint(x, y); }
    void DrawPoint(const wxPoint& pt)
        { DoDrawPoint(pt.x, pt.y); }

    void DrawLines(int n, wxPoint points[],
                   wxCoord xoffset = 0, wxCoord yoffset = 0)
        { DoDrawLines(n, points, xoffset, yoffset); }
    void DrawLines(const wxList *list,
                   wxCoord xoffset = 0, wxCoord yoffset = 0);

    void DrawPolygon(int n, wxPoint points[],
                     wxCoord xoffset = 0, wxCoord yoffset = 0,
                     int fillStyle = wxODDEVEN_RULE)
        { DoDrawPolygon(n, points, xoffset, yoffset, fillStyle); }

    void DrawPolygon(const wxList *list,
                     wxCoord xoffset = 0, wxCoord yoffset = 0,
                     int fillStyle = wxODDEVEN_RULE);

    void DrawPolyPolygon(int n, int count[], wxPoint points[],
                         wxCoord xoffset = 0, wxCoord yoffset = 0,
                         int fillStyle = wxODDEVEN_RULE)
        { DoDrawPolyPolygon(n, count, points, xoffset, yoffset, fillStyle); }

    void DrawRectangle(wxCoord x, wxCoord y, wxCoord width, wxCoord height)
        { DoDrawRectangle(x, y, width, height); }
    void DrawRectangle(const wxPoint& pt, const wxSize& sz)
        { DoDrawRectangle(pt.x, pt.y, sz.x, sz.y); }
    void DrawRectangle(const wxRect& rect)
        { DoDrawRectangle(rect.x, rect.y, rect.width, rect.height); }

    void DrawRoundedRectangle(wxCoord x, wxCoord y, wxCoord width, wxCoord height,
                              double radius)
        { DoDrawRoundedRectangle(x, y, width, height, radius); }
    void DrawRoundedRectangle(const wxPoint& pt, const wxSize& sz,
                             double radius)
        { DoDrawRoundedRectangle(pt.x, pt.y, sz.x, sz.y, radius); }
    void DrawRoundedRectangle(const wxRect& r, double radius)
        { DoDrawRoundedRectangle(r.x, r.y, r.width, r.height, radius); }

    void DrawCircle(wxCoord x, wxCoord y, wxCoord radius)
        { DoDrawEllipse(x - radius, y - radius, 2*radius, 2*radius); }
    void DrawCircle(const wxPoint& pt, wxCoord radius)
        { DrawCircle(pt.x, pt.y, radius); }

    void DrawEllipse(wxCoord x, wxCoord y, wxCoord width, wxCoord height)
        { DoDrawEllipse(x, y, width, height); }
    void DrawEllipse(const wxPoint& pt, const wxSize& sz)
        { DoDrawEllipse(pt.x, pt.y, sz.x, sz.y); }
    void DrawEllipse(const wxRect& rect)
        { DoDrawEllipse(rect.x, rect.y, rect.width, rect.height); }

    void DrawIcon(const wxIcon& icon, wxCoord x, wxCoord y)
        { DoDrawIcon(icon, x, y); }
    void DrawIcon(const wxIcon& icon, const wxPoint& pt)
        { DoDrawIcon(icon, pt.x, pt.y); }

    void DrawBitmap(const wxBitmap &bmp, wxCoord x, wxCoord y,
                    bool useMask = false)
        { DoDrawBitmap(bmp, x, y, useMask); }
    void DrawBitmap(const wxBitmap &bmp, const wxPoint& pt,
                    bool useMask = false)
        { DoDrawBitmap(bmp, pt.x, pt.y, useMask); }

    void DrawText(const wxString& text, wxCoord x, wxCoord y)
        { DoDrawText(text, x, y); }
    void DrawText(const wxString& text, const wxPoint& pt)
        { DoDrawText(text, pt.x, pt.y); }

    void DrawRotatedText(const wxString& text, wxCoord x, wxCoord y, double angle)
        { DoDrawRotatedText(text, x, y, angle); }
    void DrawRotatedText(const wxString& text, const wxPoint& pt, double angle)
        { DoDrawRotatedText(text, pt.x, pt.y, angle); }





    virtual void DrawLabel(const wxString& text,
                           const wxBitmap& image,
                           const wxRect& rect,
                           int alignment = wxALIGN_LEFT | wxALIGN_TOP,
                           int indexAccel = -1,
                           wxRect *rectBounding = __null);

    void DrawLabel(const wxString& text, const wxRect& rect,
                   int alignment = wxALIGN_LEFT | wxALIGN_TOP,
                   int indexAccel = -1)
        { DrawLabel(text, wxNullBitmap, rect, alignment, indexAccel); }

    bool Blit(wxCoord xdest, wxCoord ydest, wxCoord width, wxCoord height,
              wxDC *source, wxCoord xsrc, wxCoord ysrc,
              int rop = wxCOPY, bool useMask = false, wxCoord xsrcMask = wxDefaultCoord, wxCoord ysrcMask = wxDefaultCoord)
    {
        return DoBlit(xdest, ydest, width, height,
                      source, xsrc, ysrc, rop, useMask, xsrcMask, ysrcMask);
    }
    bool Blit(const wxPoint& destPt, const wxSize& sz,
              wxDC *source, const wxPoint& srcPt,
              int rop = wxCOPY, bool useMask = false, const wxPoint& srcPtMask = wxDefaultPosition)
    {
        return DoBlit(destPt.x, destPt.y, sz.x, sz.y,
                      source, srcPt.x, srcPt.y, rop, useMask, srcPtMask.x, srcPtMask.y);
    }

    wxBitmap GetAsBitmap(const wxRect *subrect = (const wxRect *) __null) const
    {
        return DoGetAsBitmap(subrect);
    }



    void DrawSpline(wxCoord x1, wxCoord y1,
                    wxCoord x2, wxCoord y2,
                    wxCoord x3, wxCoord y3);
    void DrawSpline(int n, wxPoint points[]);

    void DrawSpline(wxList *points) { DoDrawSpline(points); }
# 383 "/usr/include/wx-2.8/wx/dc.h"
    virtual void Clear() = 0;

    virtual bool StartDoc(const wxString& ) { return true; }
    virtual void EndDoc() { }

    virtual void StartPage() { }
    virtual void EndPage() { }


    void BeginDrawing() __attribute__ ((deprecated));
    void EndDrawing() __attribute__ ((deprecated));






    virtual void SetFont(const wxFont& font) = 0;
    virtual void SetPen(const wxPen& pen) = 0;
    virtual void SetBrush(const wxBrush& brush) = 0;
    virtual void SetBackground(const wxBrush& brush) = 0;
    virtual void SetBackgroundMode(int mode) = 0;

    virtual void SetPalette(const wxPalette& palette) = 0;





    void SetClippingRegion(wxCoord x, wxCoord y, wxCoord width, wxCoord height)
        { DoSetClippingRegion(x, y, width, height); }
    void SetClippingRegion(const wxPoint& pt, const wxSize& sz)
        { DoSetClippingRegion(pt.x, pt.y, sz.x, sz.y); }
    void SetClippingRegion(const wxRect& rect)
        { DoSetClippingRegion(rect.x, rect.y, rect.width, rect.height); }
    void SetClippingRegion(const wxRegion& region)
        { DoSetClippingRegionAsRegion(region); }


    void SetDeviceClippingRegion(const wxRegion& region)
        { DoSetClippingRegionAsRegion(region); }


    virtual void DestroyClippingRegion() { ResetClipping(); }

    void GetClippingBox(wxCoord *x, wxCoord *y, wxCoord *w, wxCoord *h) const
        { DoGetClippingBox(x, y, w, h); }
    void GetClippingBox(wxRect& rect) const
        {
          DoGetClippingBox(&rect.x, &rect.y, &rect.width, &rect.height);
        }




    virtual wxCoord GetCharHeight() const = 0;
    virtual wxCoord GetCharWidth() const = 0;


    void GetTextExtent(const wxString& string,
                       wxCoord *x, wxCoord *y,
                       wxCoord *descent = __null,
                       wxCoord *externalLeading = __null,
                       wxFont *theFont = __null) const
        { DoGetTextExtent(string, x, y, descent, externalLeading, theFont); }

    wxSize GetTextExtent(const wxString& string) const
    {
        wxCoord w, h;
        DoGetTextExtent(string, &w, &h);
        return wxSize(w, h);
    }


    virtual void GetMultiLineTextExtent(const wxString& string,
                                        wxCoord *width,
                                        wxCoord *height,
                                        wxCoord *heightLine = __null,
                                        wxFont *font = __null) const;

    wxSize GetMultiLineTextExtent(const wxString& string) const
    {
        wxCoord w, h;
        GetMultiLineTextExtent(string, &w, &h);
        return wxSize(w, h);
    }


    bool GetPartialTextExtents(const wxString& text, wxArrayInt& widths) const
        { return DoGetPartialTextExtents(text, widths); }





    void GetSize(int *width, int *height) const
        { DoGetSize(width, height); }
    wxSize GetSize() const
    {
        int w, h;
        DoGetSize(&w, &h);

        return wxSize(w, h);
    }


    void GetSizeMM(int* width, int* height) const
        { DoGetSizeMM(width, height); }
    wxSize GetSizeMM() const
    {
        int w, h;
        DoGetSizeMM(&w, &h);

        return wxSize(w, h);
    }






    wxCoord DeviceToLogicalX(wxCoord x) const;
    wxCoord DeviceToLogicalY(wxCoord y) const;
    wxCoord DeviceToLogicalXRel(wxCoord x) const;
    wxCoord DeviceToLogicalYRel(wxCoord y) const;
    wxCoord LogicalToDeviceX(wxCoord x) const;
    wxCoord LogicalToDeviceY(wxCoord y) const;
    wxCoord LogicalToDeviceXRel(wxCoord x) const;
    wxCoord LogicalToDeviceYRel(wxCoord y) const;




    virtual bool CanDrawBitmap() const = 0;
    virtual bool CanGetTextExtent() const = 0;


    virtual int GetDepth() const = 0;


    virtual wxSize GetPPI() const = 0;

    virtual bool Ok() const { return IsOk(); }
    virtual bool IsOk() const { return m_ok; }




    virtual int GetBackgroundMode() const { return m_backgroundMode; }
    virtual const wxBrush& GetBackground() const { return m_backgroundBrush; }
    virtual const wxBrush& GetBrush() const { return m_brush; }
    virtual const wxFont& GetFont() const { return m_font; }
    virtual const wxPen& GetPen() const { return m_pen; }

    virtual const wxColour& GetTextForeground() const { return m_textForegroundColour; }
    virtual const wxColour& GetTextBackground() const { return m_textBackgroundColour; }
    virtual void SetTextForeground(const wxColour& colour)
        { m_textForegroundColour = colour; }
    virtual void SetTextBackground(const wxColour& colour)
        { m_textBackgroundColour = colour; }

    virtual int GetMapMode() const { return m_mappingMode; }
    virtual void SetMapMode(int mode) = 0;

    virtual void GetUserScale(double *x, double *y) const
    {
        if ( x ) *x = m_userScaleX;
        if ( y ) *y = m_userScaleY;
    }
    virtual void SetUserScale(double x, double y) = 0;

    virtual void GetLogicalScale(double *x, double *y)
    {
        if ( x ) *x = m_logicalScaleX;
        if ( y ) *y = m_logicalScaleY;
    }
    virtual void SetLogicalScale(double x, double y)
    {
        m_logicalScaleX = x;
        m_logicalScaleY = y;
    }

    void GetLogicalOrigin(wxCoord *x, wxCoord *y) const
        { DoGetLogicalOrigin(x, y); }
    wxPoint GetLogicalOrigin() const
        { wxCoord x, y; DoGetLogicalOrigin(&x, &y); return wxPoint(x, y); }
    virtual void SetLogicalOrigin(wxCoord x, wxCoord y) = 0;

    void GetDeviceOrigin(wxCoord *x, wxCoord *y) const
        { DoGetDeviceOrigin(x, y); }
    wxPoint GetDeviceOrigin() const
        { wxCoord x, y; DoGetDeviceOrigin(&x, &y); return wxPoint(x, y); }
    virtual void SetDeviceOrigin(wxCoord x, wxCoord y) = 0;

    virtual void ComputeScaleAndOrigin() {}

    virtual void SetAxisOrientation(bool xLeftRight, bool yBottomUp) = 0;

    virtual int GetLogicalFunction() const { return m_logicalFunction; }
    virtual void SetLogicalFunction(int function) = 0;
# 592 "/usr/include/wx-2.8/wx/dc.h"
    virtual void CalcBoundingBox(wxCoord x, wxCoord y)
    {
      if ( m_isBBoxValid )
      {
         if ( x < m_minX ) m_minX = x;
         if ( y < m_minY ) m_minY = y;
         if ( x > m_maxX ) m_maxX = x;
         if ( y > m_maxY ) m_maxY = y;
      }
      else
      {
         m_isBBoxValid = true;

         m_minX = x;
         m_minY = y;
         m_maxX = x;
         m_maxY = y;
      }
    }

    void ResetBoundingBox()
    {
        m_isBBoxValid = false;

        m_minX = m_maxX = m_minY = m_maxY = 0;
    }


    wxCoord MinX() const { return m_minX; }
    wxCoord MaxX() const { return m_maxX; }
    wxCoord MinY() const { return m_minY; }
    wxCoord MaxY() const { return m_maxY; }





    void GetTextExtent(const wxString& string,
                       long *x, long *y,
                       long *descent = __null,
                       long *externalLeading = __null,
                       wxFont *theFont = __null) const
    {
        wxCoord x2, y2, descent2, externalLeading2;
        DoGetTextExtent(string, &x2, &y2,
                        &descent2, &externalLeading2,
                        theFont);
        if ( x )
            *x = x2;
        if ( y )
            *y = y2;
        if ( descent )
            *descent = descent2;
        if ( externalLeading )
            *externalLeading = externalLeading2;
    }

    void GetLogicalOrigin(long *x, long *y) const
    {
        wxCoord x2, y2;
        DoGetLogicalOrigin(&x2, &y2);
        if ( x )
            *x = x2;
        if ( y )
            *y = y2;
    }

    void GetDeviceOrigin(long *x, long *y) const
    {
        wxCoord x2, y2;
        DoGetDeviceOrigin(&x2, &y2);
        if ( x )
            *x = x2;
        if ( y )
            *y = y2;
    }
    void GetClippingBox(long *x, long *y, long *w, long *h) const
    {
        wxCoord xx,yy,ww,hh;
        DoGetClippingBox(&xx, &yy, &ww, &hh);
        if (x) *x = xx;
        if (y) *y = yy;
        if (w) *w = ww;
        if (h) *h = hh;
    }






    virtual wxLayoutDirection GetLayoutDirection() const
        { return wxLayout_Default; }
    virtual void SetLayoutDirection(wxLayoutDirection )
        { }

protected:

    virtual bool DoFloodFill(wxCoord x, wxCoord y, const wxColour& col,
                             int style = wxFLOOD_SURFACE) = 0;

    virtual void DoGradientFillLinear(const wxRect& rect,
                                      const wxColour& initialColour,
                                      const wxColour& destColour,
                                      wxDirection nDirection = wxEAST);

    virtual void DoGradientFillConcentric(const wxRect& rect,
                                        const wxColour& initialColour,
                                        const wxColour& destColour,
                                        const wxPoint& circleCenter);

    virtual bool DoGetPixel(wxCoord x, wxCoord y, wxColour *col) const = 0;

    virtual void DoDrawPoint(wxCoord x, wxCoord y) = 0;
    virtual void DoDrawLine(wxCoord x1, wxCoord y1, wxCoord x2, wxCoord y2) = 0;

    virtual void DoDrawArc(wxCoord x1, wxCoord y1,
                           wxCoord x2, wxCoord y2,
                           wxCoord xc, wxCoord yc) = 0;
    virtual void DoDrawCheckMark(wxCoord x, wxCoord y,
                                 wxCoord width, wxCoord height);
    virtual void DoDrawEllipticArc(wxCoord x, wxCoord y, wxCoord w, wxCoord h,
                                   double sa, double ea) = 0;

    virtual void DoDrawRectangle(wxCoord x, wxCoord y, wxCoord width, wxCoord height) = 0;
    virtual void DoDrawRoundedRectangle(wxCoord x, wxCoord y,
                                        wxCoord width, wxCoord height,
                                        double radius) = 0;
    virtual void DoDrawEllipse(wxCoord x, wxCoord y,
                               wxCoord width, wxCoord height) = 0;

    virtual void DoCrossHair(wxCoord x, wxCoord y) = 0;

    virtual void DoDrawIcon(const wxIcon& icon, wxCoord x, wxCoord y) = 0;
    virtual void DoDrawBitmap(const wxBitmap &bmp, wxCoord x, wxCoord y,
                              bool useMask = false) = 0;

    virtual void DoDrawText(const wxString& text, wxCoord x, wxCoord y) = 0;
    virtual void DoDrawRotatedText(const wxString& text,
                                   wxCoord x, wxCoord y, double angle) = 0;

    virtual bool DoBlit(wxCoord xdest, wxCoord ydest,
                        wxCoord width, wxCoord height,
                        wxDC *source, wxCoord xsrc, wxCoord ysrc,
                        int rop = wxCOPY, bool useMask = false, wxCoord xsrcMask = wxDefaultCoord, wxCoord ysrcMask = wxDefaultCoord) = 0;

    virtual wxBitmap DoGetAsBitmap(const wxRect *) const { return wxNullBitmap; }

    virtual void DoGetSize(int *width, int *height) const = 0;
    virtual void DoGetSizeMM(int* width, int* height) const = 0;

    virtual void DoDrawLines(int n, wxPoint points[],
                             wxCoord xoffset, wxCoord yoffset) = 0;
    virtual void DoDrawPolygon(int n, wxPoint points[],
                               wxCoord xoffset, wxCoord yoffset,
                               int fillStyle = wxODDEVEN_RULE) = 0;
    virtual void DoDrawPolyPolygon(int n, int count[], wxPoint points[],
                               wxCoord xoffset, wxCoord yoffset,
                               int fillStyle);

    virtual void DoSetClippingRegionAsRegion(const wxRegion& region) = 0;
    virtual void DoSetClippingRegion(wxCoord x, wxCoord y,
                                     wxCoord width, wxCoord height) = 0;
# 763 "/usr/include/wx-2.8/wx/dc.h"
    virtual void DoGetClippingBox(wxCoord *x, wxCoord *y,
                                  wxCoord *w, wxCoord *h) const
    {
        if ( x )
            *x = m_clipX1;
        if ( y )
            *y = m_clipY1;
        if ( w )
            *w = m_clipX2 - m_clipX1;
        if ( h )
            *h = m_clipY2 - m_clipY1;
    }

    virtual void DoGetLogicalOrigin(wxCoord *x, wxCoord *y) const
    {
        if ( x ) *x = m_logicalOriginX;
        if ( y ) *y = m_logicalOriginY;
    }

    virtual void DoGetDeviceOrigin(wxCoord *x, wxCoord *y) const
    {
        if ( x ) *x = m_deviceOriginX;
        if ( y ) *y = m_deviceOriginY;
    }

    virtual void DoGetTextExtent(const wxString& string,
                                 wxCoord *x, wxCoord *y,
                                 wxCoord *descent = __null,
                                 wxCoord *externalLeading = __null,
                                 wxFont *theFont = __null) const = 0;

    virtual bool DoGetPartialTextExtents(const wxString& text, wxArrayInt& widths) const;


    virtual void DoDrawSpline(wxList *points);






    static float GetFontPointSizeAdjustment(float dpi);


protected:

    void ResetClipping()
    {
        m_clipping = false;

        m_clipX1 = m_clipX2 = m_clipY1 = m_clipY2 = 0;
    }


    bool m_colour:1;
    bool m_ok:1;
    bool m_clipping:1;
    bool m_isInteractive:1;
    bool m_isBBoxValid:1;





    wxCoord m_logicalOriginX, m_logicalOriginY;
    wxCoord m_deviceOriginX, m_deviceOriginY;

    double m_logicalScaleX, m_logicalScaleY;
    double m_userScaleX, m_userScaleY;
    double m_scaleX, m_scaleY;


    int m_signX, m_signY;


    wxCoord m_minX, m_minY, m_maxX, m_maxY;
    wxCoord m_clipX1, m_clipY1, m_clipX2, m_clipY2;

    int m_logicalFunction;
    int m_backgroundMode;
    int m_mappingMode;


    wxPen m_pen;
    wxBrush m_brush;
    wxBrush m_backgroundBrush;
    wxColour m_textForegroundColour;
    wxColour m_textBackgroundColour;
    wxFont m_font;


    wxPalette m_palette;
    bool m_hasCustomPalette;


private:
    private: wxDCBase(const wxDCBase&); wxDCBase& operator=(const wxDCBase&);
    public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const;
};
# 874 "/usr/include/wx-2.8/wx/dc.h"
# 1 "/usr/include/wx-2.8/wx/gtk/dc.h" 1
# 32 "/usr/include/wx-2.8/wx/gtk/dc.h"
inline wxCoord wxDCBase::DeviceToLogicalX(wxCoord x) const
{
    return wxRound((x - m_deviceOriginX) / m_scaleX) * m_signX + m_logicalOriginX;
}
inline wxCoord wxDCBase::DeviceToLogicalY(wxCoord y) const
{
    return wxRound((y - m_deviceOriginY) / m_scaleY) * m_signY + m_logicalOriginY;
}
inline wxCoord wxDCBase::DeviceToLogicalXRel(wxCoord x) const
{
    return wxRound(x / m_scaleX);
}
inline wxCoord wxDCBase::DeviceToLogicalYRel(wxCoord y) const
{
    return wxRound(y / m_scaleY);
}
inline wxCoord wxDCBase::LogicalToDeviceX(wxCoord x) const
{
    return wxRound((x - m_logicalOriginX) * m_scaleX) * m_signX + m_deviceOriginX;
}
inline wxCoord wxDCBase::LogicalToDeviceY(wxCoord y) const
{
    return wxRound((y - m_logicalOriginY) * m_scaleY) * m_signY + m_deviceOriginY;
}
inline wxCoord wxDCBase::LogicalToDeviceXRel(wxCoord x) const
{
    return wxRound(x * m_scaleX);
}
inline wxCoord wxDCBase::LogicalToDeviceYRel(wxCoord y) const
{
    return wxRound(y * m_scaleY);
}





class wxDC : public wxDCBase
{
public:
    wxDC();
    virtual ~wxDC() { }


    void SetColourMap( const wxPalette& palette ) { SetPalette(palette); };



    virtual wxSize GetPPI() const;

    virtual bool StartDoc( const wxString& ) { return true; }
    virtual void EndDoc() { }
    virtual void StartPage() { }
    virtual void EndPage() { }

    virtual void SetMapMode( int mode );
    virtual void SetUserScale( double x, double y );
    virtual void SetLogicalScale( double x, double y );
    virtual void SetLogicalOrigin( wxCoord x, wxCoord y );
    virtual void SetDeviceOrigin( wxCoord x, wxCoord y );

    virtual void SetAxisOrientation( bool xLeftRight, bool yBottomUp );

    virtual void ComputeScaleAndOrigin();

    virtual GdkWindow* GetGDKWindow() const { return __null; }
    virtual wxBitmap GetSelectedBitmap() const { return wxNullBitmap; }

protected:



    wxCoord XDEV2LOG(wxCoord x) const
    {
        return DeviceToLogicalX(x);
    }
    wxCoord XDEV2LOGREL(wxCoord x) const
    {
        return DeviceToLogicalXRel(x);
    }
    wxCoord YDEV2LOG(wxCoord y) const
    {
        return DeviceToLogicalY(y);
    }
    wxCoord YDEV2LOGREL(wxCoord y) const
    {
        return DeviceToLogicalYRel(y);
    }
    wxCoord XLOG2DEV(wxCoord x) const
    {
        return LogicalToDeviceX(x);
    }
    wxCoord XLOG2DEVREL(wxCoord x) const
    {
        return LogicalToDeviceXRel(x);
    }
    wxCoord YLOG2DEV(wxCoord y) const
    {
        return LogicalToDeviceY(y);
    }
    wxCoord YLOG2DEVREL(wxCoord y) const
    {
        return LogicalToDeviceYRel(y);
    }


    virtual void DoSetClippingRegion(wxCoord x, wxCoord y, wxCoord width, wxCoord height);
    virtual void DoGetSizeMM(int* width, int* height) const;

public:




    double m_mm_to_pix_x,
                 m_mm_to_pix_y;

    bool m_needComputeScaleX,
                 m_needComputeScaleY;


private:
    public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const;
};
# 875 "/usr/include/wx-2.8/wx/dc.h" 2
# 892 "/usr/include/wx-2.8/wx/dc.h"
# 1 "/usr/include/wx-2.8/wx/dcgraph.h" 1
# 17 "/usr/include/wx-2.8/wx/dcgraph.h"
# 1 "/usr/include/wx-2.8/wx/geometry.h" 1
# 23 "/usr/include/wx-2.8/wx/geometry.h"
class wxDataInputStream;
class wxDataOutputStream;



enum wxOutCode
{
    wxInside = 0x00 ,
    wxOutLeft = 0x01 ,
    wxOutRight = 0x02 ,
    wxOutTop = 0x08 ,
    wxOutBottom = 0x04
};

class wxPoint2DInt
{
public :
    inline wxPoint2DInt();
    inline wxPoint2DInt( wxInt32 x , wxInt32 y );
    inline wxPoint2DInt( const wxPoint2DInt &pt );
    inline wxPoint2DInt( const wxPoint &pt );


    inline void GetFloor( wxInt32 *x , wxInt32 *y ) const;
    inline void GetRounded( wxInt32 *x , wxInt32 *y ) const;

    inline wxDouble GetVectorLength() const;
           wxDouble GetVectorAngle() const;
    inline void SetVectorLength( wxDouble length );
           void SetVectorAngle( wxDouble degrees );
           void SetPolarCoordinates( wxInt32 angle , wxInt32 length );

    inline void Normalize();

    inline wxDouble GetDistance( const wxPoint2DInt &pt ) const;
    inline wxDouble GetDistanceSquare( const wxPoint2DInt &pt ) const;
    inline wxInt32 GetDotProduct( const wxPoint2DInt &vec ) const;
    inline wxInt32 GetCrossProduct( const wxPoint2DInt &vec ) const;


    inline wxPoint2DInt operator-();

    inline wxPoint2DInt& operator=(const wxPoint2DInt& pt);
    inline wxPoint2DInt& operator+=(const wxPoint2DInt& pt);
    inline wxPoint2DInt& operator-=(const wxPoint2DInt& pt);
    inline wxPoint2DInt& operator*=(const wxPoint2DInt& pt);
    inline wxPoint2DInt& operator*=(wxDouble n);
    inline wxPoint2DInt& operator*=(wxInt32 n);
    inline wxPoint2DInt& operator/=(const wxPoint2DInt& pt);
    inline wxPoint2DInt& operator/=(wxDouble n);
    inline wxPoint2DInt& operator/=(wxInt32 n);
    inline operator wxPoint() const;
    inline bool operator==(const wxPoint2DInt& pt) const;
    inline bool operator!=(const wxPoint2DInt& pt) const;


    void WriteTo( wxDataOutputStream &stream ) const;
    void ReadFrom( wxDataInputStream &stream );


    wxInt32 m_x;
    wxInt32 m_y;
};

inline wxPoint2DInt operator+(const wxPoint2DInt& pt1 , const wxPoint2DInt& pt2);
inline wxPoint2DInt operator-(const wxPoint2DInt& pt1 , const wxPoint2DInt& pt2);
inline wxPoint2DInt operator*(const wxPoint2DInt& pt1 , const wxPoint2DInt& pt2);
inline wxPoint2DInt operator*(wxInt32 n , const wxPoint2DInt& pt);
inline wxPoint2DInt operator*(wxInt32 n , const wxPoint2DInt& pt);
inline wxPoint2DInt operator*(const wxPoint2DInt& pt , wxInt32 n);
inline wxPoint2DInt operator*(const wxPoint2DInt& pt , wxInt32 n);
inline wxPoint2DInt operator/(const wxPoint2DInt& pt1 , const wxPoint2DInt& pt2);
inline wxPoint2DInt operator/(const wxPoint2DInt& pt , wxInt32 n);
inline wxPoint2DInt operator/(const wxPoint2DInt& pt , wxInt32 n);

inline wxPoint2DInt::wxPoint2DInt()
{
    m_x = 0;
    m_y = 0;
}

inline wxPoint2DInt::wxPoint2DInt( wxInt32 x , wxInt32 y )
{
    m_x = x;
    m_y = y;
}

inline wxPoint2DInt::wxPoint2DInt( const wxPoint2DInt &pt )
{
    m_x = pt.m_x;
    m_y = pt.m_y;
}

inline wxPoint2DInt::wxPoint2DInt( const wxPoint &pt )
{
    m_x = pt.x;
    m_y = pt.y;
}

inline void wxPoint2DInt::GetFloor( wxInt32 *x , wxInt32 *y ) const
{
    if ( x )
        *x = m_x;
    if ( y )
        *y = m_y;
}

inline void wxPoint2DInt::GetRounded( wxInt32 *x , wxInt32 *y ) const
{
    GetFloor(x, y);
}

inline wxDouble wxPoint2DInt::GetVectorLength() const
{

    return sqrt( (double)(m_x)*(m_x) + (m_y)*(m_y) );
}

inline void wxPoint2DInt::SetVectorLength( wxDouble length )
{
    wxDouble before = GetVectorLength();
    m_x = (wxInt32)(m_x * length / before);
    m_y = (wxInt32)(m_y * length / before);
}

inline void wxPoint2DInt::Normalize()
{
    SetVectorLength( 1 );
}

inline wxDouble wxPoint2DInt::GetDistance( const wxPoint2DInt &pt ) const
{
    return sqrt( GetDistanceSquare( pt ) );
}

inline wxDouble wxPoint2DInt::GetDistanceSquare( const wxPoint2DInt &pt ) const
{
    return ( (wxDouble)(pt.m_x-m_x)*(pt.m_x-m_x) + (wxDouble)(pt.m_y-m_y)*(pt.m_y-m_y) );
}

inline wxInt32 wxPoint2DInt::GetDotProduct( const wxPoint2DInt &vec ) const
{
    return ( m_x * vec.m_x + m_y * vec.m_y );
}

inline wxInt32 wxPoint2DInt::GetCrossProduct( const wxPoint2DInt &vec ) const
{
    return ( m_x * vec.m_y - vec.m_x * m_y );
}

inline wxPoint2DInt::operator wxPoint() const
{
    return wxPoint( m_x, m_y);
}

inline wxPoint2DInt wxPoint2DInt::operator-()
{
    return wxPoint2DInt( -m_x, -m_y);
}

inline wxPoint2DInt& wxPoint2DInt::operator=(const wxPoint2DInt& pt)
{
    m_x = pt.m_x;
    m_y = pt.m_y;
    return *this;
}

inline wxPoint2DInt& wxPoint2DInt::operator+=(const wxPoint2DInt& pt)
{
    m_x = m_x + pt.m_x;
    m_y = m_y + pt.m_y;
    return *this;
}

inline wxPoint2DInt& wxPoint2DInt::operator-=(const wxPoint2DInt& pt)
{
    m_x = m_x - pt.m_x;
    m_y = m_y - pt.m_y;
    return *this;
}

inline wxPoint2DInt& wxPoint2DInt::operator*=(const wxPoint2DInt& pt)
{
    m_x = m_x + pt.m_x;
    m_y = m_y + pt.m_y;
    return *this;
}

inline wxPoint2DInt& wxPoint2DInt::operator/=(const wxPoint2DInt& pt)
{
    m_x = m_x - pt.m_x;
    m_y = m_y - pt.m_y;
    return *this;
}

inline bool wxPoint2DInt::operator==(const wxPoint2DInt& pt) const
{
    return m_x == pt.m_x && m_y == pt.m_y;
}

inline bool wxPoint2DInt::operator!=(const wxPoint2DInt& pt) const
{
    return m_x != pt.m_x || m_y != pt.m_y;
}

inline wxPoint2DInt operator+(const wxPoint2DInt& pt1 , const wxPoint2DInt& pt2)
{
    return wxPoint2DInt( pt1.m_x + pt2.m_x , pt1.m_y + pt2.m_y );
}

inline wxPoint2DInt operator-(const wxPoint2DInt& pt1 , const wxPoint2DInt& pt2)
{
    return wxPoint2DInt( pt1.m_x - pt2.m_x , pt1.m_y - pt2.m_y );
}


inline wxPoint2DInt operator*(const wxPoint2DInt& pt1 , const wxPoint2DInt& pt2)
{
    return wxPoint2DInt( pt1.m_x * pt2.m_x , pt1.m_y * pt2.m_y );
}

inline wxPoint2DInt operator*(wxInt32 n , const wxPoint2DInt& pt)
{
    return wxPoint2DInt( pt.m_x * n , pt.m_y * n );
}

inline wxPoint2DInt operator*(wxDouble n , const wxPoint2DInt& pt)
{
    return wxPoint2DInt( (int) (pt.m_x * n) , (int) (pt.m_y * n) );
}

inline wxPoint2DInt operator*(const wxPoint2DInt& pt , wxInt32 n)
{
    return wxPoint2DInt( pt.m_x * n , pt.m_y * n );
}

inline wxPoint2DInt operator*(const wxPoint2DInt& pt , wxDouble n)
{
    return wxPoint2DInt( (int) (pt.m_x * n) , (int) (pt.m_y * n) );
}

inline wxPoint2DInt operator/(const wxPoint2DInt& pt1 , const wxPoint2DInt& pt2)
{
    return wxPoint2DInt( pt1.m_x / pt2.m_x , pt1.m_y / pt2.m_y );
}

inline wxPoint2DInt operator/(const wxPoint2DInt& pt , wxInt32 n)
{
    return wxPoint2DInt( pt.m_x / n , pt.m_y / n );
}

inline wxPoint2DInt operator/(const wxPoint2DInt& pt , wxDouble n)
{
    return wxPoint2DInt( (int) (pt.m_x / n) , (int) (pt.m_y / n) );
}



class wxPoint2DDouble
{
public :
    inline wxPoint2DDouble();
    inline wxPoint2DDouble( wxDouble x , wxDouble y );
    inline wxPoint2DDouble( const wxPoint2DDouble &pt );
    wxPoint2DDouble( const wxPoint2DInt &pt )
        { m_x = (wxDouble) pt.m_x ; m_y = (wxDouble) pt.m_y ; }
    wxPoint2DDouble( const wxPoint &pt )
        { m_x = (wxDouble) pt.x ; m_y = (wxDouble) pt.y ; }


    inline void GetFloor( wxInt32 *x , wxInt32 *y ) const;
    inline void GetRounded( wxInt32 *x , wxInt32 *y ) const;

    inline wxDouble GetVectorLength() const;
     wxDouble GetVectorAngle() const ;
    void SetVectorLength( wxDouble length );
    void SetVectorAngle( wxDouble degrees );
    void SetPolarCoordinates( wxDouble angle , wxDouble length );

    void Normalize();

    inline wxDouble GetDistance( const wxPoint2DDouble &pt ) const;
    inline wxDouble GetDistanceSquare( const wxPoint2DDouble &pt ) const;
    inline wxDouble GetDotProduct( const wxPoint2DDouble &vec ) const;
    inline wxDouble GetCrossProduct( const wxPoint2DDouble &vec ) const;


    inline wxPoint2DDouble operator-();

    inline wxPoint2DDouble& operator=(const wxPoint2DDouble& pt);
    inline wxPoint2DDouble& operator+=(const wxPoint2DDouble& pt);
    inline wxPoint2DDouble& operator-=(const wxPoint2DDouble& pt);
    inline wxPoint2DDouble& operator*=(const wxPoint2DDouble& pt);
    inline wxPoint2DDouble& operator*=(wxDouble n);
    inline wxPoint2DDouble& operator*=(wxInt32 n);
    inline wxPoint2DDouble& operator/=(const wxPoint2DDouble& pt);
    inline wxPoint2DDouble& operator/=(wxDouble n);
    inline wxPoint2DDouble& operator/=(wxInt32 n);

    inline bool operator==(const wxPoint2DDouble& pt) const;
    inline bool operator!=(const wxPoint2DDouble& pt) const;

    wxDouble m_x;
    wxDouble m_y;
};

inline wxPoint2DDouble operator+(const wxPoint2DDouble& pt1 , const wxPoint2DDouble& pt2);
inline wxPoint2DDouble operator-(const wxPoint2DDouble& pt1 , const wxPoint2DDouble& pt2);
inline wxPoint2DDouble operator*(const wxPoint2DDouble& pt1 , const wxPoint2DDouble& pt2);
inline wxPoint2DDouble operator*(wxDouble n , const wxPoint2DDouble& pt);
inline wxPoint2DDouble operator*(wxInt32 n , const wxPoint2DDouble& pt);
inline wxPoint2DDouble operator*(const wxPoint2DDouble& pt , wxDouble n);
inline wxPoint2DDouble operator*(const wxPoint2DDouble& pt , wxInt32 n);
inline wxPoint2DDouble operator/(const wxPoint2DDouble& pt1 , const wxPoint2DDouble& pt2);
inline wxPoint2DDouble operator/(const wxPoint2DDouble& pt , wxDouble n);
inline wxPoint2DDouble operator/(const wxPoint2DDouble& pt , wxInt32 n);

inline wxPoint2DDouble::wxPoint2DDouble()
{
    m_x = 0.0;
    m_y = 0.0;
}

inline wxPoint2DDouble::wxPoint2DDouble( wxDouble x , wxDouble y )
{
    m_x = x;
    m_y = y;
}

inline wxPoint2DDouble::wxPoint2DDouble( const wxPoint2DDouble &pt )
{
    m_x = pt.m_x;
    m_y = pt.m_y;
}

inline void wxPoint2DDouble::GetFloor( wxInt32 *x , wxInt32 *y ) const
{
    *x = (wxInt32) floor( m_x );
    *y = (wxInt32) floor( m_y );
}

inline void wxPoint2DDouble::GetRounded( wxInt32 *x , wxInt32 *y ) const
{
    *x = (wxInt32) floor( m_x + 0.5 );
    *y = (wxInt32) floor( m_y + 0.5);
}

inline wxDouble wxPoint2DDouble::GetVectorLength() const
{
    return sqrt( (m_x)*(m_x) + (m_y)*(m_y) ) ;
}

inline void wxPoint2DDouble::SetVectorLength( wxDouble length )
{
    wxDouble before = GetVectorLength() ;
    m_x = (m_x * length / before) ;
    m_y = (m_y * length / before) ;
}

inline void wxPoint2DDouble::Normalize()
{
    SetVectorLength( 1 );
}

inline wxDouble wxPoint2DDouble::GetDistance( const wxPoint2DDouble &pt ) const
{
    return sqrt( GetDistanceSquare( pt ) );
}

inline wxDouble wxPoint2DDouble::GetDistanceSquare( const wxPoint2DDouble &pt ) const
{
    return ( (pt.m_x-m_x)*(pt.m_x-m_x) + (pt.m_y-m_y)*(pt.m_y-m_y) );
}

inline wxDouble wxPoint2DDouble::GetDotProduct( const wxPoint2DDouble &vec ) const
{
    return ( m_x * vec.m_x + m_y * vec.m_y );
}

inline wxDouble wxPoint2DDouble::GetCrossProduct( const wxPoint2DDouble &vec ) const
{
    return ( m_x * vec.m_y - vec.m_x * m_y );
}

inline wxPoint2DDouble wxPoint2DDouble::operator-()
{
    return wxPoint2DDouble( -m_x, -m_y);
}

inline wxPoint2DDouble& wxPoint2DDouble::operator=(const wxPoint2DDouble& pt)
{
    m_x = pt.m_x;
    m_y = pt.m_y;
    return *this;
}

inline wxPoint2DDouble& wxPoint2DDouble::operator+=(const wxPoint2DDouble& pt)
{
    m_x = m_x + pt.m_x;
    m_y = m_y + pt.m_y;
    return *this;
}

inline wxPoint2DDouble& wxPoint2DDouble::operator-=(const wxPoint2DDouble& pt)
{
    m_x = m_x - pt.m_x;
    m_y = m_y - pt.m_y;
    return *this;
}

inline wxPoint2DDouble& wxPoint2DDouble::operator*=(const wxPoint2DDouble& pt)
{
    m_x = m_x * pt.m_x;
    m_y = m_y * pt.m_y;
    return *this;
}

inline wxPoint2DDouble& wxPoint2DDouble::operator/=(const wxPoint2DDouble& pt)
{
    m_x = m_x / pt.m_x;
    m_y = m_y / pt.m_y;
    return *this;
}

inline bool wxPoint2DDouble::operator==(const wxPoint2DDouble& pt) const
{
    return wxIsSameDouble(m_x, pt.m_x) && wxIsSameDouble(m_y, pt.m_y);
}

inline bool wxPoint2DDouble::operator!=(const wxPoint2DDouble& pt) const
{
    return !(*this == pt);
}

inline wxPoint2DDouble operator+(const wxPoint2DDouble& pt1 , const wxPoint2DDouble& pt2)
{
    return wxPoint2DDouble( pt1.m_x + pt2.m_x , pt1.m_y + pt2.m_y );
}

inline wxPoint2DDouble operator-(const wxPoint2DDouble& pt1 , const wxPoint2DDouble& pt2)
{
    return wxPoint2DDouble( pt1.m_x - pt2.m_x , pt1.m_y - pt2.m_y );
}


inline wxPoint2DDouble operator*(const wxPoint2DDouble& pt1 , const wxPoint2DDouble& pt2)
{
    return wxPoint2DDouble( pt1.m_x * pt2.m_x , pt1.m_y * pt2.m_y );
}

inline wxPoint2DDouble operator*(wxDouble n , const wxPoint2DDouble& pt)
{
    return wxPoint2DDouble( pt.m_x * n , pt.m_y * n );
}

inline wxPoint2DDouble operator*(wxInt32 n , const wxPoint2DDouble& pt)
{
    return wxPoint2DDouble( pt.m_x * n , pt.m_y * n );
}

inline wxPoint2DDouble operator*(const wxPoint2DDouble& pt , wxDouble n)
{
    return wxPoint2DDouble( pt.m_x * n , pt.m_y * n );
}

inline wxPoint2DDouble operator*(const wxPoint2DDouble& pt , wxInt32 n)
{
    return wxPoint2DDouble( pt.m_x * n , pt.m_y * n );
}

inline wxPoint2DDouble operator/(const wxPoint2DDouble& pt1 , const wxPoint2DDouble& pt2)
{
    return wxPoint2DDouble( pt1.m_x / pt2.m_x , pt1.m_y / pt2.m_y );
}

inline wxPoint2DDouble operator/(const wxPoint2DDouble& pt , wxDouble n)
{
    return wxPoint2DDouble( pt.m_x / n , pt.m_y / n );
}

inline wxPoint2DDouble operator/(const wxPoint2DDouble& pt , wxInt32 n)
{
    return wxPoint2DDouble( pt.m_x / n , pt.m_y / n );
}





class wxRect2DDouble
{
public:
    wxRect2DDouble()
        { m_x = m_y = m_width = m_height = 0; }
    wxRect2DDouble(wxDouble x, wxDouble y, wxDouble w, wxDouble h)
        { m_x = x; m_y = y; m_width = w; m_height = h; }







    inline wxPoint2DDouble GetPosition()
        { return wxPoint2DDouble(m_x, m_y); }
    inline wxSize GetSize()
        { return wxSize((int) m_width, (int) m_height); }




    inline wxDouble GetLeft() const { return m_x; }
    inline void SetLeft( wxDouble n ) { m_width += m_x - n; m_x = n; }
    inline void MoveLeftTo( wxDouble n ) { m_x = n; }
    inline wxDouble GetTop() const { return m_y; }
    inline void SetTop( wxDouble n ) { m_height += m_y - n; m_y = n; }
    inline void MoveTopTo( wxDouble n ) { m_y = n; }
    inline wxDouble GetBottom() const { return m_y + m_height; }
    inline void SetBottom( wxDouble n ) { m_height += n - (m_y+m_height);}
    inline void MoveBottomTo( wxDouble n ) { m_y = n - m_height; }
    inline wxDouble GetRight() const { return m_x + m_width; }
    inline void SetRight( wxDouble n ) { m_width += n - (m_x+m_width) ; }
    inline void MoveRightTo( wxDouble n ) { m_x = n - m_width; }

    inline wxPoint2DDouble GetLeftTop() const
        { return wxPoint2DDouble( m_x , m_y ); }
    inline void SetLeftTop( const wxPoint2DDouble &pt )
        { m_width += m_x - pt.m_x; m_height += m_y - pt.m_y; m_x = pt.m_x; m_y = pt.m_y; }
    inline void MoveLeftTopTo( const wxPoint2DDouble &pt )
        { m_x = pt.m_x; m_y = pt.m_y; }
    inline wxPoint2DDouble GetLeftBottom() const
        { return wxPoint2DDouble( m_x , m_y + m_height ); }
    inline void SetLeftBottom( const wxPoint2DDouble &pt )
        { m_width += m_x - pt.m_x; m_height += pt.m_y - (m_y+m_height) ; m_x = pt.m_x; }
    inline void MoveLeftBottomTo( const wxPoint2DDouble &pt )
        { m_x = pt.m_x; m_y = pt.m_y - m_height; }
    inline wxPoint2DDouble GetRightTop() const
        { return wxPoint2DDouble( m_x+m_width , m_y ); }
    inline void SetRightTop( const wxPoint2DDouble &pt )
        { m_width += pt.m_x - ( m_x + m_width ); m_height += m_y - pt.m_y; m_y = pt.m_y; }
    inline void MoveRightTopTo( const wxPoint2DDouble &pt )
        { m_x = pt.m_x - m_width; m_y = pt.m_y; }
    inline wxPoint2DDouble GetRightBottom() const
        { return wxPoint2DDouble( m_x+m_width , m_y + m_height ); }
    inline void SetRightBottom( const wxPoint2DDouble &pt )
        { m_width += pt.m_x - ( m_x + m_width ); m_height += pt.m_y - (m_y+m_height);}
    inline void MoveRightBottomTo( const wxPoint2DDouble &pt )
        { m_x = pt.m_x - m_width; m_y = pt.m_y - m_height; }
    inline wxPoint2DDouble GetCentre() const
        { return wxPoint2DDouble( m_x+m_width/2 , m_y+m_height/2 ); }
    inline void SetCentre( const wxPoint2DDouble &pt )
        { MoveCentreTo( pt ); }
    inline void MoveCentreTo( const wxPoint2DDouble &pt )
        { m_x += pt.m_x - (m_x+m_width/2) , m_y += pt.m_y -(m_y+m_height/2); }
    inline wxOutCode GetOutCode( const wxPoint2DDouble &pt ) const
        { return (wxOutCode) (( ( pt.m_x < m_x ) ? wxOutLeft : 0 ) +
                     ( ( pt.m_x > m_x + m_width ) ? wxOutRight : 0 ) +
                     ( ( pt.m_y < m_y ) ? wxOutTop : 0 ) +
                     ( ( pt.m_y > m_y + m_height ) ? wxOutBottom : 0 )); }
    inline wxOutCode GetOutcode(const wxPoint2DDouble &pt) const
        { return GetOutCode(pt) ; }
    inline bool Contains( const wxPoint2DDouble &pt ) const
        { return GetOutCode( pt ) == wxInside; }
    inline bool Contains( const wxRect2DDouble &rect ) const
        { return ( ( ( m_x <= rect.m_x ) && ( rect.m_x + rect.m_width <= m_x + m_width ) ) &&
                ( ( m_y <= rect.m_y ) && ( rect.m_y + rect.m_height <= m_y + m_height ) ) ); }
    inline bool IsEmpty() const
        { return m_width <= 0 || m_height <= 0; }
    inline bool HaveEqualSize( const wxRect2DDouble &rect ) const
        { return wxIsSameDouble(rect.m_width, m_width) && wxIsSameDouble(rect.m_height, m_height); }

    inline void Inset( wxDouble x , wxDouble y )
        { m_x += x; m_y += y; m_width -= 2 * x; m_height -= 2 * y; }
    inline void Inset( wxDouble left , wxDouble top ,wxDouble right , wxDouble bottom )
        { m_x += left; m_y += top; m_width -= left + right; m_height -= top + bottom;}
    inline void Offset( const wxPoint2DDouble &pt )
        { m_x += pt.m_x; m_y += pt.m_y; }

    void ConstrainTo( const wxRect2DDouble &rect );

    inline wxPoint2DDouble Interpolate( wxInt32 widthfactor , wxInt32 heightfactor )
        { return wxPoint2DDouble( m_x + m_width * widthfactor , m_y + m_height * heightfactor ); }

    static void Intersect( const wxRect2DDouble &src1 , const wxRect2DDouble &src2 , wxRect2DDouble *dest );
    inline void Intersect( const wxRect2DDouble &otherRect )
        { Intersect( *this , otherRect , this ); }
    inline wxRect2DDouble CreateIntersection( const wxRect2DDouble &otherRect ) const
        { wxRect2DDouble result; Intersect( *this , otherRect , &result); return result; }
    bool Intersects( const wxRect2DDouble &rect ) const;

    static void Union( const wxRect2DDouble &src1 , const wxRect2DDouble &src2 , wxRect2DDouble *dest );
    void Union( const wxRect2DDouble &otherRect )
        { Union( *this , otherRect , this ); }
    void Union( const wxPoint2DDouble &pt );
    inline wxRect2DDouble CreateUnion( const wxRect2DDouble &otherRect ) const
        { wxRect2DDouble result; Union( *this , otherRect , &result); return result; }

    inline void Scale( wxDouble f )
        { m_x *= f; m_y *= f; m_width *= f; m_height *= f;}
    inline void Scale( wxInt32 num , wxInt32 denum )
        { m_x *= ((wxDouble)num)/((wxDouble)denum); m_y *= ((wxDouble)num)/((wxDouble)denum);
                m_width *= ((wxDouble)num)/((wxDouble)denum); m_height *= ((wxDouble)num)/((wxDouble)denum);}

    wxRect2DDouble& operator = (const wxRect2DDouble& rect);
    inline bool operator == (const wxRect2DDouble& rect) const
        { return wxIsSameDouble(m_x, rect.m_x) && wxIsSameDouble(m_y, rect.m_y) && HaveEqualSize(rect); }
    inline bool operator != (const wxRect2DDouble& rect) const
        { return !(*this == rect); }

    wxDouble m_x;
    wxDouble m_y;
    wxDouble m_width;
    wxDouble m_height;
};






class wxRect2DInt
{
public:
       wxRect2DInt() { m_x = m_y = m_width = m_height = 0; }
       wxRect2DInt( const wxRect& r ) { m_x = r.x ; m_y = r.y ; m_width = r.width ; m_height = r.height ; }
       wxRect2DInt(wxInt32 x, wxInt32 y, wxInt32 w, wxInt32 h) { m_x = x; m_y = y; m_width = w; m_height = h; }
       wxRect2DInt(const wxPoint2DInt& topLeft, const wxPoint2DInt& bottomRight);
       inline wxRect2DInt(const wxPoint2DInt& pos, const wxSize& size);
       inline wxRect2DInt(const wxRect2DInt& rect);



      inline wxPoint2DInt GetPosition() { return wxPoint2DInt(m_x, m_y); }
       inline wxSize GetSize() { return wxSize(m_width, m_height); }




      inline wxInt32 GetLeft() const { return m_x; }
       inline void SetLeft( wxInt32 n ) { m_width += m_x - n; m_x = n; }
       inline void MoveLeftTo( wxInt32 n ) { m_x = n; }
       inline wxInt32 GetTop() const { return m_y; }
       inline void SetTop( wxInt32 n ) { m_height += m_y - n; m_y = n; }
       inline void MoveTopTo( wxInt32 n ) { m_y = n; }
       inline wxInt32 GetBottom() const { return m_y + m_height; }
       inline void SetBottom( wxInt32 n ) { m_height += n - (m_y+m_height);}
       inline void MoveBottomTo( wxInt32 n ) { m_y = n - m_height; }
       inline wxInt32 GetRight() const { return m_x + m_width; }
       inline void SetRight( wxInt32 n ) { m_width += n - (m_x+m_width) ; }
       inline void MoveRightTo( wxInt32 n ) { m_x = n - m_width; }

        inline wxPoint2DInt GetLeftTop() const { return wxPoint2DInt( m_x , m_y ); }
        inline void SetLeftTop( const wxPoint2DInt &pt ) { m_width += m_x - pt.m_x; m_height += m_y - pt.m_y; m_x = pt.m_x; m_y = pt.m_y; }
        inline void MoveLeftTopTo( const wxPoint2DInt &pt ) { m_x = pt.m_x; m_y = pt.m_y; }
        inline wxPoint2DInt GetLeftBottom() const { return wxPoint2DInt( m_x , m_y + m_height ); }
        inline void SetLeftBottom( const wxPoint2DInt &pt ) { m_width += m_x - pt.m_x; m_height += pt.m_y - (m_y+m_height) ; m_x = pt.m_x; }
        inline void MoveLeftBottomTo( const wxPoint2DInt &pt ) { m_x = pt.m_x; m_y = pt.m_y - m_height; }
        inline wxPoint2DInt GetRightTop() const { return wxPoint2DInt( m_x+m_width , m_y ); }
        inline void SetRightTop( const wxPoint2DInt &pt ) { m_width += pt.m_x - ( m_x + m_width ); m_height += m_y - pt.m_y; m_y = pt.m_y; }
        inline void MoveRightTopTo( const wxPoint2DInt &pt ) { m_x = pt.m_x - m_width; m_y = pt.m_y; }
        inline wxPoint2DInt GetRightBottom() const { return wxPoint2DInt( m_x+m_width , m_y + m_height ); }
        inline void SetRightBottom( const wxPoint2DInt &pt ) { m_width += pt.m_x - ( m_x + m_width ); m_height += pt.m_y - (m_y+m_height);}
        inline void MoveRightBottomTo( const wxPoint2DInt &pt ) { m_x = pt.m_x - m_width; m_y = pt.m_y - m_height; }
        inline wxPoint2DInt GetCentre() const { return wxPoint2DInt( m_x+m_width/2 , m_y+m_height/2 ); }
        inline void SetCentre( const wxPoint2DInt &pt ) { MoveCentreTo( pt ); }
        inline void MoveCentreTo( const wxPoint2DInt &pt ) { m_x += pt.m_x - (m_x+m_width/2) , m_y += pt.m_y -(m_y+m_height/2); }
        inline wxOutCode GetOutCode( const wxPoint2DInt &pt ) const
            { return (wxOutCode) (( ( pt.m_x < m_x ) ? wxOutLeft : 0 ) +
                     ( ( pt.m_x >= m_x + m_width ) ? wxOutRight : 0 ) +
                     ( ( pt.m_y < m_y ) ? wxOutTop : 0 ) +
                     ( ( pt.m_y >= m_y + m_height ) ? wxOutBottom : 0 )); }
        inline wxOutCode GetOutcode( const wxPoint2DInt &pt ) const
            { return GetOutCode( pt ) ; }
        inline bool Contains( const wxPoint2DInt &pt ) const
            { return GetOutCode( pt ) == wxInside; }
        inline bool Contains( const wxRect2DInt &rect ) const
            { return ( ( ( m_x <= rect.m_x ) && ( rect.m_x + rect.m_width <= m_x + m_width ) ) &&
                ( ( m_y <= rect.m_y ) && ( rect.m_y + rect.m_height <= m_y + m_height ) ) ); }
        inline bool IsEmpty() const
            { return ( m_width <= 0 || m_height <= 0 ); }
        inline bool HaveEqualSize( const wxRect2DInt &rect ) const
            { return ( rect.m_width == m_width && rect.m_height == m_height ); }

        inline void Inset( wxInt32 x , wxInt32 y ) { m_x += x; m_y += y; m_width -= 2 * x; m_height -= 2 * y; }
        inline void Inset( wxInt32 left , wxInt32 top ,wxInt32 right , wxInt32 bottom )
            { m_x += left; m_y += top; m_width -= left + right; m_height -= top + bottom;}
        inline void Offset( const wxPoint2DInt &pt ) { m_x += pt.m_x; m_y += pt.m_y; }
        void ConstrainTo( const wxRect2DInt &rect );
        inline wxPoint2DInt Interpolate( wxInt32 widthfactor , wxInt32 heightfactor ) { return wxPoint2DInt( m_x + m_width * widthfactor , m_y + m_height * heightfactor ); }

        static void Intersect( const wxRect2DInt &src1 , const wxRect2DInt &src2 , wxRect2DInt *dest );
        inline void Intersect( const wxRect2DInt &otherRect ) { Intersect( *this , otherRect , this ); }
        inline wxRect2DInt CreateIntersection( const wxRect2DInt &otherRect ) const { wxRect2DInt result; Intersect( *this , otherRect , &result); return result; }
        bool Intersects( const wxRect2DInt &rect ) const;

        static void Union( const wxRect2DInt &src1 , const wxRect2DInt &src2 , wxRect2DInt *dest );
        void Union( const wxRect2DInt &otherRect ) { Union( *this , otherRect , this ); }
        void Union( const wxPoint2DInt &pt );
        inline wxRect2DInt CreateUnion( const wxRect2DInt &otherRect ) const { wxRect2DInt result; Union( *this , otherRect , &result); return result; }

        inline void Scale( wxInt32 f ) { m_x *= f; m_y *= f; m_width *= f; m_height *= f;}
        inline void Scale( wxInt32 num , wxInt32 denum )
            { m_x *= ((wxInt32)num)/((wxInt32)denum); m_y *= ((wxInt32)num)/((wxInt32)denum);
                m_width *= ((wxInt32)num)/((wxInt32)denum); m_height *= ((wxInt32)num)/((wxInt32)denum);}

       wxRect2DInt& operator = (const wxRect2DInt& rect);
       bool operator == (const wxRect2DInt& rect) const;
       bool operator != (const wxRect2DInt& rect) const;


       void WriteTo( wxDataOutputStream &stream ) const;
       void ReadFrom( wxDataInputStream &stream );


       wxInt32 m_x;
       wxInt32 m_y;
       wxInt32 m_width;
       wxInt32 m_height;
};

inline wxRect2DInt::wxRect2DInt( const wxRect2DInt &r )
{
    m_x = r.m_x;
    m_y = r.m_y;
    m_width = r.m_width;
    m_height = r.m_height;
}

inline wxRect2DInt::wxRect2DInt( const wxPoint2DInt &a , const wxPoint2DInt &b)
{
    m_x = (((a.m_x) < (b.m_x)) ? (a.m_x) : (b.m_x));
    m_y = (((a.m_y) < (b.m_y)) ? (a.m_y) : (b.m_y));
    m_width = abs( a.m_x - b.m_x );
    m_height = abs( a.m_y - b.m_y );
}

inline wxRect2DInt::wxRect2DInt( const wxPoint2DInt& pos, const wxSize& size)
{
    m_x = pos.m_x;
    m_y = pos.m_y;
    m_width = size.x;
    m_height = size.y;
}

inline bool wxRect2DInt::operator == (const wxRect2DInt& rect) const
{
    return (m_x==rect.m_x && m_y==rect.m_y &&
            m_width==rect.m_width && m_height==rect.m_height);
}

inline bool wxRect2DInt::operator != (const wxRect2DInt& rect) const
{
    return !(*this == rect);
}

class wxTransform2D
{
public :
    virtual ~wxTransform2D() { }
    virtual void Transform( wxPoint2DInt* pt )const = 0;
    virtual void Transform( wxRect2DInt* r ) const;
    virtual wxPoint2DInt Transform( const wxPoint2DInt &pt ) const;
    virtual wxRect2DInt Transform( const wxRect2DInt &r ) const ;

    virtual void InverseTransform( wxPoint2DInt* pt ) const = 0;
    virtual void InverseTransform( wxRect2DInt* r ) const ;
    virtual wxPoint2DInt InverseTransform( const wxPoint2DInt &pt ) const ;
    virtual wxRect2DInt InverseTransform( const wxRect2DInt &r ) const ;
};

inline void wxTransform2D::Transform( wxRect2DInt* r ) const
    { wxPoint2DInt a = r->GetLeftTop() , b = r->GetRightBottom(); Transform( &a ); Transform( &b ); *r = wxRect2DInt( a , b ); }

inline wxPoint2DInt wxTransform2D::Transform( const wxPoint2DInt &pt ) const
    { wxPoint2DInt res = pt; Transform( &res ); return res; }

inline wxRect2DInt wxTransform2D::Transform( const wxRect2DInt &r ) const
    { wxRect2DInt res = r; Transform( &res ); return res; }

inline void wxTransform2D::InverseTransform( wxRect2DInt* r ) const
    { wxPoint2DInt a = r->GetLeftTop() , b = r->GetRightBottom(); InverseTransform( &a ); InverseTransform( &b ); *r = wxRect2DInt( a , b ); }

inline wxPoint2DInt wxTransform2D::InverseTransform( const wxPoint2DInt &pt ) const
    { wxPoint2DInt res = pt; InverseTransform( &res ); return res; }

inline wxRect2DInt wxTransform2D::InverseTransform( const wxRect2DInt &r ) const
    { wxRect2DInt res = r; InverseTransform( &res ); return res; }
# 18 "/usr/include/wx-2.8/wx/dcgraph.h" 2

# 1 "/usr/include/wx-2.8/wx/graphics.h" 1
# 22 "/usr/include/wx-2.8/wx/graphics.h"
class wxWindowDC;
class wxMemoryDC;
class wxGraphicsContext;
class wxGraphicsPath;
class wxGraphicsMatrix;
class wxGraphicsFigure;
class wxGraphicsRenderer;
class wxGraphicsPen;
class wxGraphicsBrush;
class wxGraphicsFont;
class wxGraphicsBitmap;
# 51 "/usr/include/wx-2.8/wx/graphics.h"
class wxGraphicsObjectRefData : public wxObjectRefData
{
public :
    wxGraphicsObjectRefData( wxGraphicsRenderer* renderer );
    wxGraphicsObjectRefData( const wxGraphicsObjectRefData* data );
    wxGraphicsRenderer* GetRenderer() const ;
    virtual wxGraphicsObjectRefData* Clone() const ;

protected :
    wxGraphicsRenderer* m_renderer;
} ;

class wxGraphicsObject : public wxObject
{
public :
    wxGraphicsObject() ;

    wxGraphicsObject( const wxGraphicsObject& other) : wxObject( other ) {}
    wxGraphicsObject& operator= (const wxGraphicsObject & other) { Ref(other); return *this;}

    wxGraphicsObject( wxGraphicsRenderer* renderer ) ;
    virtual ~wxGraphicsObject() ;

    bool IsNull() const ;


    wxGraphicsRenderer* GetRenderer() const ;
    wxGraphicsObjectRefData* GetGraphicsData() const ;
protected :
    virtual wxObjectRefData* CreateRefData() const;
    virtual wxObjectRefData* CloneRefData(const wxObjectRefData* data) const;

    public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
} ;

class wxGraphicsPen : public wxGraphicsObject
{
public :
    wxGraphicsPen() {}

    wxGraphicsPen( const wxGraphicsPen& other) : wxGraphicsObject( other ) {}
    wxGraphicsPen& operator= (const wxGraphicsPen & other) { Ref(other); return *this;}

    virtual ~wxGraphicsPen() {}
private :
    public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
} ;

extern wxGraphicsPen wxNullGraphicsPen;

class wxGraphicsBrush : public wxGraphicsObject
{
public :
    wxGraphicsBrush() {}

    wxGraphicsBrush( const wxGraphicsBrush& other) : wxGraphicsObject( other ) {}
    wxGraphicsBrush& operator= (const wxGraphicsBrush & other) { Ref(other); return *this;}

    virtual ~wxGraphicsBrush() {}
private :
    public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
} ;

extern wxGraphicsBrush wxNullGraphicsBrush;

class wxGraphicsFont : public wxGraphicsObject
{
public :
    wxGraphicsFont() {}

    wxGraphicsFont( const wxGraphicsFont& other) : wxGraphicsObject( other ) {}
    wxGraphicsFont& operator= (const wxGraphicsFont & other) { Ref(other); return *this;}

    virtual ~wxGraphicsFont() {}
private :
    public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
} ;

extern wxGraphicsFont wxNullGraphicsFont;

class wxGraphicsBitmap : public wxGraphicsObject
{
public :
    wxGraphicsBitmap() {}

    wxGraphicsBitmap( const wxGraphicsBitmap& other) : wxGraphicsObject( other ) {}
    wxGraphicsBitmap& operator= (const wxGraphicsBitmap & other) { Ref(other); return *this;}

    virtual ~wxGraphicsBitmap() {}
private :
    public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
} ;

extern wxGraphicsBitmap wxNullGraphicsBitmap;

class wxGraphicsMatrixData : public wxGraphicsObjectRefData
{
public :
    wxGraphicsMatrixData( wxGraphicsRenderer* renderer) :
       wxGraphicsObjectRefData(renderer) {}

       virtual ~wxGraphicsMatrixData() {}


       virtual void Concat( const wxGraphicsMatrixData *t ) = 0;


       virtual void Set(wxDouble a=1.0, wxDouble b=0.0, wxDouble c=0.0, wxDouble d=1.0,
           wxDouble tx=0.0, wxDouble ty=0.0) = 0;


       virtual void Get(wxDouble* a=__null, wxDouble* b=__null, wxDouble* c=__null,
                        wxDouble* d=__null, wxDouble* tx=__null, wxDouble* ty=__null) const = 0;


       virtual void Invert() = 0;


       virtual bool IsEqual( const wxGraphicsMatrixData* t) const = 0;


       virtual bool IsIdentity() const = 0;






       virtual void Translate( wxDouble dx , wxDouble dy ) = 0;


       virtual void Scale( wxDouble xScale , wxDouble yScale ) = 0;


       virtual void Rotate( wxDouble angle ) = 0;






       virtual void TransformPoint( wxDouble *x, wxDouble *y ) const = 0;


       virtual void TransformDistance( wxDouble *dx, wxDouble *dy ) const =0;


       virtual void * GetNativeMatrix() const = 0;
} ;

class wxGraphicsMatrix : public wxGraphicsObject
{
public :
    wxGraphicsMatrix() {}

    wxGraphicsMatrix( const wxGraphicsMatrix& other) : wxGraphicsObject( other ) {}
    wxGraphicsMatrix& operator= (const wxGraphicsMatrix & other) { Ref(other); return *this;}


    virtual ~wxGraphicsMatrix() {}


    virtual void Concat( const wxGraphicsMatrix *t );
    void Concat( const wxGraphicsMatrix &t ) { Concat( &t ); }


    virtual void Set(wxDouble a=1.0, wxDouble b=0.0, wxDouble c=0.0, wxDouble d=1.0,
        wxDouble tx=0.0, wxDouble ty=0.0);


    virtual void Get(wxDouble* a=__null, wxDouble* b=__null, wxDouble* c=__null,
                     wxDouble* d=__null, wxDouble* tx=__null, wxDouble* ty=__null) const;


    virtual void Invert();


    virtual bool IsEqual( const wxGraphicsMatrix* t) const;
    bool IsEqual( const wxGraphicsMatrix& t) const { return IsEqual( &t ); }


    virtual bool IsIdentity() const;






    virtual void Translate( wxDouble dx , wxDouble dy );


    virtual void Scale( wxDouble xScale , wxDouble yScale );


    virtual void Rotate( wxDouble angle );






    virtual void TransformPoint( wxDouble *x, wxDouble *y ) const;


    virtual void TransformDistance( wxDouble *dx, wxDouble *dy ) const;


    virtual void * GetNativeMatrix() const;

    const wxGraphicsMatrixData* GetMatrixData() const
    { return (const wxGraphicsMatrixData*) GetRefData(); }
    wxGraphicsMatrixData* GetMatrixData()
    { return (wxGraphicsMatrixData*) GetRefData(); }

private :
    public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
} ;

extern wxGraphicsMatrix wxNullGraphicsMatrix;

class wxGraphicsPathData : public wxGraphicsObjectRefData
{
public :
    wxGraphicsPathData(wxGraphicsRenderer* renderer) : wxGraphicsObjectRefData(renderer) {}
    virtual ~wxGraphicsPathData() {}






    virtual void MoveToPoint( wxDouble x, wxDouble y ) = 0;


    virtual void AddLineToPoint( wxDouble x, wxDouble y ) = 0;


    virtual void AddCurveToPoint( wxDouble cx1, wxDouble cy1, wxDouble cx2, wxDouble cy2, wxDouble x, wxDouble y ) = 0;


    virtual void AddPath( const wxGraphicsPathData* path ) =0;


    virtual void CloseSubpath() = 0;


    virtual void GetCurrentPoint( wxDouble* x, wxDouble* y) const = 0;


    virtual void AddArc( wxDouble x, wxDouble y, wxDouble r, wxDouble startAngle, wxDouble endAngle, bool clockwise ) = 0;







    virtual void AddQuadCurveToPoint( wxDouble cx, wxDouble cy, wxDouble x, wxDouble y );


    virtual void AddRectangle( wxDouble x, wxDouble y, wxDouble w, wxDouble h );


    virtual void AddCircle( wxDouble x, wxDouble y, wxDouble r );


    virtual void AddArcToPoint( wxDouble x1, wxDouble y1 , wxDouble x2, wxDouble y2, wxDouble r ) ;


    virtual void AddEllipse( wxDouble x, wxDouble y, wxDouble w, wxDouble h);


    virtual void AddRoundedRectangle( wxDouble x, wxDouble y, wxDouble w, wxDouble h, wxDouble radius);


    virtual void * GetNativePath() const = 0;


    virtual void UnGetNativePath(void *p) const= 0;


    virtual void Transform( const wxGraphicsMatrixData* matrix ) =0;


    virtual void GetBox(wxDouble *x, wxDouble *y, wxDouble *w, wxDouble *h) const=0;

    virtual bool Contains( wxDouble x, wxDouble y, int fillStyle = wxODDEVEN_RULE) const=0;
};

class wxGraphicsPath : public wxGraphicsObject
{
public :
    wxGraphicsPath() {}

    wxGraphicsPath( const wxGraphicsPath& other) : wxGraphicsObject( other ) {}
    wxGraphicsPath& operator= (const wxGraphicsPath & other) { Ref(other); return *this;}

    virtual ~wxGraphicsPath() {}






    virtual void MoveToPoint( wxDouble x, wxDouble y );
    void MoveToPoint( const wxPoint2DDouble& p);


    virtual void AddLineToPoint( wxDouble x, wxDouble y );
    void AddLineToPoint( const wxPoint2DDouble& p);


    virtual void AddCurveToPoint( wxDouble cx1, wxDouble cy1, wxDouble cx2, wxDouble cy2, wxDouble x, wxDouble y ) ;
    void AddCurveToPoint( const wxPoint2DDouble& c1, const wxPoint2DDouble& c2, const wxPoint2DDouble& e);


    virtual void AddPath( const wxGraphicsPath& path );


    virtual void CloseSubpath() ;


    virtual void GetCurrentPoint( wxDouble* x, wxDouble* y) const;
    wxPoint2DDouble GetCurrentPoint() const;


    virtual void AddArc( wxDouble x, wxDouble y, wxDouble r, wxDouble startAngle, wxDouble endAngle, bool clockwise ) ;
    void AddArc( const wxPoint2DDouble& c, wxDouble r, wxDouble startAngle, wxDouble endAngle, bool clockwise);







    virtual void AddQuadCurveToPoint( wxDouble cx, wxDouble cy, wxDouble x, wxDouble y );


    virtual void AddRectangle( wxDouble x, wxDouble y, wxDouble w, wxDouble h );


    virtual void AddCircle( wxDouble x, wxDouble y, wxDouble r );


    virtual void AddArcToPoint( wxDouble x1, wxDouble y1 , wxDouble x2, wxDouble y2, wxDouble r ) ;


    virtual void AddEllipse( wxDouble x, wxDouble y, wxDouble w, wxDouble h);


    virtual void AddRoundedRectangle( wxDouble x, wxDouble y, wxDouble w, wxDouble h, wxDouble radius);


    virtual void * GetNativePath() const;


    virtual void UnGetNativePath(void *p)const;


    virtual void Transform( const wxGraphicsMatrix& matrix );


    virtual void GetBox(wxDouble *x, wxDouble *y, wxDouble *w, wxDouble *h)const;
    wxRect2DDouble GetBox()const;

    virtual bool Contains( wxDouble x, wxDouble y, int fillStyle = wxODDEVEN_RULE)const;
    bool Contains( const wxPoint2DDouble& c, int fillStyle = wxODDEVEN_RULE)const;

    const wxGraphicsPathData* GetPathData() const
    { return (const wxGraphicsPathData*) GetRefData(); }
    wxGraphicsPathData* GetPathData()
    { return (wxGraphicsPathData*) GetRefData(); }

private :
    public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
} ;

extern wxGraphicsPath wxNullGraphicsPath;


class wxGraphicsContext : public wxGraphicsObject
{
public:
    wxGraphicsContext(wxGraphicsRenderer* renderer);

    virtual ~wxGraphicsContext();

    static wxGraphicsContext* Create( const wxWindowDC& dc) ;





    static wxGraphicsContext* CreateFromNative( void * context ) ;

    static wxGraphicsContext* CreateFromNativeWindow( void * window ) ;

    static wxGraphicsContext* Create( wxWindow* window ) ;


    static wxGraphicsContext * Create();

    wxGraphicsPath CreatePath() const;

    virtual wxGraphicsPen CreatePen(const wxPen& pen) const;

    virtual wxGraphicsBrush CreateBrush(const wxBrush& brush ) const;


    virtual wxGraphicsBrush CreateLinearGradientBrush( wxDouble x1, wxDouble y1, wxDouble x2, wxDouble y2,
        const wxColour&c1, const wxColour&c2) const;



    virtual wxGraphicsBrush CreateRadialGradientBrush( wxDouble xo, wxDouble yo, wxDouble xc, wxDouble yc, wxDouble radius,
        const wxColour &oColor, const wxColour &cColor) const;


    virtual wxGraphicsFont CreateFont( const wxFont &font , const wxColour &col = *wxStockGDI::GetColour(wxStockGDI::COLOUR_BLACK) ) const;


    wxGraphicsBitmap CreateBitmap( const wxBitmap &bitmap ) const;





    virtual wxGraphicsMatrix CreateMatrix( wxDouble a=1.0, wxDouble b=0.0, wxDouble c=0.0, wxDouble d=1.0,
        wxDouble tx=0.0, wxDouble ty=0.0) const;


    virtual void PushState() = 0;


    virtual void PopState() = 0;


    virtual void Clip( const wxRegion &region ) = 0;


    virtual void Clip( wxDouble x, wxDouble y, wxDouble w, wxDouble h ) = 0;


    virtual void ResetClip() = 0 ;


    virtual void * GetNativeContext() = 0;


    virtual int GetLogicalFunction() const { return m_logicalFunction; }


    virtual bool SetLogicalFunction(int function) ;






    virtual void Translate( wxDouble dx , wxDouble dy ) = 0;


    virtual void Scale( wxDouble xScale , wxDouble yScale ) = 0;


    virtual void Rotate( wxDouble angle ) = 0;


    virtual void ConcatTransform( const wxGraphicsMatrix& matrix ) = 0;


    virtual void SetTransform( const wxGraphicsMatrix& matrix ) = 0;


    virtual wxGraphicsMatrix GetTransform() const = 0;





    virtual void SetPen( const wxGraphicsPen& pen );

    void SetPen( const wxPen& pen );


    virtual void SetBrush( const wxGraphicsBrush& brush );

    void SetBrush( const wxBrush& brush );


    virtual void SetFont( const wxGraphicsFont& font );

    void SetFont( const wxFont& font, const wxColour& colour );



    virtual void StrokePath( const wxGraphicsPath& path ) = 0;


    virtual void FillPath( const wxGraphicsPath& path, int fillStyle = wxODDEVEN_RULE ) = 0;


    virtual void DrawPath( const wxGraphicsPath& path, int fillStyle = wxODDEVEN_RULE );





    virtual void DrawText( const wxString &str, wxDouble x, wxDouble y ) = 0;

    virtual void DrawText( const wxString &str, wxDouble x, wxDouble y, wxDouble angle );

    virtual void DrawText( const wxString &str, wxDouble x, wxDouble y, const wxGraphicsBrush& backgroundBrush ) ;

    virtual void DrawText( const wxString &str, wxDouble x, wxDouble y, wxDouble angle, const wxGraphicsBrush& backgroundBrush );

    virtual void GetTextExtent( const wxString &text, wxDouble *width, wxDouble *height,
        wxDouble *descent, wxDouble *externalLeading ) const = 0;

    virtual void GetPartialTextExtents(const wxString& text, wxArrayDouble& widths) const = 0;





    void DrawGraphicsBitmap( const wxGraphicsBitmap &bmp, wxDouble x, wxDouble y, wxDouble w, wxDouble h );


    virtual void DrawBitmap( const wxBitmap &bmp, wxDouble x, wxDouble y, wxDouble w, wxDouble h ) = 0;

    virtual void DrawIcon( const wxIcon &icon, wxDouble x, wxDouble y, wxDouble w, wxDouble h ) = 0;






    virtual void StrokeLine( wxDouble x1, wxDouble y1, wxDouble x2, wxDouble y2);


    virtual void StrokeLines( size_t n, const wxPoint2DDouble *points);


    virtual void StrokeLines( size_t n, const wxPoint2DDouble *beginPoints, const wxPoint2DDouble *endPoints);


    virtual void DrawLines( size_t n, const wxPoint2DDouble *points, int fillStyle = wxODDEVEN_RULE );


    virtual void DrawRectangle( wxDouble x, wxDouble y, wxDouble w, wxDouble h);


    virtual void DrawEllipse( wxDouble x, wxDouble y, wxDouble w, wxDouble h);


    virtual void DrawRoundedRectangle( wxDouble x, wxDouble y, wxDouble w, wxDouble h, wxDouble radius);




    virtual bool ShouldOffset() const { return false; }

protected :

    wxGraphicsPen m_pen;
    wxGraphicsBrush m_brush;
    wxGraphicsFont m_font;
    int m_logicalFunction;

private :
    private: wxGraphicsContext(const wxGraphicsContext&); wxGraphicsContext& operator=(const wxGraphicsContext&);
    public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const;
};
# 670 "/usr/include/wx-2.8/wx/graphics.h"
class wxGraphicsRenderer : public wxObject
{
public :
    wxGraphicsRenderer() {}

    virtual ~wxGraphicsRenderer() {}

    static wxGraphicsRenderer* GetDefaultRenderer();


    static wxGraphicsRenderer* GetCairoRenderer();



    virtual wxGraphicsContext * CreateContext( const wxWindowDC& dc) = 0 ;



    virtual wxGraphicsContext * CreateContextFromNativeContext( void * context ) = 0;

    virtual wxGraphicsContext * CreateContextFromNativeWindow( void * window ) = 0;

    virtual wxGraphicsContext * CreateContext( wxWindow* window ) = 0;


    virtual wxGraphicsContext * CreateMeasuringContext() = 0;



    virtual wxGraphicsPath CreatePath() = 0;



    virtual wxGraphicsMatrix CreateMatrix( wxDouble a=1.0, wxDouble b=0.0, wxDouble c=0.0, wxDouble d=1.0,
        wxDouble tx=0.0, wxDouble ty=0.0) = 0;



    virtual wxGraphicsPen CreatePen(const wxPen& pen) = 0 ;

    virtual wxGraphicsBrush CreateBrush(const wxBrush& brush ) = 0 ;


    virtual wxGraphicsBrush CreateLinearGradientBrush( wxDouble x1, wxDouble y1, wxDouble x2, wxDouble y2,
        const wxColour&c1, const wxColour&c2) = 0;



    virtual wxGraphicsBrush CreateRadialGradientBrush( wxDouble xo, wxDouble yo, wxDouble xc, wxDouble yc, wxDouble radius,
        const wxColour &oColor, const wxColour &cColor) = 0;


    virtual wxGraphicsFont CreateFont( const wxFont &font , const wxColour &col = *wxStockGDI::GetColour(wxStockGDI::COLOUR_BLACK) ) = 0;


    wxGraphicsBitmap CreateBitmap( const wxBitmap &bmp );


private :
    private: wxGraphicsRenderer(const wxGraphicsRenderer&); wxGraphicsRenderer& operator=(const wxGraphicsRenderer&);
    public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const;
} ;
# 20 "/usr/include/wx-2.8/wx/dcgraph.h" 2

class wxWindowDC;





class wxGCDC:



    public wxDC

{
    public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
    private: wxGCDC(const wxGCDC&); wxGCDC& operator=(const wxGCDC&);

public:
    wxGCDC(const wxWindowDC& dc);



    wxGCDC();
    virtual ~wxGCDC();

    void Init();





    virtual void Clear();

    virtual bool StartDoc( const wxString& message );
    virtual void EndDoc();

    virtual void StartPage();
    virtual void EndPage();



    void Flush();

    virtual void SetFont(const wxFont& font);
    virtual void SetPen(const wxPen& pen);
    virtual void SetBrush(const wxBrush& brush);
    virtual void SetBackground(const wxBrush& brush);
    virtual void SetBackgroundMode(int mode);
    virtual void SetPalette(const wxPalette& palette);

    virtual void DestroyClippingRegion();

    virtual wxCoord GetCharHeight() const;
    virtual wxCoord GetCharWidth() const;

    virtual bool CanDrawBitmap() const;
    virtual bool CanGetTextExtent() const;
    virtual int GetDepth() const;
    virtual wxSize GetPPI() const;

    virtual void SetMapMode(int mode);
    virtual void SetUserScale(double x, double y);

    virtual void SetLogicalScale(double x, double y);
    virtual void SetLogicalOrigin(wxCoord x, wxCoord y);
    virtual void SetDeviceOrigin(wxCoord x, wxCoord y);
    virtual void SetAxisOrientation(bool xLeftRight, bool yBottomUp);
    virtual void SetLogicalFunction(int function);

    virtual void SetTextForeground(const wxColour& colour);
    virtual void SetTextBackground(const wxColour& colour);

    virtual void ComputeScaleAndOrigin();

    wxGraphicsContext* GetGraphicsContext() { return m_graphicContext; }
    virtual void SetGraphicsContext( wxGraphicsContext* ctx );

protected:

    virtual bool DoFloodFill(wxCoord x, wxCoord y, const wxColour& col,
        int style = wxFLOOD_SURFACE);

    virtual void DoGradientFillLinear(const wxRect& rect,
        const wxColour& initialColour,
        const wxColour& destColour,
        wxDirection nDirection = wxEAST);

    virtual void DoGradientFillConcentric(const wxRect& rect,
        const wxColour& initialColour,
        const wxColour& destColour,
        const wxPoint& circleCenter);

    virtual bool DoGetPixel(wxCoord x, wxCoord y, wxColour *col) const;

    virtual void DoDrawPoint(wxCoord x, wxCoord y);


    virtual void DoDrawSpline(wxList *points);


    virtual void DoDrawLine(wxCoord x1, wxCoord y1, wxCoord x2, wxCoord y2);

    virtual void DoDrawArc(wxCoord x1, wxCoord y1,
        wxCoord x2, wxCoord y2,
        wxCoord xc, wxCoord yc);

    virtual void DoDrawCheckMark(wxCoord x, wxCoord y,
        wxCoord width, wxCoord height);

    virtual void DoDrawEllipticArc(wxCoord x, wxCoord y, wxCoord w, wxCoord h,
        double sa, double ea);

    virtual void DoDrawRectangle(wxCoord x, wxCoord y, wxCoord width, wxCoord height);
    virtual void DoDrawRoundedRectangle(wxCoord x, wxCoord y,
        wxCoord width, wxCoord height,
        double radius);
    virtual void DoDrawEllipse(wxCoord x, wxCoord y, wxCoord width, wxCoord height);

    virtual void DoCrossHair(wxCoord x, wxCoord y);

    virtual void DoDrawIcon(const wxIcon& icon, wxCoord x, wxCoord y);
    virtual void DoDrawBitmap(const wxBitmap &bmp, wxCoord x, wxCoord y,
        bool useMask = false);

    virtual void DoDrawText(const wxString& text, wxCoord x, wxCoord y);
    virtual void DoDrawRotatedText(const wxString& text, wxCoord x, wxCoord y,
        double angle);

    virtual bool DoBlit(wxCoord xdest, wxCoord ydest, wxCoord width, wxCoord height,
        wxDC *source, wxCoord xsrc, wxCoord ysrc,
        int rop = wxCOPY, bool useMask = false, wxCoord xsrcMask = -1, wxCoord ysrcMask = -1);

    virtual void DoGetSize(int *,int *) const;
    virtual void DoGetSizeMM(int* width, int* height) const;

    virtual void DoDrawLines(int n, wxPoint points[],
        wxCoord xoffset, wxCoord yoffset);
    virtual void DoDrawPolygon(int n, wxPoint points[],
        wxCoord xoffset, wxCoord yoffset,
        int fillStyle = wxODDEVEN_RULE);
    virtual void DoDrawPolyPolygon(int n, int count[], wxPoint points[],
        wxCoord xoffset, wxCoord yoffset,
        int fillStyle);

    virtual void DoSetClippingRegionAsRegion(const wxRegion& region);
    virtual void DoSetClippingRegion(wxCoord x, wxCoord y,
        wxCoord width, wxCoord height);

    virtual void DoGetTextExtent(const wxString& string,
        wxCoord *x, wxCoord *y,
        wxCoord *descent = __null,
        wxCoord *externalLeading = __null,
        wxFont *theFont = __null) const;

    virtual bool DoGetPartialTextExtents(const wxString& text, wxArrayInt& widths) const;

protected:

    bool m_logicalFunctionSupported;
    double m_mm_to_pix_x, m_mm_to_pix_y;
    wxGraphicsMatrix m_matrixOriginal;
    wxGraphicsMatrix m_matrixCurrent;

    double m_formerScaleX, m_formerScaleY;

    wxGraphicsContext* m_graphicContext;
};
# 893 "/usr/include/wx-2.8/wx/dc.h" 2







class wxDCTextColourChanger
{
public:
    wxDCTextColourChanger(wxDC& dc) : m_dc(dc), m_colFgOld() { }

    wxDCTextColourChanger(wxDC& dc, const wxColour& col) : m_dc(dc)
    {
        Set(col);
    }

    ~wxDCTextColourChanger()
    {
        if ( m_colFgOld.Ok() )
            m_dc.SetTextForeground(m_colFgOld);
    }

    void Set(const wxColour& col)
    {
        if ( !m_colFgOld.Ok() )
            m_colFgOld = m_dc.GetTextForeground();
        m_dc.SetTextForeground(col);
    }

private:
    wxDC& m_dc;

    wxColour m_colFgOld;

    private: wxDCTextColourChanger(const wxDCTextColourChanger&); wxDCTextColourChanger& operator=(const wxDCTextColourChanger&);
};






class wxDCPenChanger
{
public:
    wxDCPenChanger(wxDC& dc, const wxPen& pen) : m_dc(dc), m_penOld(dc.GetPen())
    {
        m_dc.SetPen(pen);
    }

    ~wxDCPenChanger()
    {
        if ( m_penOld.Ok() )
            m_dc.SetPen(m_penOld);
    }

private:
    wxDC& m_dc;

    wxPen m_penOld;

    private: wxDCPenChanger(const wxDCPenChanger&); wxDCPenChanger& operator=(const wxDCPenChanger&);
};






class wxDCBrushChanger
{
public:
    wxDCBrushChanger(wxDC& dc, const wxBrush& brush) : m_dc(dc), m_brushOld(dc.GetBrush())
    {
        m_dc.SetBrush(brush);
    }

    ~wxDCBrushChanger()
    {
        if ( m_brushOld.Ok() )
            m_dc.SetBrush(m_brushOld);
    }

private:
    wxDC& m_dc;

    wxBrush m_brushOld;

    private: wxDCBrushChanger(const wxDCBrushChanger&); wxDCBrushChanger& operator=(const wxDCBrushChanger&);
};






class wxDCClipper
{
public:
    wxDCClipper(wxDC& dc, const wxRegion& r) : m_dc(dc)
        { dc.SetClippingRegion(r); }
    wxDCClipper(wxDC& dc, const wxRect& r) : m_dc(dc)
        { dc.SetClippingRegion(r.x, r.y, r.width, r.height); }
    wxDCClipper(wxDC& dc, wxCoord x, wxCoord y, wxCoord w, wxCoord h) : m_dc(dc)
        { dc.SetClippingRegion(x, y, w, h); }

    ~wxDCClipper() { m_dc.DestroyClippingRegion(); }

private:
    wxDC& m_dc;

    private: wxDCClipper(const wxDCClipper&); wxDCClipper& operator=(const wxDCClipper&);
};
# 49 "/usr/include/wx-2.8/wx/wx.h" 2
# 1 "/usr/include/wx-2.8/wx/dcclient.h" 1
# 24 "/usr/include/wx-2.8/wx/dcclient.h"
# 1 "/usr/include/wx-2.8/wx/gtk/dcclient.h" 1
# 16 "/usr/include/wx-2.8/wx/gtk/dcclient.h"
class wxWindow;





class wxWindowDC : public wxDC
{
public:
    wxWindowDC();
    wxWindowDC( wxWindow *win );

    virtual ~wxWindowDC();

    virtual bool CanDrawBitmap() const { return true; }
    virtual bool CanGetTextExtent() const { return true; }

protected:
    virtual void DoGetSize(int *width, int *height) const;
    virtual bool DoFloodFill( wxCoord x, wxCoord y, const wxColour& col, int style=wxFLOOD_SURFACE );
    virtual bool DoGetPixel( wxCoord x1, wxCoord y1, wxColour *col ) const;

    virtual void DoDrawLine( wxCoord x1, wxCoord y1, wxCoord x2, wxCoord y2 );
    virtual void DoCrossHair( wxCoord x, wxCoord y );
    virtual void DoDrawArc( wxCoord x1, wxCoord y1, wxCoord x2, wxCoord y2,
                            wxCoord xc, wxCoord yc );
    virtual void DoDrawEllipticArc( wxCoord x, wxCoord y, wxCoord width, wxCoord height,
                                    double sa, double ea );
    virtual void DoDrawPoint( wxCoord x, wxCoord y );

    virtual void DoDrawLines(int n, wxPoint points[],
                             wxCoord xoffset, wxCoord yoffset);
    virtual void DoDrawPolygon(int n, wxPoint points[],
                               wxCoord xoffset, wxCoord yoffset,
                               int fillStyle = wxODDEVEN_RULE);

    virtual void DoDrawRectangle( wxCoord x, wxCoord y, wxCoord width, wxCoord height );
    virtual void DoDrawRoundedRectangle( wxCoord x, wxCoord y, wxCoord width, wxCoord height, double radius = 20.0 );
    virtual void DoDrawEllipse( wxCoord x, wxCoord y, wxCoord width, wxCoord height );

    virtual void DoDrawIcon( const wxIcon &icon, wxCoord x, wxCoord y );
    virtual void DoDrawBitmap( const wxBitmap &bitmap, wxCoord x, wxCoord y,
                               bool useMask = false );

    virtual bool DoBlit( wxCoord xdest, wxCoord ydest, wxCoord width, wxCoord height,
                         wxDC *source, wxCoord xsrc, wxCoord ysrc,
                         int logical_func = wxCOPY, bool useMask = false, wxCoord xsrcMask = -1, wxCoord ysrcMask = -1 );

    virtual void DoDrawText( const wxString &text, wxCoord x, wxCoord y );
    virtual void DoDrawRotatedText(const wxString& text, wxCoord x, wxCoord y,
                                   double angle);
    virtual void DoGetTextExtent( const wxString &string,
                                wxCoord *width, wxCoord *height,
                                wxCoord *descent = (wxCoord *) __null,
                                wxCoord *externalLeading = (wxCoord *) __null,
                                wxFont *theFont = (wxFont *) __null) const;
    virtual bool DoGetPartialTextExtents(const wxString& text, wxArrayInt& widths) const;
    virtual void DoSetClippingRegion( wxCoord x, wxCoord y, wxCoord width, wxCoord height );
    virtual void DoSetClippingRegionAsRegion( const wxRegion &region );


public:
    virtual wxCoord GetCharWidth() const;
    virtual wxCoord GetCharHeight() const;

    virtual void Clear();

    virtual void SetFont( const wxFont &font );
    virtual void SetPen( const wxPen &pen );
    virtual void SetBrush( const wxBrush &brush );
    virtual void SetBackground( const wxBrush &brush );
    virtual void SetLogicalFunction( int function );
    virtual void SetTextForeground( const wxColour &col );
    virtual void SetTextBackground( const wxColour &col );
    virtual void SetBackgroundMode( int mode );
    virtual void SetPalette( const wxPalette& palette );

    virtual void DestroyClippingRegion();


    virtual wxSize GetPPI() const;
    virtual int GetDepth() const;


    virtual void SetDeviceOrigin( wxCoord x, wxCoord y );
    virtual void SetAxisOrientation( bool xLeftRight, bool yBottomUp );





    GdkWindow *m_window;
    GdkGC *m_penGC;
    GdkGC *m_brushGC;
    GdkGC *m_textGC;
    GdkGC *m_bgGC;
    GdkColormap *m_cmap;
    bool m_isMemDC;
    bool m_isScreenDC;
    wxWindow *m_owner;
    wxRegion m_currentClippingRegion;
    wxRegion m_paintClippingRegion;


    PangoContext *m_context;
    PangoLayout *m_layout;
    PangoFontDescription *m_fontdesc;

    void SetUpDC();
    void Destroy();

    virtual void ComputeScaleAndOrigin();

    virtual GdkWindow *GetGDKWindow() const { return m_window; }

private:
    public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};





class wxClientDC : public wxWindowDC
{
public:
    wxClientDC() { }
    wxClientDC( wxWindow *win );

protected:
    virtual void DoGetSize(int *width, int *height) const;

private:
    public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};





class wxPaintDC : public wxClientDC
{
public:
    wxPaintDC() { }
    wxPaintDC( wxWindow *win );

private:
    public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};
# 25 "/usr/include/wx-2.8/wx/dcclient.h" 2
# 50 "/usr/include/wx-2.8/wx/wx.h" 2
# 1 "/usr/include/wx-2.8/wx/dcmemory.h" 1
# 21 "/usr/include/wx-2.8/wx/dcmemory.h"
class wxMemoryDCBase
{
public:
    wxMemoryDCBase() { }


    virtual ~wxMemoryDCBase() { }


    void SelectObject(wxBitmap& bmp)
    {



        if (bmp.IsOk())
            bmp.UnShare();

        DoSelect(bmp);
    }


    virtual void SelectObjectAsSource(const wxBitmap& bmp)
    {
        DoSelect(bmp);
    }

protected:
    virtual void DoSelect(const wxBitmap& bmp) = 0;
};
# 58 "/usr/include/wx-2.8/wx/dcmemory.h"
# 1 "/usr/include/wx-2.8/wx/gtk/dcmemory.h" 1
# 19 "/usr/include/wx-2.8/wx/gtk/dcmemory.h"
class wxMemoryDC : public wxWindowDC, public wxMemoryDCBase
{
public:
    wxMemoryDC() : wxWindowDC() { Init(); }
    wxMemoryDC(wxBitmap& bitmap) : wxWindowDC() { Init(); SelectObject(bitmap); }
    wxMemoryDC( wxDC *dc );
    virtual ~wxMemoryDC();





    virtual void SetPen( const wxPen &pen );
    virtual void SetBrush( const wxBrush &brush );
    virtual void SetBackground( const wxBrush &brush );
    virtual void SetTextForeground( const wxColour &col );
    virtual void SetTextBackground( const wxColour &col );


    virtual wxBitmap GetSelectedBitmap() const { return m_selected; }
    wxBitmap m_selected;

protected:
    void DoGetSize( int *width, int *height ) const;
    virtual void DoSelect(const wxBitmap& bitmap);
    virtual wxBitmap DoGetAsBitmap(const wxRect *subrect) const
    { return subrect == __null ? GetSelectedBitmap() : GetSelectedBitmap().GetSubBitmap(*subrect); }

private:
    void Init();

    public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};
# 59 "/usr/include/wx-2.8/wx/dcmemory.h" 2
# 51 "/usr/include/wx-2.8/wx/wx.h" 2
# 1 "/usr/include/wx-2.8/wx/dcprint.h" 1
# 52 "/usr/include/wx-2.8/wx/wx.h" 2
# 1 "/usr/include/wx-2.8/wx/dcscreen.h" 1
# 24 "/usr/include/wx-2.8/wx/dcscreen.h"
# 1 "/usr/include/wx-2.8/wx/gtk/dcscreen.h" 1
# 19 "/usr/include/wx-2.8/wx/gtk/dcscreen.h"
class wxScreenDC;





class wxScreenDC : public wxPaintDC
{
public:
    wxScreenDC();
    virtual ~wxScreenDC();

    static bool StartDrawingOnTop( wxWindow *window );
    static bool StartDrawingOnTop( wxRect *rect = (wxRect *) __null );
    static bool EndDrawingOnTop();



    static GdkWindow *sm_overlayWindow;
    static int sm_overlayWindowX;
    static int sm_overlayWindowY;

protected:
    virtual void DoGetSize(int *width, int *height) const;

private:
    public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};
# 25 "/usr/include/wx-2.8/wx/dcscreen.h" 2
# 53 "/usr/include/wx-2.8/wx/wx.h" 2
# 1 "/usr/include/wx-2.8/wx/button.h" 1
# 46 "/usr/include/wx-2.8/wx/button.h"
# 1 "/usr/include/wx-2.8/wx/control.h" 1
# 25 "/usr/include/wx-2.8/wx/control.h"
extern const wxChar wxControlNameStr[];





class wxControlBase : public wxWindow
{
public:
    wxControlBase() { }

    virtual ~wxControlBase();


    bool Create(wxWindow *parent, wxWindowID id,
                const wxPoint& pos = wxDefaultPosition,
                const wxSize& size = wxDefaultSize,
                long style = 0,
                const wxValidator& validator = wxDefaultValidator,
                const wxString& name = wxControlNameStr);


    int GetAlignment() const { return m_windowStyle & wxALIGN_MASK; }


    static wxString GetLabelText(const wxString& label);


    wxString GetLabelText() const { return GetLabelText(GetLabel()); }




    virtual bool ShouldInheritColours() const { return true; }






    virtual void Command(wxCommandEvent &event);

    virtual void SetLabel( const wxString &label );
    virtual bool SetFont(const wxFont& font);


    virtual void DoUpdateWindowUI(wxUpdateUIEvent& event);

protected:


    bool CreateControl(wxWindowBase *parent,
                       wxWindowID id,
                       const wxPoint& pos,
                       const wxSize& size,
                       long style,
                       const wxValidator& validator,
                       const wxString& name);


    void InitCommandEvent(wxCommandEvent& event) const;

    private: wxControlBase(const wxControlBase&); wxControlBase& operator=(const wxControlBase&);
};
# 103 "/usr/include/wx-2.8/wx/control.h"
# 1 "/usr/include/wx-2.8/wx/gtk/control.h" 1
# 13 "/usr/include/wx-2.8/wx/gtk/control.h"
typedef struct _GtkLabel GtkLabel;
typedef struct _GtkFrame GtkFrame;






extern "C" {
    typedef GtkWidget* (*wxGtkWidgetNew_t)(void);
    typedef GtkWidget* (*wxGtkWidgetNewFromStr_t)(const gchar*);
    typedef GtkWidget* (*wxGtkWidgetNewFromAdj_t)(GtkAdjustment*);
}

class wxControl : public wxControlBase
{
public:
    wxControl();
    wxControl(wxWindow *parent, wxWindowID id,
             const wxPoint& pos = wxDefaultPosition,
             const wxSize& size = wxDefaultSize, long style = 0,
             const wxValidator& validator = wxDefaultValidator,
             const wxString& name = wxControlNameStr)
    {
        Create(parent, id, pos, size, style, validator, name);
    }

    bool Create(wxWindow *parent, wxWindowID id,
            const wxPoint& pos = wxDefaultPosition,
            const wxSize& size = wxDefaultSize, long style = 0,
            const wxValidator& validator = wxDefaultValidator,
            const wxString& name = wxControlNameStr);

    virtual void SetLabel( const wxString &label );
    virtual wxString GetLabel() const;

    virtual wxVisualAttributes GetDefaultAttributes() const;

    virtual void OnInternalIdle();

protected:
    virtual wxSize DoGetBestSize() const;
    void PostCreation(const wxSize& size);


    void GTKSetLabelForLabel(GtkLabel *w, const wxString& label);


    GtkWidget* GTKCreateFrame(const wxString& label);
    void GTKSetLabelForFrame(GtkFrame *w, const wxString& label);
    void GTKFrameApplyWidgetStyle(GtkFrame* w, GtkRcStyle* rc);
    void GTKFrameSetMnemonicWidget(GtkFrame* w, GtkWidget* widget);


    static wxString GTKRemoveMnemonics(const wxString& label);





    static wxString GTKConvertMnemonics(const wxString &label);


    static wxVisualAttributes
        GetDefaultAttributesFromGTKWidget(GtkWidget* widget,
                                          bool useBase = false,
                                          int state = -1);
    static wxVisualAttributes
        GetDefaultAttributesFromGTKWidget(wxGtkWidgetNew_t,
                                          bool useBase = false,
                                          int state = -1);
    static wxVisualAttributes
        GetDefaultAttributesFromGTKWidget(wxGtkWidgetNewFromStr_t,
                                          bool useBase = false,
                                          int state = -1);

    static wxVisualAttributes
        GetDefaultAttributesFromGTKWidget(wxGtkWidgetNewFromAdj_t,
                                          bool useBase = false,
                                          int state = -1);



    virtual bool UseGTKStyleBase() const { return false; }


    wxString m_label;

private:
    public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};


void wxGtkFixSensitivity(wxWindow* ctrl);
# 104 "/usr/include/wx-2.8/wx/control.h" 2
# 47 "/usr/include/wx-2.8/wx/button.h" 2

class wxBitmap;

extern const wxChar wxButtonNameStr[];





class wxButtonBase : public wxControl
{
public:
    wxButtonBase() { }


    virtual void SetImageLabel(const wxBitmap& ) { }


    virtual void SetImageMargins(wxCoord , wxCoord ) { }



    virtual void SetDefault() { }




    virtual bool ShouldInheritColours() const { return false; }


    static wxSize GetDefaultSize();

protected:
    private: wxButtonBase(const wxButtonBase&); wxButtonBase& operator=(const wxButtonBase&);
};
# 90 "/usr/include/wx-2.8/wx/button.h"
# 1 "/usr/include/wx-2.8/wx/gtk/button.h" 1
# 17 "/usr/include/wx-2.8/wx/gtk/button.h"
class wxButton: public wxButtonBase
{
public:
    wxButton();
    wxButton(wxWindow *parent, wxWindowID id,
           const wxString& label = wxEmptyString,
           const wxPoint& pos = wxDefaultPosition,
           const wxSize& size = wxDefaultSize, long style = 0,
           const wxValidator& validator = wxDefaultValidator,
           const wxString& name = wxButtonNameStr)
    {
        Create(parent, id, label, pos, size, style, validator, name);
    }

    virtual ~wxButton();

    bool Create(wxWindow *parent, wxWindowID id,
           const wxString& label = wxEmptyString,
           const wxPoint& pos = wxDefaultPosition,
           const wxSize& size = wxDefaultSize, long style = 0,
           const wxValidator& validator = wxDefaultValidator,
           const wxString& name = wxButtonNameStr);

    virtual void SetDefault();
    virtual void SetLabel( const wxString &label );
    virtual bool Enable( bool enable = 1 );






    virtual bool ShouldInheritColours() const { return false; }

    static wxVisualAttributes
    GetClassDefaultAttributes(wxWindowVariant variant = wxWINDOW_VARIANT_NORMAL);


    void MoveWindow(int x, int y, int width, int height) { DoMoveWindow(x, y, width, height); }

protected:
    virtual wxSize DoGetBestSize() const;
    virtual void DoApplyWidgetStyle(GtkRcStyle *style);

    virtual GdkWindow *GTKGetWindow(wxArrayGdkWindows& windows) const;

private:
    public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};
# 91 "/usr/include/wx-2.8/wx/button.h" 2
# 54 "/usr/include/wx-2.8/wx/wx.h" 2
# 1 "/usr/include/wx-2.8/wx/menuitem.h" 1
# 29 "/usr/include/wx-2.8/wx/menuitem.h"
class wxAcceleratorEntry;
class wxMenuItem;
class wxMenu;






class wxMenuItemBase : public wxObject
{
public:

    static wxMenuItem *New(wxMenu *parentMenu = (wxMenu *)__null,
                           int itemid = wxID_SEPARATOR,
                           const wxString& text = wxEmptyString,
                           const wxString& help = wxEmptyString,
                           wxItemKind kind = wxITEM_NORMAL,
                           wxMenu *subMenu = (wxMenu *)__null);


    virtual ~wxMenuItemBase();


    wxMenu *GetMenu() const { return m_parentMenu; }
    void SetMenu(wxMenu* menu) { m_parentMenu = menu; }


    void SetId(int itemid) { m_id = itemid; }
    int GetId() const { return m_id; }
    bool IsSeparator() const { return m_id == wxID_SEPARATOR; }







    virtual void SetText(const wxString& str);

    wxString GetLabel() const { return GetLabelFromText(m_text); }
    const wxString& GetText() const { return m_text; }


    static wxString GetLabelFromText(const wxString& text);


    wxItemKind GetKind() const { return m_kind; }
    void SetKind(wxItemKind kind) { m_kind = kind; }

    virtual void SetCheckable(bool checkable) { m_kind = checkable ? wxITEM_CHECK : wxITEM_NORMAL; }
    bool IsCheckable() const
        { return m_kind == wxITEM_CHECK || m_kind == wxITEM_RADIO; }

    bool IsSubMenu() const { return m_subMenu != __null; }
    void SetSubMenu(wxMenu *menu) { m_subMenu = menu; }
    wxMenu *GetSubMenu() const { return m_subMenu; }


    virtual void Enable(bool enable = true) { m_isEnabled = enable; }
    virtual bool IsEnabled() const { return m_isEnabled; }

    virtual void Check(bool check = true) { m_isChecked = check; }
    virtual bool IsChecked() const { return m_isChecked; }
    void Toggle() { Check(!m_isChecked); }


    void SetHelp(const wxString& str);
    const wxString& GetHelp() const { return m_help; }




    static wxAcceleratorEntry *GetAccelFromString(const wxString& label);


    virtual wxAcceleratorEntry *GetAccel() const;



    virtual void SetAccel(wxAcceleratorEntry *accel);



    void SetName(const wxString& str) { SetText(str); }
    const wxString& GetName() const { return GetText(); }

    static wxMenuItem *New(wxMenu *parentMenu,
                           int itemid,
                           const wxString& text,
                           const wxString& help,
                           bool isCheckable,
                           wxMenu *subMenu = (wxMenu *)__null)
    {
        return New(parentMenu, itemid, text, help,
                   isCheckable ? wxITEM_CHECK : wxITEM_NORMAL, subMenu);
    }

protected:
    int m_id;
    wxMenu *m_parentMenu,
                 *m_subMenu;
    wxString m_text,
                  m_help;
    wxItemKind m_kind;
    bool m_isChecked;
    bool m_isEnabled;


    wxMenuItemBase(wxMenu *parentMenu = (wxMenu *)__null,
                   int itemid = wxID_SEPARATOR,
                   const wxString& text = wxEmptyString,
                   const wxString& help = wxEmptyString,
                   wxItemKind kind = wxITEM_NORMAL,
                   wxMenu *subMenu = (wxMenu *)__null);

private:


    wxMenuItemBase(const wxMenuItemBase& item);
    wxMenuItemBase& operator=(const wxMenuItemBase& item);

public:



    void SetItemLabel(const wxString& str) { SetText(str); }
# 164 "/usr/include/wx-2.8/wx/menuitem.h"
    wxString GetItemLabelText() const { return GetLabelText(m_text); }



    static wxString GetLabelText(const wxString& label);

};
# 188 "/usr/include/wx-2.8/wx/menuitem.h"
# 1 "/usr/include/wx-2.8/wx/gtk/menuitem.h" 1
# 19 "/usr/include/wx-2.8/wx/gtk/menuitem.h"
class wxMenuItem : public wxMenuItemBase
{
public:
    wxMenuItem(wxMenu *parentMenu = (wxMenu *)__null,
               int id = wxID_SEPARATOR,
               const wxString& text = wxEmptyString,
               const wxString& help = wxEmptyString,
               wxItemKind kind = wxITEM_NORMAL,
               wxMenu *subMenu = (wxMenu *)__null);
    virtual ~wxMenuItem();


    virtual void SetText( const wxString& str );
    virtual void Enable( bool enable = 1 );
    virtual void Check( bool check = 1 );
    virtual bool IsChecked() const;
    virtual void SetBitmap(const wxBitmap& bitmap) { m_bitmap = bitmap; }
    virtual const wxBitmap& GetBitmap() const { return m_bitmap; }


    virtual wxAcceleratorEntry *GetAccel() const;



    void SetMenuItem(GtkWidget *menuItem) { m_menuItem = menuItem; }
    GtkWidget *GetMenuItem() const { return m_menuItem; }
    GtkWidget *GetLabelWidget() const { return m_labelWidget; }
    void SetLabelWidget(GtkWidget *labelWidget) { m_labelWidget = labelWidget; }
    wxString GetFactoryPath() const;

    wxString GetHotKey() const { return m_hotKey; }



    static wxString GTKProcessMenuItemLabel(const wxString& str, wxString *hotKey);


    wxMenuItem(wxMenu *parentMenu,
               int id,
               const wxString& text,
               const wxString& help,
               bool isCheckable,
               wxMenu *subMenu = (wxMenu *)__null);

private:

    void Init(const wxString& text);



    void DoSetText(const wxString& text);

    wxString m_hotKey;
    wxBitmap m_bitmap;

    GtkWidget *m_menuItem;
    GtkWidget* m_labelWidget;

    public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();

public:



    wxString GetItemLabel() const;


};
# 189 "/usr/include/wx-2.8/wx/menuitem.h" 2
# 55 "/usr/include/wx-2.8/wx/wx.h" 2
# 1 "/usr/include/wx-2.8/wx/menu.h" 1
# 30 "/usr/include/wx-2.8/wx/menu.h"
class wxMenu;
class wxMenuBarBase;
class wxMenuBar;
class wxMenuItem;


typedef wxMenu _WX_LIST_ITEM_TYPE_wxMenuList; typedef int (*wxSortFuncFor_wxMenuList)(const wxMenu **, const wxMenu **); class wxwxMenuListNode : public wxNodeBase { public: wxwxMenuListNode(wxListBase *list = (wxListBase *)__null, wxwxMenuListNode *previous = (wxwxMenuListNode *)__null, wxwxMenuListNode *next = (wxwxMenuListNode *)__null, wxMenu *data = (wxMenu *)__null, const wxListKey& key = wxDefaultListKey) : wxNodeBase(list, previous, next, data, key) { } wxwxMenuListNode *GetNext() const { return (wxwxMenuListNode *)wxNodeBase::GetNext(); } wxwxMenuListNode *GetPrevious() const { return (wxwxMenuListNode *)wxNodeBase::GetPrevious(); } wxMenu *GetData() const { return (wxMenu *)wxNodeBase::GetData(); } void SetData(wxMenu *data) { wxNodeBase::SetData(data); } protected: virtual void DeleteData(); private: wxwxMenuListNode(const wxwxMenuListNode&); wxwxMenuListNode& operator=(const wxwxMenuListNode&); }; class wxMenuList : public wxListBase { public: typedef wxwxMenuListNode Node; class compatibility_iterator { public: compatibility_iterator(Node *ptr = __null) : m_ptr(ptr) { } Node *operator->() const { return m_ptr; } operator Node *() const { return m_ptr; } private: Node *m_ptr; }; wxMenuList(wxKeyType keyType = wxKEY_NONE) : wxListBase(keyType) { } wxMenuList(const wxMenuList& list) : wxListBase(list.GetKeyType()) { Assign(list); } wxMenuList(size_t count, wxMenu *elements[]) : wxListBase(count, (void **)elements) { } wxMenuList& operator=(const wxMenuList& list) { Assign(list); return *this; } wxwxMenuListNode *GetFirst() const { return (wxwxMenuListNode *)wxListBase::GetFirst(); } wxwxMenuListNode *GetLast() const { return (wxwxMenuListNode *)wxListBase::GetLast(); } wxwxMenuListNode *Item(size_t index) const { return (wxwxMenuListNode *)wxListBase::Item(index); } wxMenu *operator[](size_t index) const { wxwxMenuListNode *node = Item(index); return node ? (wxMenu*)(node->GetData()) : (wxMenu*)__null; } wxwxMenuListNode *Append(wxMenu *object) { return (wxwxMenuListNode *)wxListBase::Append(object); } wxwxMenuListNode *Insert(wxMenu *object) { return (wxwxMenuListNode *)Insert((wxwxMenuListNode*)__null, object); } wxwxMenuListNode *Insert(size_t pos, wxMenu *object) { return (wxwxMenuListNode *)wxListBase::Insert(pos, object); } wxwxMenuListNode *Insert(wxwxMenuListNode *prev, wxMenu *object) { return (wxwxMenuListNode *)wxListBase::Insert(prev, object); } wxwxMenuListNode *Append(long key, void *object) { return (wxwxMenuListNode *)wxListBase::Append(key, object); } wxwxMenuListNode *Append(const wxChar *key, void *object) { return (wxwxMenuListNode *)wxListBase::Append(key, object); } wxwxMenuListNode *DetachNode(wxwxMenuListNode *node) { return (wxwxMenuListNode *)wxListBase::DetachNode(node); } bool DeleteNode(wxwxMenuListNode *node) { return wxListBase::DeleteNode(node); } bool DeleteObject(wxMenu *object) { return wxListBase::DeleteObject(object); } void Erase(wxwxMenuListNode *it) { DeleteNode(it); } wxwxMenuListNode *Find(const wxMenu *object) const { return (wxwxMenuListNode *)wxListBase::Find(object); } virtual wxwxMenuListNode *Find(const wxListKey& key) const { return (wxwxMenuListNode *)wxListBase::Find(key); } int IndexOf(wxMenu *object) const { return wxListBase::IndexOf(object); } void Sort(wxSortCompareFunction func) { wxListBase::Sort(func); } void Sort(wxSortFuncFor_wxMenuList func) { Sort((wxSortCompareFunction)func); } protected: virtual wxNodeBase *CreateNode(wxNodeBase *prev, wxNodeBase *next, void *data, const wxListKey& key = wxDefaultListKey) { return new wxwxMenuListNode(this, (wxwxMenuListNode *)prev, (wxwxMenuListNode *)next, (wxMenu *)data, key); } public: typedef size_t size_type; typedef int difference_type; typedef wxMenu* value_type; typedef wxMenu* base_value_type; typedef value_type& reference; typedef const value_type& const_reference; typedef base_value_type& base_reference; typedef const base_value_type& const_base_reference; class iterator { typedef wxMenuList list; public: typedef wxwxMenuListNode Node; typedef iterator itor; typedef wxMenu* value_type; typedef value_type* ptr_type; typedef value_type& reference; Node* m_node; Node* m_init; public: typedef reference reference_type; typedef ptr_type pointer_type; iterator(Node* node, Node* init) : m_node(node), m_init(init) {} iterator() : m_node(__null), m_init(__null) { } reference_type operator*() const { return *(pointer_type)m_node->GetDataPtr(); } itor& operator++() { m_node = m_node->GetNext(); return *this; } const itor operator++(int) { itor tmp = *this; m_node = m_node->GetNext(); return tmp; } itor& operator--() { m_node = m_node ? m_node->GetPrevious() : m_init; return *this; } const itor operator--(int) { itor tmp = *this; m_node = m_node ? m_node->GetPrevious() : m_init; return tmp; } bool operator!=(const itor& it) const { return it.m_node != m_node; } bool operator==(const itor& it) const { return it.m_node == m_node; } }; class const_iterator { typedef wxMenuList list; public: typedef wxwxMenuListNode Node; typedef wxMenu* value_type; typedef const value_type& const_reference; typedef const_iterator itor; typedef value_type* ptr_type; Node* m_node; Node* m_init; public: typedef const_reference reference_type; typedef const ptr_type pointer_type; const_iterator(Node* node, Node* init) : m_node(node), m_init(init) { } const_iterator() : m_node(__null), m_init(__null) { } const_iterator(const iterator& it) : m_node(it.m_node), m_init(it.m_init) { } reference_type operator*() const { return *(pointer_type)m_node->GetDataPtr(); } itor& operator++() { m_node = m_node->GetNext(); return *this; } const itor operator++(int) { itor tmp = *this; m_node = m_node->GetNext(); return tmp; } itor& operator--() { m_node = m_node ? m_node->GetPrevious() : m_init; return *this; } const itor operator--(int) { itor tmp = *this; m_node = m_node ? m_node->GetPrevious() : m_init; return tmp; } bool operator!=(const itor& it) const { return it.m_node != m_node; } bool operator==(const itor& it) const { return it.m_node == m_node; } }; class reverse_iterator { typedef wxMenuList list; public: typedef wxwxMenuListNode Node; typedef wxMenu* value_type; typedef reverse_iterator itor; typedef value_type* ptr_type; typedef value_type& reference; Node* m_node; Node* m_init; public: typedef reference reference_type; typedef ptr_type pointer_type; reverse_iterator(Node* node, Node* init) : m_node(node), m_init(init) { } reverse_iterator() : m_node(__null), m_init(__null) { } reference_type operator*() const { return *(pointer_type)m_node->GetDataPtr(); } itor& operator++() { m_node = m_node->GetPrevious(); return *this; } const itor operator++(int) { itor tmp = *this; m_node = m_node->GetPrevious(); return tmp; } itor& operator--() { m_node = m_node ? m_node->GetNext() : m_init; return *this; } const itor operator--(int) { itor tmp = *this; m_node = m_node ? m_node->GetNext() : m_init; return tmp; } bool operator!=(const itor& it) const { return it.m_node != m_node; } bool operator==(const itor& it) const { return it.m_node == m_node; } }; class const_reverse_iterator { typedef wxMenuList list; public: typedef wxwxMenuListNode Node; typedef wxMenu* value_type; typedef const_reverse_iterator itor; typedef value_type* ptr_type; typedef const value_type& const_reference; Node* m_node; Node* m_init; public: typedef const_reference reference_type; typedef const ptr_type pointer_type; const_reverse_iterator(Node* node, Node* init) : m_node(node), m_init(init) { } const_reverse_iterator() : m_node(__null), m_init(__null) { } const_reverse_iterator(const reverse_iterator& it) : m_node(it.m_node), m_init(it.m_init) { } reference_type operator*() const { return *(pointer_type)m_node->GetDataPtr(); } itor& operator++() { m_node = m_node->GetPrevious(); return *this; } const itor operator++(int) { itor tmp = *this; m_node = m_node->GetPrevious(); return tmp; } itor& operator--() { m_node = m_node ? m_node->GetNext() : m_init; return *this;} const itor operator--(int) { itor tmp = *this; m_node = m_node ? m_node->GetNext() : m_init; return tmp; } bool operator!=(const itor& it) const { return it.m_node != m_node; } bool operator==(const itor& it) const { return it.m_node == m_node; } }; explicit wxMenuList(size_type n, const_reference v = value_type()) { assign(n, v); } wxMenuList(const const_iterator& first, const const_iterator& last) { assign(first, last); } iterator begin() { return iterator(GetFirst(), GetLast()); } const_iterator begin() const { return const_iterator(GetFirst(), GetLast()); } iterator end() { return iterator(__null, GetLast()); } const_iterator end() const { return const_iterator(__null, GetLast()); } reverse_iterator rbegin() { return reverse_iterator(GetLast(), GetFirst()); } const_reverse_iterator rbegin() const { return const_reverse_iterator(GetLast(), GetFirst()); } reverse_iterator rend() { return reverse_iterator(__null, GetFirst()); } const_reverse_iterator rend() const { return const_reverse_iterator(__null, GetFirst()); } void resize(size_type n, value_type v = value_type()) { while (n < size()) pop_back(); while (n > size()) push_back(v); } size_type size() const { return GetCount(); } size_type max_size() const { return 2147483647; } bool empty() const { return IsEmpty(); } reference front() { return *begin(); } const_reference front() const { return *begin(); } reference back() { iterator tmp = end(); return *--tmp; } const_reference back() const { const_iterator tmp = end(); return *--tmp; } void push_front(const_reference v = value_type()) { Insert(GetFirst(), (const_base_reference)v); } void pop_front() { DeleteNode(GetFirst()); } void push_back(const_reference v = value_type()) { Append((const_base_reference)v); } void pop_back() { DeleteNode(GetLast()); } void assign(const_iterator first, const const_iterator& last) { clear(); for(; first != last; ++first) Append((const_base_reference)*first); } void assign(size_type n, const_reference v = value_type()) { clear(); for(size_type i = 0; i < n; ++i) Append((const_base_reference)v); } iterator insert(const iterator& it, const_reference v = value_type()) { if ( it == end() ) Append((const_base_reference)v); else Insert(it.m_node, (const_base_reference)v); iterator itprev(it); return itprev--; } void insert(const iterator& it, size_type n, const_reference v = value_type()) { for(size_type i = 0; i < n; ++i) insert(it, v); } void insert(const iterator& it, const_iterator first, const const_iterator& last) { for(; first != last; ++first) insert(it, *first); } iterator erase(const iterator& it) { iterator next = iterator(it.m_node->GetNext(), GetLast()); DeleteNode(it.m_node); return next; } iterator erase(const iterator& first, const iterator& last) { iterator next = last; if ( next != end() ) ++next; DeleteNodes(first.m_node, last.m_node); return next; } void clear() { Clear(); } void splice(const iterator& it, wxMenuList& l, const iterator& first, const iterator& last) { insert(it, first, last); l.erase(first, last); } void splice(const iterator& it, wxMenuList& l) { splice(it, l, l.begin(), l.end() ); } void splice(const iterator& it, wxMenuList& l, const iterator& first) { if ( it != first ) { insert(it, *first); l.erase(first); } } void remove(const_reference v) { DeleteObject((const_base_reference)v); } void reverse() { Reverse(); } };
typedef wxMenuItem _WX_LIST_ITEM_TYPE_wxMenuItemList; typedef int (*wxSortFuncFor_wxMenuItemList)(const wxMenuItem **, const wxMenuItem **); class wxwxMenuItemListNode : public wxNodeBase { public: wxwxMenuItemListNode(wxListBase *list = (wxListBase *)__null, wxwxMenuItemListNode *previous = (wxwxMenuItemListNode *)__null, wxwxMenuItemListNode *next = (wxwxMenuItemListNode *)__null, wxMenuItem *data = (wxMenuItem *)__null, const wxListKey& key = wxDefaultListKey) : wxNodeBase(list, previous, next, data, key) { } wxwxMenuItemListNode *GetNext() const { return (wxwxMenuItemListNode *)wxNodeBase::GetNext(); } wxwxMenuItemListNode *GetPrevious() const { return (wxwxMenuItemListNode *)wxNodeBase::GetPrevious(); } wxMenuItem *GetData() const { return (wxMenuItem *)wxNodeBase::GetData(); } void SetData(wxMenuItem *data) { wxNodeBase::SetData(data); } protected: virtual void DeleteData(); private: wxwxMenuItemListNode(const wxwxMenuItemListNode&); wxwxMenuItemListNode& operator=(const wxwxMenuItemListNode&); }; class wxMenuItemList : public wxListBase { public: typedef wxwxMenuItemListNode Node; class compatibility_iterator { public: compatibility_iterator(Node *ptr = __null) : m_ptr(ptr) { } Node *operator->() const { return m_ptr; } operator Node *() const { return m_ptr; } private: Node *m_ptr; }; wxMenuItemList(wxKeyType keyType = wxKEY_NONE) : wxListBase(keyType) { } wxMenuItemList(const wxMenuItemList& list) : wxListBase(list.GetKeyType()) { Assign(list); } wxMenuItemList(size_t count, wxMenuItem *elements[]) : wxListBase(count, (void **)elements) { } wxMenuItemList& operator=(const wxMenuItemList& list) { Assign(list); return *this; } wxwxMenuItemListNode *GetFirst() const { return (wxwxMenuItemListNode *)wxListBase::GetFirst(); } wxwxMenuItemListNode *GetLast() const { return (wxwxMenuItemListNode *)wxListBase::GetLast(); } wxwxMenuItemListNode *Item(size_t index) const { return (wxwxMenuItemListNode *)wxListBase::Item(index); } wxMenuItem *operator[](size_t index) const { wxwxMenuItemListNode *node = Item(index); return node ? (wxMenuItem*)(node->GetData()) : (wxMenuItem*)__null; } wxwxMenuItemListNode *Append(wxMenuItem *object) { return (wxwxMenuItemListNode *)wxListBase::Append(object); } wxwxMenuItemListNode *Insert(wxMenuItem *object) { return (wxwxMenuItemListNode *)Insert((wxwxMenuItemListNode*)__null, object); } wxwxMenuItemListNode *Insert(size_t pos, wxMenuItem *object) { return (wxwxMenuItemListNode *)wxListBase::Insert(pos, object); } wxwxMenuItemListNode *Insert(wxwxMenuItemListNode *prev, wxMenuItem *object) { return (wxwxMenuItemListNode *)wxListBase::Insert(prev, object); } wxwxMenuItemListNode *Append(long key, void *object) { return (wxwxMenuItemListNode *)wxListBase::Append(key, object); } wxwxMenuItemListNode *Append(const wxChar *key, void *object) { return (wxwxMenuItemListNode *)wxListBase::Append(key, object); } wxwxMenuItemListNode *DetachNode(wxwxMenuItemListNode *node) { return (wxwxMenuItemListNode *)wxListBase::DetachNode(node); } bool DeleteNode(wxwxMenuItemListNode *node) { return wxListBase::DeleteNode(node); } bool DeleteObject(wxMenuItem *object) { return wxListBase::DeleteObject(object); } void Erase(wxwxMenuItemListNode *it) { DeleteNode(it); } wxwxMenuItemListNode *Find(const wxMenuItem *object) const { return (wxwxMenuItemListNode *)wxListBase::Find(object); } virtual wxwxMenuItemListNode *Find(const wxListKey& key) const { return (wxwxMenuItemListNode *)wxListBase::Find(key); } int IndexOf(wxMenuItem *object) const { return wxListBase::IndexOf(object); } void Sort(wxSortCompareFunction func) { wxListBase::Sort(func); } void Sort(wxSortFuncFor_wxMenuItemList func) { Sort((wxSortCompareFunction)func); } protected: virtual wxNodeBase *CreateNode(wxNodeBase *prev, wxNodeBase *next, void *data, const wxListKey& key = wxDefaultListKey) { return new wxwxMenuItemListNode(this, (wxwxMenuItemListNode *)prev, (wxwxMenuItemListNode *)next, (wxMenuItem *)data, key); } public: typedef size_t size_type; typedef int difference_type; typedef wxMenuItem* value_type; typedef wxMenuItem* base_value_type; typedef value_type& reference; typedef const value_type& const_reference; typedef base_value_type& base_reference; typedef const base_value_type& const_base_reference; class iterator { typedef wxMenuItemList list; public: typedef wxwxMenuItemListNode Node; typedef iterator itor; typedef wxMenuItem* value_type; typedef value_type* ptr_type; typedef value_type& reference; Node* m_node; Node* m_init; public: typedef reference reference_type; typedef ptr_type pointer_type; iterator(Node* node, Node* init) : m_node(node), m_init(init) {} iterator() : m_node(__null), m_init(__null) { } reference_type operator*() const { return *(pointer_type)m_node->GetDataPtr(); } itor& operator++() { m_node = m_node->GetNext(); return *this; } const itor operator++(int) { itor tmp = *this; m_node = m_node->GetNext(); return tmp; } itor& operator--() { m_node = m_node ? m_node->GetPrevious() : m_init; return *this; } const itor operator--(int) { itor tmp = *this; m_node = m_node ? m_node->GetPrevious() : m_init; return tmp; } bool operator!=(const itor& it) const { return it.m_node != m_node; } bool operator==(const itor& it) const { return it.m_node == m_node; } }; class const_iterator { typedef wxMenuItemList list; public: typedef wxwxMenuItemListNode Node; typedef wxMenuItem* value_type; typedef const value_type& const_reference; typedef const_iterator itor; typedef value_type* ptr_type; Node* m_node; Node* m_init; public: typedef const_reference reference_type; typedef const ptr_type pointer_type; const_iterator(Node* node, Node* init) : m_node(node), m_init(init) { } const_iterator() : m_node(__null), m_init(__null) { } const_iterator(const iterator& it) : m_node(it.m_node), m_init(it.m_init) { } reference_type operator*() const { return *(pointer_type)m_node->GetDataPtr(); } itor& operator++() { m_node = m_node->GetNext(); return *this; } const itor operator++(int) { itor tmp = *this; m_node = m_node->GetNext(); return tmp; } itor& operator--() { m_node = m_node ? m_node->GetPrevious() : m_init; return *this; } const itor operator--(int) { itor tmp = *this; m_node = m_node ? m_node->GetPrevious() : m_init; return tmp; } bool operator!=(const itor& it) const { return it.m_node != m_node; } bool operator==(const itor& it) const { return it.m_node == m_node; } }; class reverse_iterator { typedef wxMenuItemList list; public: typedef wxwxMenuItemListNode Node; typedef wxMenuItem* value_type; typedef reverse_iterator itor; typedef value_type* ptr_type; typedef value_type& reference; Node* m_node; Node* m_init; public: typedef reference reference_type; typedef ptr_type pointer_type; reverse_iterator(Node* node, Node* init) : m_node(node), m_init(init) { } reverse_iterator() : m_node(__null), m_init(__null) { } reference_type operator*() const { return *(pointer_type)m_node->GetDataPtr(); } itor& operator++() { m_node = m_node->GetPrevious(); return *this; } const itor operator++(int) { itor tmp = *this; m_node = m_node->GetPrevious(); return tmp; } itor& operator--() { m_node = m_node ? m_node->GetNext() : m_init; return *this; } const itor operator--(int) { itor tmp = *this; m_node = m_node ? m_node->GetNext() : m_init; return tmp; } bool operator!=(const itor& it) const { return it.m_node != m_node; } bool operator==(const itor& it) const { return it.m_node == m_node; } }; class const_reverse_iterator { typedef wxMenuItemList list; public: typedef wxwxMenuItemListNode Node; typedef wxMenuItem* value_type; typedef const_reverse_iterator itor; typedef value_type* ptr_type; typedef const value_type& const_reference; Node* m_node; Node* m_init; public: typedef const_reference reference_type; typedef const ptr_type pointer_type; const_reverse_iterator(Node* node, Node* init) : m_node(node), m_init(init) { } const_reverse_iterator() : m_node(__null), m_init(__null) { } const_reverse_iterator(const reverse_iterator& it) : m_node(it.m_node), m_init(it.m_init) { } reference_type operator*() const { return *(pointer_type)m_node->GetDataPtr(); } itor& operator++() { m_node = m_node->GetPrevious(); return *this; } const itor operator++(int) { itor tmp = *this; m_node = m_node->GetPrevious(); return tmp; } itor& operator--() { m_node = m_node ? m_node->GetNext() : m_init; return *this;} const itor operator--(int) { itor tmp = *this; m_node = m_node ? m_node->GetNext() : m_init; return tmp; } bool operator!=(const itor& it) const { return it.m_node != m_node; } bool operator==(const itor& it) const { return it.m_node == m_node; } }; explicit wxMenuItemList(size_type n, const_reference v = value_type()) { assign(n, v); } wxMenuItemList(const const_iterator& first, const const_iterator& last) { assign(first, last); } iterator begin() { return iterator(GetFirst(), GetLast()); } const_iterator begin() const { return const_iterator(GetFirst(), GetLast()); } iterator end() { return iterator(__null, GetLast()); } const_iterator end() const { return const_iterator(__null, GetLast()); } reverse_iterator rbegin() { return reverse_iterator(GetLast(), GetFirst()); } const_reverse_iterator rbegin() const { return const_reverse_iterator(GetLast(), GetFirst()); } reverse_iterator rend() { return reverse_iterator(__null, GetFirst()); } const_reverse_iterator rend() const { return const_reverse_iterator(__null, GetFirst()); } void resize(size_type n, value_type v = value_type()) { while (n < size()) pop_back(); while (n > size()) push_back(v); } size_type size() const { return GetCount(); } size_type max_size() const { return 2147483647; } bool empty() const { return IsEmpty(); } reference front() { return *begin(); } const_reference front() const { return *begin(); } reference back() { iterator tmp = end(); return *--tmp; } const_reference back() const { const_iterator tmp = end(); return *--tmp; } void push_front(const_reference v = value_type()) { Insert(GetFirst(), (const_base_reference)v); } void pop_front() { DeleteNode(GetFirst()); } void push_back(const_reference v = value_type()) { Append((const_base_reference)v); } void pop_back() { DeleteNode(GetLast()); } void assign(const_iterator first, const const_iterator& last) { clear(); for(; first != last; ++first) Append((const_base_reference)*first); } void assign(size_type n, const_reference v = value_type()) { clear(); for(size_type i = 0; i < n; ++i) Append((const_base_reference)v); } iterator insert(const iterator& it, const_reference v = value_type()) { if ( it == end() ) Append((const_base_reference)v); else Insert(it.m_node, (const_base_reference)v); iterator itprev(it); return itprev--; } void insert(const iterator& it, size_type n, const_reference v = value_type()) { for(size_type i = 0; i < n; ++i) insert(it, v); } void insert(const iterator& it, const_iterator first, const const_iterator& last) { for(; first != last; ++first) insert(it, *first); } iterator erase(const iterator& it) { iterator next = iterator(it.m_node->GetNext(), GetLast()); DeleteNode(it.m_node); return next; } iterator erase(const iterator& first, const iterator& last) { iterator next = last; if ( next != end() ) ++next; DeleteNodes(first.m_node, last.m_node); return next; } void clear() { Clear(); } void splice(const iterator& it, wxMenuItemList& l, const iterator& first, const iterator& last) { insert(it, first, last); l.erase(first, last); } void splice(const iterator& it, wxMenuItemList& l) { splice(it, l, l.begin(), l.end() ); } void splice(const iterator& it, wxMenuItemList& l, const iterator& first) { if ( it != first ) { insert(it, *first); l.erase(first); } } void remove(const_reference v) { DeleteObject((const_base_reference)v); } void reverse() { Reverse(); } };





class wxMenuBase : public wxEvtHandler
{
public:

    static wxMenu *New(const wxString& title = wxEmptyString, long style = 0);


    wxMenuBase(const wxString& title, long style = 0) : m_title(title)
        { Init(style); }
    wxMenuBase(long style = 0)
        { Init(style); }


    virtual ~wxMenuBase();





    wxMenuItem* Append(int itemid,
                       const wxString& text = wxEmptyString,
                       const wxString& help = wxEmptyString,
                       wxItemKind kind = wxITEM_NORMAL)
    {
        return DoAppend(wxMenuItem::New((wxMenu *)this, itemid, text, help, kind));
    }


    wxMenuItem* AppendSeparator() { return Append(wxID_SEPARATOR, wxEmptyString); }


    wxMenuItem* AppendCheckItem(int itemid,
                                const wxString& text,
                                const wxString& help = wxEmptyString)
    {
        return Append(itemid, text, help, wxITEM_CHECK);
    }


    wxMenuItem* AppendRadioItem(int itemid,
                                const wxString& text,
                                const wxString& help = wxEmptyString)
    {
        return Append(itemid, text, help, wxITEM_RADIO);
    }


    wxMenuItem* AppendSubMenu(wxMenu *submenu,
                              const wxString& text,
                              const wxString& help = wxEmptyString)
    {
        return DoAppend(wxMenuItem::New((wxMenu *)this, wxID_ANY, text, help,
                                        wxITEM_NORMAL, submenu));
    }


    wxMenuItem* Append(wxMenuItem *item) { return DoAppend(item); }



    virtual void Break() { }


    wxMenuItem* Insert(size_t pos, wxMenuItem *item);


    wxMenuItem* Insert(size_t pos,
                       int itemid,
                       const wxString& text = wxEmptyString,
                       const wxString& help = wxEmptyString,
                       wxItemKind kind = wxITEM_NORMAL)
    {
        return Insert(pos, wxMenuItem::New((wxMenu *)this, itemid, text, help, kind));
    }


    wxMenuItem* InsertSeparator(size_t pos)
    {
        return Insert(pos, wxMenuItem::New((wxMenu *)this, wxID_SEPARATOR));
    }


    wxMenuItem* InsertCheckItem(size_t pos,
                                int itemid,
                                const wxString& text,
                                const wxString& help = wxEmptyString)
    {
        return Insert(pos, itemid, text, help, wxITEM_CHECK);
    }


     wxMenuItem* InsertRadioItem(size_t pos,
                                 int itemid,
                                 const wxString& text,
                                 const wxString& help = wxEmptyString)
    {
        return Insert(pos, itemid, text, help, wxITEM_RADIO);
    }


    wxMenuItem* Insert(size_t pos,
                       int itemid,
                       const wxString& text,
                       wxMenu *submenu,
                       const wxString& help = wxEmptyString)
    {
        return Insert(pos, wxMenuItem::New((wxMenu *)this, itemid, text, help,
                                           wxITEM_NORMAL, submenu));
    }


    wxMenuItem* Prepend(wxMenuItem *item)
    {
        return Insert(0u, item);
    }


    wxMenuItem* Prepend(int itemid,
                        const wxString& text = wxEmptyString,
                        const wxString& help = wxEmptyString,
                        wxItemKind kind = wxITEM_NORMAL)
    {
        return Insert(0u, itemid, text, help, kind);
    }


    wxMenuItem* PrependSeparator()
    {
        return InsertSeparator(0u);
    }


    wxMenuItem* PrependCheckItem(int itemid,
                                 const wxString& text,
                                 const wxString& help = wxEmptyString)
    {
        return InsertCheckItem(0u, itemid, text, help);
    }


    wxMenuItem* PrependRadioItem(int itemid,
                                 const wxString& text,
                                 const wxString& help = wxEmptyString)
    {
        return InsertRadioItem(0u, itemid, text, help);
    }


    wxMenuItem* Prepend(int itemid,
                        const wxString& text,
                        wxMenu *submenu,
                        const wxString& help = wxEmptyString)
    {
        return Insert(0u, itemid, text, submenu, help);
    }




    wxMenuItem *Remove(int itemid) { return Remove(FindChildItem(itemid)); }
    wxMenuItem *Remove(wxMenuItem *item);



    bool Delete(int itemid) { return Delete(FindChildItem(itemid)); }
    bool Delete(wxMenuItem *item);


    bool Destroy(int itemid) { return Destroy(FindChildItem(itemid)); }
    bool Destroy(wxMenuItem *item);





    size_t GetMenuItemCount() const { return m_items.GetCount(); }

    const wxMenuItemList& GetMenuItems() const { return m_items; }
    wxMenuItemList& GetMenuItems() { return m_items; }


    virtual int FindItem(const wxString& item) const;
    wxMenuItem* FindItem(int itemid, wxMenu **menu = __null) const;


    wxMenuItem* FindItemByPosition(size_t position) const;


    void Enable(int itemid, bool enable);
    bool IsEnabled(int itemid) const;

    void Check(int itemid, bool check);
    bool IsChecked(int itemid) const;

    void SetLabel(int itemid, const wxString& label);
    wxString GetLabel(int itemid) const;

    virtual void SetHelpString(int itemid, const wxString& helpString);
    virtual wxString GetHelpString(int itemid) const;





    virtual void SetTitle(const wxString& title) { m_title = title; }
    const wxString GetTitle() const { return m_title; }


    void SetEventHandler(wxEvtHandler *handler) { m_eventHandler = handler; }
    wxEvtHandler *GetEventHandler() const { return m_eventHandler; }


    void SetInvokingWindow(wxWindow *win) { m_invokingWindow = win; }
    wxWindow *GetInvokingWindow() const { return m_invokingWindow; }


    long GetStyle() const { return m_style; }







    void UpdateUI(wxEvtHandler* source = (wxEvtHandler*)__null);



    wxMenuBar *GetMenuBar() const;


    virtual void Attach(wxMenuBarBase *menubar);
    virtual void Detach();


    bool IsAttached() const { return GetMenuBar() != __null; }


    void SetParent(wxMenu *parent) { m_menuParent = parent; }
    wxMenu *GetParent() const { return m_menuParent; }







    wxMenuItem *FindChildItem(int itemid, size_t *pos = __null) const;





    bool SendEvent(int itemid, int checked = -1);






    void Append(int itemid,
                const wxString& text,
                const wxString& help,
                bool isCheckable)
    {
        Append(itemid, text, help, isCheckable ? wxITEM_CHECK : wxITEM_NORMAL);
    }


    wxMenuItem* Append(int itemid,
                       const wxString& text,
                       wxMenu *submenu,
                       const wxString& help = wxEmptyString)
    {
        return DoAppend(wxMenuItem::New((wxMenu *)this, itemid, text, help,
                                        wxITEM_NORMAL, submenu));
    }

    void Insert(size_t pos,
                int itemid,
                const wxString& text,
                const wxString& help,
                bool isCheckable)
    {
        Insert(pos, itemid, text, help, isCheckable ? wxITEM_CHECK : wxITEM_NORMAL);
    }

    void Prepend(int itemid,
                 const wxString& text,
                 const wxString& help,
                 bool isCheckable)
    {
        Insert(0u, itemid, text, help, isCheckable);
    }

    static void LockAccels(bool locked)
    {
        ms_locked = locked;
    }

protected:



    virtual wxMenuItem* DoAppend(wxMenuItem *item);
    virtual wxMenuItem* DoInsert(size_t pos, wxMenuItem *item);

    virtual wxMenuItem *DoRemove(wxMenuItem *item);
    virtual bool DoDelete(wxMenuItem *item);
    virtual bool DoDestroy(wxMenuItem *item);





    void Init(long style);


    void AddSubMenu(wxMenu *submenu);

    wxMenuBar *m_menuBar;
    wxMenu *m_menuParent;

    wxString m_title;
    wxMenuItemList m_items;

    wxWindow *m_invokingWindow;

    long m_style;

    wxEvtHandler *m_eventHandler;

    static bool ms_locked;

    private: wxMenuBase(const wxMenuBase&); wxMenuBase& operator=(const wxMenuBase&);

public:



    wxString GetLabelText(int itemid) const { return wxMenuItem::GetLabelFromText(GetLabel(itemid)); }


};





class wxMenuBarBase : public wxWindow
{
public:

    wxMenuBarBase();


    virtual ~wxMenuBarBase();





    virtual bool Append(wxMenu *menu, const wxString& title);



    virtual bool Insert(size_t pos, wxMenu *menu, const wxString& title);





    size_t GetMenuCount() const { return m_menus.GetCount(); }


    wxMenu *GetMenu(size_t pos) const;



    virtual wxMenu *Replace(size_t pos, wxMenu *menu, const wxString& title);



    virtual wxMenu *Remove(size_t pos);


    virtual void EnableTop(size_t pos, bool enable) = 0;


    virtual bool IsEnabledTop(size_t ) const { return true; }


    virtual void SetLabelTop(size_t pos, const wxString& label) = 0;
    virtual wxString GetLabelTop(size_t pos) const = 0;






    virtual int FindMenuItem(const wxString& menu, const wxString& item) const;




    virtual wxMenuItem* FindItem(int itemid, wxMenu **menu = __null) const;


    int FindMenu(const wxString& title) const;
# 462 "/usr/include/wx-2.8/wx/menu.h"
    void Enable(int itemid, bool enable);
    void Check(int itemid, bool check);
    bool IsChecked(int itemid) const;
    bool IsEnabled(int itemid) const;
    virtual bool IsEnabled() const { return wxWindow::IsEnabled(); }

    void SetLabel(int itemid, const wxString &label);
    wxString GetLabel(int itemid) const;

    void SetHelpString(int itemid, const wxString& helpString);
    wxString GetHelpString(int itemid) const;




    wxFrame *GetFrame() const { return m_menuBarFrame; }


    bool IsAttached() const { return GetFrame() != __null; }


    virtual void Attach(wxFrame *frame);


    virtual void Detach();


    virtual bool Enable(bool enable = true) { return wxWindow::Enable(enable); }
    virtual void SetLabel(const wxString& s) { wxWindow::SetLabel(s); }
    virtual wxString GetLabel() const { return wxWindow::GetLabel(); }


    virtual bool AcceptsFocusFromKeyboard() const { return false; }


    virtual void UpdateMenus();

protected:

    wxMenuList m_menus;


    wxFrame *m_menuBarFrame;

    private: wxMenuBarBase(const wxMenuBarBase&); wxMenuBarBase& operator=(const wxMenuBarBase&);

public:



    void SetMenuLabel(size_t pos, const wxString& label) { SetLabelTop(pos, label); }






    wxString GetMenuLabelText(size_t pos) const;


};
# 540 "/usr/include/wx-2.8/wx/menu.h"
# 1 "/usr/include/wx-2.8/wx/gtk/menu.h" 1
# 17 "/usr/include/wx-2.8/wx/gtk/menu.h"
class wxMenuBar : public wxMenuBarBase
{
public:

    wxMenuBar();
    wxMenuBar(long style);
    wxMenuBar(size_t n, wxMenu *menus[], const wxString titles[], long style = 0);
    virtual ~wxMenuBar();


    virtual bool Append( wxMenu *menu, const wxString &title );
    virtual bool Insert(size_t pos, wxMenu *menu, const wxString& title);
    virtual wxMenu *Replace(size_t pos, wxMenu *menu, const wxString& title);
    virtual wxMenu *Remove(size_t pos);

    virtual int FindMenuItem(const wxString& menuString,
                             const wxString& itemString) const;
    virtual wxMenuItem* FindItem( int id, wxMenu **menu = __null ) const;

    virtual void EnableTop( size_t pos, bool flag );
    virtual void SetLabelTop( size_t pos, const wxString& label );
    virtual wxString GetLabelTop( size_t pos ) const;

    void SetLayoutDirection(wxLayoutDirection dir);
    wxLayoutDirection GetLayoutDirection() const;

    void Attach(wxFrame *frame);


    void SetInvokingWindow( wxWindow *win );
    void UnsetInvokingWindow( wxWindow *win );


    bool GtkAppend(wxMenu *menu, const wxString& title, int pos=-1);

    GtkWidget *m_menubar;
    long m_style;
    wxWindow *m_invokingWindow;

private:
    void Init(size_t n, wxMenu *menus[], const wxString titles[], long style);

    public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();

public:



    wxString GetMenuLabel(size_t pos) const;

};





class wxMenu : public wxMenuBase
{
public:

    wxMenu(const wxString& title, long style = 0)
        : wxMenuBase(title, style) { Init(); }

    wxMenu(long style = 0) : wxMenuBase(style) { Init(); }

    virtual ~wxMenu();

    void Attach(wxMenuBarBase *menubar);

    void SetLayoutDirection(const wxLayoutDirection dir);
    wxLayoutDirection GetLayoutDirection() const;




    int FindMenuIdByMenuItem( GtkWidget *menuItem ) const;


    GtkWidget *m_menu;
    GtkWidget *m_owner;
    GtkAccelGroup *m_accel;

protected:
    virtual wxMenuItem* DoAppend(wxMenuItem *item);
    virtual wxMenuItem* DoInsert(size_t pos, wxMenuItem *item);
    virtual wxMenuItem* DoRemove(wxMenuItem *item);

private:

    void Init();


    bool GtkAppend(wxMenuItem *item, int pos=-1);

    GtkWidget *m_prevRadio;

    public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};
# 541 "/usr/include/wx-2.8/wx/menu.h" 2
# 56 "/usr/include/wx-2.8/wx/wx.h" 2



# 1 "/usr/include/wx-2.8/wx/icon.h" 1
# 15 "/usr/include/wx-2.8/wx/icon.h"
# 1 "/usr/include/wx-2.8/wx/iconloc.h" 1
# 21 "/usr/include/wx-2.8/wx/iconloc.h"
class wxIconLocationBase
{
public:

    explicit wxIconLocationBase(const wxString& filename = wxEmptyString)
        : m_filename(filename) { }





    bool IsOk() const { return !m_filename.empty(); }


    void SetFileName(const wxString& filename) { m_filename = filename; }
    const wxString& GetFileName() const { return m_filename; }

private:
    wxString m_filename;
};
# 71 "/usr/include/wx-2.8/wx/iconloc.h"
class wxIconLocation : public wxIconLocationBase
{
public:
    explicit wxIconLocation(const wxString& filename = wxEmptyString)
        : wxIconLocationBase(filename) { }
};
# 16 "/usr/include/wx-2.8/wx/icon.h" 2
# 24 "/usr/include/wx-2.8/wx/icon.h"
# 1 "/usr/include/wx-2.8/wx/generic/icon.h" 1
# 25 "/usr/include/wx-2.8/wx/generic/icon.h"
class wxIcon: public wxBitmap
{
public:
    wxIcon();

    wxIcon( const char **bits, int width=-1, int height=-1 );
    wxIcon( char **bits, int width=-1, int height=-1 );



    wxIcon( const wxString& filename,
            wxBitmapType type = wxBITMAP_TYPE_XPM,
            int =-1, int =-1 ) :
        wxBitmap(filename, type)
    {
    }

    wxIcon(const wxIconLocation& loc)
        : wxBitmap(loc.GetFileName(), wxBITMAP_TYPE_ANY)
    {
    }




    void CopyFromBitmap(const wxBitmap& bmp);

private:
    public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};
# 25 "/usr/include/wx-2.8/wx/icon.h" 2
# 48 "/usr/include/wx-2.8/wx/icon.h"
 wxIcon& operator << ( wxIcon &object, const wxVariant &variant ); wxVariant& operator << ( wxVariant &variant, const wxIcon &object );
# 60 "/usr/include/wx-2.8/wx/wx.h" 2

# 1 "/usr/include/wx-2.8/wx/dialog.h" 1
# 19 "/usr/include/wx-2.8/wx/dialog.h"
class wxSizer;
class wxStdDialogButtonSizer;
# 30 "/usr/include/wx-2.8/wx/dialog.h"
extern const wxChar wxDialogNameStr[];

class wxDialogBase : public wxTopLevelWindow
{
public:
    enum
    {

        ButtonSizerFlags = 0x00000004|0x00000010|0x00000002|0x00000008|0x00008000|0x00000080
    };

    wxDialogBase() { Init(); }
    virtual ~wxDialogBase() { }


    virtual int ShowModal() = 0;
    virtual void EndModal(int retCode) = 0;
    virtual bool IsModal() const = 0;




    void SetReturnCode(int returnCode) { m_returnCode = returnCode; }
    int GetReturnCode() const { return m_returnCode; }



    void SetAffirmativeId(int affirmativeId);
    int GetAffirmativeId() const { return m_affirmativeId; }





    void SetEscapeId(int escapeId);
    int GetEscapeId() const { return m_escapeId; }




    wxSizer *CreateTextSizer( const wxString &message );







    wxSizer *CreateButtonSizer(long flags);




    wxSizer *CreateSeparatedButtonSizer(long flags);


    wxStdDialogButtonSizer *CreateStdDialogButtonSizer( long flags );


protected:



    bool EmulateButtonClickIfPresent(int id);







    virtual bool IsEscapeKey(const wxKeyEvent& event);



    void EndDialog(int rc);



    void AcceptAndClose();



    int m_returnCode;


    int m_affirmativeId;


    int m_escapeId;

private:

    void Init();


    void OnCharHook(wxKeyEvent& event);


    void OnCloseWindow(wxCloseEvent& event);


    void OnButton(wxCommandEvent& event);


    void OnSysColourChanged(wxSysColourChangedEvent& event);


    private: wxDialogBase(const wxDialogBase&); wxDialogBase& operator=(const wxDialogBase&);
    private: static const wxEventTableEntry sm_eventTableEntries[]; protected: static const wxEventTable sm_eventTable; virtual const wxEventTable* GetEventTable() const; static wxEventHashTable sm_eventHashTable; virtual wxEventHashTable& GetEventHashTable() const;
    public: void OnNavigationKey(wxNavigationKeyEvent& event); void OnFocus(wxFocusEvent& event); virtual void OnChildFocus(wxChildFocusEvent& event); virtual void SetFocus(); virtual void SetFocusIgnoringChildren(); virtual void RemoveChild(wxWindowBase *child); virtual bool AcceptsFocus() const; protected: wxControlContainer m_container;
};
# 154 "/usr/include/wx-2.8/wx/dialog.h"
# 1 "/usr/include/wx-2.8/wx/gtk/dialog.h" 1
# 20 "/usr/include/wx-2.8/wx/gtk/dialog.h"
class wxDialog;





extern const wxChar wxDialogNameStr[];





class wxDialog: public wxDialogBase
{
public:
    wxDialog() { Init(); }
    wxDialog( wxWindow *parent, wxWindowID id,
            const wxString &title,
            const wxPoint &pos = wxDefaultPosition,
            const wxSize &size = wxDefaultSize,
            long style = (0x20000000 | 0x0800 | 0x1000),
            const wxString &name = wxDialogNameStr );
    bool Create( wxWindow *parent, wxWindowID id,
            const wxString &title,
            const wxPoint &pos = wxDefaultPosition,
            const wxSize &size = wxDefaultSize,
            long style = (0x20000000 | 0x0800 | 0x1000),
            const wxString &name = wxDialogNameStr );
    virtual ~wxDialog() {}

    virtual bool Show( bool show = 1 );
    virtual int ShowModal();
    virtual void EndModal( int retCode );
    virtual bool IsModal() const;
    void SetModal( bool modal );




    bool m_modalShowing;

private:

    void Init();

    public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};
# 155 "/usr/include/wx-2.8/wx/dialog.h" 2
# 62 "/usr/include/wx-2.8/wx/wx.h" 2
# 1 "/usr/include/wx-2.8/wx/timer.h" 1
# 36 "/usr/include/wx-2.8/wx/timer.h"
class wxTimerBase : public wxEvtHandler
{
public:





    wxTimerBase()
        { Init(); SetOwner(this); }




    wxTimerBase(wxEvtHandler *owner, int timerid = wxID_ANY)
        { Init(); SetOwner(owner, timerid); }


    void SetOwner(wxEvtHandler *owner, int timerid = wxID_ANY)
    {
        m_owner = owner;
        m_idTimer = timerid == wxID_ANY ? wxWindow::NewControlId() : timerid;
    }

    wxEvtHandler *GetOwner() const { return m_owner; }

    virtual ~wxTimerBase();
# 72 "/usr/include/wx-2.8/wx/timer.h"
    virtual bool Start(int milliseconds = -1, bool oneShot = false);


    virtual void Stop() = 0;



    virtual void Notify();





    virtual bool IsRunning() const = 0;


    int GetId() const { return m_idTimer; }


    int GetInterval() const { return m_milli; }


    bool IsOneShot() const { return m_oneShot; }

protected:

    void Init()
        { m_owner = __null; m_idTimer = wxID_ANY; m_milli = 0; m_oneShot = false; }

    wxEvtHandler *m_owner;
    int m_idTimer;
    int m_milli;
    bool m_oneShot;

    private: wxTimerBase(const wxTimerBase&); wxTimerBase& operator=(const wxTimerBase&);
};
# 118 "/usr/include/wx-2.8/wx/timer.h"
# 1 "/usr/include/wx-2.8/wx/gtk/timer.h" 1
# 17 "/usr/include/wx-2.8/wx/gtk/timer.h"
class wxTimer : public wxTimerBase
{
public:
    wxTimer() { Init(); }
    wxTimer(wxEvtHandler *owner, int id = -1) : wxTimerBase(owner, id)
        { Init(); }
    virtual ~wxTimer();

    virtual bool Start( int millisecs = -1, bool oneShot = 0 );
    virtual void Stop();

    virtual bool IsRunning() const { return m_tag != -1; }

protected:
    void Init();

    int m_tag;

private:
    public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const;
};
# 119 "/usr/include/wx-2.8/wx/timer.h" 2
# 135 "/usr/include/wx-2.8/wx/timer.h"
class wxTimerRunner
{
public:
    wxTimerRunner(wxTimer& timer) : m_timer(timer) { }
    wxTimerRunner(wxTimer& timer, int milli, bool oneShot = false)
        : m_timer(timer)
    {
        m_timer.Start(milli, oneShot);
    }

    void Start(int milli, bool oneShot = false)
    {
        m_timer.Start(milli, oneShot);
    }

    ~wxTimerRunner()
    {
        if ( m_timer.IsRunning() )
        {
            m_timer.Stop();
        }
    }

private:
    wxTimer& m_timer;

    private: wxTimerRunner(const wxTimerRunner&); wxTimerRunner& operator=(const wxTimerRunner&);
};





class wxTimerEvent : public wxEvent
{
public:
    wxTimerEvent(int timerid = 0, int interval = 0) : wxEvent(timerid)
    {
        m_eventType = wxEVT_TIMER;

        m_interval = interval;
    }


    int GetInterval() const { return m_interval; }


    virtual wxEvent *Clone() const { return new wxTimerEvent(*this); }

private:
    int m_interval;

    private: wxTimerEvent& operator=(const wxTimerEvent&); public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};

typedef void (wxEvtHandler::*wxTimerEventFunction)(wxTimerEvent&);
# 63 "/usr/include/wx-2.8/wx/wx.h" 2
# 1 "/usr/include/wx-2.8/wx/settings.h" 1
# 18 "/usr/include/wx-2.8/wx/settings.h"
class wxWindow;





enum wxSystemFont
{
    wxSYS_OEM_FIXED_FONT = 10,
    wxSYS_ANSI_FIXED_FONT,
    wxSYS_ANSI_VAR_FONT,
    wxSYS_SYSTEM_FONT,
    wxSYS_DEVICE_DEFAULT_FONT,
    wxSYS_DEFAULT_PALETTE,
    wxSYS_SYSTEM_FIXED_FONT,
    wxSYS_DEFAULT_GUI_FONT,


    wxSYS_ICONTITLE_FONT = wxSYS_DEFAULT_GUI_FONT
};





enum wxSystemColour
{
    wxSYS_COLOUR_SCROLLBAR,
    wxSYS_COLOUR_BACKGROUND,
    wxSYS_COLOUR_DESKTOP = wxSYS_COLOUR_BACKGROUND,
    wxSYS_COLOUR_ACTIVECAPTION,
    wxSYS_COLOUR_INACTIVECAPTION,
    wxSYS_COLOUR_MENU,
    wxSYS_COLOUR_WINDOW,
    wxSYS_COLOUR_WINDOWFRAME,
    wxSYS_COLOUR_MENUTEXT,
    wxSYS_COLOUR_WINDOWTEXT,
    wxSYS_COLOUR_CAPTIONTEXT,
    wxSYS_COLOUR_ACTIVEBORDER,
    wxSYS_COLOUR_INACTIVEBORDER,
    wxSYS_COLOUR_APPWORKSPACE,
    wxSYS_COLOUR_HIGHLIGHT,
    wxSYS_COLOUR_HIGHLIGHTTEXT,
    wxSYS_COLOUR_BTNFACE,
    wxSYS_COLOUR_3DFACE = wxSYS_COLOUR_BTNFACE,
    wxSYS_COLOUR_BTNSHADOW,
    wxSYS_COLOUR_3DSHADOW = wxSYS_COLOUR_BTNSHADOW,
    wxSYS_COLOUR_GRAYTEXT,
    wxSYS_COLOUR_BTNTEXT,
    wxSYS_COLOUR_INACTIVECAPTIONTEXT,
    wxSYS_COLOUR_BTNHIGHLIGHT,
    wxSYS_COLOUR_BTNHILIGHT = wxSYS_COLOUR_BTNHIGHLIGHT,
    wxSYS_COLOUR_3DHIGHLIGHT = wxSYS_COLOUR_BTNHIGHLIGHT,
    wxSYS_COLOUR_3DHILIGHT = wxSYS_COLOUR_BTNHIGHLIGHT,
    wxSYS_COLOUR_3DDKSHADOW,
    wxSYS_COLOUR_3DLIGHT,
    wxSYS_COLOUR_INFOTEXT,
    wxSYS_COLOUR_INFOBK,
    wxSYS_COLOUR_LISTBOX,
    wxSYS_COLOUR_HOTLIGHT,
    wxSYS_COLOUR_GRADIENTACTIVECAPTION,
    wxSYS_COLOUR_GRADIENTINACTIVECAPTION,
    wxSYS_COLOUR_MENUHILIGHT,
    wxSYS_COLOUR_MENUBAR,
    wxSYS_COLOUR_LISTBOXTEXT,

    wxSYS_COLOUR_MAX
};





enum wxSystemMetric
{
    wxSYS_MOUSE_BUTTONS = 1,
    wxSYS_BORDER_X,
    wxSYS_BORDER_Y,
    wxSYS_CURSOR_X,
    wxSYS_CURSOR_Y,
    wxSYS_DCLICK_X,
    wxSYS_DCLICK_Y,
    wxSYS_DRAG_X,
    wxSYS_DRAG_Y,
    wxSYS_EDGE_X,
    wxSYS_EDGE_Y,
    wxSYS_HSCROLL_ARROW_X,
    wxSYS_HSCROLL_ARROW_Y,
    wxSYS_HTHUMB_X,
    wxSYS_ICON_X,
    wxSYS_ICON_Y,
    wxSYS_ICONSPACING_X,
    wxSYS_ICONSPACING_Y,
    wxSYS_WINDOWMIN_X,
    wxSYS_WINDOWMIN_Y,
    wxSYS_SCREEN_X,
    wxSYS_SCREEN_Y,
    wxSYS_FRAMESIZE_X,
    wxSYS_FRAMESIZE_Y,
    wxSYS_SMALLICON_X,
    wxSYS_SMALLICON_Y,
    wxSYS_HSCROLL_Y,
    wxSYS_VSCROLL_X,
    wxSYS_VSCROLL_ARROW_X,
    wxSYS_VSCROLL_ARROW_Y,
    wxSYS_VTHUMB_Y,
    wxSYS_CAPTION_Y,
    wxSYS_MENU_Y,
    wxSYS_NETWORK_PRESENT,
    wxSYS_PENWINDOWS_PRESENT,
    wxSYS_SHOW_SOUNDS,
    wxSYS_SWAP_BUTTONS
};


enum wxSystemFeature
{
    wxSYS_CAN_DRAW_FRAME_DECORATIONS = 1,
    wxSYS_CAN_ICONIZE_FRAME,
    wxSYS_TABLET_PRESENT
};


enum wxSystemScreenType
{
    wxSYS_SCREEN_NONE = 0,

    wxSYS_SCREEN_TINY,
    wxSYS_SCREEN_PDA,
    wxSYS_SCREEN_SMALL,
    wxSYS_SCREEN_DESKTOP
};
# 162 "/usr/include/wx-2.8/wx/settings.h"
class wxSystemSettingsNative
{
public:

    static wxColour GetColour(wxSystemColour index);


    static wxFont GetFont(wxSystemFont index);


    static int GetMetric(wxSystemMetric index, wxWindow * win = __null);


    static bool HasFeature(wxSystemFeature index);
};





class wxSystemSettings : public wxSystemSettingsNative
{
public:
# 194 "/usr/include/wx-2.8/wx/settings.h"
    static wxSystemScreenType GetScreenType();


    static void SetScreenType( wxSystemScreenType screen );


    static wxSystemScreenType ms_screen;
# 209 "/usr/include/wx-2.8/wx/settings.h"
};
# 64 "/usr/include/wx-2.8/wx/wx.h" 2
# 1 "/usr/include/wx-2.8/wx/msgdlg.h" 1
# 19 "/usr/include/wx-2.8/wx/msgdlg.h"
class wxMessageDialogBase
{
protected:

    void SetMessageDialogStyle(long style)
    {
        ;


        ;


        m_dialogStyle = style;
    }
    inline long GetMessageDialogStyle() const
    {
        return m_dialogStyle;
    }

private:
    long m_dialogStyle;
};
# 53 "/usr/include/wx-2.8/wx/msgdlg.h"
# 1 "/usr/include/wx-2.8/wx/gtk/msgdlg.h" 1
# 21 "/usr/include/wx-2.8/wx/gtk/msgdlg.h"
 extern const wxChar wxMessageBoxCaptionStr[];

class wxMessageDialog: public wxDialog, public wxMessageDialogBase
{
public:
    wxMessageDialog(wxWindow *parent, const wxString& message,
                    const wxString& caption = wxMessageBoxCaptionStr,
                    long style = 0x00000004|wxCENTRE,
                    const wxPoint& pos = wxDefaultPosition);
    virtual ~wxMessageDialog();

    int ShowModal();
    virtual bool Show( bool = true ) { return false; };

protected:


    virtual void DoSetSize(int , int ,
                           int , int ,
                           int = (0x0001|0x0002)) {}
    virtual void DoMoveWindow(int , int ,
                              int , int ) {}

private:
    wxString m_caption;
    wxString m_message;

    public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};
# 54 "/usr/include/wx-2.8/wx/msgdlg.h" 2
# 70 "/usr/include/wx-2.8/wx/msgdlg.h"
int wxMessageBox(const wxString& message,
                             const wxString& caption = wxMessageBoxCaptionStr,
                             long style = 0x00000004 | wxCENTRE,
                             wxWindow *parent = __null,
                             int x = wxDefaultCoord, int y = wxDefaultCoord);
# 65 "/usr/include/wx-2.8/wx/wx.h" 2
# 1 "/usr/include/wx-2.8/wx/cmndata.h" 1
# 17 "/usr/include/wx-2.8/wx/cmndata.h"
# 1 "/usr/include/wx-2.8/wx/encinfo.h" 1
# 35 "/usr/include/wx-2.8/wx/encinfo.h"
struct wxNativeEncodingInfo
{
    wxString facename;

    wxFontEncoding encoding;
# 69 "/usr/include/wx-2.8/wx/encinfo.h"
    bool FromString(const wxString& s);
    wxString ToString() const;
};
# 18 "/usr/include/wx-2.8/wx/cmndata.h" 2
# 26 "/usr/include/wx-2.8/wx/cmndata.h"
class wxPrintNativeDataBase;


class wxColourData: public wxObject
{
public:
    wxColourData();
    wxColourData(const wxColourData& data);
    virtual ~wxColourData();

    void SetChooseFull(bool flag) { m_chooseFull = flag; }
    bool GetChooseFull() const { return m_chooseFull; }
    void SetColour(const wxColour& colour) { m_dataColour = colour; }
    const wxColour& GetColour() const { return m_dataColour; }
    wxColour& GetColour() { return m_dataColour; }


    void SetCustomColour(int i, const wxColour& colour);
    wxColour GetCustomColour(int i);

    void operator=(const wxColourData& data);

public:
    wxColour m_dataColour;
    wxColour m_custColours[16];
    bool m_chooseFull;

private:
    public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};

class wxFontData : public wxObject
{
public:
    wxFontData();
    virtual ~wxFontData();

    wxFontData(const wxFontData& data)
        : wxObject(),
          m_fontColour(data.m_fontColour),
          m_showHelp(data.m_showHelp),
          m_allowSymbols(data.m_allowSymbols),
          m_enableEffects(data.m_enableEffects),
          m_initialFont(data.m_initialFont),
          m_chosenFont(data.m_chosenFont),
          m_minSize(data.m_minSize),
          m_maxSize(data.m_maxSize),
          m_encoding(data.m_encoding),
          m_encodingInfo(data.m_encodingInfo)
    {
    }

    wxFontData& operator=(const wxFontData& data)
    {
        wxObject::operator=(data);
        m_fontColour = data.m_fontColour;
        m_showHelp = data.m_showHelp;
        m_allowSymbols = data.m_allowSymbols;
        m_enableEffects = data.m_enableEffects;
        m_initialFont = data.m_initialFont;
        m_chosenFont = data.m_chosenFont;
        m_minSize = data.m_minSize;
        m_maxSize = data.m_maxSize;
        m_encoding = data.m_encoding;
        m_encodingInfo = data.m_encodingInfo;
        return *this;
    }

    void SetAllowSymbols(bool flag) { m_allowSymbols = flag; }
    bool GetAllowSymbols() const { return m_allowSymbols; }

    void SetColour(const wxColour& colour) { m_fontColour = colour; }
    const wxColour& GetColour() const { return m_fontColour; }

    void SetShowHelp(bool flag) { m_showHelp = flag; }
    bool GetShowHelp() const { return m_showHelp; }

    void EnableEffects(bool flag) { m_enableEffects = flag; }
    bool GetEnableEffects() const { return m_enableEffects; }

    void SetInitialFont(const wxFont& font) { m_initialFont = font; }
    wxFont GetInitialFont() const { return m_initialFont; }

    void SetChosenFont(const wxFont& font) { m_chosenFont = font; }
    wxFont GetChosenFont() const { return m_chosenFont; }

    void SetRange(int minRange, int maxRange) { m_minSize = minRange; m_maxSize = maxRange; }




    wxFontEncoding GetEncoding() const { return m_encoding; }
    void SetEncoding(wxFontEncoding encoding) { m_encoding = encoding; }

    wxNativeEncodingInfo& EncodingInfo() { return m_encodingInfo; }



public:
    wxColour m_fontColour;
    bool m_showHelp;
    bool m_allowSymbols;
    bool m_enableEffects;
    wxFont m_initialFont;
    wxFont m_chosenFont;
    int m_minSize;
    int m_maxSize;

private:
    wxFontEncoding m_encoding;
    wxNativeEncodingInfo m_encodingInfo;

private:
    public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};







enum wxPrintBin
{
    wxPRINTBIN_DEFAULT,

    wxPRINTBIN_ONLYONE,
    wxPRINTBIN_LOWER,
    wxPRINTBIN_MIDDLE,
    wxPRINTBIN_MANUAL,
    wxPRINTBIN_ENVELOPE,
    wxPRINTBIN_ENVMANUAL,
    wxPRINTBIN_AUTO,
    wxPRINTBIN_TRACTOR,
    wxPRINTBIN_SMALLFMT,
    wxPRINTBIN_LARGEFMT,
    wxPRINTBIN_LARGECAPACITY,
    wxPRINTBIN_CASSETTE,
    wxPRINTBIN_FORMSOURCE,

    wxPRINTBIN_USER
};

const int wxPRINTMEDIA_DEFAULT = 0;

class wxPrintData: public wxObject
{
public:
    wxPrintData();
    wxPrintData(const wxPrintData& printData);
    virtual ~wxPrintData();

    int GetNoCopies() const { return m_printNoCopies; }
    bool GetCollate() const { return m_printCollate; }
    int GetOrientation() const { return m_printOrientation; }
    bool IsOrientationReversed() const { return m_printOrientationReversed; }


    bool Ok() const { return IsOk(); }
    bool IsOk() const ;

    const wxString& GetPrinterName() const { return m_printerName; }
    bool GetColour() const { return m_colour; }
    wxDuplexMode GetDuplex() const { return m_duplexMode; }
    wxPaperSize GetPaperId() const { return m_paperId; }
    const wxSize& GetPaperSize() const { return m_paperSize; }

    wxPrintQuality GetQuality() const { return m_printQuality; }
    wxPrintBin GetBin() const { return m_bin; }
    wxPrintMode GetPrintMode() const { return m_printMode; }
    int GetMedia() const { return m_media; }

    void SetNoCopies(int v) { m_printNoCopies = v; }
    void SetCollate(bool flag) { m_printCollate = flag; }
    void SetOrientation(int orient) { m_printOrientation = orient; }
    void SetOrientationReversed(bool reversed) { m_printOrientationReversed = reversed; }

    void SetPrinterName(const wxString& name) { m_printerName = name; }
    void SetColour(bool colour) { m_colour = colour; }
    void SetDuplex(wxDuplexMode duplex) { m_duplexMode = duplex; }
    void SetPaperId(wxPaperSize sizeId) { m_paperId = sizeId; }
    void SetPaperSize(const wxSize& sz) { m_paperSize = sz; }
    void SetQuality(wxPrintQuality quality) { m_printQuality = quality; }
    void SetBin(wxPrintBin bin) { m_bin = bin; }
    void SetMedia(int media) { m_media = media; }
    void SetPrintMode(wxPrintMode printMode) { m_printMode = printMode; }

    wxString GetFilename() const { return m_filename; }
    void SetFilename( const wxString &filename ) { m_filename = filename; }

    void operator=(const wxPrintData& data);

    char* GetPrivData() const { return m_privData; }
    int GetPrivDataLen() const { return m_privDataLen; }
    void SetPrivData( char *privData, int len );
# 247 "/usr/include/wx-2.8/wx/cmndata.h"
    void ConvertToNative();
    void ConvertFromNative();

    wxPrintNativeDataBase *GetNativeData() const { return m_nativeData; }

private:
    wxPrintBin m_bin;
    int m_media;
    wxPrintMode m_printMode;

    int m_printNoCopies;
    int m_printOrientation;
    bool m_printOrientationReversed;
    bool m_printCollate;

    wxString m_printerName;
    bool m_colour;
    wxDuplexMode m_duplexMode;
    wxPrintQuality m_printQuality;
    wxPaperSize m_paperId;
    wxSize m_paperSize;

    wxString m_filename;

    char* m_privData;
    int m_privDataLen;

    wxPrintNativeDataBase *m_nativeData;

private:
    public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};
# 287 "/usr/include/wx-2.8/wx/cmndata.h"
class wxPrintDialogData: public wxObject
{
public:
    wxPrintDialogData();
    wxPrintDialogData(const wxPrintDialogData& dialogData);
    wxPrintDialogData(const wxPrintData& printData);
    virtual ~wxPrintDialogData();

    int GetFromPage() const { return m_printFromPage; }
    int GetToPage() const { return m_printToPage; }
    int GetMinPage() const { return m_printMinPage; }
    int GetMaxPage() const { return m_printMaxPage; }
    int GetNoCopies() const { return m_printNoCopies; }
    bool GetAllPages() const { return m_printAllPages; }
    bool GetSelection() const { return m_printSelection; }
    bool GetCollate() const { return m_printCollate; }
    bool GetPrintToFile() const { return m_printToFile; }



    void SetFromPage(int v) { m_printFromPage = v; }
    void SetToPage(int v) { m_printToPage = v; }
    void SetMinPage(int v) { m_printMinPage = v; }
    void SetMaxPage(int v) { m_printMaxPage = v; }
    void SetNoCopies(int v) { m_printNoCopies = v; }
    void SetAllPages(bool flag) { m_printAllPages = flag; }
    void SetSelection(bool flag) { m_printSelection = flag; }
    void SetCollate(bool flag) { m_printCollate = flag; }
    void SetPrintToFile(bool flag) { m_printToFile = flag; }



    void EnablePrintToFile(bool flag) { m_printEnablePrintToFile = flag; }
    void EnableSelection(bool flag) { m_printEnableSelection = flag; }
    void EnablePageNumbers(bool flag) { m_printEnablePageNumbers = flag; }
    void EnableHelp(bool flag) { m_printEnableHelp = flag; }

    bool GetEnablePrintToFile() const { return m_printEnablePrintToFile; }
    bool GetEnableSelection() const { return m_printEnableSelection; }
    bool GetEnablePageNumbers() const { return m_printEnablePageNumbers; }
    bool GetEnableHelp() const { return m_printEnableHelp; }


    bool Ok() const { return IsOk(); }
    bool IsOk() const { return m_printData.Ok() ; }

    wxPrintData& GetPrintData() { return m_printData; }
    void SetPrintData(const wxPrintData& printData) { m_printData = printData; }

    void operator=(const wxPrintDialogData& data);
    void operator=(const wxPrintData& data);

private:
    int m_printFromPage;
    int m_printToPage;
    int m_printMinPage;
    int m_printMaxPage;
    int m_printNoCopies;
    bool m_printAllPages;
    bool m_printCollate;
    bool m_printToFile;
    bool m_printSelection;
    bool m_printEnableSelection;
    bool m_printEnablePageNumbers;
    bool m_printEnableHelp;
    bool m_printEnablePrintToFile;



    wxPrintData m_printData;

private:
    public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};
# 369 "/usr/include/wx-2.8/wx/cmndata.h"
class wxPageSetupDialogData: public wxObject
{
public:
    wxPageSetupDialogData();
    wxPageSetupDialogData(const wxPageSetupDialogData& dialogData);
    wxPageSetupDialogData(const wxPrintData& printData);
    virtual ~wxPageSetupDialogData();

    wxSize GetPaperSize() const { return m_paperSize; }
    wxPaperSize GetPaperId() const { return m_printData.GetPaperId(); }
    wxPoint GetMinMarginTopLeft() const { return m_minMarginTopLeft; }
    wxPoint GetMinMarginBottomRight() const { return m_minMarginBottomRight; }
    wxPoint GetMarginTopLeft() const { return m_marginTopLeft; }
    wxPoint GetMarginBottomRight() const { return m_marginBottomRight; }

    bool GetDefaultMinMargins() const { return m_defaultMinMargins; }
    bool GetEnableMargins() const { return m_enableMargins; }
    bool GetEnableOrientation() const { return m_enableOrientation; }
    bool GetEnablePaper() const { return m_enablePaper; }
    bool GetEnablePrinter() const { return m_enablePrinter; }
    bool GetDefaultInfo() const { return m_getDefaultInfo; }
    bool GetEnableHelp() const { return m_enableHelp; }


    bool Ok() const { return IsOk(); }
    bool IsOk() const { return m_printData.Ok() ; }



    void SetPaperSize(const wxSize& sz);

    void SetPaperId(wxPaperSize id) { m_printData.SetPaperId(id); }


    void SetPaperSize(wxPaperSize id);

    void SetMinMarginTopLeft(const wxPoint& pt) { m_minMarginTopLeft = pt; }
    void SetMinMarginBottomRight(const wxPoint& pt) { m_minMarginBottomRight = pt; }
    void SetMarginTopLeft(const wxPoint& pt) { m_marginTopLeft = pt; }
    void SetMarginBottomRight(const wxPoint& pt) { m_marginBottomRight = pt; }
    void SetDefaultMinMargins(bool flag) { m_defaultMinMargins = flag; }
    void SetDefaultInfo(bool flag) { m_getDefaultInfo = flag; }

    void EnableMargins(bool flag) { m_enableMargins = flag; }
    void EnableOrientation(bool flag) { m_enableOrientation = flag; }
    void EnablePaper(bool flag) { m_enablePaper = flag; }
    void EnablePrinter(bool flag) { m_enablePrinter = flag; }
    void EnableHelp(bool flag) { m_enableHelp = flag; }



    void CalculateIdFromPaperSize();


    void CalculatePaperSizeFromId();

    wxPageSetupDialogData& operator=(const wxPageSetupDialogData& data);
    wxPageSetupDialogData& operator=(const wxPrintData& data);

    wxPrintData& GetPrintData() { return m_printData; }
    const wxPrintData& GetPrintData() const { return m_printData; }
    void SetPrintData(const wxPrintData& printData);

private:
    wxSize m_paperSize;
    wxPoint m_minMarginTopLeft;
    wxPoint m_minMarginBottomRight;
    wxPoint m_marginTopLeft;
    wxPoint m_marginBottomRight;
    bool m_defaultMinMargins;
    bool m_enableMargins;
    bool m_enableOrientation;
    bool m_enablePaper;
    bool m_enablePrinter;
    bool m_getDefaultInfo;
    bool m_enableHelp;
    wxPrintData m_printData;

private:
    public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};
# 66 "/usr/include/wx-2.8/wx/wx.h" 2
# 1 "/usr/include/wx-2.8/wx/dataobj.h" 1
# 80 "/usr/include/wx-2.8/wx/dataobj.h"
# 1 "/usr/include/wx-2.8/wx/gtk/dataform.h" 1
# 15 "/usr/include/wx-2.8/wx/gtk/dataform.h"
class wxDataFormat
{
public:

    typedef GdkAtom NativeFormat;

    wxDataFormat();
    wxDataFormat( wxDataFormatId type );
    wxDataFormat( const wxString &id );
    wxDataFormat( const wxChar *id );
    wxDataFormat( NativeFormat format );

    wxDataFormat& operator=(const wxDataFormat& format)
        { m_type = format.m_type; m_format = format.m_format; return *this; }
    wxDataFormat& operator=(NativeFormat format)
        { SetId(format); return *this; }


    bool operator==(NativeFormat format) const
        { return m_format == (NativeFormat)format; }
    bool operator!=(NativeFormat format) const
        { return m_format != (NativeFormat)format; }
    bool operator==(wxDataFormatId format) const
        { return m_type == (wxDataFormatId)format; }
    bool operator!=(wxDataFormatId format) const
        { return m_type != (wxDataFormatId)format; }




    NativeFormat GetFormatId() const { return m_format; }
    operator NativeFormat() const { return m_format; }

    void SetId( NativeFormat format );



    wxString GetId() const;
    void SetId( const wxChar *id );


    wxDataFormatId GetType() const;
    void SetType( wxDataFormatId type );

private:
    wxDataFormatId m_type;
    NativeFormat m_format;

    void PrepareFormats();
};
# 81 "/usr/include/wx-2.8/wx/dataobj.h" 2
# 95 "/usr/include/wx-2.8/wx/dataobj.h"
extern const wxDataFormat& wxFormatInvalid;
# 117 "/usr/include/wx-2.8/wx/dataobj.h"
class wxDataObjectBase
{
public:
    enum Direction
    {
        Get = 0x01,
        Set = 0x02,
        Both = 0x03
    };


    virtual ~wxDataObjectBase();


    virtual wxDataFormat GetPreferredFormat(Direction dir = Get) const = 0;


    virtual size_t GetFormatCount(Direction dir = Get) const = 0;


    virtual void GetAllFormats(wxDataFormat *formats,
                               Direction dir = Get) const = 0;


    virtual size_t GetDataSize(const wxDataFormat& format) const = 0;



    virtual bool GetDataHere(const wxDataFormat& format, void *buf) const = 0;



    virtual bool SetData(const wxDataFormat& ,
                         size_t , const void * )
    {
        return false;
    }


    bool IsSupported(const wxDataFormat& format, Direction dir = Get) const;
};
# 170 "/usr/include/wx-2.8/wx/dataobj.h"
# 1 "/usr/include/wx-2.8/wx/gtk/dataobj.h" 1
# 17 "/usr/include/wx-2.8/wx/gtk/dataobj.h"
class wxDataObject : public wxDataObjectBase
{
public:
    wxDataObject();
    virtual ~wxDataObject();

    virtual bool IsSupportedFormat( const wxDataFormat& format, Direction dir = Get ) const;
};
# 171 "/usr/include/wx-2.8/wx/dataobj.h" 2
# 197 "/usr/include/wx-2.8/wx/dataobj.h"
class wxDataObjectSimple : public wxDataObject
{
public:


    wxDataObjectSimple(const wxDataFormat& format = wxFormatInvalid)
        : m_format(format)
        {
        }


    const wxDataFormat& GetFormat() const { return m_format; }
    void SetFormat(const wxDataFormat& format) { m_format = format; }






    virtual size_t GetDataSize() const
        { return 0; }


    virtual bool GetDataHere(void *) const
        { return false; }


    virtual bool SetData(size_t , const void *)
        { return false; }



    virtual wxDataFormat GetPreferredFormat(wxDataObjectBase::Direction = Get) const
        { return m_format; }
    virtual size_t GetFormatCount(wxDataObjectBase::Direction = Get) const
        { return 1; }
    virtual void GetAllFormats(wxDataFormat *formats,
                               wxDataObjectBase::Direction = Get) const
        { *formats = m_format; }
    virtual size_t GetDataSize(const wxDataFormat& ) const
        { return GetDataSize(); }
    virtual bool GetDataHere(const wxDataFormat& ,
                             void *buf) const
        { return GetDataHere(buf); }
    virtual bool SetData(const wxDataFormat& ,
                         size_t len, const void *buf)
        { return SetData(len, buf); }

private:

    wxDataFormat m_format;

    private: wxDataObjectSimple(const wxDataObjectSimple&); wxDataObjectSimple& operator=(const wxDataObjectSimple&);
};
# 262 "/usr/include/wx-2.8/wx/dataobj.h"
typedef wxDataObjectSimple _WX_LIST_ITEM_TYPE_wxSimpleDataObjectList; typedef int (*wxSortFuncFor_wxSimpleDataObjectList)(const wxDataObjectSimple **, const wxDataObjectSimple **); class wxwxSimpleDataObjectListNode : public wxNodeBase { public: wxwxSimpleDataObjectListNode(wxListBase *list = (wxListBase *)__null, wxwxSimpleDataObjectListNode *previous = (wxwxSimpleDataObjectListNode *)__null, wxwxSimpleDataObjectListNode *next = (wxwxSimpleDataObjectListNode *)__null, wxDataObjectSimple *data = (wxDataObjectSimple *)__null, const wxListKey& key = wxDefaultListKey) : wxNodeBase(list, previous, next, data, key) { } wxwxSimpleDataObjectListNode *GetNext() const { return (wxwxSimpleDataObjectListNode *)wxNodeBase::GetNext(); } wxwxSimpleDataObjectListNode *GetPrevious() const { return (wxwxSimpleDataObjectListNode *)wxNodeBase::GetPrevious(); } wxDataObjectSimple *GetData() const { return (wxDataObjectSimple *)wxNodeBase::GetData(); } void SetData(wxDataObjectSimple *data) { wxNodeBase::SetData(data); } protected: virtual void DeleteData(); private: wxwxSimpleDataObjectListNode(const wxwxSimpleDataObjectListNode&); wxwxSimpleDataObjectListNode& operator=(const wxwxSimpleDataObjectListNode&); }; class wxSimpleDataObjectList : public wxListBase { public: typedef wxwxSimpleDataObjectListNode Node; class compatibility_iterator { public: compatibility_iterator(Node *ptr = __null) : m_ptr(ptr) { } Node *operator->() const { return m_ptr; } operator Node *() const { return m_ptr; } private: Node *m_ptr; }; wxSimpleDataObjectList(wxKeyType keyType = wxKEY_NONE) : wxListBase(keyType) { } wxSimpleDataObjectList(const wxSimpleDataObjectList& list) : wxListBase(list.GetKeyType()) { Assign(list); } wxSimpleDataObjectList(size_t count, wxDataObjectSimple *elements[]) : wxListBase(count, (void **)elements) { } wxSimpleDataObjectList& operator=(const wxSimpleDataObjectList& list) { Assign(list); return *this; } wxwxSimpleDataObjectListNode *GetFirst() const { return (wxwxSimpleDataObjectListNode *)wxListBase::GetFirst(); } wxwxSimpleDataObjectListNode *GetLast() const { return (wxwxSimpleDataObjectListNode *)wxListBase::GetLast(); } wxwxSimpleDataObjectListNode *Item(size_t index) const { return (wxwxSimpleDataObjectListNode *)wxListBase::Item(index); } wxDataObjectSimple *operator[](size_t index) const { wxwxSimpleDataObjectListNode *node = Item(index); return node ? (wxDataObjectSimple*)(node->GetData()) : (wxDataObjectSimple*)__null; } wxwxSimpleDataObjectListNode *Append(wxDataObjectSimple *object) { return (wxwxSimpleDataObjectListNode *)wxListBase::Append(object); } wxwxSimpleDataObjectListNode *Insert(wxDataObjectSimple *object) { return (wxwxSimpleDataObjectListNode *)Insert((wxwxSimpleDataObjectListNode*)__null, object); } wxwxSimpleDataObjectListNode *Insert(size_t pos, wxDataObjectSimple *object) { return (wxwxSimpleDataObjectListNode *)wxListBase::Insert(pos, object); } wxwxSimpleDataObjectListNode *Insert(wxwxSimpleDataObjectListNode *prev, wxDataObjectSimple *object) { return (wxwxSimpleDataObjectListNode *)wxListBase::Insert(prev, object); } wxwxSimpleDataObjectListNode *Append(long key, void *object) { return (wxwxSimpleDataObjectListNode *)wxListBase::Append(key, object); } wxwxSimpleDataObjectListNode *Append(const wxChar *key, void *object) { return (wxwxSimpleDataObjectListNode *)wxListBase::Append(key, object); } wxwxSimpleDataObjectListNode *DetachNode(wxwxSimpleDataObjectListNode *node) { return (wxwxSimpleDataObjectListNode *)wxListBase::DetachNode(node); } bool DeleteNode(wxwxSimpleDataObjectListNode *node) { return wxListBase::DeleteNode(node); } bool DeleteObject(wxDataObjectSimple *object) { return wxListBase::DeleteObject(object); } void Erase(wxwxSimpleDataObjectListNode *it) { DeleteNode(it); } wxwxSimpleDataObjectListNode *Find(const wxDataObjectSimple *object) const { return (wxwxSimpleDataObjectListNode *)wxListBase::Find(object); } virtual wxwxSimpleDataObjectListNode *Find(const wxListKey& key) const { return (wxwxSimpleDataObjectListNode *)wxListBase::Find(key); } int IndexOf(wxDataObjectSimple *object) const { return wxListBase::IndexOf(object); } void Sort(wxSortCompareFunction func) { wxListBase::Sort(func); } void Sort(wxSortFuncFor_wxSimpleDataObjectList func) { Sort((wxSortCompareFunction)func); } protected: virtual wxNodeBase *CreateNode(wxNodeBase *prev, wxNodeBase *next, void *data, const wxListKey& key = wxDefaultListKey) { return new wxwxSimpleDataObjectListNode(this, (wxwxSimpleDataObjectListNode *)prev, (wxwxSimpleDataObjectListNode *)next, (wxDataObjectSimple *)data, key); } public: typedef size_t size_type; typedef int difference_type; typedef wxDataObjectSimple* value_type; typedef wxDataObjectSimple* base_value_type; typedef value_type& reference; typedef const value_type& const_reference; typedef base_value_type& base_reference; typedef const base_value_type& const_base_reference; class iterator { typedef wxSimpleDataObjectList list; public: typedef wxwxSimpleDataObjectListNode Node; typedef iterator itor; typedef wxDataObjectSimple* value_type; typedef value_type* ptr_type; typedef value_type& reference; Node* m_node; Node* m_init; public: typedef reference reference_type; typedef ptr_type pointer_type; iterator(Node* node, Node* init) : m_node(node), m_init(init) {} iterator() : m_node(__null), m_init(__null) { } reference_type operator*() const { return *(pointer_type)m_node->GetDataPtr(); } itor& operator++() { m_node = m_node->GetNext(); return *this; } const itor operator++(int) { itor tmp = *this; m_node = m_node->GetNext(); return tmp; } itor& operator--() { m_node = m_node ? m_node->GetPrevious() : m_init; return *this; } const itor operator--(int) { itor tmp = *this; m_node = m_node ? m_node->GetPrevious() : m_init; return tmp; } bool operator!=(const itor& it) const { return it.m_node != m_node; } bool operator==(const itor& it) const { return it.m_node == m_node; } }; class const_iterator { typedef wxSimpleDataObjectList list; public: typedef wxwxSimpleDataObjectListNode Node; typedef wxDataObjectSimple* value_type; typedef const value_type& const_reference; typedef const_iterator itor; typedef value_type* ptr_type; Node* m_node; Node* m_init; public: typedef const_reference reference_type; typedef const ptr_type pointer_type; const_iterator(Node* node, Node* init) : m_node(node), m_init(init) { } const_iterator() : m_node(__null), m_init(__null) { } const_iterator(const iterator& it) : m_node(it.m_node), m_init(it.m_init) { } reference_type operator*() const { return *(pointer_type)m_node->GetDataPtr(); } itor& operator++() { m_node = m_node->GetNext(); return *this; } const itor operator++(int) { itor tmp = *this; m_node = m_node->GetNext(); return tmp; } itor& operator--() { m_node = m_node ? m_node->GetPrevious() : m_init; return *this; } const itor operator--(int) { itor tmp = *this; m_node = m_node ? m_node->GetPrevious() : m_init; return tmp; } bool operator!=(const itor& it) const { return it.m_node != m_node; } bool operator==(const itor& it) const { return it.m_node == m_node; } }; class reverse_iterator { typedef wxSimpleDataObjectList list; public: typedef wxwxSimpleDataObjectListNode Node; typedef wxDataObjectSimple* value_type; typedef reverse_iterator itor; typedef value_type* ptr_type; typedef value_type& reference; Node* m_node; Node* m_init; public: typedef reference reference_type; typedef ptr_type pointer_type; reverse_iterator(Node* node, Node* init) : m_node(node), m_init(init) { } reverse_iterator() : m_node(__null), m_init(__null) { } reference_type operator*() const { return *(pointer_type)m_node->GetDataPtr(); } itor& operator++() { m_node = m_node->GetPrevious(); return *this; } const itor operator++(int) { itor tmp = *this; m_node = m_node->GetPrevious(); return tmp; } itor& operator--() { m_node = m_node ? m_node->GetNext() : m_init; return *this; } const itor operator--(int) { itor tmp = *this; m_node = m_node ? m_node->GetNext() : m_init; return tmp; } bool operator!=(const itor& it) const { return it.m_node != m_node; } bool operator==(const itor& it) const { return it.m_node == m_node; } }; class const_reverse_iterator { typedef wxSimpleDataObjectList list; public: typedef wxwxSimpleDataObjectListNode Node; typedef wxDataObjectSimple* value_type; typedef const_reverse_iterator itor; typedef value_type* ptr_type; typedef const value_type& const_reference; Node* m_node; Node* m_init; public: typedef const_reference reference_type; typedef const ptr_type pointer_type; const_reverse_iterator(Node* node, Node* init) : m_node(node), m_init(init) { } const_reverse_iterator() : m_node(__null), m_init(__null) { } const_reverse_iterator(const reverse_iterator& it) : m_node(it.m_node), m_init(it.m_init) { } reference_type operator*() const { return *(pointer_type)m_node->GetDataPtr(); } itor& operator++() { m_node = m_node->GetPrevious(); return *this; } const itor operator++(int) { itor tmp = *this; m_node = m_node->GetPrevious(); return tmp; } itor& operator--() { m_node = m_node ? m_node->GetNext() : m_init; return *this;} const itor operator--(int) { itor tmp = *this; m_node = m_node ? m_node->GetNext() : m_init; return tmp; } bool operator!=(const itor& it) const { return it.m_node != m_node; } bool operator==(const itor& it) const { return it.m_node == m_node; } }; explicit wxSimpleDataObjectList(size_type n, const_reference v = value_type()) { assign(n, v); } wxSimpleDataObjectList(const const_iterator& first, const const_iterator& last) { assign(first, last); } iterator begin() { return iterator(GetFirst(), GetLast()); } const_iterator begin() const { return const_iterator(GetFirst(), GetLast()); } iterator end() { return iterator(__null, GetLast()); } const_iterator end() const { return const_iterator(__null, GetLast()); } reverse_iterator rbegin() { return reverse_iterator(GetLast(), GetFirst()); } const_reverse_iterator rbegin() const { return const_reverse_iterator(GetLast(), GetFirst()); } reverse_iterator rend() { return reverse_iterator(__null, GetFirst()); } const_reverse_iterator rend() const { return const_reverse_iterator(__null, GetFirst()); } void resize(size_type n, value_type v = value_type()) { while (n < size()) pop_back(); while (n > size()) push_back(v); } size_type size() const { return GetCount(); } size_type max_size() const { return 2147483647; } bool empty() const { return IsEmpty(); } reference front() { return *begin(); } const_reference front() const { return *begin(); } reference back() { iterator tmp = end(); return *--tmp; } const_reference back() const { const_iterator tmp = end(); return *--tmp; } void push_front(const_reference v = value_type()) { Insert(GetFirst(), (const_base_reference)v); } void pop_front() { DeleteNode(GetFirst()); } void push_back(const_reference v = value_type()) { Append((const_base_reference)v); } void pop_back() { DeleteNode(GetLast()); } void assign(const_iterator first, const const_iterator& last) { clear(); for(; first != last; ++first) Append((const_base_reference)*first); } void assign(size_type n, const_reference v = value_type()) { clear(); for(size_type i = 0; i < n; ++i) Append((const_base_reference)v); } iterator insert(const iterator& it, const_reference v = value_type()) { if ( it == end() ) Append((const_base_reference)v); else Insert(it.m_node, (const_base_reference)v); iterator itprev(it); return itprev--; } void insert(const iterator& it, size_type n, const_reference v = value_type()) { for(size_type i = 0; i < n; ++i) insert(it, v); } void insert(const iterator& it, const_iterator first, const const_iterator& last) { for(; first != last; ++first) insert(it, *first); } iterator erase(const iterator& it) { iterator next = iterator(it.m_node->GetNext(), GetLast()); DeleteNode(it.m_node); return next; } iterator erase(const iterator& first, const iterator& last) { iterator next = last; if ( next != end() ) ++next; DeleteNodes(first.m_node, last.m_node); return next; } void clear() { Clear(); } void splice(const iterator& it, wxSimpleDataObjectList& l, const iterator& first, const iterator& last) { insert(it, first, last); l.erase(first, last); } void splice(const iterator& it, wxSimpleDataObjectList& l) { splice(it, l, l.begin(), l.end() ); } void splice(const iterator& it, wxSimpleDataObjectList& l, const iterator& first) { if ( it != first ) { insert(it, *first); l.erase(first); } } void remove(const_reference v) { DeleteObject((const_base_reference)v); } void reverse() { Reverse(); } };

class wxDataObjectComposite : public wxDataObject
{
public:

    wxDataObjectComposite();
    virtual ~wxDataObjectComposite();




    void Add(wxDataObjectSimple *dataObject, bool preferred = false);





    wxDataFormat GetReceivedFormat() const;



    virtual wxDataFormat GetPreferredFormat(wxDataObjectBase::Direction dir = Get) const;
    virtual size_t GetFormatCount(wxDataObjectBase::Direction dir = Get) const;
    virtual void GetAllFormats(wxDataFormat *formats, wxDataObjectBase::Direction dir = Get) const;
    virtual size_t GetDataSize(const wxDataFormat& format) const;
    virtual bool GetDataHere(const wxDataFormat& format, void *buf) const;
    virtual bool SetData(const wxDataFormat& format, size_t len, const void *buf);
# 298 "/usr/include/wx-2.8/wx/dataobj.h"
protected:

    wxDataObjectSimple *GetObject(const wxDataFormat& format) const;

private:

    wxSimpleDataObjectList m_dataObjects;



    size_t m_preferred;

    wxDataFormat m_receivedFormat;

    private: wxDataObjectComposite(const wxDataObjectComposite&); wxDataObjectComposite& operator=(const wxDataObjectComposite&);
};
# 327 "/usr/include/wx-2.8/wx/dataobj.h"
class wxTextDataObject : public wxDataObjectSimple
{
public:


    wxTextDataObject(const wxString& text = wxEmptyString)
        : wxDataObjectSimple(

                             wxDF_UNICODETEXT



                            ),
          m_text(text)
        {
        }



    virtual size_t GetTextLength() const { return m_text.Len() + 1; }
    virtual wxString GetText() const { return m_text; }
    virtual void SetText(const wxString& text) { m_text = text; }






    virtual size_t GetFormatCount(Direction = Get) const { return 2; }
    virtual void GetAllFormats(wxDataFormat *formats,
                               wxDataObjectBase::Direction = Get) const;

    virtual size_t GetDataSize() const { return GetDataSize(GetPreferredFormat()); }
    virtual bool GetDataHere(void *buf) const { return GetDataHere(GetPreferredFormat(), buf); }
    virtual bool SetData(size_t len, const void *buf) { return SetData(GetPreferredFormat(), len, buf); }

    size_t GetDataSize(const wxDataFormat& format) const;
    bool GetDataHere(const wxDataFormat& format, void *pBuf) const;
    bool SetData(const wxDataFormat& format, size_t nLen, const void* pBuf);
# 385 "/usr/include/wx-2.8/wx/dataobj.h"
private:
    wxString m_text;

    private: wxTextDataObject(const wxTextDataObject&); wxTextDataObject& operator=(const wxTextDataObject&);
};





class wxBitmapDataObjectBase : public wxDataObjectSimple
{
public:


    wxBitmapDataObjectBase(const wxBitmap& bitmap = wxNullBitmap)
        : wxDataObjectSimple(wxDF_BITMAP), m_bitmap(bitmap)
        {
        }



    virtual wxBitmap GetBitmap() const { return m_bitmap; }
    virtual void SetBitmap(const wxBitmap& bitmap) { m_bitmap = bitmap; }

protected:
    wxBitmap m_bitmap;

    private: wxBitmapDataObjectBase(const wxBitmapDataObjectBase&); wxBitmapDataObjectBase& operator=(const wxBitmapDataObjectBase&);
};
# 423 "/usr/include/wx-2.8/wx/dataobj.h"
class wxFileDataObjectBase : public wxDataObjectSimple
{
public:

    wxFileDataObjectBase() : wxDataObjectSimple(wxDF_FILENAME) { }


    const wxArrayString& GetFilenames() const { return m_filenames; }

protected:
    wxArrayString m_filenames;

    private: wxFileDataObjectBase(const wxFileDataObjectBase&); wxFileDataObjectBase& operator=(const wxFileDataObjectBase&);
};







class wxCustomDataObject : public wxDataObjectSimple
{
public:


    wxCustomDataObject(const wxDataFormat& format = wxFormatInvalid);


    virtual ~wxCustomDataObject();




    void TakeData(size_t size, void *data);



    virtual void *Alloc(size_t size);




    virtual void Free();



    virtual size_t GetSize() const { return m_size; }
    virtual void *GetData() const { return m_data; }



    virtual size_t GetDataSize() const;
    virtual bool GetDataHere(void *buf) const;
    virtual bool SetData(size_t size, const void *buf);

    virtual size_t GetDataSize(const wxDataFormat&) const
    {
        return GetDataSize();
    }
    virtual bool GetDataHere(const wxDataFormat&, void *buf) const
    {
        return GetDataHere(buf);
    }
    virtual bool SetData(const wxDataFormat&, size_t len, const void *buf)
    {
        return SetData(len, buf);
    }

private:
    size_t m_size;
    void *m_data;

    private: wxCustomDataObject(const wxCustomDataObject&); wxCustomDataObject& operator=(const wxCustomDataObject&);
};
# 509 "/usr/include/wx-2.8/wx/dataobj.h"
# 1 "/usr/include/wx-2.8/wx/gtk/dataobj2.h" 1
# 18 "/usr/include/wx-2.8/wx/gtk/dataobj2.h"
class wxBitmapDataObject : public wxBitmapDataObjectBase
{
public:

    wxBitmapDataObject();
    wxBitmapDataObject(const wxBitmap& bitmap);


    virtual ~wxBitmapDataObject();


    virtual void SetBitmap(const wxBitmap& bitmap);




    virtual size_t GetDataSize() const { return m_pngSize; }
    virtual bool GetDataHere(void *buf) const;
    virtual bool SetData(size_t len, const void *buf);

    virtual size_t GetDataSize(const wxDataFormat&) const
    {
        return GetDataSize();
    }
    virtual bool GetDataHere(const wxDataFormat&, void *buf) const
    {
        return GetDataHere(buf);
    }
    virtual bool SetData(const wxDataFormat&, size_t len, const void *buf)
    {
        return SetData(len, buf);
    }

protected:
    void Init() { m_pngData = (void *)__null; m_pngSize = 0; }
    void Clear() { free(m_pngData); }
    void ClearAll() { Clear(); Init(); }

    size_t m_pngSize;
    void *m_pngData;

    void DoConvertToPng();
};





class wxFileDataObject : public wxFileDataObjectBase
{
public:



    void AddFile( const wxString &filename );

    virtual size_t GetDataSize() const;
    virtual bool GetDataHere(void *buf) const;
    virtual bool SetData(size_t len, const void *buf);

    virtual size_t GetDataSize(const wxDataFormat&) const
    {
        return GetDataSize();
    }
    virtual bool GetDataHere(const wxDataFormat&, void *buf) const
    {
        return GetDataHere(buf);
    }
    virtual bool SetData(const wxDataFormat&, size_t len, const void *buf)
    {
        return SetData(len, buf);
    }
};
# 510 "/usr/include/wx-2.8/wx/dataobj.h" 2
# 525 "/usr/include/wx-2.8/wx/dataobj.h"
    class wxURLDataObject : public wxTextDataObject
    {
    public:
        wxURLDataObject(const wxString& url = wxEmptyString)
            : wxTextDataObject(url)
        {
        }

        wxString GetURL() const { return GetText(); }
        void SetURL(const wxString& url) { SetText(url); }
    };
# 67 "/usr/include/wx-2.8/wx/wx.h" 2


# 1 "/usr/include/wx-2.8/wx/ctrlsub.h" 1
# 32 "/usr/include/wx-2.8/wx/ctrlsub.h"
class wxItemContainerImmutable
{
public:
    wxItemContainerImmutable() { }
    virtual ~wxItemContainerImmutable();




    virtual unsigned int GetCount() const = 0;
    bool IsEmpty() const { return GetCount() == 0; }

    virtual wxString GetString(unsigned int n) const = 0;
    wxArrayString GetStrings() const;
    virtual void SetString(unsigned int n, const wxString& s) = 0;




    virtual int FindString(const wxString& s, bool bCase = false) const
    {
        unsigned int count = GetCount();

        for ( unsigned int i = 0; i < count ; ++i )
        {
            if (GetString(i).IsSameAs( s , bCase ))
                return (int)i;
        }

        return (-1);
    }





    virtual void SetSelection(int n) = 0;
    virtual int GetSelection() const = 0;


    bool SetStringSelection(const wxString& s);


    wxString GetStringSelection() const;



    void Select(int n) { SetSelection(n); }


protected:


    inline bool IsValid(unsigned int n) const { return n < GetCount(); }
    inline bool IsValidInsert(unsigned int n) const { return n <= GetCount(); }
};

class wxItemContainer : public wxItemContainerImmutable
{
public:
    wxItemContainer() { m_clientDataItemsType = wxClientData_None; }
    virtual ~wxItemContainer();




    int Append(const wxString& item)
        { return DoAppend(item); }
    int Append(const wxString& item, void *clientData)
        { int n = DoAppend(item); SetClientData(n, clientData); return n; }
    int Append(const wxString& item, wxClientData *clientData)
        { int n = DoAppend(item); SetClientObject(n, clientData); return n; }


    void AppendString( const wxString& item)
        { Append( item ); }


    void Append(const wxArrayString& strings);

    int Insert(const wxString& item, unsigned int pos)
        { return DoInsert(item, pos); }
    int Insert(const wxString& item, unsigned int pos, void *clientData);
    int Insert(const wxString& item, unsigned int pos, wxClientData *clientData);




    virtual void Clear() = 0;
    virtual void Delete(unsigned int n) = 0;





    void SetClientData(unsigned int n, void* clientData);
    void* GetClientData(unsigned int n) const;

    void SetClientObject(unsigned int n, wxClientData* clientData);
    wxClientData* GetClientObject(unsigned int n) const;

    bool HasClientObjectData() const
        { return m_clientDataItemsType == wxClientData_Object; }
    bool HasClientUntypedData() const
        { return m_clientDataItemsType == wxClientData_Void; }

protected:
    virtual int DoAppend(const wxString& item) = 0;
    virtual int DoInsert(const wxString& item, unsigned int pos) = 0;

    virtual void DoSetItemClientData(unsigned int n, void* clientData) = 0;
    virtual void* DoGetItemClientData(unsigned int n) const = 0;
    virtual void DoSetItemClientObject(unsigned int n, wxClientData* clientData) = 0;
    virtual wxClientData* DoGetItemClientObject(unsigned int n) const = 0;



    wxClientDataType m_clientDataItemsType;
};
# 174 "/usr/include/wx-2.8/wx/ctrlsub.h"
class wxControlWithItems : public wxControl, public wxItemContainer
{
public:
    wxControlWithItems() { }
    virtual ~wxControlWithItems();






    void SetClientData(void *data) { wxEvtHandler::SetClientData(data); } void *GetClientData() const { return wxEvtHandler::GetClientData(); } void SetClientObject(wxClientData *data) { wxEvtHandler::SetClientObject(data); } wxClientData *GetClientObject() const { return wxEvtHandler::GetClientObject(); } void SetClientData(unsigned int n, void* clientData) { wxItemContainer::SetClientData(n, clientData); } void* GetClientData(unsigned int n) const { return wxItemContainer::GetClientData(n); } void SetClientObject(unsigned int n, wxClientData* clientData) { wxItemContainer::SetClientObject(n, clientData); } wxClientData* GetClientObject(unsigned int n) const { return wxItemContainer::GetClientObject(n); }



    virtual bool ShouldInheritColours() const { return false; }

protected:




    void InitCommandEventWithItems(wxCommandEvent& event, int n);

private:
    public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const;
    private: wxControlWithItems(const wxControlWithItems&); wxControlWithItems& operator=(const wxControlWithItems&);
};
# 70 "/usr/include/wx-2.8/wx/wx.h" 2
# 1 "/usr/include/wx-2.8/wx/bmpbuttn.h" 1
# 22 "/usr/include/wx-2.8/wx/bmpbuttn.h"
extern const wxChar wxButtonNameStr[];






class wxBitmapButtonBase : public wxButton
{
public:
    wxBitmapButtonBase()
    {
        m_marginX =
        m_marginY = 0;
    }


    void SetBitmapLabel(const wxBitmap& bitmap)
        { m_bmpNormal = bitmap; OnSetBitmap(); }
    void SetBitmapSelected(const wxBitmap& sel)
        { m_bmpSelected = sel; OnSetBitmap(); }
    void SetBitmapFocus(const wxBitmap& focus)
        { m_bmpFocus = focus; OnSetBitmap(); }
    void SetBitmapDisabled(const wxBitmap& disabled)
        { m_bmpDisabled = disabled; OnSetBitmap(); }
    void SetBitmapHover(const wxBitmap& hover)
        { m_bmpHover = hover; OnSetBitmap(); }


    const wxBitmap& GetBitmapLabel() const { return m_bmpNormal; }
    const wxBitmap& GetBitmapSelected() const { return m_bmpSelected; }
    const wxBitmap& GetBitmapFocus() const { return m_bmpFocus; }
    const wxBitmap& GetBitmapDisabled() const { return m_bmpDisabled; }
    const wxBitmap& GetBitmapHover() const { return m_bmpHover; }
    wxBitmap& GetBitmapLabel() { return m_bmpNormal; }
    wxBitmap& GetBitmapSelected() { return m_bmpSelected; }
    wxBitmap& GetBitmapFocus() { return m_bmpFocus; }
    wxBitmap& GetBitmapDisabled() { return m_bmpDisabled; }
    wxBitmap& GetBitmapHover() { return m_bmpHover; }


    virtual void SetMargins(int x, int y) { m_marginX = x; m_marginY = y; }
    int GetMarginX() const { return m_marginX; }
    int GetMarginY() const { return m_marginY; }



    void SetLabel(const wxBitmap& bitmap) __attribute__ ((deprecated));


    virtual void SetLabel(const wxString& label)
        { wxWindow::SetLabel(label); }


protected:

    virtual void OnSetBitmap() { InvalidateBestSize(); Refresh(); }


    wxBitmap m_bmpNormal,
             m_bmpSelected,
             m_bmpFocus,
             m_bmpDisabled,
             m_bmpHover;


    int m_marginX,
        m_marginY;


    private: wxBitmapButtonBase(const wxBitmapButtonBase&); wxBitmapButtonBase& operator=(const wxBitmapButtonBase&);
};


inline void wxBitmapButtonBase::SetLabel(const wxBitmap& bitmap)
{
    SetBitmapLabel(bitmap);
}
# 109 "/usr/include/wx-2.8/wx/bmpbuttn.h"
# 1 "/usr/include/wx-2.8/wx/gtk/bmpbuttn.h" 1
# 18 "/usr/include/wx-2.8/wx/gtk/bmpbuttn.h"
class wxBitmapButton: public wxBitmapButtonBase
{
public:
    wxBitmapButton() { Init(); }

    wxBitmapButton(wxWindow *parent,
                   wxWindowID id,
                   const wxBitmap& bitmap,
                   const wxPoint& pos = wxDefaultPosition,
                   const wxSize& size = wxDefaultSize,
                   long style = 0x0004,
                   const wxValidator& validator = wxDefaultValidator,
                   const wxString& name = wxButtonNameStr)
    {
        Init();

        Create(parent, id, bitmap, pos, size, style, validator, name);
    }

    bool Create(wxWindow *parent,
                wxWindowID id,
                const wxBitmap& bitmap,
                const wxPoint& pos = wxDefaultPosition,
                const wxSize& size = wxDefaultSize,
                long style = 0x0004,
                const wxValidator& validator = wxDefaultValidator,
                const wxString& name = wxButtonNameStr);

    void SetLabel( const wxString &label );
    virtual void SetLabel( const wxBitmap& bitmap ) { SetBitmapLabel(bitmap); }

    virtual void SetDefault();
    virtual bool Enable(bool enable = 1);




    void HasFocus();
    void NotFocus();
    void StartSelect();
    void EndSelect();

    bool m_hasFocus:1;
    bool m_isSelected:1;

protected:
    virtual void OnSetBitmap();
    virtual wxSize DoGetBestSize() const;
    void DoApplyWidgetStyle(GtkRcStyle *style);

    void Init();

private:
    void OnFocusChange(wxFocusEvent& event);

    public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};
# 110 "/usr/include/wx-2.8/wx/bmpbuttn.h" 2
# 71 "/usr/include/wx-2.8/wx/wx.h" 2
# 1 "/usr/include/wx-2.8/wx/checkbox.h" 1
# 44 "/usr/include/wx-2.8/wx/checkbox.h"
enum wxCheckBoxState
{
    wxCHK_UNCHECKED,
    wxCHK_CHECKED,
    wxCHK_UNDETERMINED
};


extern const wxChar wxCheckBoxNameStr[];





class wxCheckBoxBase : public wxControl
{
public:
    wxCheckBoxBase() { }


    virtual void SetValue(bool value) = 0;
    virtual bool GetValue() const = 0;

    bool IsChecked() const
    {
        ;


        return GetValue();
    }

    wxCheckBoxState Get3StateValue() const
    {
        wxCheckBoxState state = DoGet3StateValue();

        if ( state == wxCHK_UNDETERMINED && !Is3State() )
        {

            ;


            state = wxCHK_UNCHECKED;
        }

        return state;
    }

    void Set3StateValue(wxCheckBoxState state)
    {
        if ( state == wxCHK_UNDETERMINED && !Is3State() )
        {
            ;
            state = wxCHK_UNCHECKED;
        }

        DoSet3StateValue(state);
    }

    bool Is3State() const { return HasFlag(0x1000); }

    bool Is3rdStateAllowedForUser() const
    {
        return HasFlag(0x2000);
    }

    virtual bool HasTransparentBackground() { return true; }


    virtual void DoUpdateWindowUI(wxUpdateUIEvent& event)
    {
        wxControl::DoUpdateWindowUI(event);

        if ( event.GetSetChecked() )
            SetValue(event.GetChecked());
    }

protected:
    virtual void DoSet3StateValue(wxCheckBoxState ) { ; }

    virtual wxCheckBoxState DoGet3StateValue() const
    {
        ;
        return wxCHK_UNCHECKED;
    }

private:
    private: wxCheckBoxBase(const wxCheckBoxBase&); wxCheckBoxBase& operator=(const wxCheckBoxBase&);
};
# 140 "/usr/include/wx-2.8/wx/checkbox.h"
# 1 "/usr/include/wx-2.8/wx/gtk/checkbox.h" 1
# 17 "/usr/include/wx-2.8/wx/gtk/checkbox.h"
class wxCheckBox : public wxCheckBoxBase
{
public:
    wxCheckBox();
    wxCheckBox( wxWindow *parent, wxWindowID id, const wxString& label,
            const wxPoint& pos = wxDefaultPosition,
            const wxSize& size = wxDefaultSize, long style = 0,
            const wxValidator& validator = wxDefaultValidator,
            const wxString& name = wxCheckBoxNameStr)
    {
        Create(parent, id, label, pos, size, style, validator, name);
    }
    bool Create(wxWindow *parent,
                wxWindowID id,
                const wxString& label,
                const wxPoint& pos = wxDefaultPosition,
                const wxSize& size = wxDefaultSize,
                long style = 0,
                const wxValidator& validator = wxDefaultValidator,
                const wxString& name = wxCheckBoxNameStr );

    void SetValue( bool state );
    bool GetValue() const;

    virtual void SetLabel( const wxString& label );
    virtual bool Enable( bool enable = 1 );

    static wxVisualAttributes
    GetClassDefaultAttributes(wxWindowVariant variant = wxWINDOW_VARIANT_NORMAL);




    GtkWidget *m_widgetCheckbox;
    GtkWidget *m_widgetLabel;

    bool m_blockEvent;

protected:
    virtual wxSize DoGetBestSize() const;
    virtual void DoApplyWidgetStyle(GtkRcStyle *style);
    virtual GdkWindow *GTKGetWindow(wxArrayGdkWindows& windows) const;

    void DoSet3StateValue(wxCheckBoxState state);
    wxCheckBoxState DoGet3StateValue() const;

private:
    public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};
# 141 "/usr/include/wx-2.8/wx/checkbox.h" 2
# 72 "/usr/include/wx-2.8/wx/wx.h" 2
# 1 "/usr/include/wx-2.8/wx/checklst.h" 1
# 17 "/usr/include/wx-2.8/wx/checklst.h"
# 1 "/usr/include/wx-2.8/wx/listbox.h" 1
# 26 "/usr/include/wx-2.8/wx/listbox.h"
class wxArrayInt;
class wxArrayString;





extern const wxChar wxListBoxNameStr[];





class wxListBoxBase : public wxControlWithItems
{
public:
    wxListBoxBase() { }
    virtual ~wxListBoxBase();



    void Insert(const wxString& item, unsigned int pos)
        { wxControlWithItems::Insert(item,pos); }
    void Insert(const wxString& item, unsigned int pos, void *clientData)
        { wxControlWithItems::Insert(item,pos,clientData); }
    void Insert(const wxString& item, unsigned int pos, wxClientData *clientData)
        { wxControlWithItems::Insert(item,pos,clientData); }

    void InsertItems(unsigned int nItems, const wxString *items, unsigned int pos);
    void InsertItems(const wxArrayString& items, unsigned int pos)
        { DoInsertItems(items, pos); }

    void Set(int n, const wxString* items, void **clientData = __null);
    void Set(const wxArrayString& items, void **clientData = __null)
        { DoSetItems(items, clientData); }


    virtual bool IsSelected(int n) const = 0;
    virtual void SetSelection(int n) { DoSetSelection(n, true); }
    void SetSelection(int n, bool select) { DoSetSelection(n, select); }
    void Deselect(int n) { DoSetSelection(n, false); }
    void DeselectAll(int itemToLeaveSelected = -1);

    virtual bool SetStringSelection(const wxString& s, bool select);
    virtual bool SetStringSelection(const wxString& s)
    {
        return SetStringSelection(s, true);
    }



    virtual int GetSelections(wxArrayInt& aSelections) const = 0;



    void SetFirstItem(int n) { DoSetFirstItem(n); }
    void SetFirstItem(const wxString& s);



    virtual void EnsureVisible(int n);



    void AppendAndEnsureVisible(const wxString& s);


    bool HasMultipleSelection() const
    {
        return (m_windowStyle & 0x0040) ||
               (m_windowStyle & 0x0080);
    }


    bool IsSorted() const { return (m_windowStyle & 0x0010) != 0; }



    void Command(wxCommandEvent& event);


    int HitTest(const wxPoint& point) const { return DoListHitTest(point); }




    bool Selected(int n) const __attribute__ ((deprecated));


protected:


    virtual int DoInsert(const wxString& item, unsigned int pos)
        { InsertItems(1, &item, pos); return pos; }


    virtual void DoInsertItems(const wxArrayString& items, unsigned int pos) = 0;
    virtual void DoSetItems(const wxArrayString& items, void **clientData) = 0;

    virtual void DoSetFirstItem(int n) = 0;

    virtual void DoSetSelection(int n, bool select) = 0;


    virtual int DoListHitTest(const wxPoint& ) const
        { return (-1); }


    private: wxListBoxBase(const wxListBoxBase&); wxListBoxBase& operator=(const wxListBoxBase&);
};


    inline bool wxListBoxBase::Selected(int n) const { return IsSelected(n); }
# 152 "/usr/include/wx-2.8/wx/listbox.h"
# 1 "/usr/include/wx-2.8/wx/gtk/listbox.h" 1
# 17 "/usr/include/wx-2.8/wx/gtk/listbox.h"
class wxListBox : public wxListBoxBase
{
public:

    wxListBox()
    {
        Init();
    }
    wxListBox( wxWindow *parent, wxWindowID id,
            const wxPoint& pos = wxDefaultPosition,
            const wxSize& size = wxDefaultSize,
            int n = 0, const wxString choices[] = (const wxString *) __null,
            long style = 0,
            const wxValidator& validator = wxDefaultValidator,
            const wxString& name = wxListBoxNameStr )
    {
        Init();
        Create(parent, id, pos, size, n, choices, style, validator, name);
    }
    wxListBox( wxWindow *parent, wxWindowID id,
            const wxPoint& pos,
            const wxSize& size,
            const wxArrayString& choices,
            long style = 0,
            const wxValidator& validator = wxDefaultValidator,
            const wxString& name = wxListBoxNameStr )
    {
        Init();
        Create(parent, id, pos, size, choices, style, validator, name);
    }
    virtual ~wxListBox();

    bool Create(wxWindow *parent, wxWindowID id,
                const wxPoint& pos = wxDefaultPosition,
                const wxSize& size = wxDefaultSize,
                int n = 0, const wxString choices[] = (const wxString *) __null,
                long style = 0,
                const wxValidator& validator = wxDefaultValidator,
                const wxString& name = wxListBoxNameStr);
    bool Create(wxWindow *parent, wxWindowID id,
                const wxPoint& pos,
                const wxSize& size,
                const wxArrayString& choices,
                long style = 0,
                const wxValidator& validator = wxDefaultValidator,
                const wxString& name = wxListBoxNameStr);


    virtual void Clear();
    virtual void Delete(unsigned int n);

    virtual unsigned int GetCount() const;
    virtual wxString GetString(unsigned int n) const;
    virtual void SetString(unsigned int n, const wxString& s);
    virtual int FindString(const wxString& s, bool bCase = false) const;

    virtual bool IsSelected(int n) const;
    virtual int GetSelection() const;
    virtual int GetSelections(wxArrayInt& aSelections) const;

    virtual void EnsureVisible(int n);

    static wxVisualAttributes
    GetClassDefaultAttributes(wxWindowVariant variant = wxWINDOW_VARIANT_NORMAL);



    GtkWidget *GetConnectWidget();


    void ApplyToolTip( GtkTooltips *tips, const wxChar *tip );


    struct _GtkTreeView *m_treeview;
    struct _GtkListStore *m_liststore;


    bool m_hasCheckBoxes;


    bool m_blockEvent;

    struct _GtkTreeEntry* GtkGetEntry(int pos) const;
    void GtkInsertItems(const wxArrayString& items,
                        void** clientData, unsigned int pos);
    void GtkDeselectAll();
    void GtkSetSelection(int n, const bool select, const bool blockEvent);

protected:
    virtual wxSize DoGetBestSize() const;
    virtual void DoApplyWidgetStyle(GtkRcStyle *style);
    virtual GdkWindow *GTKGetWindow(wxArrayGdkWindows& windows) const;

    virtual void DoSetSelection(int n, bool select);
    virtual int DoAppend(const wxString& item);
    virtual void DoInsertItems(const wxArrayString& items, unsigned int pos);
    virtual void DoSetItems(const wxArrayString& items, void **clientData);
    virtual void DoSetFirstItem(int n);
    virtual void DoSetItemClientData(unsigned int n, void* clientData);
    virtual void* DoGetItemClientData(unsigned int n) const;
    virtual void DoSetItemClientObject(unsigned int n, wxClientData* clientData);
    virtual wxClientData* DoGetItemClientObject(unsigned int n) const;
    virtual int DoListHitTest(const wxPoint& point) const;

private:
    void Init();


    void DoScrollToCell(int n, float alignY, float alignX);

    public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};
# 153 "/usr/include/wx-2.8/wx/listbox.h" 2
# 18 "/usr/include/wx-2.8/wx/checklst.h" 2





class wxCheckListBoxBase : public




                                                  wxListBox

{
public:
    wxCheckListBoxBase() { }


    virtual bool IsChecked(unsigned int item) const = 0;
    virtual void Check(unsigned int item, bool check = true) = 0;

    private: wxCheckListBoxBase(const wxCheckListBoxBase&); wxCheckListBoxBase& operator=(const wxCheckListBoxBase&);
};
# 50 "/usr/include/wx-2.8/wx/checklst.h"
# 1 "/usr/include/wx-2.8/wx/gtk/checklst.h" 1
# 31 "/usr/include/wx-2.8/wx/gtk/checklst.h"
class wxCheckListBox : public wxListBox
{
public:
    wxCheckListBox();
    wxCheckListBox(wxWindow *parent, wxWindowID id,
            const wxPoint& pos = wxDefaultPosition,
            const wxSize& size = wxDefaultSize,
            int nStrings = 0,
            const wxString *choices = (const wxString *)__null,
            long style = 0,
            const wxValidator& validator = wxDefaultValidator,
            const wxString& name = wxListBoxNameStr);
    wxCheckListBox(wxWindow *parent, wxWindowID id,
            const wxPoint& pos,
            const wxSize& size,
            const wxArrayString& choices,
            long style = 0,
            const wxValidator& validator = wxDefaultValidator,
            const wxString& name = wxListBoxNameStr);

    bool IsChecked(unsigned int index) const;
    void Check(unsigned int index, bool check = true);

    int GetItemHeight() const;

    void DoCreateCheckList();

private:
    public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};
# 51 "/usr/include/wx-2.8/wx/checklst.h" 2
# 73 "/usr/include/wx-2.8/wx/wx.h" 2
# 1 "/usr/include/wx-2.8/wx/choice.h" 1
# 29 "/usr/include/wx-2.8/wx/choice.h"
extern const wxChar wxChoiceNameStr[];





class wxChoiceBase : public wxControlWithItems
{
public:
    wxChoiceBase() { }
    virtual ~wxChoiceBase();
# 48 "/usr/include/wx-2.8/wx/choice.h"
    virtual int GetCurrentSelection() const { return GetSelection(); }



    virtual void SetColumns(int = 1 ) { }
    virtual int GetColumns() const { return 1 ; }


    void Command(wxCommandEvent& event);

private:
    private: wxChoiceBase(const wxChoiceBase&); wxChoiceBase& operator=(const wxChoiceBase&);
};
# 75 "/usr/include/wx-2.8/wx/choice.h"
# 1 "/usr/include/wx-2.8/wx/gtk/choice.h" 1
# 13 "/usr/include/wx-2.8/wx/gtk/choice.h"
class wxSortedArrayString;
class wxArrayString;





class wxChoice : public wxChoiceBase
{
public:
    wxChoice();
    wxChoice( wxWindow *parent, wxWindowID id,
            const wxPoint& pos = wxDefaultPosition,
            const wxSize& size = wxDefaultSize,
            int n = 0, const wxString choices[] = (const wxString *) __null,
            long style = 0,
            const wxValidator& validator = wxDefaultValidator,
            const wxString& name = wxChoiceNameStr )
    {
        m_strings = (wxSortedArrayString *)__null;

        Create(parent, id, pos, size, n, choices, style, validator, name);
    }
    wxChoice( wxWindow *parent, wxWindowID id,
            const wxPoint& pos,
            const wxSize& size,
            const wxArrayString& choices,
            long style = 0,
            const wxValidator& validator = wxDefaultValidator,
            const wxString& name = wxChoiceNameStr )
    {
        m_strings = (wxSortedArrayString *)__null;

        Create(parent, id, pos, size, choices, style, validator, name);
    }
    virtual ~wxChoice();
    bool Create( wxWindow *parent, wxWindowID id,
            const wxPoint& pos = wxDefaultPosition,
            const wxSize& size = wxDefaultSize,
            int n = 0, const wxString choices[] = (wxString *) __null,
            long style = 0,
            const wxValidator& validator = wxDefaultValidator,
            const wxString& name = wxChoiceNameStr );
    bool Create( wxWindow *parent, wxWindowID id,
            const wxPoint& pos,
            const wxSize& size,
            const wxArrayString& choices,
            long style = 0,
            const wxValidator& validator = wxDefaultValidator,
            const wxString& name = wxChoiceNameStr );


    void Delete(unsigned int n);
    void Clear();

    int GetSelection() const;
    void SetSelection(int n);

    virtual unsigned int GetCount() const;
    virtual int FindString(const wxString& s, bool bCase = false) const;
    virtual wxString GetString(unsigned int n) const;
    virtual void SetString(unsigned int n, const wxString& string);

    static wxVisualAttributes
    GetClassDefaultAttributes(wxWindowVariant variant = wxWINDOW_VARIANT_NORMAL);

protected:
    wxList m_clientList;

    virtual wxSize DoGetBestSize() const;
    virtual void DoApplyWidgetStyle(GtkRcStyle *style);
    virtual GdkWindow *GTKGetWindow(wxArrayGdkWindows& windows) const;

    virtual int DoAppend(const wxString& item);
    virtual int DoInsert(const wxString& item, unsigned int pos);

    virtual void DoSetItemClientData(unsigned int n, void* clientData);
    virtual void* DoGetItemClientData(unsigned int n) const;
    virtual void DoSetItemClientObject(unsigned int n, wxClientData* clientData);
    virtual wxClientData* DoGetItemClientObject(unsigned int n) const;

private:

    int GtkAddHelper(GtkWidget *menu, unsigned int pos, const wxString& item);



    wxSortedArrayString *m_strings;

public:


    int m_selection_hack;

private:
    public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};
# 76 "/usr/include/wx-2.8/wx/choice.h" 2
# 74 "/usr/include/wx-2.8/wx/wx.h" 2
# 1 "/usr/include/wx-2.8/wx/scrolbar.h" 1
# 21 "/usr/include/wx-2.8/wx/scrolbar.h"
extern const wxChar wxScrollBarNameStr[];





class wxScrollBarBase : public wxControl
{
public:
    wxScrollBarBase() { }


    bool Create(wxWindow *parent,
                wxWindowID id,
                const wxPoint& pos = wxDefaultPosition,
                const wxSize& size = wxDefaultSize,
                long style = wxHORIZONTAL,
                const wxValidator& validator = wxDefaultValidator,
                const wxString& name = wxScrollBarNameStr);


    virtual int GetThumbPosition() const = 0;
    virtual int GetThumbSize() const = 0;
    virtual int GetPageSize() const = 0;
    virtual int GetRange() const = 0;

    bool IsVertical() const { return (m_windowStyle & wxVERTICAL) != 0; }


    virtual void SetThumbPosition(int viewStart) = 0;
    virtual void SetScrollbar(int position, int thumbSize,
                              int range, int pageSize,
                              bool refresh = true) = 0;

private:
    private: wxScrollBarBase(const wxScrollBarBase&); wxScrollBarBase& operator=(const wxScrollBarBase&);
};
# 66 "/usr/include/wx-2.8/wx/scrolbar.h"
# 1 "/usr/include/wx-2.8/wx/gtk/scrolbar.h" 1
# 19 "/usr/include/wx-2.8/wx/gtk/scrolbar.h"
class wxScrollBar;





class wxScrollBar: public wxScrollBarBase
{
public:
    wxScrollBar();
    inline wxScrollBar( wxWindow *parent, wxWindowID id,
           const wxPoint& pos = wxDefaultPosition,
           const wxSize& size = wxDefaultSize,
           long style = wxHORIZONTAL,
           const wxValidator& validator = wxDefaultValidator,
           const wxString& name = wxScrollBarNameStr )
    {
        Create( parent, id, pos, size, style, validator, name );
    }
    bool Create( wxWindow *parent, wxWindowID id,
           const wxPoint& pos = wxDefaultPosition,
           const wxSize& size = wxDefaultSize,
           long style = wxHORIZONTAL,
           const wxValidator& validator = wxDefaultValidator,
           const wxString& name = wxScrollBarNameStr );
    virtual ~wxScrollBar();
    int GetThumbPosition() const;
    int GetThumbSize() const;
    int GetPageSize() const;
    int GetRange() const;
    virtual void SetThumbPosition( int viewStart );
    virtual void SetScrollbar( int position, int thumbSize, int range, int pageSize,
      bool refresh = true );

    void SetThumbSize(int thumbSize);
    void SetPageSize( int pageLength );
    void SetRange(int range);

    static wxVisualAttributes
    GetClassDefaultAttributes(wxWindowVariant variant = wxWINDOW_VARIANT_NORMAL);

protected:
    virtual GdkWindow *GTKGetWindow(wxArrayGdkWindows& windows) const;

private:
    public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};
# 67 "/usr/include/wx-2.8/wx/scrolbar.h" 2
# 75 "/usr/include/wx-2.8/wx/wx.h" 2
# 1 "/usr/include/wx-2.8/wx/stattext.h" 1
# 21 "/usr/include/wx-2.8/wx/stattext.h"
extern const wxChar wxStaticTextNameStr[];

class wxStaticTextBase : public wxControl
{
public:
    wxStaticTextBase() { }
# 39 "/usr/include/wx-2.8/wx/stattext.h"
    virtual bool AcceptsFocus() const { return false; }
    virtual bool HasTransparentBackground() { return true; }

private:
    private: wxStaticTextBase(const wxStaticTextBase&); wxStaticTextBase& operator=(const wxStaticTextBase&);
};
# 53 "/usr/include/wx-2.8/wx/stattext.h"
# 1 "/usr/include/wx-2.8/wx/gtk/stattext.h" 1
# 17 "/usr/include/wx-2.8/wx/gtk/stattext.h"
class wxStaticText : public wxControl
{
public:
    wxStaticText();
    wxStaticText(wxWindow *parent,
                 wxWindowID id,
                 const wxString &label,
                 const wxPoint &pos = wxDefaultPosition,
                 const wxSize &size = wxDefaultSize,
                 long style = 0,
                 const wxString &name = wxStaticTextNameStr );

    bool Create(wxWindow *parent,
                wxWindowID id,
                const wxString &label,
                const wxPoint &pos = wxDefaultPosition,
                const wxSize &size = wxDefaultSize,
                long style = 0,
                const wxString &name = wxStaticTextNameStr );

    wxString GetLabel() const;
    void SetLabel( const wxString &label );

    bool SetFont( const wxFont &font );
    bool SetForegroundColour( const wxColour& colour );

    static wxVisualAttributes
    GetClassDefaultAttributes(wxWindowVariant variant = wxWINDOW_VARIANT_NORMAL);


    void Wrap(int width);




protected:
    virtual bool GTKWidgetNeedsMnemonic() const;
    virtual void GTKWidgetDoSetMnemonic(GtkWidget* w);

    virtual void DoSetSize(int x, int y,
                           int width, int height,
                           int sizeFlags = (0x0001|0x0002));

    virtual wxSize DoGetBestSize() const;

    public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};
# 54 "/usr/include/wx-2.8/wx/stattext.h" 2
# 76 "/usr/include/wx-2.8/wx/wx.h" 2
# 1 "/usr/include/wx-2.8/wx/statbmp.h" 1
# 23 "/usr/include/wx-2.8/wx/statbmp.h"
extern const wxChar wxStaticBitmapNameStr[];


class wxStaticBitmapBase : public wxControl
{
public:
    wxStaticBitmapBase() { }
    virtual ~wxStaticBitmapBase();


    virtual void SetIcon(const wxIcon& icon) = 0;
    virtual void SetBitmap(const wxBitmap& bitmap) = 0;
    virtual wxBitmap GetBitmap() const = 0;
    virtual wxIcon GetIcon() const
    {


        return wxIcon();
    }


    virtual bool AcceptsFocus() const { return false; }
    virtual bool HasTransparentBackground() { return true; }

protected:
    virtual wxSize DoGetBestSize() const;

    private: wxStaticBitmapBase(const wxStaticBitmapBase&); wxStaticBitmapBase& operator=(const wxStaticBitmapBase&);
};
# 60 "/usr/include/wx-2.8/wx/statbmp.h"
# 1 "/usr/include/wx-2.8/wx/gtk/statbmp.h" 1
# 19 "/usr/include/wx-2.8/wx/gtk/statbmp.h"
class wxStaticBitmap : public wxStaticBitmapBase
{
public:
    wxStaticBitmap();
    wxStaticBitmap( wxWindow *parent,
                    wxWindowID id,
                    const wxBitmap& label,
                    const wxPoint& pos = wxDefaultPosition,
                    const wxSize& size = wxDefaultSize,
                    long style = 0,
                    const wxString& name = wxStaticBitmapNameStr );
    bool Create( wxWindow *parent,
                 wxWindowID id,
                 const wxBitmap& label,
                 const wxPoint& pos = wxDefaultPosition,
                 const wxSize& size = wxDefaultSize,
                 long style = 0,
                 const wxString& name = wxStaticBitmapNameStr);

    virtual void SetIcon(const wxIcon& icon) { SetBitmap( icon ); }
    virtual void SetBitmap( const wxBitmap& bitmap );
    virtual wxBitmap GetBitmap() const { return m_bitmap; }


    wxIcon GetIcon() const
    {


        return (const wxIcon &)m_bitmap;
    }

    static wxVisualAttributes
    GetClassDefaultAttributes(wxWindowVariant variant = wxWINDOW_VARIANT_NORMAL);

private:
    wxBitmap m_bitmap;

    public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};
# 61 "/usr/include/wx-2.8/wx/statbmp.h" 2
# 77 "/usr/include/wx-2.8/wx/wx.h" 2
# 1 "/usr/include/wx-2.8/wx/statbox.h" 1
# 21 "/usr/include/wx-2.8/wx/statbox.h"
extern const wxChar wxStaticBoxNameStr[];





class wxStaticBoxBase : public wxControl
{
public:
    wxStaticBoxBase() { }


    virtual bool AcceptsFocus() const { return false; }
    virtual bool HasTransparentBackground() { return true; }






    virtual void GetBordersForSizer(int *borderTop, int *borderOther) const
    {
        const int BORDER = 5;

        *borderTop = GetLabel().empty() ? BORDER : GetCharHeight();
        *borderOther = BORDER;
    }

private:
    private: wxStaticBoxBase(const wxStaticBoxBase&); wxStaticBoxBase& operator=(const wxStaticBoxBase&);
};
# 60 "/usr/include/wx-2.8/wx/statbox.h"
# 1 "/usr/include/wx-2.8/wx/gtk/statbox.h" 1
# 17 "/usr/include/wx-2.8/wx/gtk/statbox.h"
class wxStaticBox : public wxStaticBoxBase
{
public:
    wxStaticBox();
    wxStaticBox( wxWindow *parent,
                 wxWindowID id,
                 const wxString &label,
                 const wxPoint &pos = wxDefaultPosition,
                 const wxSize &size = wxDefaultSize,
                 long style = 0,
                 const wxString &name = wxStaticBoxNameStr );
    bool Create( wxWindow *parent,
                 wxWindowID id,
                 const wxString &label,
                 const wxPoint &pos = wxDefaultPosition,
                 const wxSize &size = wxDefaultSize,
                 long style = 0,
                 const wxString &name = wxStaticBoxNameStr );

    virtual void SetLabel( const wxString &label );

    static wxVisualAttributes
    GetClassDefaultAttributes(wxWindowVariant variant = wxWINDOW_VARIANT_NORMAL);



    virtual bool IsTransparentForMouse() const { return 1; }

    virtual void GetBordersForSizer(int *borderTop, int *borderOther) const;

protected:
    virtual bool GTKWidgetNeedsMnemonic() const;
    virtual void GTKWidgetDoSetMnemonic(GtkWidget* w);

    void DoApplyWidgetStyle(GtkRcStyle *style);

private:
    public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};
# 61 "/usr/include/wx-2.8/wx/statbox.h" 2
# 78 "/usr/include/wx-2.8/wx/wx.h" 2

# 1 "/usr/include/wx-2.8/wx/radiobox.h" 1
# 23 "/usr/include/wx-2.8/wx/radiobox.h"
class wxToolTip;

typedef wxToolTip * _wxArraywxToolTipArray; struct wxAssert_wxToolTipArray { unsigned int TypeTooBigToBeStoredInwxBaseArrayPtrVoid: sizeof(_wxArraywxToolTipArray) <= sizeof(wxBaseArrayPtrVoid::base_type); }; typedef int ( *CMPFUNC_wxArraywxToolTipArray)(_wxArraywxToolTipArray *pItem1, _wxArraywxToolTipArray *pItem2); class wxToolTipArray : public wxBaseArrayPtrVoid { public: wxToolTipArray() { } ~wxToolTipArray() { } wxToolTipArray& operator=(const wxToolTipArray& src) { wxBaseArrayPtrVoid* temp = (wxBaseArrayPtrVoid*) this; (*temp) = ((const wxBaseArrayPtrVoid&)src); return *this; } _wxArraywxToolTipArray& operator[](size_t uiIndex) const { return (_wxArraywxToolTipArray&)(wxBaseArrayPtrVoid::operator[](uiIndex)); } _wxArraywxToolTipArray& Item(size_t uiIndex) const { return (_wxArraywxToolTipArray&)(wxBaseArrayPtrVoid::operator[](uiIndex)); } _wxArraywxToolTipArray& Last() const { return (_wxArraywxToolTipArray&)(wxBaseArrayPtrVoid::operator[](Count() - 1)); } int Index(_wxArraywxToolTipArray lItem, bool bFromEnd = false) const { return wxBaseArrayPtrVoid::Index((base_type)lItem, bFromEnd); } void Add(_wxArraywxToolTipArray lItem, size_t nInsert = 1) { wxBaseArrayPtrVoid::Add((base_type)lItem, nInsert); } void Insert(_wxArraywxToolTipArray lItem, size_t uiIndex, size_t nInsert = 1) { wxBaseArrayPtrVoid::Insert((base_type)lItem, uiIndex, nInsert) ; } void RemoveAt(size_t uiIndex, size_t nRemove = 1) { wxBaseArrayPtrVoid::RemoveAt(uiIndex, nRemove); } void Remove(_wxArraywxToolTipArray lItem) { int iIndex = Index(lItem); if ( iIndex != (-1) ) ; else { ; return; } typedef int wxDummyCheckInt; wxBaseArrayPtrVoid::RemoveAt((size_t)iIndex); } void Sort(CMPFUNC_wxArraywxToolTipArray fCmp) { wxBaseArrayPtrVoid::Sort((CMPFUNC)fCmp); } private: typedef wxBaseArrayPtrVoid::iterator biterator; typedef wxBaseArrayPtrVoid::const_iterator bconst_iterator; typedef wxBaseArrayPtrVoid::value_type bvalue_type; typedef wxBaseArrayPtrVoid::const_reference bconst_reference; public: typedef _wxArraywxToolTipArray value_type; typedef value_type* pointer; typedef const value_type* const_pointer; typedef value_type* iterator; typedef const value_type* const_iterator; typedef value_type& reference; typedef const value_type& const_reference; typedef wxBaseArrayPtrVoid::difference_type difference_type; typedef wxBaseArrayPtrVoid::size_type size_type; class reverse_iterator { typedef _wxArraywxToolTipArray value_type; typedef value_type& reference; typedef value_type* pointer; typedef reverse_iterator itor; friend inline itor operator+(int o, const itor& it) { return it.m_ptr - o; } friend inline itor operator+(const itor& it, int o) { return it.m_ptr - o; } friend inline itor operator-(const itor& it, int o) { return it.m_ptr + o; } friend inline difference_type operator-(const itor& i1, const itor& i2) { return i1.m_ptr - i2.m_ptr; } public: pointer m_ptr; reverse_iterator() : m_ptr(__null) { } reverse_iterator(pointer ptr) : m_ptr(ptr) { } reverse_iterator(const itor& it) : m_ptr(it.m_ptr) { } reference operator*() const { return *m_ptr; } itor& operator++() { --m_ptr; return *this; } const itor operator++(int) { reverse_iterator tmp = *this; --m_ptr; return tmp; } itor& operator--() { ++m_ptr; return *this; } const itor operator--(int) { itor tmp = *this; ++m_ptr; return tmp; } bool operator ==(const itor& it) const { return m_ptr == it.m_ptr; } bool operator !=(const itor& it) const { return m_ptr != it.m_ptr; } }; class const_reverse_iterator { typedef _wxArraywxToolTipArray value_type; typedef const value_type& reference; typedef const value_type* pointer; typedef const_reverse_iterator itor; friend inline itor operator+(int o, const itor& it) { return it.m_ptr - o; } friend inline itor operator+(const itor& it, int o) { return it.m_ptr - o; } friend inline itor operator-(const itor& it, int o) { return it.m_ptr + o; } friend inline difference_type operator-(const itor& i1, const itor& i2) { return i1.m_ptr - i2.m_ptr; } public: pointer m_ptr; const_reverse_iterator() : m_ptr(__null) { } const_reverse_iterator(pointer ptr) : m_ptr(ptr) { } const_reverse_iterator(const itor& it) : m_ptr(it.m_ptr) { } const_reverse_iterator(const reverse_iterator& it) : m_ptr(it.m_ptr) { } reference operator*() const { return *m_ptr; } itor& operator++() { --m_ptr; return *this; } const itor operator++(int) { itor tmp = *this; --m_ptr; return tmp; } itor& operator--() { ++m_ptr; return *this; } const itor operator--(int) { itor tmp = *this; ++m_ptr; return tmp; } bool operator ==(const itor& it) const { return m_ptr == it.m_ptr; } bool operator !=(const itor& it) const { return m_ptr != it.m_ptr; } }; wxToolTipArray(size_type n, const_reference v) { assign(n, v); } wxToolTipArray(const_iterator first, const_iterator last) { assign(first, last); } void assign(const_iterator first, const_iterator last) { wxBaseArrayPtrVoid::assign((bconst_iterator)first, (bconst_iterator)last); } void assign(size_type n, const_reference v) { wxBaseArrayPtrVoid::assign(n, (bconst_reference)v); } reference back() { return *(end() - 1); } const_reference back() const { return *(end() - 1); } iterator begin() { return (iterator)wxBaseArrayPtrVoid::begin(); } const_iterator begin() const { return (const_iterator)wxBaseArrayPtrVoid::begin(); } size_type capacity() const { return wxBaseArrayPtrVoid::capacity(); } iterator end() { return (iterator)wxBaseArrayPtrVoid::end(); } const_iterator end() const { return (const_iterator)wxBaseArrayPtrVoid::end(); } iterator erase(iterator first, iterator last) { return (iterator)wxBaseArrayPtrVoid::erase((biterator)first, (biterator)last); } iterator erase(iterator it) { return (iterator)wxBaseArrayPtrVoid::erase((biterator)it); } reference front() { return *begin(); } const_reference front() const { return *begin(); } void insert(iterator it, size_type n, const_reference v) { wxBaseArrayPtrVoid::insert((biterator)it, n, (bconst_reference)v); } iterator insert(iterator it, const_reference v = value_type()) { return (iterator)wxBaseArrayPtrVoid::insert((biterator)it, (bconst_reference)v); } void insert(iterator it, const_iterator first, const_iterator last) { wxBaseArrayPtrVoid::insert((biterator)it, (bconst_iterator)first, (bconst_iterator)last); } void pop_back() { wxBaseArrayPtrVoid::pop_back(); } void push_back(const_reference v) { wxBaseArrayPtrVoid::push_back((bconst_reference)v); } reverse_iterator rbegin() { return reverse_iterator(end() - 1); } const_reverse_iterator rbegin() const; reverse_iterator rend() { return reverse_iterator(begin() - 1); } const_reverse_iterator rend() const; void reserve(size_type n) { wxBaseArrayPtrVoid::reserve(n); } void resize(size_type n, value_type v = value_type()) { wxBaseArrayPtrVoid::resize(n, v); } };



extern const wxChar wxRadioBoxNameStr[];







class wxRadioBoxBase : public wxItemContainerImmutable
{
public:
    virtual ~wxRadioBoxBase();


    virtual bool Enable(unsigned int n, bool enable = true) = 0;
    virtual bool Show(unsigned int n, bool show = true) = 0;
    virtual bool IsItemEnabled(unsigned int n) const = 0;
    virtual bool IsItemShown(unsigned int n) const = 0;


    unsigned int GetColumnCount() const { return m_numCols; }
    unsigned int GetRowCount() const { return m_numRows; }



    int GetNextItem(int item, wxDirection dir, long style) const;



    void SetItemToolTip(unsigned int item, const wxString& text);


    wxToolTip *GetItemToolTip(unsigned int item) const
        { return m_itemsTooltips ? (*m_itemsTooltips)[item] : __null; }




    void SetItemHelpText(unsigned int n, const wxString& helpText);


    wxString GetItemHelpText(unsigned int n) const;
# 82 "/usr/include/wx-2.8/wx/radiobox.h"
    virtual int GetItemFromPoint(const wxPoint& ) const
    {
        return (-1);
    }
# 96 "/usr/include/wx-2.8/wx/radiobox.h"
protected:
    wxRadioBoxBase()
    {
        m_numCols =
        m_numRows =
        m_majorDim = 0;


        m_itemsTooltips = __null;

    }



    unsigned int GetMajorDim() const { return m_majorDim; }




    void SetMajorDim(unsigned int majorDim, long style);
# 124 "/usr/include/wx-2.8/wx/radiobox.h"
    virtual void DoSetItemToolTip(unsigned int item, wxToolTip *tooltip);


    bool HasItemToolTips() const { return m_itemsTooltips != __null; }





    wxString DoGetHelpTextAtPoint(const wxWindow *derived,
                                  const wxPoint& pt,
                                  wxHelpEvent::Origin origin) const;


private:



    unsigned int m_majorDim,
                 m_numCols,
                 m_numRows;





    wxToolTipArray *m_itemsTooltips;




    wxArrayString m_itemsHelpTexts;

};
# 166 "/usr/include/wx-2.8/wx/radiobox.h"
# 1 "/usr/include/wx-2.8/wx/gtk/radiobox.h" 1
# 15 "/usr/include/wx-2.8/wx/gtk/radiobox.h"
class wxGTKRadioButtonInfo;



typedef wxGTKRadioButtonInfo _WX_LIST_ITEM_TYPE_wxRadioBoxButtonsInfoList; typedef int (*wxSortFuncFor_wxRadioBoxButtonsInfoList)(const wxGTKRadioButtonInfo **, const wxGTKRadioButtonInfo **); class wxwxRadioBoxButtonsInfoListNode : public wxNodeBase { public: wxwxRadioBoxButtonsInfoListNode(wxListBase *list = (wxListBase *)__null, wxwxRadioBoxButtonsInfoListNode *previous = (wxwxRadioBoxButtonsInfoListNode *)__null, wxwxRadioBoxButtonsInfoListNode *next = (wxwxRadioBoxButtonsInfoListNode *)__null, wxGTKRadioButtonInfo *data = (wxGTKRadioButtonInfo *)__null, const wxListKey& key = wxDefaultListKey) : wxNodeBase(list, previous, next, data, key) { } wxwxRadioBoxButtonsInfoListNode *GetNext() const { return (wxwxRadioBoxButtonsInfoListNode *)wxNodeBase::GetNext(); } wxwxRadioBoxButtonsInfoListNode *GetPrevious() const { return (wxwxRadioBoxButtonsInfoListNode *)wxNodeBase::GetPrevious(); } wxGTKRadioButtonInfo *GetData() const { return (wxGTKRadioButtonInfo *)wxNodeBase::GetData(); } void SetData(wxGTKRadioButtonInfo *data) { wxNodeBase::SetData(data); } protected: virtual void DeleteData(); private: wxwxRadioBoxButtonsInfoListNode(const wxwxRadioBoxButtonsInfoListNode&); wxwxRadioBoxButtonsInfoListNode& operator=(const wxwxRadioBoxButtonsInfoListNode&); }; class wxRadioBoxButtonsInfoList : public wxListBase { public: typedef wxwxRadioBoxButtonsInfoListNode Node; class compatibility_iterator { public: compatibility_iterator(Node *ptr = __null) : m_ptr(ptr) { } Node *operator->() const { return m_ptr; } operator Node *() const { return m_ptr; } private: Node *m_ptr; }; wxRadioBoxButtonsInfoList(wxKeyType keyType = wxKEY_NONE) : wxListBase(keyType) { } wxRadioBoxButtonsInfoList(const wxRadioBoxButtonsInfoList& list) : wxListBase(list.GetKeyType()) { Assign(list); } wxRadioBoxButtonsInfoList(size_t count, wxGTKRadioButtonInfo *elements[]) : wxListBase(count, (void **)elements) { } wxRadioBoxButtonsInfoList& operator=(const wxRadioBoxButtonsInfoList& list) { Assign(list); return *this; } wxwxRadioBoxButtonsInfoListNode *GetFirst() const { return (wxwxRadioBoxButtonsInfoListNode *)wxListBase::GetFirst(); } wxwxRadioBoxButtonsInfoListNode *GetLast() const { return (wxwxRadioBoxButtonsInfoListNode *)wxListBase::GetLast(); } wxwxRadioBoxButtonsInfoListNode *Item(size_t index) const { return (wxwxRadioBoxButtonsInfoListNode *)wxListBase::Item(index); } wxGTKRadioButtonInfo *operator[](size_t index) const { wxwxRadioBoxButtonsInfoListNode *node = Item(index); return node ? (wxGTKRadioButtonInfo*)(node->GetData()) : (wxGTKRadioButtonInfo*)__null; } wxwxRadioBoxButtonsInfoListNode *Append(wxGTKRadioButtonInfo *object) { return (wxwxRadioBoxButtonsInfoListNode *)wxListBase::Append(object); } wxwxRadioBoxButtonsInfoListNode *Insert(wxGTKRadioButtonInfo *object) { return (wxwxRadioBoxButtonsInfoListNode *)Insert((wxwxRadioBoxButtonsInfoListNode*)__null, object); } wxwxRadioBoxButtonsInfoListNode *Insert(size_t pos, wxGTKRadioButtonInfo *object) { return (wxwxRadioBoxButtonsInfoListNode *)wxListBase::Insert(pos, object); } wxwxRadioBoxButtonsInfoListNode *Insert(wxwxRadioBoxButtonsInfoListNode *prev, wxGTKRadioButtonInfo *object) { return (wxwxRadioBoxButtonsInfoListNode *)wxListBase::Insert(prev, object); } wxwxRadioBoxButtonsInfoListNode *Append(long key, void *object) { return (wxwxRadioBoxButtonsInfoListNode *)wxListBase::Append(key, object); } wxwxRadioBoxButtonsInfoListNode *Append(const wxChar *key, void *object) { return (wxwxRadioBoxButtonsInfoListNode *)wxListBase::Append(key, object); } wxwxRadioBoxButtonsInfoListNode *DetachNode(wxwxRadioBoxButtonsInfoListNode *node) { return (wxwxRadioBoxButtonsInfoListNode *)wxListBase::DetachNode(node); } bool DeleteNode(wxwxRadioBoxButtonsInfoListNode *node) { return wxListBase::DeleteNode(node); } bool DeleteObject(wxGTKRadioButtonInfo *object) { return wxListBase::DeleteObject(object); } void Erase(wxwxRadioBoxButtonsInfoListNode *it) { DeleteNode(it); } wxwxRadioBoxButtonsInfoListNode *Find(const wxGTKRadioButtonInfo *object) const { return (wxwxRadioBoxButtonsInfoListNode *)wxListBase::Find(object); } virtual wxwxRadioBoxButtonsInfoListNode *Find(const wxListKey& key) const { return (wxwxRadioBoxButtonsInfoListNode *)wxListBase::Find(key); } int IndexOf(wxGTKRadioButtonInfo *object) const { return wxListBase::IndexOf(object); } void Sort(wxSortCompareFunction func) { wxListBase::Sort(func); } void Sort(wxSortFuncFor_wxRadioBoxButtonsInfoList func) { Sort((wxSortCompareFunction)func); } protected: virtual wxNodeBase *CreateNode(wxNodeBase *prev, wxNodeBase *next, void *data, const wxListKey& key = wxDefaultListKey) { return new wxwxRadioBoxButtonsInfoListNode(this, (wxwxRadioBoxButtonsInfoListNode *)prev, (wxwxRadioBoxButtonsInfoListNode *)next, (wxGTKRadioButtonInfo *)data, key); } public: typedef size_t size_type; typedef int difference_type; typedef wxGTKRadioButtonInfo* value_type; typedef wxGTKRadioButtonInfo* base_value_type; typedef value_type& reference; typedef const value_type& const_reference; typedef base_value_type& base_reference; typedef const base_value_type& const_base_reference; class iterator { typedef wxRadioBoxButtonsInfoList list; public: typedef wxwxRadioBoxButtonsInfoListNode Node; typedef iterator itor; typedef wxGTKRadioButtonInfo* value_type; typedef value_type* ptr_type; typedef value_type& reference; Node* m_node; Node* m_init; public: typedef reference reference_type; typedef ptr_type pointer_type; iterator(Node* node, Node* init) : m_node(node), m_init(init) {} iterator() : m_node(__null), m_init(__null) { } reference_type operator*() const { return *(pointer_type)m_node->GetDataPtr(); } itor& operator++() { m_node = m_node->GetNext(); return *this; } const itor operator++(int) { itor tmp = *this; m_node = m_node->GetNext(); return tmp; } itor& operator--() { m_node = m_node ? m_node->GetPrevious() : m_init; return *this; } const itor operator--(int) { itor tmp = *this; m_node = m_node ? m_node->GetPrevious() : m_init; return tmp; } bool operator!=(const itor& it) const { return it.m_node != m_node; } bool operator==(const itor& it) const { return it.m_node == m_node; } }; class const_iterator { typedef wxRadioBoxButtonsInfoList list; public: typedef wxwxRadioBoxButtonsInfoListNode Node; typedef wxGTKRadioButtonInfo* value_type; typedef const value_type& const_reference; typedef const_iterator itor; typedef value_type* ptr_type; Node* m_node; Node* m_init; public: typedef const_reference reference_type; typedef const ptr_type pointer_type; const_iterator(Node* node, Node* init) : m_node(node), m_init(init) { } const_iterator() : m_node(__null), m_init(__null) { } const_iterator(const iterator& it) : m_node(it.m_node), m_init(it.m_init) { } reference_type operator*() const { return *(pointer_type)m_node->GetDataPtr(); } itor& operator++() { m_node = m_node->GetNext(); return *this; } const itor operator++(int) { itor tmp = *this; m_node = m_node->GetNext(); return tmp; } itor& operator--() { m_node = m_node ? m_node->GetPrevious() : m_init; return *this; } const itor operator--(int) { itor tmp = *this; m_node = m_node ? m_node->GetPrevious() : m_init; return tmp; } bool operator!=(const itor& it) const { return it.m_node != m_node; } bool operator==(const itor& it) const { return it.m_node == m_node; } }; class reverse_iterator { typedef wxRadioBoxButtonsInfoList list; public: typedef wxwxRadioBoxButtonsInfoListNode Node; typedef wxGTKRadioButtonInfo* value_type; typedef reverse_iterator itor; typedef value_type* ptr_type; typedef value_type& reference; Node* m_node; Node* m_init; public: typedef reference reference_type; typedef ptr_type pointer_type; reverse_iterator(Node* node, Node* init) : m_node(node), m_init(init) { } reverse_iterator() : m_node(__null), m_init(__null) { } reference_type operator*() const { return *(pointer_type)m_node->GetDataPtr(); } itor& operator++() { m_node = m_node->GetPrevious(); return *this; } const itor operator++(int) { itor tmp = *this; m_node = m_node->GetPrevious(); return tmp; } itor& operator--() { m_node = m_node ? m_node->GetNext() : m_init; return *this; } const itor operator--(int) { itor tmp = *this; m_node = m_node ? m_node->GetNext() : m_init; return tmp; } bool operator!=(const itor& it) const { return it.m_node != m_node; } bool operator==(const itor& it) const { return it.m_node == m_node; } }; class const_reverse_iterator { typedef wxRadioBoxButtonsInfoList list; public: typedef wxwxRadioBoxButtonsInfoListNode Node; typedef wxGTKRadioButtonInfo* value_type; typedef const_reverse_iterator itor; typedef value_type* ptr_type; typedef const value_type& const_reference; Node* m_node; Node* m_init; public: typedef const_reference reference_type; typedef const ptr_type pointer_type; const_reverse_iterator(Node* node, Node* init) : m_node(node), m_init(init) { } const_reverse_iterator() : m_node(__null), m_init(__null) { } const_reverse_iterator(const reverse_iterator& it) : m_node(it.m_node), m_init(it.m_init) { } reference_type operator*() const { return *(pointer_type)m_node->GetDataPtr(); } itor& operator++() { m_node = m_node->GetPrevious(); return *this; } const itor operator++(int) { itor tmp = *this; m_node = m_node->GetPrevious(); return tmp; } itor& operator--() { m_node = m_node ? m_node->GetNext() : m_init; return *this;} const itor operator--(int) { itor tmp = *this; m_node = m_node ? m_node->GetNext() : m_init; return tmp; } bool operator!=(const itor& it) const { return it.m_node != m_node; } bool operator==(const itor& it) const { return it.m_node == m_node; } }; explicit wxRadioBoxButtonsInfoList(size_type n, const_reference v = value_type()) { assign(n, v); } wxRadioBoxButtonsInfoList(const const_iterator& first, const const_iterator& last) { assign(first, last); } iterator begin() { return iterator(GetFirst(), GetLast()); } const_iterator begin() const { return const_iterator(GetFirst(), GetLast()); } iterator end() { return iterator(__null, GetLast()); } const_iterator end() const { return const_iterator(__null, GetLast()); } reverse_iterator rbegin() { return reverse_iterator(GetLast(), GetFirst()); } const_reverse_iterator rbegin() const { return const_reverse_iterator(GetLast(), GetFirst()); } reverse_iterator rend() { return reverse_iterator(__null, GetFirst()); } const_reverse_iterator rend() const { return const_reverse_iterator(__null, GetFirst()); } void resize(size_type n, value_type v = value_type()) { while (n < size()) pop_back(); while (n > size()) push_back(v); } size_type size() const { return GetCount(); } size_type max_size() const { return 2147483647; } bool empty() const { return IsEmpty(); } reference front() { return *begin(); } const_reference front() const { return *begin(); } reference back() { iterator tmp = end(); return *--tmp; } const_reference back() const { const_iterator tmp = end(); return *--tmp; } void push_front(const_reference v = value_type()) { Insert(GetFirst(), (const_base_reference)v); } void pop_front() { DeleteNode(GetFirst()); } void push_back(const_reference v = value_type()) { Append((const_base_reference)v); } void pop_back() { DeleteNode(GetLast()); } void assign(const_iterator first, const const_iterator& last) { clear(); for(; first != last; ++first) Append((const_base_reference)*first); } void assign(size_type n, const_reference v = value_type()) { clear(); for(size_type i = 0; i < n; ++i) Append((const_base_reference)v); } iterator insert(const iterator& it, const_reference v = value_type()) { if ( it == end() ) Append((const_base_reference)v); else Insert(it.m_node, (const_base_reference)v); iterator itprev(it); return itprev--; } void insert(const iterator& it, size_type n, const_reference v = value_type()) { for(size_type i = 0; i < n; ++i) insert(it, v); } void insert(const iterator& it, const_iterator first, const const_iterator& last) { for(; first != last; ++first) insert(it, *first); } iterator erase(const iterator& it) { iterator next = iterator(it.m_node->GetNext(), GetLast()); DeleteNode(it.m_node); return next; } iterator erase(const iterator& first, const iterator& last) { iterator next = last; if ( next != end() ) ++next; DeleteNodes(first.m_node, last.m_node); return next; } void clear() { Clear(); } void splice(const iterator& it, wxRadioBoxButtonsInfoList& l, const iterator& first, const iterator& last) { insert(it, first, last); l.erase(first, last); } void splice(const iterator& it, wxRadioBoxButtonsInfoList& l) { splice(it, l, l.begin(), l.end() ); } void splice(const iterator& it, wxRadioBoxButtonsInfoList& l, const iterator& first) { if ( it != first ) { insert(it, *first); l.erase(first); } } void remove(const_reference v) { DeleteObject((const_base_reference)v); } void reverse() { Reverse(); } };






class wxRadioBox : public wxControl,
                                    public wxRadioBoxBase
{
public:

    wxRadioBox() { Init(); }
    wxRadioBox(wxWindow *parent,
               wxWindowID id,
               const wxString& title,
               const wxPoint& pos = wxDefaultPosition,
               const wxSize& size = wxDefaultSize,
               int n = 0,
               const wxString choices[] = (const wxString *) __null,
               int majorDim = 1,
               long style = wxHORIZONTAL,
               const wxValidator& val = wxDefaultValidator,
               const wxString& name = wxRadioBoxNameStr)
    {
        Init();

        Create( parent, id, title, pos, size, n, choices, majorDim, style, val, name );
    }

    wxRadioBox(wxWindow *parent,
               wxWindowID id,
               const wxString& title,
               const wxPoint& pos,
               const wxSize& size,
               const wxArrayString& choices,
               int majorDim = 1,
               long style = wxHORIZONTAL,
               const wxValidator& val = wxDefaultValidator,
               const wxString& name = wxRadioBoxNameStr)
    {
        Init();

        Create( parent, id, title, pos, size, choices, majorDim, style, val, name );
    }

    bool Create(wxWindow *parent,
                wxWindowID id,
                const wxString& title,
                const wxPoint& pos = wxDefaultPosition,
                const wxSize& size = wxDefaultSize,
                int n = 0,
                const wxString choices[] = (const wxString *) __null,
                int majorDim = 0,
                long style = wxHORIZONTAL,
                const wxValidator& val = wxDefaultValidator,
                const wxString& name = wxRadioBoxNameStr);
    bool Create(wxWindow *parent,
                wxWindowID id,
                const wxString& title,
                const wxPoint& pos,
                const wxSize& size,
                const wxArrayString& choices,
                int majorDim = 0,
                long style = wxHORIZONTAL,
                const wxValidator& val = wxDefaultValidator,
                const wxString& name = wxRadioBoxNameStr);

    virtual ~wxRadioBox();



    virtual unsigned int GetCount() const;

    virtual wxString GetString(unsigned int n) const;
    virtual void SetString(unsigned int n, const wxString& s);

    virtual void SetSelection(int n);
    virtual int GetSelection() const;



    virtual bool Show(unsigned int n, bool show = true);
    virtual bool Enable(unsigned int n, bool enable = true);

    virtual bool IsItemEnabled(unsigned int n) const;
    virtual bool IsItemShown(unsigned int n) const;



    virtual bool Show( bool show = true );
    virtual bool Enable( bool enable = true );

    virtual void SetLabel( const wxString& label );

    static wxVisualAttributes
    GetClassDefaultAttributes(wxWindowVariant variant = wxWINDOW_VARIANT_NORMAL);

    virtual int GetItemFromPoint( const wxPoint& pt ) const;




    virtual wxString GetHelpTextAtPoint(const wxPoint & pt, wxHelpEvent::Origin origin) const
    {
        return wxRadioBoxBase::DoGetHelpTextAtPoint( this, pt, origin );
    }





    void SetFocus();
    void GtkDisableEvents();
    void GtkEnableEvents();

    void ApplyToolTip( GtkTooltips *tips, const wxChar *tip );


    virtual void OnInternalIdle();

    bool m_hasFocus,
                                m_lostFocus;
    wxRadioBoxButtonsInfoList m_buttonsInfo;

protected:

    virtual void DoSetItemToolTip(unsigned int n, wxToolTip *tooltip);


    virtual void DoApplyWidgetStyle(GtkRcStyle *style);
    virtual GdkWindow *GTKGetWindow(wxArrayGdkWindows& windows) const;

    virtual bool GTKWidgetNeedsMnemonic() const;
    virtual void GTKWidgetDoSetMnemonic(GtkWidget* w);


    void Init();

private:
    public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};
# 167 "/usr/include/wx-2.8/wx/radiobox.h" 2
# 80 "/usr/include/wx-2.8/wx/wx.h" 2
# 1 "/usr/include/wx-2.8/wx/radiobut.h" 1
# 36 "/usr/include/wx-2.8/wx/radiobut.h"
extern const wxChar wxRadioButtonNameStr[];
# 45 "/usr/include/wx-2.8/wx/radiobut.h"
# 1 "/usr/include/wx-2.8/wx/gtk/radiobut.h" 1
# 17 "/usr/include/wx-2.8/wx/gtk/radiobut.h"
class wxRadioButton: public wxControl
{
public:
    wxRadioButton() { }
    wxRadioButton( wxWindow *parent,
                   wxWindowID id,
                   const wxString& label,
                   const wxPoint& pos = wxDefaultPosition,
                   const wxSize& size = wxDefaultSize,
                   long style = 0,
                   const wxValidator& validator = wxDefaultValidator,
                   const wxString& name = wxRadioButtonNameStr )
    {
        Create( parent, id, label, pos, size, style, validator, name );
    }

    bool Create( wxWindow *parent,
                 wxWindowID id,
                 const wxString& label,
                 const wxPoint& pos = wxDefaultPosition,
                 const wxSize& size = wxDefaultSize,
                 long style = 0,
                 const wxValidator& validator = wxDefaultValidator,
                 const wxString& name = wxRadioButtonNameStr );

    virtual void SetLabel(const wxString& label);
    virtual void SetValue(bool val);
    virtual bool GetValue() const;
    virtual bool Enable( bool enable = 1 );

    static wxVisualAttributes
    GetClassDefaultAttributes(wxWindowVariant variant = wxWINDOW_VARIANT_NORMAL);



    virtual bool IsRadioButton() const { return 1; }

    bool m_blockEvent;

protected:
    virtual wxSize DoGetBestSize() const;
    virtual void DoApplyWidgetStyle(GtkRcStyle *style);
    virtual GdkWindow *GTKGetWindow(wxArrayGdkWindows& windows) const;

private:
    public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};
# 46 "/usr/include/wx-2.8/wx/radiobut.h" 2
# 81 "/usr/include/wx-2.8/wx/wx.h" 2
# 1 "/usr/include/wx-2.8/wx/textctrl.h" 1
# 36 "/usr/include/wx-2.8/wx/textctrl.h"
# 1 "/usr/include/wx-2.8/wx/ioswrap.h" 1
# 17 "/usr/include/wx-2.8/wx/ioswrap.h"
# 1 "/usr/include/c++/4.4/iostream" 1 3
# 37 "/usr/include/c++/4.4/iostream" 3
       
# 38 "/usr/include/c++/4.4/iostream" 3


# 1 "/usr/include/c++/4.4/ostream" 1 3
# 38 "/usr/include/c++/4.4/ostream" 3
       
# 39 "/usr/include/c++/4.4/ostream" 3

# 1 "/usr/include/c++/4.4/ios" 1 3
# 37 "/usr/include/c++/4.4/ios" 3
       
# 38 "/usr/include/c++/4.4/ios" 3





# 1 "/usr/include/c++/4.4/bits/ios_base.h" 1 3
# 39 "/usr/include/c++/4.4/bits/ios_base.h" 3
       
# 40 "/usr/include/c++/4.4/bits/ios_base.h" 3



# 1 "/usr/include/c++/4.4/bits/locale_classes.h" 1 3
# 39 "/usr/include/c++/4.4/bits/locale_classes.h" 3
       
# 40 "/usr/include/c++/4.4/bits/locale_classes.h" 3





namespace std __attribute__ ((__visibility__ ("default"))) {
# 61 "/usr/include/c++/4.4/bits/locale_classes.h" 3
  class locale
  {
  public:


    typedef int category;


    class facet;
    class id;
    class _Impl;

    friend class facet;
    friend class _Impl;

    template<typename _Facet>
      friend bool
      has_facet(const locale&) throw();

    template<typename _Facet>
      friend const _Facet&
      use_facet(const locale&);

    template<typename _Cache>
      friend struct __use_cache;
# 97 "/usr/include/c++/4.4/bits/locale_classes.h" 3
    static const category none = 0;
    static const category ctype = 1L << 0;
    static const category numeric = 1L << 1;
    static const category collate = 1L << 2;
    static const category time = 1L << 3;
    static const category monetary = 1L << 4;
    static const category messages = 1L << 5;
    static const category all = (ctype | numeric | collate |
        time | monetary | messages);
# 116 "/usr/include/c++/4.4/bits/locale_classes.h" 3
    locale() throw();
# 125 "/usr/include/c++/4.4/bits/locale_classes.h" 3
    locale(const locale& __other) throw();
# 135 "/usr/include/c++/4.4/bits/locale_classes.h" 3
    explicit
    locale(const char* __s);
# 150 "/usr/include/c++/4.4/bits/locale_classes.h" 3
    locale(const locale& __base, const char* __s, category __cat);
# 163 "/usr/include/c++/4.4/bits/locale_classes.h" 3
    locale(const locale& __base, const locale& __add, category __cat);
# 175 "/usr/include/c++/4.4/bits/locale_classes.h" 3
    template<typename _Facet>
      locale(const locale& __other, _Facet* __f);


    ~locale() throw();
# 189 "/usr/include/c++/4.4/bits/locale_classes.h" 3
    const locale&
    operator=(const locale& __other) throw();
# 204 "/usr/include/c++/4.4/bits/locale_classes.h" 3
    template<typename _Facet>
      locale
      combine(const locale& __other) const;






    string
    name() const;
# 223 "/usr/include/c++/4.4/bits/locale_classes.h" 3
    bool
    operator==(const locale& __other) const throw ();







    bool
    operator!=(const locale& __other) const throw ()
    { return !(this->operator==(__other)); }
# 251 "/usr/include/c++/4.4/bits/locale_classes.h" 3
    template<typename _Char, typename _Traits, typename _Alloc>
      bool
      operator()(const basic_string<_Char, _Traits, _Alloc>& __s1,
   const basic_string<_Char, _Traits, _Alloc>& __s2) const;
# 267 "/usr/include/c++/4.4/bits/locale_classes.h" 3
    static locale
    global(const locale&);




    static const locale&
    classic();

  private:

    _Impl* _M_impl;


    static _Impl* _S_classic;


    static _Impl* _S_global;





    static const char* const* const _S_categories;
# 302 "/usr/include/c++/4.4/bits/locale_classes.h" 3
    enum { _S_categories_size = 6 + 6 };


    static __gthread_once_t _S_once;


    explicit
    locale(_Impl*) throw();

    static void
    _S_initialize();

    static void
    _S_initialize_once();

    static category
    _S_normalize_category(category);

    void
    _M_coalesce(const locale& __base, const locale& __add, category __cat);
  };
# 335 "/usr/include/c++/4.4/bits/locale_classes.h" 3
  class locale::facet
  {
  private:
    friend class locale;
    friend class locale::_Impl;

    mutable _Atomic_word _M_refcount;


    static __c_locale _S_c_locale;


    static const char _S_c_name[2];


    static __gthread_once_t _S_once;


    static void
    _S_initialize_once();

  protected:
# 366 "/usr/include/c++/4.4/bits/locale_classes.h" 3
    explicit
    facet(size_t __refs = 0) throw() : _M_refcount(__refs ? 1 : 0)
    { }


    virtual
    ~facet();

    static void
    _S_create_c_locale(__c_locale& __cloc, const char* __s,
         __c_locale __old = 0);

    static __c_locale
    _S_clone_c_locale(__c_locale& __cloc);

    static void
    _S_destroy_c_locale(__c_locale& __cloc);



    static __c_locale
    _S_get_c_locale();

    static const char*
    _S_get_c_name();

  private:
    void
    _M_add_reference() const throw()
    { __gnu_cxx::__atomic_add_dispatch(&_M_refcount, 1); }

    void
    _M_remove_reference() const throw()
    {
      if (__gnu_cxx::__exchange_and_add_dispatch(&_M_refcount, -1) == 1)
 {
   try
     { delete this; }
   catch(...)
     { }
 }
    }

    facet(const facet&);

    facet&
    operator=(const facet&);
  };
# 426 "/usr/include/c++/4.4/bits/locale_classes.h" 3
  class locale::id
  {
  private:
    friend class locale;
    friend class locale::_Impl;

    template<typename _Facet>
      friend const _Facet&
      use_facet(const locale&);

    template<typename _Facet>
      friend bool
      has_facet(const locale&) throw ();




    mutable size_t _M_index;


    static _Atomic_word _S_refcount;

    void
    operator=(const id&);

    id(const id&);

  public:



    id() { }

    size_t
    _M_id() const;
  };



  class locale::_Impl
  {
  public:

    friend class locale;
    friend class locale::facet;

    template<typename _Facet>
      friend bool
      has_facet(const locale&) throw();

    template<typename _Facet>
      friend const _Facet&
      use_facet(const locale&);

    template<typename _Cache>
      friend struct __use_cache;

  private:

    _Atomic_word _M_refcount;
    const facet** _M_facets;
    size_t _M_facets_size;
    const facet** _M_caches;
    char** _M_names;
    static const locale::id* const _S_id_ctype[];
    static const locale::id* const _S_id_numeric[];
    static const locale::id* const _S_id_collate[];
    static const locale::id* const _S_id_time[];
    static const locale::id* const _S_id_monetary[];
    static const locale::id* const _S_id_messages[];
    static const locale::id* const* const _S_facet_categories[];

    void
    _M_add_reference() throw()
    { __gnu_cxx::__atomic_add_dispatch(&_M_refcount, 1); }

    void
    _M_remove_reference() throw()
    {
      if (__gnu_cxx::__exchange_and_add_dispatch(&_M_refcount, -1) == 1)
 {
   try
     { delete this; }
   catch(...)
     { }
 }
    }

    _Impl(const _Impl&, size_t);
    _Impl(const char*, size_t);
    _Impl(size_t) throw();

   ~_Impl() throw();

    _Impl(const _Impl&);

    void
    operator=(const _Impl&);

    bool
    _M_check_same_name()
    {
      bool __ret = true;
      if (_M_names[1])

 for (size_t __i = 0; __ret && __i < _S_categories_size - 1; ++__i)
   __ret = __builtin_strcmp(_M_names[__i], _M_names[__i + 1]) == 0;
      return __ret;
    }

    void
    _M_replace_categories(const _Impl*, category);

    void
    _M_replace_category(const _Impl*, const locale::id* const*);

    void
    _M_replace_facet(const _Impl*, const locale::id*);

    void
    _M_install_facet(const locale::id*, const facet*);

    template<typename _Facet>
      void
      _M_init_facet(_Facet* __facet)
      { _M_install_facet(&_Facet::id, __facet); }

    void
    _M_install_cache(const facet*, size_t);
  };
# 569 "/usr/include/c++/4.4/bits/locale_classes.h" 3
  template<typename _Facet>
    bool
    has_facet(const locale& __loc) throw();
# 586 "/usr/include/c++/4.4/bits/locale_classes.h" 3
  template<typename _Facet>
    const _Facet&
    use_facet(const locale& __loc);
# 603 "/usr/include/c++/4.4/bits/locale_classes.h" 3
  template<typename _CharT>
    class collate : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;


    protected:


      __c_locale _M_c_locale_collate;

    public:

      static locale::id id;
# 630 "/usr/include/c++/4.4/bits/locale_classes.h" 3
      explicit
      collate(size_t __refs = 0)
      : facet(__refs), _M_c_locale_collate(_S_get_c_locale())
      { }
# 644 "/usr/include/c++/4.4/bits/locale_classes.h" 3
      explicit
      collate(__c_locale __cloc, size_t __refs = 0)
      : facet(__refs), _M_c_locale_collate(_S_clone_c_locale(__cloc))
      { }
# 661 "/usr/include/c++/4.4/bits/locale_classes.h" 3
      int
      compare(const _CharT* __lo1, const _CharT* __hi1,
       const _CharT* __lo2, const _CharT* __hi2) const
      { return this->do_compare(__lo1, __hi1, __lo2, __hi2); }
# 680 "/usr/include/c++/4.4/bits/locale_classes.h" 3
      string_type
      transform(const _CharT* __lo, const _CharT* __hi) const
      { return this->do_transform(__lo, __hi); }
# 694 "/usr/include/c++/4.4/bits/locale_classes.h" 3
      long
      hash(const _CharT* __lo, const _CharT* __hi) const
      { return this->do_hash(__lo, __hi); }


      int
      _M_compare(const _CharT*, const _CharT*) const;

      size_t
      _M_transform(_CharT*, const _CharT*, size_t) const;

  protected:

      virtual
      ~collate()
      { _S_destroy_c_locale(_M_c_locale_collate); }
# 723 "/usr/include/c++/4.4/bits/locale_classes.h" 3
      virtual int
      do_compare(const _CharT* __lo1, const _CharT* __hi1,
   const _CharT* __lo2, const _CharT* __hi2) const;
# 739 "/usr/include/c++/4.4/bits/locale_classes.h" 3
      virtual string_type
      do_transform(const _CharT* __lo, const _CharT* __hi) const;
# 752 "/usr/include/c++/4.4/bits/locale_classes.h" 3
      virtual long
      do_hash(const _CharT* __lo, const _CharT* __hi) const;
    };

  template<typename _CharT>
    locale::id collate<_CharT>::id;


  template<>
    int
    collate<char>::_M_compare(const char*, const char*) const;

  template<>
    size_t
    collate<char>::_M_transform(char*, const char*, size_t) const;


  template<>
    int
    collate<wchar_t>::_M_compare(const wchar_t*, const wchar_t*) const;

  template<>
    size_t
    collate<wchar_t>::_M_transform(wchar_t*, const wchar_t*, size_t) const;



  template<typename _CharT>
    class collate_byname : public collate<_CharT>
    {
    public:


      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;


      explicit
      collate_byname(const char* __s, size_t __refs = 0)
      : collate<_CharT>(__refs)
      {
 if (__builtin_strcmp(__s, "C") != 0
     && __builtin_strcmp(__s, "POSIX") != 0)
   {
     this->_S_destroy_c_locale(this->_M_c_locale_collate);
     this->_S_create_c_locale(this->_M_c_locale_collate, __s);
   }
      }

    protected:
      virtual
      ~collate_byname() { }
    };

}


# 1 "/usr/include/c++/4.4/bits/locale_classes.tcc" 1 3
# 37 "/usr/include/c++/4.4/bits/locale_classes.tcc" 3
       
# 38 "/usr/include/c++/4.4/bits/locale_classes.tcc" 3

namespace std __attribute__ ((__visibility__ ("default"))) {

  template<typename _Facet>
    locale::
    locale(const locale& __other, _Facet* __f)
    {
      _M_impl = new _Impl(*__other._M_impl, 1);

      try
 { _M_impl->_M_install_facet(&_Facet::id, __f); }
      catch(...)
 {
   _M_impl->_M_remove_reference();
   throw;
 }
      delete [] _M_impl->_M_names[0];
      _M_impl->_M_names[0] = 0;
    }

  template<typename _Facet>
    locale
    locale::
    combine(const locale& __other) const
    {
      _Impl* __tmp = new _Impl(*_M_impl, 1);
      try
 {
   __tmp->_M_replace_facet(__other._M_impl, &_Facet::id);
 }
      catch(...)
 {
   __tmp->_M_remove_reference();
   throw;
 }
      return locale(__tmp);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    bool
    locale::
    operator()(const basic_string<_CharT, _Traits, _Alloc>& __s1,
        const basic_string<_CharT, _Traits, _Alloc>& __s2) const
    {
      typedef std::collate<_CharT> __collate_type;
      const __collate_type& __collate = use_facet<__collate_type>(*this);
      return (__collate.compare(__s1.data(), __s1.data() + __s1.length(),
    __s2.data(), __s2.data() + __s2.length()) < 0);
    }


  template<typename _Facet>
    bool
    has_facet(const locale& __loc) throw()
    {
      const size_t __i = _Facet::id._M_id();
      const locale::facet** __facets = __loc._M_impl->_M_facets;
      return (__i < __loc._M_impl->_M_facets_size

       && dynamic_cast<const _Facet*>(__facets[__i]));



    }

  template<typename _Facet>
    const _Facet&
    use_facet(const locale& __loc)
    {
      const size_t __i = _Facet::id._M_id();
      const locale::facet** __facets = __loc._M_impl->_M_facets;
      if (__i >= __loc._M_impl->_M_facets_size || !__facets[__i])
        __throw_bad_cast();

      return dynamic_cast<const _Facet&>(*__facets[__i]);



    }



  template<typename _CharT>
    int
    collate<_CharT>::_M_compare(const _CharT*, const _CharT*) const
    { return 0; }


  template<typename _CharT>
    size_t
    collate<_CharT>::_M_transform(_CharT*, const _CharT*, size_t) const
    { return 0; }

  template<typename _CharT>
    int
    collate<_CharT>::
    do_compare(const _CharT* __lo1, const _CharT* __hi1,
        const _CharT* __lo2, const _CharT* __hi2) const
    {


      const string_type __one(__lo1, __hi1);
      const string_type __two(__lo2, __hi2);

      const _CharT* __p = __one.c_str();
      const _CharT* __pend = __one.data() + __one.length();
      const _CharT* __q = __two.c_str();
      const _CharT* __qend = __two.data() + __two.length();




      for (;;)
 {
   const int __res = _M_compare(__p, __q);
   if (__res)
     return __res;

   __p += char_traits<_CharT>::length(__p);
   __q += char_traits<_CharT>::length(__q);
   if (__p == __pend && __q == __qend)
     return 0;
   else if (__p == __pend)
     return -1;
   else if (__q == __qend)
     return 1;

   __p++;
   __q++;
 }
    }

  template<typename _CharT>
    typename collate<_CharT>::string_type
    collate<_CharT>::
    do_transform(const _CharT* __lo, const _CharT* __hi) const
    {
      string_type __ret;


      const string_type __str(__lo, __hi);

      const _CharT* __p = __str.c_str();
      const _CharT* __pend = __str.data() + __str.length();

      size_t __len = (__hi - __lo) * 2;

      _CharT* __c = new _CharT[__len];

      try
 {



   for (;;)
     {

       size_t __res = _M_transform(__c, __p, __len);


       if (__res >= __len)
  {
    __len = __res + 1;
    delete [] __c, __c = 0;
    __c = new _CharT[__len];
    __res = _M_transform(__c, __p, __len);
  }

       __ret.append(__c, __res);
       __p += char_traits<_CharT>::length(__p);
       if (__p == __pend)
  break;

       __p++;
       __ret.push_back(_CharT());
     }
 }
      catch(...)
 {
   delete [] __c;
   throw;
 }

      delete [] __c;

      return __ret;
    }

  template<typename _CharT>
    long
    collate<_CharT>::
    do_hash(const _CharT* __lo, const _CharT* __hi) const
    {
      unsigned long __val = 0;
      for (; __lo < __hi; ++__lo)
 __val =
   *__lo + ((__val << 7)
     | (__val >> (__gnu_cxx::__numeric_traits<unsigned long>::
    __digits - 7)));
      return static_cast<long>(__val);
    }





  extern template class collate<char>;
  extern template class collate_byname<char>;

  extern template
    const collate<char>&
    use_facet<collate<char> >(const locale&);

  extern template
    bool
    has_facet<collate<char> >(const locale&);


  extern template class collate<wchar_t>;
  extern template class collate_byname<wchar_t>;

  extern template
    const collate<wchar_t>&
    use_facet<collate<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<collate<wchar_t> >(const locale&);



}
# 810 "/usr/include/c++/4.4/bits/locale_classes.h" 2 3
# 44 "/usr/include/c++/4.4/bits/ios_base.h" 2 3
# 54 "/usr/include/c++/4.4/bits/ios_base.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {





  enum _Ios_Fmtflags
    {
      _S_boolalpha = 1L << 0,
      _S_dec = 1L << 1,
      _S_fixed = 1L << 2,
      _S_hex = 1L << 3,
      _S_internal = 1L << 4,
      _S_left = 1L << 5,
      _S_oct = 1L << 6,
      _S_right = 1L << 7,
      _S_scientific = 1L << 8,
      _S_showbase = 1L << 9,
      _S_showpoint = 1L << 10,
      _S_showpos = 1L << 11,
      _S_skipws = 1L << 12,
      _S_unitbuf = 1L << 13,
      _S_uppercase = 1L << 14,
      _S_adjustfield = _S_left | _S_right | _S_internal,
      _S_basefield = _S_dec | _S_oct | _S_hex,
      _S_floatfield = _S_scientific | _S_fixed,
      _S_ios_fmtflags_end = 1L << 16
    };

  inline _Ios_Fmtflags
  operator&(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
  { return _Ios_Fmtflags(static_cast<int>(__a) & static_cast<int>(__b)); }

  inline _Ios_Fmtflags
  operator|(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
  { return _Ios_Fmtflags(static_cast<int>(__a) | static_cast<int>(__b)); }

  inline _Ios_Fmtflags
  operator^(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
  { return _Ios_Fmtflags(static_cast<int>(__a) ^ static_cast<int>(__b)); }

  inline _Ios_Fmtflags&
  operator|=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)
  { return __a = __a | __b; }

  inline _Ios_Fmtflags&
  operator&=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)
  { return __a = __a & __b; }

  inline _Ios_Fmtflags&
  operator^=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)
  { return __a = __a ^ __b; }

  inline _Ios_Fmtflags
  operator~(_Ios_Fmtflags __a)
  { return _Ios_Fmtflags(~static_cast<int>(__a)); }


  enum _Ios_Openmode
    {
      _S_app = 1L << 0,
      _S_ate = 1L << 1,
      _S_bin = 1L << 2,
      _S_in = 1L << 3,
      _S_out = 1L << 4,
      _S_trunc = 1L << 5,
      _S_ios_openmode_end = 1L << 16
    };

  inline _Ios_Openmode
  operator&(_Ios_Openmode __a, _Ios_Openmode __b)
  { return _Ios_Openmode(static_cast<int>(__a) & static_cast<int>(__b)); }

  inline _Ios_Openmode
  operator|(_Ios_Openmode __a, _Ios_Openmode __b)
  { return _Ios_Openmode(static_cast<int>(__a) | static_cast<int>(__b)); }

  inline _Ios_Openmode
  operator^(_Ios_Openmode __a, _Ios_Openmode __b)
  { return _Ios_Openmode(static_cast<int>(__a) ^ static_cast<int>(__b)); }

  inline _Ios_Openmode&
  operator|=(_Ios_Openmode& __a, _Ios_Openmode __b)
  { return __a = __a | __b; }

  inline _Ios_Openmode&
  operator&=(_Ios_Openmode& __a, _Ios_Openmode __b)
  { return __a = __a & __b; }

  inline _Ios_Openmode&
  operator^=(_Ios_Openmode& __a, _Ios_Openmode __b)
  { return __a = __a ^ __b; }

  inline _Ios_Openmode
  operator~(_Ios_Openmode __a)
  { return _Ios_Openmode(~static_cast<int>(__a)); }


  enum _Ios_Iostate
    {
      _S_goodbit = 0,
      _S_badbit = 1L << 0,
      _S_eofbit = 1L << 1,
      _S_failbit = 1L << 2,
      _S_ios_iostate_end = 1L << 16
    };

  inline _Ios_Iostate
  operator&(_Ios_Iostate __a, _Ios_Iostate __b)
  { return _Ios_Iostate(static_cast<int>(__a) & static_cast<int>(__b)); }

  inline _Ios_Iostate
  operator|(_Ios_Iostate __a, _Ios_Iostate __b)
  { return _Ios_Iostate(static_cast<int>(__a) | static_cast<int>(__b)); }

  inline _Ios_Iostate
  operator^(_Ios_Iostate __a, _Ios_Iostate __b)
  { return _Ios_Iostate(static_cast<int>(__a) ^ static_cast<int>(__b)); }

  inline _Ios_Iostate&
  operator|=(_Ios_Iostate& __a, _Ios_Iostate __b)
  { return __a = __a | __b; }

  inline _Ios_Iostate&
  operator&=(_Ios_Iostate& __a, _Ios_Iostate __b)
  { return __a = __a & __b; }

  inline _Ios_Iostate&
  operator^=(_Ios_Iostate& __a, _Ios_Iostate __b)
  { return __a = __a ^ __b; }

  inline _Ios_Iostate
  operator~(_Ios_Iostate __a)
  { return _Ios_Iostate(~static_cast<int>(__a)); }

  enum _Ios_Seekdir
    {
      _S_beg = 0,
      _S_cur = 1,
      _S_end = 2,
      _S_ios_seekdir_end = 1L << 16
    };
# 207 "/usr/include/c++/4.4/bits/ios_base.h" 3
  class ios_base
  {
  public:







    class failure : public exception
    {
    public:


      explicit
      failure(const string& __str) throw();



      virtual
      ~failure() throw();

      virtual const char*
      what() const throw();

    private:
      string _M_msg;
    };
# 263 "/usr/include/c++/4.4/bits/ios_base.h" 3
    typedef _Ios_Fmtflags fmtflags;


    static const fmtflags boolalpha = _S_boolalpha;


    static const fmtflags dec = _S_dec;


    static const fmtflags fixed = _S_fixed;


    static const fmtflags hex = _S_hex;




    static const fmtflags internal = _S_internal;



    static const fmtflags left = _S_left;


    static const fmtflags oct = _S_oct;



    static const fmtflags right = _S_right;


    static const fmtflags scientific = _S_scientific;



    static const fmtflags showbase = _S_showbase;



    static const fmtflags showpoint = _S_showpoint;


    static const fmtflags showpos = _S_showpos;


    static const fmtflags skipws = _S_skipws;


    static const fmtflags unitbuf = _S_unitbuf;



    static const fmtflags uppercase = _S_uppercase;


    static const fmtflags adjustfield = _S_adjustfield;


    static const fmtflags basefield = _S_basefield;


    static const fmtflags floatfield = _S_floatfield;
# 338 "/usr/include/c++/4.4/bits/ios_base.h" 3
    typedef _Ios_Iostate iostate;



    static const iostate badbit = _S_badbit;


    static const iostate eofbit = _S_eofbit;




    static const iostate failbit = _S_failbit;


    static const iostate goodbit = _S_goodbit;
# 369 "/usr/include/c++/4.4/bits/ios_base.h" 3
    typedef _Ios_Openmode openmode;


    static const openmode app = _S_app;


    static const openmode ate = _S_ate;




    static const openmode binary = _S_bin;


    static const openmode in = _S_in;


    static const openmode out = _S_out;


    static const openmode trunc = _S_trunc;
# 401 "/usr/include/c++/4.4/bits/ios_base.h" 3
    typedef _Ios_Seekdir seekdir;


    static const seekdir beg = _S_beg;


    static const seekdir cur = _S_cur;


    static const seekdir end = _S_end;


    typedef int io_state;
    typedef int open_mode;
    typedef int seek_dir;

    typedef std::streampos streampos;
    typedef std::streamoff streamoff;
# 427 "/usr/include/c++/4.4/bits/ios_base.h" 3
    enum event
    {
      erase_event,
      imbue_event,
      copyfmt_event
    };
# 444 "/usr/include/c++/4.4/bits/ios_base.h" 3
    typedef void (*event_callback) (event, ios_base&, int);
# 456 "/usr/include/c++/4.4/bits/ios_base.h" 3
    void
    register_callback(event_callback __fn, int __index);

  protected:




    streamsize _M_precision;
    streamsize _M_width;
    fmtflags _M_flags;
    iostate _M_exception;
    iostate _M_streambuf_state;




    struct _Callback_list
    {

      _Callback_list* _M_next;
      ios_base::event_callback _M_fn;
      int _M_index;
      _Atomic_word _M_refcount;

      _Callback_list(ios_base::event_callback __fn, int __index,
       _Callback_list* __cb)
      : _M_next(__cb), _M_fn(__fn), _M_index(__index), _M_refcount(0) { }

      void
      _M_add_reference() { __gnu_cxx::__atomic_add_dispatch(&_M_refcount, 1); }


      int
      _M_remove_reference()
      { return __gnu_cxx::__exchange_and_add_dispatch(&_M_refcount, -1); }
    };

     _Callback_list* _M_callbacks;

    void
    _M_call_callbacks(event __ev) throw();

    void
    _M_dispose_callbacks(void);


    struct _Words
    {
      void* _M_pword;
      long _M_iword;
      _Words() : _M_pword(0), _M_iword(0) { }
    };


    _Words _M_word_zero;



    enum { _S_local_word_size = 8 };
    _Words _M_local_word[_S_local_word_size];


    int _M_word_size;
    _Words* _M_word;

    _Words&
    _M_grow_words(int __index, bool __iword);


    locale _M_ios_locale;

    void
    _M_init();

  public:





    class Init
    {
      friend class ios_base;
    public:
      Init();
      ~Init();

    private:
      static _Atomic_word _S_refcount;
      static bool _S_synced_with_stdio;
    };






    fmtflags
    flags() const
    { return _M_flags; }
# 565 "/usr/include/c++/4.4/bits/ios_base.h" 3
    fmtflags
    flags(fmtflags __fmtfl)
    {
      fmtflags __old = _M_flags;
      _M_flags = __fmtfl;
      return __old;
    }
# 581 "/usr/include/c++/4.4/bits/ios_base.h" 3
    fmtflags
    setf(fmtflags __fmtfl)
    {
      fmtflags __old = _M_flags;
      _M_flags |= __fmtfl;
      return __old;
    }
# 598 "/usr/include/c++/4.4/bits/ios_base.h" 3
    fmtflags
    setf(fmtflags __fmtfl, fmtflags __mask)
    {
      fmtflags __old = _M_flags;
      _M_flags &= ~__mask;
      _M_flags |= (__fmtfl & __mask);
      return __old;
    }







    void
    unsetf(fmtflags __mask)
    { _M_flags &= ~__mask; }
# 624 "/usr/include/c++/4.4/bits/ios_base.h" 3
    streamsize
    precision() const
    { return _M_precision; }






    streamsize
    precision(streamsize __prec)
    {
      streamsize __old = _M_precision;
      _M_precision = __prec;
      return __old;
    }







    streamsize
    width() const
    { return _M_width; }






    streamsize
    width(streamsize __wide)
    {
      streamsize __old = _M_width;
      _M_width = __wide;
      return __old;
    }
# 675 "/usr/include/c++/4.4/bits/ios_base.h" 3
    static bool
    sync_with_stdio(bool __sync = true);
# 687 "/usr/include/c++/4.4/bits/ios_base.h" 3
    locale
    imbue(const locale& __loc);
# 698 "/usr/include/c++/4.4/bits/ios_base.h" 3
    locale
    getloc() const
    { return _M_ios_locale; }
# 709 "/usr/include/c++/4.4/bits/ios_base.h" 3
    const locale&
    _M_getloc() const
    { return _M_ios_locale; }
# 728 "/usr/include/c++/4.4/bits/ios_base.h" 3
    static int
    xalloc() throw();
# 744 "/usr/include/c++/4.4/bits/ios_base.h" 3
    long&
    iword(int __ix)
    {
      _Words& __word = (__ix < _M_word_size)
   ? _M_word[__ix] : _M_grow_words(__ix, true);
      return __word._M_iword;
    }
# 765 "/usr/include/c++/4.4/bits/ios_base.h" 3
    void*&
    pword(int __ix)
    {
      _Words& __word = (__ix < _M_word_size)
   ? _M_word[__ix] : _M_grow_words(__ix, false);
      return __word._M_pword;
    }
# 782 "/usr/include/c++/4.4/bits/ios_base.h" 3
    virtual ~ios_base();

  protected:
    ios_base();



  private:
    ios_base(const ios_base&);

    ios_base&
    operator=(const ios_base&);
  };



  inline ios_base&
  boolalpha(ios_base& __base)
  {
    __base.setf(ios_base::boolalpha);
    return __base;
  }


  inline ios_base&
  noboolalpha(ios_base& __base)
  {
    __base.unsetf(ios_base::boolalpha);
    return __base;
  }


  inline ios_base&
  showbase(ios_base& __base)
  {
    __base.setf(ios_base::showbase);
    return __base;
  }


  inline ios_base&
  noshowbase(ios_base& __base)
  {
    __base.unsetf(ios_base::showbase);
    return __base;
  }


  inline ios_base&
  showpoint(ios_base& __base)
  {
    __base.setf(ios_base::showpoint);
    return __base;
  }


  inline ios_base&
  noshowpoint(ios_base& __base)
  {
    __base.unsetf(ios_base::showpoint);
    return __base;
  }


  inline ios_base&
  showpos(ios_base& __base)
  {
    __base.setf(ios_base::showpos);
    return __base;
  }


  inline ios_base&
  noshowpos(ios_base& __base)
  {
    __base.unsetf(ios_base::showpos);
    return __base;
  }


  inline ios_base&
  skipws(ios_base& __base)
  {
    __base.setf(ios_base::skipws);
    return __base;
  }


  inline ios_base&
  noskipws(ios_base& __base)
  {
    __base.unsetf(ios_base::skipws);
    return __base;
  }


  inline ios_base&
  uppercase(ios_base& __base)
  {
    __base.setf(ios_base::uppercase);
    return __base;
  }


  inline ios_base&
  nouppercase(ios_base& __base)
  {
    __base.unsetf(ios_base::uppercase);
    return __base;
  }


  inline ios_base&
  unitbuf(ios_base& __base)
  {
     __base.setf(ios_base::unitbuf);
     return __base;
  }


  inline ios_base&
  nounitbuf(ios_base& __base)
  {
     __base.unsetf(ios_base::unitbuf);
     return __base;
  }



  inline ios_base&
  internal(ios_base& __base)
  {
     __base.setf(ios_base::internal, ios_base::adjustfield);
     return __base;
  }


  inline ios_base&
  left(ios_base& __base)
  {
    __base.setf(ios_base::left, ios_base::adjustfield);
    return __base;
  }


  inline ios_base&
  right(ios_base& __base)
  {
    __base.setf(ios_base::right, ios_base::adjustfield);
    return __base;
  }



  inline ios_base&
  dec(ios_base& __base)
  {
    __base.setf(ios_base::dec, ios_base::basefield);
    return __base;
  }


  inline ios_base&
  hex(ios_base& __base)
  {
    __base.setf(ios_base::hex, ios_base::basefield);
    return __base;
  }


  inline ios_base&
  oct(ios_base& __base)
  {
    __base.setf(ios_base::oct, ios_base::basefield);
    return __base;
  }



  inline ios_base&
  fixed(ios_base& __base)
  {
    __base.setf(ios_base::fixed, ios_base::floatfield);
    return __base;
  }


  inline ios_base&
  scientific(ios_base& __base)
  {
    __base.setf(ios_base::scientific, ios_base::floatfield);
    return __base;
  }

}
# 44 "/usr/include/c++/4.4/ios" 2 3
# 1 "/usr/include/c++/4.4/streambuf" 1 3
# 37 "/usr/include/c++/4.4/streambuf" 3
       
# 38 "/usr/include/c++/4.4/streambuf" 3
# 46 "/usr/include/c++/4.4/streambuf" 3
namespace std __attribute__ ((__visibility__ ("default"))) {

  template<typename _CharT, typename _Traits>
    streamsize
    __copy_streambufs_eof(basic_streambuf<_CharT, _Traits>*,
     basic_streambuf<_CharT, _Traits>*, bool&);
# 113 "/usr/include/c++/4.4/streambuf" 3
  template<typename _CharT, typename _Traits>
    class basic_streambuf
    {
    public:






      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;




      typedef basic_streambuf<char_type, traits_type> __streambuf_type;


      friend class basic_ios<char_type, traits_type>;
      friend class basic_istream<char_type, traits_type>;
      friend class basic_ostream<char_type, traits_type>;
      friend class istreambuf_iterator<char_type, traits_type>;
      friend class ostreambuf_iterator<char_type, traits_type>;

      friend streamsize
      __copy_streambufs_eof<>(__streambuf_type*, __streambuf_type*, bool&);

      template<bool _IsMove, typename _CharT2>
        friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
            _CharT2*>::__type
        __copy_move_a2(istreambuf_iterator<_CharT2>,
         istreambuf_iterator<_CharT2>, _CharT2*);

      template<typename _CharT2>
        friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
      istreambuf_iterator<_CharT2> >::__type
        find(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      const _CharT2&);

      template<typename _CharT2, typename _Traits2>
        friend basic_istream<_CharT2, _Traits2>&
        operator>>(basic_istream<_CharT2, _Traits2>&, _CharT2*);

      template<typename _CharT2, typename _Traits2, typename _Alloc>
        friend basic_istream<_CharT2, _Traits2>&
        operator>>(basic_istream<_CharT2, _Traits2>&,
     basic_string<_CharT2, _Traits2, _Alloc>&);

      template<typename _CharT2, typename _Traits2, typename _Alloc>
        friend basic_istream<_CharT2, _Traits2>&
        getline(basic_istream<_CharT2, _Traits2>&,
  basic_string<_CharT2, _Traits2, _Alloc>&, _CharT2);

    protected:
# 179 "/usr/include/c++/4.4/streambuf" 3
      char_type* _M_in_beg;
      char_type* _M_in_cur;
      char_type* _M_in_end;
      char_type* _M_out_beg;
      char_type* _M_out_cur;
      char_type* _M_out_end;


      locale _M_buf_locale;

  public:

      virtual
      ~basic_streambuf()
      { }
# 203 "/usr/include/c++/4.4/streambuf" 3
      locale
      pubimbue(const locale &__loc)
      {
 locale __tmp(this->getloc());
 this->imbue(__loc);
 _M_buf_locale = __loc;
 return __tmp;
      }
# 220 "/usr/include/c++/4.4/streambuf" 3
      locale
      getloc() const
      { return _M_buf_locale; }
# 233 "/usr/include/c++/4.4/streambuf" 3
      __streambuf_type*
      pubsetbuf(char_type* __s, streamsize __n)
      { return this->setbuf(__s, __n); }

      pos_type
      pubseekoff(off_type __off, ios_base::seekdir __way,
   ios_base::openmode __mode = ios_base::in | ios_base::out)
      { return this->seekoff(__off, __way, __mode); }

      pos_type
      pubseekpos(pos_type __sp,
   ios_base::openmode __mode = ios_base::in | ios_base::out)
      { return this->seekpos(__sp, __mode); }

      int
      pubsync() { return this->sync(); }
# 260 "/usr/include/c++/4.4/streambuf" 3
      streamsize
      in_avail()
      {
 const streamsize __ret = this->egptr() - this->gptr();
 return __ret ? __ret : this->showmanyc();
      }
# 274 "/usr/include/c++/4.4/streambuf" 3
      int_type
      snextc()
      {
 int_type __ret = traits_type::eof();
 if (__builtin_expect(!traits_type::eq_int_type(this->sbumpc(),
             __ret), true))
   __ret = this->sgetc();
 return __ret;
      }
# 292 "/usr/include/c++/4.4/streambuf" 3
      int_type
      sbumpc()
      {
 int_type __ret;
 if (__builtin_expect(this->gptr() < this->egptr(), true))
   {
     __ret = traits_type::to_int_type(*this->gptr());
     this->gbump(1);
   }
 else
   __ret = this->uflow();
 return __ret;
      }
# 314 "/usr/include/c++/4.4/streambuf" 3
      int_type
      sgetc()
      {
 int_type __ret;
 if (__builtin_expect(this->gptr() < this->egptr(), true))
   __ret = traits_type::to_int_type(*this->gptr());
 else
   __ret = this->underflow();
 return __ret;
      }
# 333 "/usr/include/c++/4.4/streambuf" 3
      streamsize
      sgetn(char_type* __s, streamsize __n)
      { return this->xsgetn(__s, __n); }
# 347 "/usr/include/c++/4.4/streambuf" 3
      int_type
      sputbackc(char_type __c)
      {
 int_type __ret;
 const bool __testpos = this->eback() < this->gptr();
 if (__builtin_expect(!__testpos ||
        !traits_type::eq(__c, this->gptr()[-1]), false))
   __ret = this->pbackfail(traits_type::to_int_type(__c));
 else
   {
     this->gbump(-1);
     __ret = traits_type::to_int_type(*this->gptr());
   }
 return __ret;
      }
# 372 "/usr/include/c++/4.4/streambuf" 3
      int_type
      sungetc()
      {
 int_type __ret;
 if (__builtin_expect(this->eback() < this->gptr(), true))
   {
     this->gbump(-1);
     __ret = traits_type::to_int_type(*this->gptr());
   }
 else
   __ret = this->pbackfail();
 return __ret;
      }
# 399 "/usr/include/c++/4.4/streambuf" 3
      int_type
      sputc(char_type __c)
      {
 int_type __ret;
 if (__builtin_expect(this->pptr() < this->epptr(), true))
   {
     *this->pptr() = __c;
     this->pbump(1);
     __ret = traits_type::to_int_type(__c);
   }
 else
   __ret = this->overflow(traits_type::to_int_type(__c));
 return __ret;
      }
# 425 "/usr/include/c++/4.4/streambuf" 3
      streamsize
      sputn(const char_type* __s, streamsize __n)
      { return this->xsputn(__s, __n); }

    protected:
# 439 "/usr/include/c++/4.4/streambuf" 3
      basic_streambuf()
      : _M_in_beg(0), _M_in_cur(0), _M_in_end(0),
      _M_out_beg(0), _M_out_cur(0), _M_out_end(0),
      _M_buf_locale(locale())
      { }
# 457 "/usr/include/c++/4.4/streambuf" 3
      char_type*
      eback() const { return _M_in_beg; }

      char_type*
      gptr() const { return _M_in_cur; }

      char_type*
      egptr() const { return _M_in_end; }
# 473 "/usr/include/c++/4.4/streambuf" 3
      void
      gbump(int __n) { _M_in_cur += __n; }
# 484 "/usr/include/c++/4.4/streambuf" 3
      void
      setg(char_type* __gbeg, char_type* __gnext, char_type* __gend)
      {
 _M_in_beg = __gbeg;
 _M_in_cur = __gnext;
 _M_in_end = __gend;
      }
# 504 "/usr/include/c++/4.4/streambuf" 3
      char_type*
      pbase() const { return _M_out_beg; }

      char_type*
      pptr() const { return _M_out_cur; }

      char_type*
      epptr() const { return _M_out_end; }
# 520 "/usr/include/c++/4.4/streambuf" 3
      void
      pbump(int __n) { _M_out_cur += __n; }
# 530 "/usr/include/c++/4.4/streambuf" 3
      void
      setp(char_type* __pbeg, char_type* __pend)
      {
 _M_out_beg = _M_out_cur = __pbeg;
 _M_out_end = __pend;
      }
# 551 "/usr/include/c++/4.4/streambuf" 3
      virtual void
      imbue(const locale&)
      { }
# 566 "/usr/include/c++/4.4/streambuf" 3
      virtual basic_streambuf<char_type,_Traits>*
      setbuf(char_type*, streamsize)
      { return this; }
# 577 "/usr/include/c++/4.4/streambuf" 3
      virtual pos_type
      seekoff(off_type, ios_base::seekdir,
       ios_base::openmode = ios_base::in | ios_base::out)
      { return pos_type(off_type(-1)); }
# 589 "/usr/include/c++/4.4/streambuf" 3
      virtual pos_type
      seekpos(pos_type,
       ios_base::openmode = ios_base::in | ios_base::out)
      { return pos_type(off_type(-1)); }
# 602 "/usr/include/c++/4.4/streambuf" 3
      virtual int
      sync() { return 0; }
# 624 "/usr/include/c++/4.4/streambuf" 3
      virtual streamsize
      showmanyc() { return 0; }
# 640 "/usr/include/c++/4.4/streambuf" 3
      virtual streamsize
      xsgetn(char_type* __s, streamsize __n);
# 662 "/usr/include/c++/4.4/streambuf" 3
      virtual int_type
      underflow()
      { return traits_type::eof(); }
# 675 "/usr/include/c++/4.4/streambuf" 3
      virtual int_type
      uflow()
      {
 int_type __ret = traits_type::eof();
 const bool __testeof = traits_type::eq_int_type(this->underflow(),
       __ret);
 if (!__testeof)
   {
     __ret = traits_type::to_int_type(*this->gptr());
     this->gbump(1);
   }
 return __ret;
      }
# 699 "/usr/include/c++/4.4/streambuf" 3
      virtual int_type
      pbackfail(int_type = traits_type::eof())
      { return traits_type::eof(); }
# 717 "/usr/include/c++/4.4/streambuf" 3
      virtual streamsize
      xsputn(const char_type* __s, streamsize __n);
# 742 "/usr/include/c++/4.4/streambuf" 3
      virtual int_type
      overflow(int_type = traits_type::eof())
      { return traits_type::eof(); }



    public:
# 757 "/usr/include/c++/4.4/streambuf" 3
      void
      stossc()
      {
 if (this->gptr() < this->egptr())
   this->gbump(1);
 else
   this->uflow();
      }


    private:


      basic_streambuf(const __streambuf_type& __sb)
      : _M_in_beg(__sb._M_in_beg), _M_in_cur(__sb._M_in_cur),
      _M_in_end(__sb._M_in_end), _M_out_beg(__sb._M_out_beg),
      _M_out_cur(__sb._M_out_cur), _M_out_end(__sb._M_out_cur),
      _M_buf_locale(__sb._M_buf_locale)
      { }

      __streambuf_type&
      operator=(const __streambuf_type&) { return *this; };
    };


  template<>
    streamsize
    __copy_streambufs_eof(basic_streambuf<char>* __sbin,
     basic_streambuf<char>* __sbout, bool& __ineof);

  template<>
    streamsize
    __copy_streambufs_eof(basic_streambuf<wchar_t>* __sbin,
     basic_streambuf<wchar_t>* __sbout, bool& __ineof);


}


# 1 "/usr/include/c++/4.4/bits/streambuf.tcc" 1 3
# 38 "/usr/include/c++/4.4/bits/streambuf.tcc" 3
       
# 39 "/usr/include/c++/4.4/bits/streambuf.tcc" 3

namespace std __attribute__ ((__visibility__ ("default"))) {

  template<typename _CharT, typename _Traits>
    streamsize
    basic_streambuf<_CharT, _Traits>::
    xsgetn(char_type* __s, streamsize __n)
    {
      streamsize __ret = 0;
      while (__ret < __n)
 {
   const streamsize __buf_len = this->egptr() - this->gptr();
   if (__buf_len)
     {
       const streamsize __remaining = __n - __ret;
       const streamsize __len = std::min(__buf_len, __remaining);
       traits_type::copy(__s, this->gptr(), __len);
       __ret += __len;
       __s += __len;
       this->gbump(__len);
     }

   if (__ret < __n)
     {
       const int_type __c = this->uflow();
       if (!traits_type::eq_int_type(__c, traits_type::eof()))
  {
    traits_type::assign(*__s++, traits_type::to_char_type(__c));
    ++__ret;
  }
       else
  break;
     }
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    streamsize
    basic_streambuf<_CharT, _Traits>::
    xsputn(const char_type* __s, streamsize __n)
    {
      streamsize __ret = 0;
      while (__ret < __n)
 {
   const streamsize __buf_len = this->epptr() - this->pptr();
   if (__buf_len)
     {
       const streamsize __remaining = __n - __ret;
       const streamsize __len = std::min(__buf_len, __remaining);
       traits_type::copy(this->pptr(), __s, __len);
       __ret += __len;
       __s += __len;
       this->pbump(__len);
     }

   if (__ret < __n)
     {
       int_type __c = this->overflow(traits_type::to_int_type(*__s));
       if (!traits_type::eq_int_type(__c, traits_type::eof()))
  {
    ++__ret;
    ++__s;
  }
       else
  break;
     }
 }
      return __ret;
    }




  template<typename _CharT, typename _Traits>
    streamsize
    __copy_streambufs_eof(basic_streambuf<_CharT, _Traits>* __sbin,
     basic_streambuf<_CharT, _Traits>* __sbout,
     bool& __ineof)
    {
      streamsize __ret = 0;
      __ineof = true;
      typename _Traits::int_type __c = __sbin->sgetc();
      while (!_Traits::eq_int_type(__c, _Traits::eof()))
 {
   __c = __sbout->sputc(_Traits::to_char_type(__c));
   if (_Traits::eq_int_type(__c, _Traits::eof()))
     {
       __ineof = false;
       break;
     }
   ++__ret;
   __c = __sbin->snextc();
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    inline streamsize
    __copy_streambufs(basic_streambuf<_CharT, _Traits>* __sbin,
        basic_streambuf<_CharT, _Traits>* __sbout)
    {
      bool __ineof;
      return __copy_streambufs_eof(__sbin, __sbout, __ineof);
    }





  extern template class basic_streambuf<char>;
  extern template
    streamsize
    __copy_streambufs(basic_streambuf<char>*,
        basic_streambuf<char>*);
  extern template
    streamsize
    __copy_streambufs_eof(basic_streambuf<char>*,
     basic_streambuf<char>*, bool&);


  extern template class basic_streambuf<wchar_t>;
  extern template
    streamsize
    __copy_streambufs(basic_streambuf<wchar_t>*,
        basic_streambuf<wchar_t>*);
  extern template
    streamsize
    __copy_streambufs_eof(basic_streambuf<wchar_t>*,
     basic_streambuf<wchar_t>*, bool&);



}
# 797 "/usr/include/c++/4.4/streambuf" 2 3
# 45 "/usr/include/c++/4.4/ios" 2 3
# 1 "/usr/include/c++/4.4/bits/basic_ios.h" 1 3
# 35 "/usr/include/c++/4.4/bits/basic_ios.h" 3
       
# 36 "/usr/include/c++/4.4/bits/basic_ios.h" 3



# 1 "/usr/include/c++/4.4/bits/locale_facets.h" 1 3
# 39 "/usr/include/c++/4.4/bits/locale_facets.h" 3
       
# 40 "/usr/include/c++/4.4/bits/locale_facets.h" 3

# 1 "/usr/include/c++/4.4/cwctype" 1 3
# 41 "/usr/include/c++/4.4/cwctype" 3
       
# 42 "/usr/include/c++/4.4/cwctype" 3
# 76 "/usr/include/c++/4.4/cwctype" 3
namespace std __attribute__ ((__visibility__ ("default"))) {

  using ::wctrans_t;
  using ::wctype_t;
  using ::wint_t;

  using ::iswalnum;
  using ::iswalpha;

  using ::iswblank;

  using ::iswcntrl;
  using ::iswctype;
  using ::iswdigit;
  using ::iswgraph;
  using ::iswlower;
  using ::iswprint;
  using ::iswpunct;
  using ::iswspace;
  using ::iswupper;
  using ::iswxdigit;
  using ::towctrans;
  using ::towlower;
  using ::towupper;
  using ::wctrans;
  using ::wctype;

}
# 42 "/usr/include/c++/4.4/bits/locale_facets.h" 2 3
# 1 "/usr/include/c++/4.4/cctype" 1 3
# 41 "/usr/include/c++/4.4/cctype" 3
       
# 42 "/usr/include/c++/4.4/cctype" 3
# 43 "/usr/include/c++/4.4/bits/locale_facets.h" 2 3
# 1 "/usr/include/c++/4.4/i686-linux-gnu/bits/ctype_base.h" 1 3
# 37 "/usr/include/c++/4.4/i686-linux-gnu/bits/ctype_base.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {


  struct ctype_base
  {

    typedef const int* __to_type;



    typedef unsigned short mask;
    static const mask upper = _ISupper;
    static const mask lower = _ISlower;
    static const mask alpha = _ISalpha;
    static const mask digit = _ISdigit;
    static const mask xdigit = _ISxdigit;
    static const mask space = _ISspace;
    static const mask print = _ISprint;
    static const mask graph = _ISalpha | _ISdigit | _ISpunct;
    static const mask cntrl = _IScntrl;
    static const mask punct = _ISpunct;
    static const mask alnum = _ISalpha | _ISdigit;
  };

}
# 44 "/usr/include/c++/4.4/bits/locale_facets.h" 2 3






# 1 "/usr/include/c++/4.4/bits/streambuf_iterator.h" 1 3
# 35 "/usr/include/c++/4.4/bits/streambuf_iterator.h" 3
       
# 36 "/usr/include/c++/4.4/bits/streambuf_iterator.h" 3




namespace std __attribute__ ((__visibility__ ("default"))) {



  template<typename _CharT, typename _Traits>
    class istreambuf_iterator
    : public iterator<input_iterator_tag, _CharT, typename _Traits::off_type,
        _CharT*, _CharT&>
    {
    public:



      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename _Traits::int_type int_type;
      typedef basic_streambuf<_CharT, _Traits> streambuf_type;
      typedef basic_istream<_CharT, _Traits> istream_type;


      template<typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
                      ostreambuf_iterator<_CharT2> >::__type
 copy(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      ostreambuf_iterator<_CharT2>);

      template<bool _IsMove, typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
            _CharT2*>::__type
 __copy_move_a2(istreambuf_iterator<_CharT2>,
         istreambuf_iterator<_CharT2>, _CharT2*);

      template<typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
               istreambuf_iterator<_CharT2> >::__type
 find(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      const _CharT2&);

    private:







      mutable streambuf_type* _M_sbuf;
      mutable int_type _M_c;

    public:

      istreambuf_iterator() throw()
      : _M_sbuf(0), _M_c(traits_type::eof()) { }


      istreambuf_iterator(istream_type& __s) throw()
      : _M_sbuf(__s.rdbuf()), _M_c(traits_type::eof()) { }


      istreambuf_iterator(streambuf_type* __s) throw()
      : _M_sbuf(__s), _M_c(traits_type::eof()) { }




      char_type
      operator*() const
      {







 return traits_type::to_char_type(_M_get());
      }


      istreambuf_iterator&
      operator++()
      {
 ;


 if (_M_sbuf)
   {
     _M_sbuf->sbumpc();
     _M_c = traits_type::eof();
   }
 return *this;
      }


      istreambuf_iterator
      operator++(int)
      {
 ;



 istreambuf_iterator __old = *this;
 if (_M_sbuf)
   {
     __old._M_c = _M_sbuf->sbumpc();
     _M_c = traits_type::eof();
   }
 return __old;
      }





      bool
      equal(const istreambuf_iterator& __b) const
      { return _M_at_eof() == __b._M_at_eof(); }

    private:
      int_type
      _M_get() const
      {
 const int_type __eof = traits_type::eof();
 int_type __ret = __eof;
 if (_M_sbuf)
   {
     if (!traits_type::eq_int_type(_M_c, __eof))
       __ret = _M_c;
     else if (!traits_type::eq_int_type((__ret = _M_sbuf->sgetc()),
            __eof))
       _M_c = __ret;
     else
       _M_sbuf = 0;
   }
 return __ret;
      }

      bool
      _M_at_eof() const
      {
 const int_type __eof = traits_type::eof();
 return traits_type::eq_int_type(_M_get(), __eof);
      }
    };

  template<typename _CharT, typename _Traits>
    inline bool
    operator==(const istreambuf_iterator<_CharT, _Traits>& __a,
        const istreambuf_iterator<_CharT, _Traits>& __b)
    { return __a.equal(__b); }

  template<typename _CharT, typename _Traits>
    inline bool
    operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
        const istreambuf_iterator<_CharT, _Traits>& __b)
    { return !__a.equal(__b); }


  template<typename _CharT, typename _Traits>
    class ostreambuf_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    public:



      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef basic_streambuf<_CharT, _Traits> streambuf_type;
      typedef basic_ostream<_CharT, _Traits> ostream_type;


      template<typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
                      ostreambuf_iterator<_CharT2> >::__type
 copy(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      ostreambuf_iterator<_CharT2>);

    private:
      streambuf_type* _M_sbuf;
      bool _M_failed;

    public:

      ostreambuf_iterator(ostream_type& __s) throw ()
      : _M_sbuf(__s.rdbuf()), _M_failed(!_M_sbuf) { }


      ostreambuf_iterator(streambuf_type* __s) throw ()
      : _M_sbuf(__s), _M_failed(!_M_sbuf) { }


      ostreambuf_iterator&
      operator=(_CharT __c)
      {
 if (!_M_failed &&
     _Traits::eq_int_type(_M_sbuf->sputc(__c), _Traits::eof()))
   _M_failed = true;
 return *this;
      }


      ostreambuf_iterator&
      operator*()
      { return *this; }


      ostreambuf_iterator&
      operator++(int)
      { return *this; }


      ostreambuf_iterator&
      operator++()
      { return *this; }


      bool
      failed() const throw()
      { return _M_failed; }

      ostreambuf_iterator&
      _M_put(const _CharT* __ws, streamsize __len)
      {
 if (__builtin_expect(!_M_failed, true)
     && __builtin_expect(this->_M_sbuf->sputn(__ws, __len) != __len,
    false))
   _M_failed = true;
 return *this;
      }
    };


  template<typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
                           ostreambuf_iterator<_CharT> >::__type
    copy(istreambuf_iterator<_CharT> __first,
  istreambuf_iterator<_CharT> __last,
  ostreambuf_iterator<_CharT> __result)
    {
      if (__first._M_sbuf && !__last._M_sbuf && !__result._M_failed)
 {
   bool __ineof;
   __copy_streambufs_eof(__first._M_sbuf, __result._M_sbuf, __ineof);
   if (!__ineof)
     __result._M_failed = true;
 }
      return __result;
    }

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
            ostreambuf_iterator<_CharT> >::__type
    __copy_move_a2(_CharT* __first, _CharT* __last,
     ostreambuf_iterator<_CharT> __result)
    {
      const streamsize __num = __last - __first;
      if (__num > 0)
 __result._M_put(__first, __num);
      return __result;
    }

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
        ostreambuf_iterator<_CharT> >::__type
    __copy_move_a2(const _CharT* __first, const _CharT* __last,
     ostreambuf_iterator<_CharT> __result)
    {
      const streamsize __num = __last - __first;
      if (__num > 0)
 __result._M_put(__first, __num);
      return __result;
    }

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
            _CharT*>::__type
    __copy_move_a2(istreambuf_iterator<_CharT> __first,
     istreambuf_iterator<_CharT> __last, _CharT* __result)
    {
      typedef istreambuf_iterator<_CharT> __is_iterator_type;
      typedef typename __is_iterator_type::traits_type traits_type;
      typedef typename __is_iterator_type::streambuf_type streambuf_type;
      typedef typename traits_type::int_type int_type;

      if (__first._M_sbuf && !__last._M_sbuf)
 {
   streambuf_type* __sb = __first._M_sbuf;
   int_type __c = __sb->sgetc();
   while (!traits_type::eq_int_type(__c, traits_type::eof()))
     {
       const streamsize __n = __sb->egptr() - __sb->gptr();
       if (__n > 1)
  {
    traits_type::copy(__result, __sb->gptr(), __n);
    __sb->gbump(__n);
    __result += __n;
    __c = __sb->underflow();
  }
       else
  {
    *__result++ = traits_type::to_char_type(__c);
    __c = __sb->snextc();
  }
     }
 }
      return __result;
    }

  template<typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
          istreambuf_iterator<_CharT> >::__type
    find(istreambuf_iterator<_CharT> __first,
  istreambuf_iterator<_CharT> __last, const _CharT& __val)
    {
      typedef istreambuf_iterator<_CharT> __is_iterator_type;
      typedef typename __is_iterator_type::traits_type traits_type;
      typedef typename __is_iterator_type::streambuf_type streambuf_type;
      typedef typename traits_type::int_type int_type;

      if (__first._M_sbuf && !__last._M_sbuf)
 {
   const int_type __ival = traits_type::to_int_type(__val);
   streambuf_type* __sb = __first._M_sbuf;
   int_type __c = __sb->sgetc();
   while (!traits_type::eq_int_type(__c, traits_type::eof())
   && !traits_type::eq_int_type(__c, __ival))
     {
       streamsize __n = __sb->egptr() - __sb->gptr();
       if (__n > 1)
  {
    const _CharT* __p = traits_type::find(__sb->gptr(),
       __n, __val);
    if (__p)
      __n = __p - __sb->gptr();
    __sb->gbump(__n);
    __c = __sb->sgetc();
  }
       else
  __c = __sb->snextc();
     }

   if (!traits_type::eq_int_type(__c, traits_type::eof()))
     __first._M_c = __c;
   else
     __first._M_sbuf = 0;
 }
      return __first;
    }

}
# 51 "/usr/include/c++/4.4/bits/locale_facets.h" 2 3

namespace std __attribute__ ((__visibility__ ("default"))) {
# 64 "/usr/include/c++/4.4/bits/locale_facets.h" 3
  template<typename _Tv>
    void
    __convert_to_v(const char* __in, _Tv& __out, ios_base::iostate& __err,
     const __c_locale& __cloc);


  template<>
    void
    __convert_to_v(const char*, float&, ios_base::iostate&,
     const __c_locale&);

  template<>
    void
    __convert_to_v(const char*, double&, ios_base::iostate&,
     const __c_locale&);

  template<>
    void
    __convert_to_v(const char*, long double&, ios_base::iostate&,
     const __c_locale&);



  template<typename _CharT, typename _Traits>
    struct __pad
    {
      static void
      _S_pad(ios_base& __io, _CharT __fill, _CharT* __news,
      const _CharT* __olds, streamsize __newlen, streamsize __oldlen);
    };






  template<typename _CharT>
    _CharT*
    __add_grouping(_CharT* __s, _CharT __sep,
     const char* __gbeg, size_t __gsize,
     const _CharT* __first, const _CharT* __last);




  template<typename _CharT>
    inline
    ostreambuf_iterator<_CharT>
    __write(ostreambuf_iterator<_CharT> __s, const _CharT* __ws, int __len)
    {
      __s._M_put(__ws, __len);
      return __s;
    }


  template<typename _CharT, typename _OutIter>
    inline
    _OutIter
    __write(_OutIter __s, const _CharT* __ws, int __len)
    {
      for (int __j = 0; __j < __len; __j++, ++__s)
 *__s = __ws[__j];
      return __s;
    }
# 143 "/usr/include/c++/4.4/bits/locale_facets.h" 3
  template<typename _CharT>
    class __ctype_abstract_base : public locale::facet, public ctype_base
    {
    public:


      typedef _CharT char_type;
# 161 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      bool
      is(mask __m, char_type __c) const
      { return this->do_is(__m, __c); }
# 178 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      const char_type*
      is(const char_type *__lo, const char_type *__hi, mask *__vec) const
      { return this->do_is(__lo, __hi, __vec); }
# 194 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      const char_type*
      scan_is(mask __m, const char_type* __lo, const char_type* __hi) const
      { return this->do_scan_is(__m, __lo, __hi); }
# 210 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      const char_type*
      scan_not(mask __m, const char_type* __lo, const char_type* __hi) const
      { return this->do_scan_not(__m, __lo, __hi); }
# 224 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      char_type
      toupper(char_type __c) const
      { return this->do_toupper(__c); }
# 239 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      const char_type*
      toupper(char_type *__lo, const char_type* __hi) const
      { return this->do_toupper(__lo, __hi); }
# 253 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      char_type
      tolower(char_type __c) const
      { return this->do_tolower(__c); }
# 268 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      const char_type*
      tolower(char_type* __lo, const char_type* __hi) const
      { return this->do_tolower(__lo, __hi); }
# 285 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      char_type
      widen(char __c) const
      { return this->do_widen(__c); }
# 304 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      const char*
      widen(const char* __lo, const char* __hi, char_type* __to) const
      { return this->do_widen(__lo, __hi, __to); }
# 323 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      char
      narrow(char_type __c, char __dfault) const
      { return this->do_narrow(__c, __dfault); }
# 345 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      const char_type*
      narrow(const char_type* __lo, const char_type* __hi,
       char __dfault, char *__to) const
      { return this->do_narrow(__lo, __hi, __dfault, __to); }

    protected:
      explicit
      __ctype_abstract_base(size_t __refs = 0): facet(__refs) { }

      virtual
      ~__ctype_abstract_base() { }
# 370 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      virtual bool
      do_is(mask __m, char_type __c) const = 0;
# 389 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      virtual const char_type*
      do_is(const char_type* __lo, const char_type* __hi,
     mask* __vec) const = 0;
# 408 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_is(mask __m, const char_type* __lo,
   const char_type* __hi) const = 0;
# 427 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_not(mask __m, const char_type* __lo,
    const char_type* __hi) const = 0;
# 445 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      virtual char_type
      do_toupper(char_type) const = 0;
# 462 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const = 0;
# 478 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      virtual char_type
      do_tolower(char_type) const = 0;
# 495 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const = 0;
# 514 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      virtual char_type
      do_widen(char) const = 0;
# 535 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      virtual const char*
      do_widen(const char* __lo, const char* __hi,
        char_type* __dest) const = 0;
# 557 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      virtual char
      do_narrow(char_type, char __dfault) const = 0;
# 581 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault, char* __dest) const = 0;
    };
# 604 "/usr/include/c++/4.4/bits/locale_facets.h" 3
  template<typename _CharT>
    class ctype : public __ctype_abstract_base<_CharT>
    {
    public:

      typedef _CharT char_type;
      typedef typename __ctype_abstract_base<_CharT>::mask mask;


      static locale::id id;

      explicit
      ctype(size_t __refs = 0) : __ctype_abstract_base<_CharT>(__refs) { }

   protected:
      virtual
      ~ctype();

      virtual bool
      do_is(mask __m, char_type __c) const;

      virtual const char_type*
      do_is(const char_type* __lo, const char_type* __hi, mask* __vec) const;

      virtual const char_type*
      do_scan_is(mask __m, const char_type* __lo, const char_type* __hi) const;

      virtual const char_type*
      do_scan_not(mask __m, const char_type* __lo,
    const char_type* __hi) const;

      virtual char_type
      do_toupper(char_type __c) const;

      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const;

      virtual char_type
      do_tolower(char_type __c) const;

      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const;

      virtual char_type
      do_widen(char __c) const;

      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __dest) const;

      virtual char
      do_narrow(char_type, char __dfault) const;

      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault, char* __dest) const;
    };

  template<typename _CharT>
    locale::id ctype<_CharT>::id;
# 673 "/usr/include/c++/4.4/bits/locale_facets.h" 3
  template<>
    class ctype<char> : public locale::facet, public ctype_base
    {
    public:


      typedef char char_type;

    protected:

      __c_locale _M_c_locale_ctype;
      bool _M_del;
      __to_type _M_toupper;
      __to_type _M_tolower;
      const mask* _M_table;
      mutable char _M_widen_ok;
      mutable char _M_widen[1 + static_cast<unsigned char>(-1)];
      mutable char _M_narrow[1 + static_cast<unsigned char>(-1)];
      mutable char _M_narrow_ok;


    public:

      static locale::id id;

      static const size_t table_size = 1 + static_cast<unsigned char>(-1);
# 710 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      explicit
      ctype(const mask* __table = 0, bool __del = false, size_t __refs = 0);
# 723 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      explicit
      ctype(__c_locale __cloc, const mask* __table = 0, bool __del = false,
     size_t __refs = 0);
# 736 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      inline bool
      is(mask __m, char __c) const;
# 751 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      inline const char*
      is(const char* __lo, const char* __hi, mask* __vec) const;
# 765 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      inline const char*
      scan_is(mask __m, const char* __lo, const char* __hi) const;
# 779 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      inline const char*
      scan_not(mask __m, const char* __lo, const char* __hi) const;
# 794 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      char_type
      toupper(char_type __c) const
      { return this->do_toupper(__c); }
# 811 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      const char_type*
      toupper(char_type *__lo, const char_type* __hi) const
      { return this->do_toupper(__lo, __hi); }
# 827 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      char_type
      tolower(char_type __c) const
      { return this->do_tolower(__c); }
# 844 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      const char_type*
      tolower(char_type* __lo, const char_type* __hi) const
      { return this->do_tolower(__lo, __hi); }
# 864 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      char_type
      widen(char __c) const
      {
 if (_M_widen_ok)
   return _M_widen[static_cast<unsigned char>(__c)];
 this->_M_widen_init();
 return this->do_widen(__c);
      }
# 891 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      const char*
      widen(const char* __lo, const char* __hi, char_type* __to) const
      {
 if (_M_widen_ok == 1)
   {
     __builtin_memcpy(__to, __lo, __hi - __lo);
     return __hi;
   }
 if (!_M_widen_ok)
   _M_widen_init();
 return this->do_widen(__lo, __hi, __to);
      }
# 922 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      char
      narrow(char_type __c, char __dfault) const
      {
 if (_M_narrow[static_cast<unsigned char>(__c)])
   return _M_narrow[static_cast<unsigned char>(__c)];
 const char __t = do_narrow(__c, __dfault);
 if (__t != __dfault)
   _M_narrow[static_cast<unsigned char>(__c)] = __t;
 return __t;
      }
# 955 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      const char_type*
      narrow(const char_type* __lo, const char_type* __hi,
      char __dfault, char *__to) const
      {
 if (__builtin_expect(_M_narrow_ok == 1, true))
   {
     __builtin_memcpy(__to, __lo, __hi - __lo);
     return __hi;
   }
 if (!_M_narrow_ok)
   _M_narrow_init();
 return this->do_narrow(__lo, __hi, __dfault, __to);
      }





      const mask*
      table() const throw()
      { return _M_table; }


      static const mask*
      classic_table() throw();
    protected:







      virtual
      ~ctype();
# 1004 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      virtual char_type
      do_toupper(char_type) const;
# 1021 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const;
# 1037 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      virtual char_type
      do_tolower(char_type) const;
# 1054 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const;
# 1074 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      virtual char_type
      do_widen(char __c) const
      { return __c; }
# 1097 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __dest) const
      {
 __builtin_memcpy(__dest, __lo, __hi - __lo);
 return __hi;
      }
# 1123 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      virtual char
      do_narrow(char_type __c, char) const
      { return __c; }
# 1149 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char, char* __dest) const
      {
 __builtin_memcpy(__dest, __lo, __hi - __lo);
 return __hi;
      }

    private:
      void _M_narrow_init() const;
      void _M_widen_init() const;
    };
# 1174 "/usr/include/c++/4.4/bits/locale_facets.h" 3
  template<>
    class ctype<wchar_t> : public __ctype_abstract_base<wchar_t>
    {
    public:


      typedef wchar_t char_type;
      typedef wctype_t __wmask_type;

    protected:
      __c_locale _M_c_locale_ctype;


      bool _M_narrow_ok;
      char _M_narrow[128];
      wint_t _M_widen[1 + static_cast<unsigned char>(-1)];


      mask _M_bit[16];
      __wmask_type _M_wmask[16];

    public:


      static locale::id id;
# 1207 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      explicit
      ctype(size_t __refs = 0);
# 1218 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      explicit
      ctype(__c_locale __cloc, size_t __refs = 0);

    protected:
      __wmask_type
      _M_convert_to_wmask(const mask __m) const;


      virtual
      ~ctype();
# 1242 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      virtual bool
      do_is(mask __m, char_type __c) const;
# 1261 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      virtual const char_type*
      do_is(const char_type* __lo, const char_type* __hi, mask* __vec) const;
# 1279 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_is(mask __m, const char_type* __lo, const char_type* __hi) const;
# 1297 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_not(mask __m, const char_type* __lo,
    const char_type* __hi) const;
# 1314 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      virtual char_type
      do_toupper(char_type) const;
# 1331 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const;
# 1347 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      virtual char_type
      do_tolower(char_type) const;
# 1364 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const;
# 1384 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      virtual char_type
      do_widen(char) const;
# 1406 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __dest) const;
# 1429 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      virtual char
      do_narrow(char_type, char __dfault) const;
# 1455 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault, char* __dest) const;


      void
      _M_initialize_ctype();
    };



  template<typename _CharT>
    class ctype_byname : public ctype<_CharT>
    {
    public:
      typedef typename ctype<_CharT>::mask mask;

      explicit
      ctype_byname(const char* __s, size_t __refs = 0);

    protected:
      virtual
      ~ctype_byname() { };
    };


  template<>
    class ctype_byname<char> : public ctype<char>
    {
    public:
      explicit
      ctype_byname(const char* __s, size_t __refs = 0);

    protected:
      virtual
      ~ctype_byname();
    };


  template<>
    class ctype_byname<wchar_t> : public ctype<wchar_t>
    {
    public:
      explicit
      ctype_byname(const char* __s, size_t __refs = 0);

    protected:
      virtual
      ~ctype_byname();
    };


}


# 1 "/usr/include/c++/4.4/i686-linux-gnu/bits/ctype_inline.h" 1 3
# 37 "/usr/include/c++/4.4/i686-linux-gnu/bits/ctype_inline.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {

  bool
  ctype<char>::
  is(mask __m, char __c) const
  { return _M_table[static_cast<unsigned char>(__c)] & __m; }

  const char*
  ctype<char>::
  is(const char* __low, const char* __high, mask* __vec) const
  {
    while (__low < __high)
      *__vec++ = _M_table[static_cast<unsigned char>(*__low++)];
    return __high;
  }

  const char*
  ctype<char>::
  scan_is(mask __m, const char* __low, const char* __high) const
  {
    while (__low < __high
    && !(_M_table[static_cast<unsigned char>(*__low)] & __m))
      ++__low;
    return __low;
  }

  const char*
  ctype<char>::
  scan_not(mask __m, const char* __low, const char* __high) const
  {
    while (__low < __high
    && (_M_table[static_cast<unsigned char>(*__low)] & __m) != 0)
      ++__low;
    return __low;
  }

}
# 1511 "/usr/include/c++/4.4/bits/locale_facets.h" 2 3

namespace std __attribute__ ((__visibility__ ("default"))) {


  class __num_base
  {
  public:


    enum
      {
        _S_ominus,
        _S_oplus,
        _S_ox,
        _S_oX,
        _S_odigits,
        _S_odigits_end = _S_odigits + 16,
        _S_oudigits = _S_odigits_end,
        _S_oudigits_end = _S_oudigits + 16,
        _S_oe = _S_odigits + 14,
        _S_oE = _S_oudigits + 14,
 _S_oend = _S_oudigits_end
      };






    static const char* _S_atoms_out;



    static const char* _S_atoms_in;

    enum
    {
      _S_iminus,
      _S_iplus,
      _S_ix,
      _S_iX,
      _S_izero,
      _S_ie = _S_izero + 14,
      _S_iE = _S_izero + 20,
      _S_iend = 26
    };



    static void
    _S_format_float(const ios_base& __io, char* __fptr, char __mod);
  };

  template<typename _CharT>
    struct __numpunct_cache : public locale::facet
    {
      const char* _M_grouping;
      size_t _M_grouping_size;
      bool _M_use_grouping;
      const _CharT* _M_truename;
      size_t _M_truename_size;
      const _CharT* _M_falsename;
      size_t _M_falsename_size;
      _CharT _M_decimal_point;
      _CharT _M_thousands_sep;





      _CharT _M_atoms_out[__num_base::_S_oend];





      _CharT _M_atoms_in[__num_base::_S_iend];

      bool _M_allocated;

      __numpunct_cache(size_t __refs = 0) : facet(__refs),
      _M_grouping(__null), _M_grouping_size(0), _M_use_grouping(false),
      _M_truename(__null), _M_truename_size(0), _M_falsename(__null),
      _M_falsename_size(0), _M_decimal_point(_CharT()),
      _M_thousands_sep(_CharT()), _M_allocated(false)
      { }

      ~__numpunct_cache();

      void
      _M_cache(const locale& __loc);

    private:
      __numpunct_cache&
      operator=(const __numpunct_cache&);

      explicit
      __numpunct_cache(const __numpunct_cache&);
    };

  template<typename _CharT>
    __numpunct_cache<_CharT>::~__numpunct_cache()
    {
      if (_M_allocated)
 {
   delete [] _M_grouping;
   delete [] _M_truename;
   delete [] _M_falsename;
 }
    }
# 1635 "/usr/include/c++/4.4/bits/locale_facets.h" 3
  template<typename _CharT>
    class numpunct : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      typedef __numpunct_cache<_CharT> __cache_type;

    protected:
      __cache_type* _M_data;

    public:

      static locale::id id;






      explicit
      numpunct(size_t __refs = 0) : facet(__refs), _M_data(__null)
      { _M_initialize_numpunct(); }
# 1672 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      explicit
      numpunct(__cache_type* __cache, size_t __refs = 0)
      : facet(__refs), _M_data(__cache)
      { _M_initialize_numpunct(); }
# 1686 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      explicit
      numpunct(__c_locale __cloc, size_t __refs = 0)
      : facet(__refs), _M_data(__null)
      { _M_initialize_numpunct(__cloc); }
# 1700 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      char_type
      decimal_point() const
      { return this->do_decimal_point(); }
# 1713 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      char_type
      thousands_sep() const
      { return this->do_thousands_sep(); }
# 1744 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      string
      grouping() const
      { return this->do_grouping(); }
# 1757 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      string_type
      truename() const
      { return this->do_truename(); }
# 1770 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      string_type
      falsename() const
      { return this->do_falsename(); }

    protected:

      virtual
      ~numpunct();
# 1787 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      virtual char_type
      do_decimal_point() const
      { return _M_data->_M_decimal_point; }
# 1799 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      virtual char_type
      do_thousands_sep() const
      { return _M_data->_M_thousands_sep; }
# 1812 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      virtual string
      do_grouping() const
      { return _M_data->_M_grouping; }
# 1825 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      virtual string_type
      do_truename() const
      { return _M_data->_M_truename; }
# 1838 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      virtual string_type
      do_falsename() const
      { return _M_data->_M_falsename; }


      void
      _M_initialize_numpunct(__c_locale __cloc = __null);
    };

  template<typename _CharT>
    locale::id numpunct<_CharT>::id;

  template<>
    numpunct<char>::~numpunct();

  template<>
    void
    numpunct<char>::_M_initialize_numpunct(__c_locale __cloc);


  template<>
    numpunct<wchar_t>::~numpunct();

  template<>
    void
    numpunct<wchar_t>::_M_initialize_numpunct(__c_locale __cloc);



  template<typename _CharT>
    class numpunct_byname : public numpunct<_CharT>
    {
    public:
      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      explicit
      numpunct_byname(const char* __s, size_t __refs = 0)
      : numpunct<_CharT>(__refs)
      {
 if (__builtin_strcmp(__s, "C") != 0
     && __builtin_strcmp(__s, "POSIX") != 0)
   {
     __c_locale __tmp;
     this->_S_create_c_locale(__tmp, __s);
     this->_M_initialize_numpunct(__tmp);
     this->_S_destroy_c_locale(__tmp);
   }
      }

    protected:
      virtual
      ~numpunct_byname() { }
    };


# 1907 "/usr/include/c++/4.4/bits/locale_facets.h" 3
  template<typename _CharT, typename _InIter>
    class num_get : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef _InIter iter_type;



      static locale::id id;
# 1928 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      explicit
      num_get(size_t __refs = 0) : facet(__refs) { }
# 1954 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, bool& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
# 1990 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned short& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned int& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }


      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, long long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned long long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
# 2049 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, float& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, double& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, long double& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
# 2091 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, void*& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

    protected:

      virtual ~num_get() { }

      iter_type
      _M_extract_float(iter_type, iter_type, ios_base&, ios_base::iostate&,
         string&) const;

      template<typename _ValueT>
        iter_type
        _M_extract_int(iter_type, iter_type, ios_base&, ios_base::iostate&,
         _ValueT&) const;

      template<typename _CharT2>
      typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, int>::__type
        _M_find(const _CharT2*, size_t __len, _CharT2 __c) const
        {
   int __ret = -1;
   if (__len <= 10)
     {
       if (__c >= _CharT2('0') && __c < _CharT2(_CharT2('0') + __len))
  __ret = __c - _CharT2('0');
     }
   else
     {
       if (__c >= _CharT2('0') && __c <= _CharT2('9'))
  __ret = __c - _CharT2('0');
       else if (__c >= _CharT2('a') && __c <= _CharT2('f'))
  __ret = 10 + (__c - _CharT2('a'));
       else if (__c >= _CharT2('A') && __c <= _CharT2('F'))
  __ret = 10 + (__c - _CharT2('A'));
     }
   return __ret;
 }

      template<typename _CharT2>
      typename __gnu_cxx::__enable_if<!__is_char<_CharT2>::__value,
          int>::__type
        _M_find(const _CharT2* __zero, size_t __len, _CharT2 __c) const
        {
   int __ret = -1;
   const char_type* __q = char_traits<_CharT2>::find(__zero, __len, __c);
   if (__q)
     {
       __ret = __q - __zero;
       if (__ret > 15)
  __ret -= 6;
     }
   return __ret;
 }
# 2162 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&, bool&) const;

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, long& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, unsigned short& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, unsigned int& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, unsigned long& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }


      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, long long& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, unsigned long long& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }


      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
      float&) const;

      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
      double&) const;







      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
      long double&) const;


      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
      void*&) const;
# 2227 "/usr/include/c++/4.4/bits/locale_facets.h" 3
    };

  template<typename _CharT, typename _InIter>
    locale::id num_get<_CharT, _InIter>::id;
# 2244 "/usr/include/c++/4.4/bits/locale_facets.h" 3
  template<typename _CharT, typename _OutIter>
    class num_put : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef _OutIter iter_type;



      static locale::id id;
# 2265 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      explicit
      num_put(size_t __refs = 0) : facet(__refs) { }
# 2283 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill, bool __v) const
      { return this->do_put(__s, __f, __fill, __v); }
# 2325 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill, long __v) const
      { return this->do_put(__s, __f, __fill, __v); }

      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill,
   unsigned long __v) const
      { return this->do_put(__s, __f, __fill, __v); }


      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill, long long __v) const
      { return this->do_put(__s, __f, __fill, __v); }

      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill,
   unsigned long long __v) const
      { return this->do_put(__s, __f, __fill, __v); }
# 2388 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill, double __v) const
      { return this->do_put(__s, __f, __fill, __v); }

      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill,
   long double __v) const
      { return this->do_put(__s, __f, __fill, __v); }
# 2413 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill,
   const void* __v) const
      { return this->do_put(__s, __f, __fill, __v); }

    protected:
      template<typename _ValueT>
        iter_type
        _M_insert_float(iter_type, ios_base& __io, char_type __fill,
   char __mod, _ValueT __v) const;

      void
      _M_group_float(const char* __grouping, size_t __grouping_size,
       char_type __sep, const char_type* __p, char_type* __new,
       char_type* __cs, int& __len) const;

      template<typename _ValueT>
        iter_type
        _M_insert_int(iter_type, ios_base& __io, char_type __fill,
        _ValueT __v) const;

      void
      _M_group_int(const char* __grouping, size_t __grouping_size,
     char_type __sep, ios_base& __io, char_type* __new,
     char_type* __cs, int& __len) const;

      void
      _M_pad(char_type __fill, streamsize __w, ios_base& __io,
      char_type* __new, const char_type* __cs, int& __len) const;


      virtual
      ~num_put() { };
# 2461 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, bool __v) const;

      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill, long __v) const
      { return _M_insert_int(__s, __io, __fill, __v); }

      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill,
      unsigned long __v) const
      { return _M_insert_int(__s, __io, __fill, __v); }


      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill,
      long long __v) const
      { return _M_insert_int(__s, __io, __fill, __v); }

      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill,
      unsigned long long __v) const
      { return _M_insert_int(__s, __io, __fill, __v); }


      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, double __v) const;






      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, long double __v) const;


      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, const void* __v) const;







    };

  template <typename _CharT, typename _OutIter>
    locale::id num_put<_CharT, _OutIter>::id;









  template<typename _CharT>
    inline bool
    isspace(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::space, __c); }


  template<typename _CharT>
    inline bool
    isprint(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::print, __c); }


  template<typename _CharT>
    inline bool
    iscntrl(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::cntrl, __c); }


  template<typename _CharT>
    inline bool
    isupper(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::upper, __c); }


  template<typename _CharT>
    inline bool
    islower(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::lower, __c); }


  template<typename _CharT>
    inline bool
    isalpha(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alpha, __c); }


  template<typename _CharT>
    inline bool
    isdigit(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::digit, __c); }


  template<typename _CharT>
    inline bool
    ispunct(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::punct, __c); }


  template<typename _CharT>
    inline bool
    isxdigit(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::xdigit, __c); }


  template<typename _CharT>
    inline bool
    isalnum(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alnum, __c); }


  template<typename _CharT>
    inline bool
    isgraph(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::graph, __c); }


  template<typename _CharT>
    inline _CharT
    toupper(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).toupper(__c); }


  template<typename _CharT>
    inline _CharT
    tolower(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).tolower(__c); }

}


# 1 "/usr/include/c++/4.4/bits/locale_facets.tcc" 1 3
# 35 "/usr/include/c++/4.4/bits/locale_facets.tcc" 3
       
# 36 "/usr/include/c++/4.4/bits/locale_facets.tcc" 3

namespace std __attribute__ ((__visibility__ ("default"))) {



  template<typename _Facet>
    struct __use_cache
    {
      const _Facet*
      operator() (const locale& __loc) const;
    };


  template<typename _CharT>
    struct __use_cache<__numpunct_cache<_CharT> >
    {
      const __numpunct_cache<_CharT>*
      operator() (const locale& __loc) const
      {
 const size_t __i = numpunct<_CharT>::id._M_id();
 const locale::facet** __caches = __loc._M_impl->_M_caches;
 if (!__caches[__i])
   {
     __numpunct_cache<_CharT>* __tmp = __null;
     try
       {
  __tmp = new __numpunct_cache<_CharT>;
  __tmp->_M_cache(__loc);
       }
     catch(...)
       {
  delete __tmp;
  throw;
       }
     __loc._M_impl->_M_install_cache(__tmp, __i);
   }
 return static_cast<const __numpunct_cache<_CharT>*>(__caches[__i]);
      }
    };

  template<typename _CharT>
    void
    __numpunct_cache<_CharT>::_M_cache(const locale& __loc)
    {
      _M_allocated = true;

      const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__loc);

      _M_grouping_size = __np.grouping().size();
      char* __grouping = new char[_M_grouping_size];
      __np.grouping().copy(__grouping, _M_grouping_size);
      _M_grouping = __grouping;
      _M_use_grouping = (_M_grouping_size
    && static_cast<signed char>(_M_grouping[0]) > 0
    && (_M_grouping[0]
        != __gnu_cxx::__numeric_traits<char>::__max));

      _M_truename_size = __np.truename().size();
      _CharT* __truename = new _CharT[_M_truename_size];
      __np.truename().copy(__truename, _M_truename_size);
      _M_truename = __truename;

      _M_falsename_size = __np.falsename().size();
      _CharT* __falsename = new _CharT[_M_falsename_size];
      __np.falsename().copy(__falsename, _M_falsename_size);
      _M_falsename = __falsename;

      _M_decimal_point = __np.decimal_point();
      _M_thousands_sep = __np.thousands_sep();

      const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__loc);
      __ct.widen(__num_base::_S_atoms_out,
   __num_base::_S_atoms_out + __num_base::_S_oend, _M_atoms_out);
      __ct.widen(__num_base::_S_atoms_in,
   __num_base::_S_atoms_in + __num_base::_S_iend, _M_atoms_in);
    }
# 121 "/usr/include/c++/4.4/bits/locale_facets.tcc" 3
  bool
  __verify_grouping(const char* __grouping, size_t __grouping_size,
      const string& __grouping_tmp);



  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    _M_extract_float(_InIter __beg, _InIter __end, ios_base& __io,
       ios_base::iostate& __err, string& __xtrc) const
    {
      typedef char_traits<_CharT> __traits_type;
      typedef __numpunct_cache<_CharT> __cache_type;
      __use_cache<__cache_type> __uc;
      const locale& __loc = __io._M_getloc();
      const __cache_type* __lc = __uc(__loc);
      const _CharT* __lit = __lc->_M_atoms_in;
      char_type __c = char_type();


      bool __testeof = __beg == __end;


      if (!__testeof)
 {
   __c = *__beg;
   const bool __plus = __c == __lit[__num_base::_S_iplus];
   if ((__plus || __c == __lit[__num_base::_S_iminus])
       && !(__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
       && !(__c == __lc->_M_decimal_point))
     {
       __xtrc += __plus ? '+' : '-';
       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }
 }


      bool __found_mantissa = false;
      int __sep_pos = 0;
      while (!__testeof)
 {
   if ((__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
       || __c == __lc->_M_decimal_point)
     break;
   else if (__c == __lit[__num_base::_S_izero])
     {
       if (!__found_mantissa)
  {
    __xtrc += '0';
    __found_mantissa = true;
  }
       ++__sep_pos;

       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }
   else
     break;
 }


      bool __found_dec = false;
      bool __found_sci = false;
      string __found_grouping;
      if (__lc->_M_use_grouping)
 __found_grouping.reserve(32);
      const char_type* __lit_zero = __lit + __num_base::_S_izero;

      if (!__lc->_M_allocated)

 while (!__testeof)
   {
     const int __digit = _M_find(__lit_zero, 10, __c);
     if (__digit != -1)
       {
  __xtrc += '0' + __digit;
  __found_mantissa = true;
       }
     else if (__c == __lc->_M_decimal_point
       && !__found_dec && !__found_sci)
       {
  __xtrc += '.';
  __found_dec = true;
       }
     else if ((__c == __lit[__num_base::_S_ie]
        || __c == __lit[__num_base::_S_iE])
       && !__found_sci && __found_mantissa)
       {

  __xtrc += 'e';
  __found_sci = true;


  if (++__beg != __end)
    {
      __c = *__beg;
      const bool __plus = __c == __lit[__num_base::_S_iplus];
      if (__plus || __c == __lit[__num_base::_S_iminus])
        __xtrc += __plus ? '+' : '-';
      else
        continue;
    }
  else
    {
      __testeof = true;
      break;
    }
       }
     else
       break;

     if (++__beg != __end)
       __c = *__beg;
     else
       __testeof = true;
   }
      else
 while (!__testeof)
   {


     if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
       {
  if (!__found_dec && !__found_sci)
    {


      if (__sep_pos)
        {
   __found_grouping += static_cast<char>(__sep_pos);
   __sep_pos = 0;
        }
      else
        {


   __xtrc.clear();
   break;
        }
    }
  else
    break;
       }
     else if (__c == __lc->_M_decimal_point)
       {
  if (!__found_dec && !__found_sci)
    {



      if (__found_grouping.size())
        __found_grouping += static_cast<char>(__sep_pos);
      __xtrc += '.';
      __found_dec = true;
    }
  else
    break;
       }
     else
       {
  const char_type* __q =
    __traits_type::find(__lit_zero, 10, __c);
  if (__q)
    {
      __xtrc += '0' + (__q - __lit_zero);
      __found_mantissa = true;
      ++__sep_pos;
    }
  else if ((__c == __lit[__num_base::_S_ie]
     || __c == __lit[__num_base::_S_iE])
    && !__found_sci && __found_mantissa)
    {

      if (__found_grouping.size() && !__found_dec)
        __found_grouping += static_cast<char>(__sep_pos);
      __xtrc += 'e';
      __found_sci = true;


      if (++__beg != __end)
        {
   __c = *__beg;
   const bool __plus = __c == __lit[__num_base::_S_iplus];
   if ((__plus || __c == __lit[__num_base::_S_iminus])
       && !(__lc->_M_use_grouping
     && __c == __lc->_M_thousands_sep)
       && !(__c == __lc->_M_decimal_point))
        __xtrc += __plus ? '+' : '-';
   else
     continue;
        }
      else
        {
   __testeof = true;
   break;
        }
    }
  else
    break;
       }

     if (++__beg != __end)
       __c = *__beg;
     else
       __testeof = true;
   }



      if (__found_grouping.size())
        {

   if (!__found_dec && !__found_sci)
     __found_grouping += static_cast<char>(__sep_pos);

          if (!std::__verify_grouping(__lc->_M_grouping,
          __lc->_M_grouping_size,
          __found_grouping))
     __err = ios_base::failbit;
        }

      return __beg;
    }

  template<typename _CharT, typename _InIter>
    template<typename _ValueT>
      _InIter
      num_get<_CharT, _InIter>::
      _M_extract_int(_InIter __beg, _InIter __end, ios_base& __io,
       ios_base::iostate& __err, _ValueT& __v) const
      {
        typedef char_traits<_CharT> __traits_type;
 using __gnu_cxx::__add_unsigned;
 typedef typename __add_unsigned<_ValueT>::__type __unsigned_type;
 typedef __numpunct_cache<_CharT> __cache_type;
 __use_cache<__cache_type> __uc;
 const locale& __loc = __io._M_getloc();
 const __cache_type* __lc = __uc(__loc);
 const _CharT* __lit = __lc->_M_atoms_in;
 char_type __c = char_type();


 const ios_base::fmtflags __basefield = __io.flags()
                                        & ios_base::basefield;
 const bool __oct = __basefield == ios_base::oct;
 int __base = __oct ? 8 : (__basefield == ios_base::hex ? 16 : 10);


 bool __testeof = __beg == __end;


 bool __negative = false;
 if (!__testeof)
   {
     __c = *__beg;
     __negative = __c == __lit[__num_base::_S_iminus];
     if ((__negative || __c == __lit[__num_base::_S_iplus])
  && !(__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
  && !(__c == __lc->_M_decimal_point))
       {
  if (++__beg != __end)
    __c = *__beg;
  else
    __testeof = true;
       }
   }



 bool __found_zero = false;
 int __sep_pos = 0;
 while (!__testeof)
   {
     if ((__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
  || __c == __lc->_M_decimal_point)
       break;
     else if (__c == __lit[__num_base::_S_izero]
       && (!__found_zero || __base == 10))
       {
  __found_zero = true;
  ++__sep_pos;
  if (__basefield == 0)
    __base = 8;
  if (__base == 8)
    __sep_pos = 0;
       }
     else if (__found_zero
       && (__c == __lit[__num_base::_S_ix]
    || __c == __lit[__num_base::_S_iX]))
       {
  if (__basefield == 0)
    __base = 16;
  if (__base == 16)
    {
      __found_zero = false;
      __sep_pos = 0;
    }
  else
    break;
       }
     else
       break;

     if (++__beg != __end)
       {
  __c = *__beg;
  if (!__found_zero)
    break;
       }
     else
       __testeof = true;
   }



 const size_t __len = (__base == 16 ? __num_base::_S_iend
         - __num_base::_S_izero : __base);


 string __found_grouping;
 if (__lc->_M_use_grouping)
   __found_grouping.reserve(32);
 bool __testfail = false;
 bool __testoverflow = false;
 const __unsigned_type __max =
   (__negative && __gnu_cxx::__numeric_traits<_ValueT>::__is_signed)
   ? -__gnu_cxx::__numeric_traits<_ValueT>::__min
   : __gnu_cxx::__numeric_traits<_ValueT>::__max;
 const __unsigned_type __smax = __max / __base;
 __unsigned_type __result = 0;
 int __digit = 0;
 const char_type* __lit_zero = __lit + __num_base::_S_izero;

 if (!__lc->_M_allocated)

   while (!__testeof)
     {
       __digit = _M_find(__lit_zero, __len, __c);
       if (__digit == -1)
  break;

       if (__result > __smax)
  __testoverflow = true;
       else
  {
    __result *= __base;
    __testoverflow |= __result > __max - __digit;
    __result += __digit;
    ++__sep_pos;
  }

       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }
 else
   while (!__testeof)
     {


       if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
  {


    if (__sep_pos)
      {
        __found_grouping += static_cast<char>(__sep_pos);
        __sep_pos = 0;
      }
    else
      {
        __testfail = true;
        break;
      }
  }
       else if (__c == __lc->_M_decimal_point)
  break;
       else
  {
    const char_type* __q =
      __traits_type::find(__lit_zero, __len, __c);
    if (!__q)
      break;

    __digit = __q - __lit_zero;
    if (__digit > 15)
      __digit -= 6;
    if (__result > __smax)
      __testoverflow = true;
    else
      {
        __result *= __base;
        __testoverflow |= __result > __max - __digit;
        __result += __digit;
        ++__sep_pos;
      }
  }

       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }



 if (__found_grouping.size())
   {

     __found_grouping += static_cast<char>(__sep_pos);

     if (!std::__verify_grouping(__lc->_M_grouping,
     __lc->_M_grouping_size,
     __found_grouping))
       __err = ios_base::failbit;
   }



 if ((!__sep_pos && !__found_zero && !__found_grouping.size())
     || __testfail)
   {
     __v = 0;
     __err = ios_base::failbit;
   }
 else if (__testoverflow)
   {
     if (__negative
  && __gnu_cxx::__numeric_traits<_ValueT>::__is_signed)
       __v = __gnu_cxx::__numeric_traits<_ValueT>::__min;
     else
       __v = __gnu_cxx::__numeric_traits<_ValueT>::__max;
     __err = ios_base::failbit;
   }
 else
   __v = __negative ? -__result : __result;

 if (__testeof)
   __err |= ios_base::eofbit;
 return __beg;
      }



  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, bool& __v) const
    {
      if (!(__io.flags() & ios_base::boolalpha))
        {



   long __l = -1;
          __beg = _M_extract_int(__beg, __end, __io, __err, __l);
   if (__l == 0 || __l == 1)
     __v = bool(__l);
   else
     {


       __v = true;
       __err = ios_base::failbit;
       if (__beg == __end)
  __err |= ios_base::eofbit;
     }
        }
      else
        {

   typedef __numpunct_cache<_CharT> __cache_type;
   __use_cache<__cache_type> __uc;
   const locale& __loc = __io._M_getloc();
   const __cache_type* __lc = __uc(__loc);

   bool __testf = true;
   bool __testt = true;
   bool __donef = __lc->_M_falsename_size == 0;
   bool __donet = __lc->_M_truename_size == 0;
   bool __testeof = false;
   size_t __n = 0;
   while (!__donef || !__donet)
     {
       if (__beg == __end)
  {
    __testeof = true;
    break;
  }

       const char_type __c = *__beg;

       if (!__donef)
  __testf = __c == __lc->_M_falsename[__n];

       if (!__testf && __donet)
  break;

       if (!__donet)
  __testt = __c == __lc->_M_truename[__n];

       if (!__testt && __donef)
  break;

       if (!__testt && !__testf)
  break;

       ++__n;
       ++__beg;

       __donef = !__testf || __n >= __lc->_M_falsename_size;
       __donet = !__testt || __n >= __lc->_M_truename_size;
     }
   if (__testf && __n == __lc->_M_falsename_size && __n)
     {
       __v = false;
       if (__testt && __n == __lc->_M_truename_size)
  __err = ios_base::failbit;
       else
  __err = __testeof ? ios_base::eofbit : ios_base::goodbit;
     }
   else if (__testt && __n == __lc->_M_truename_size && __n)
     {
       __v = true;
       __err = __testeof ? ios_base::eofbit : ios_base::goodbit;
     }
   else
     {


       __v = false;
       __err = ios_base::failbit;
       if (__testeof)
  __err |= ios_base::eofbit;
     }
 }
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
    ios_base::iostate& __err, float& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
      std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, double& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
      std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }
# 715 "/usr/include/c++/4.4/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, long double& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
      std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, void*& __v) const
    {

      typedef ios_base::fmtflags fmtflags;
      const fmtflags __fmt = __io.flags();
      __io.flags((__fmt & ~ios_base::basefield) | ios_base::hex);

      typedef __gnu_cxx::__conditional_type<(sizeof(void*)
          <= sizeof(unsigned long)),
 unsigned long, unsigned long long>::__type _UIntPtrType;

      _UIntPtrType __ul;
      __beg = _M_extract_int(__beg, __end, __io, __err, __ul);


      __io.flags(__fmt);

      __v = reinterpret_cast<void*>(__ul);
      return __beg;
    }



  template<typename _CharT, typename _OutIter>
    void
    num_put<_CharT, _OutIter>::
    _M_pad(_CharT __fill, streamsize __w, ios_base& __io,
    _CharT* __new, const _CharT* __cs, int& __len) const
    {


      __pad<_CharT, char_traits<_CharT> >::_S_pad(__io, __fill, __new,
        __cs, __w, __len);
      __len = static_cast<int>(__w);
    }



  template<typename _CharT, typename _ValueT>
    int
    __int_to_char(_CharT* __bufend, _ValueT __v, const _CharT* __lit,
    ios_base::fmtflags __flags, bool __dec)
    {
      _CharT* __buf = __bufend;
      if (__builtin_expect(__dec, true))
 {

   do
     {
       *--__buf = __lit[(__v % 10) + __num_base::_S_odigits];
       __v /= 10;
     }
   while (__v != 0);
 }
      else if ((__flags & ios_base::basefield) == ios_base::oct)
 {

   do
     {
       *--__buf = __lit[(__v & 0x7) + __num_base::_S_odigits];
       __v >>= 3;
     }
   while (__v != 0);
 }
      else
 {

   const bool __uppercase = __flags & ios_base::uppercase;
   const int __case_offset = __uppercase ? __num_base::_S_oudigits
                                         : __num_base::_S_odigits;
   do
     {
       *--__buf = __lit[(__v & 0xf) + __case_offset];
       __v >>= 4;
     }
   while (__v != 0);
 }
      return __bufend - __buf;
    }



  template<typename _CharT, typename _OutIter>
    void
    num_put<_CharT, _OutIter>::
    _M_group_int(const char* __grouping, size_t __grouping_size, _CharT __sep,
   ios_base&, _CharT* __new, _CharT* __cs, int& __len) const
    {
      _CharT* __p = std::__add_grouping(__new, __sep, __grouping,
     __grouping_size, __cs, __cs + __len);
      __len = __p - __new;
    }

  template<typename _CharT, typename _OutIter>
    template<typename _ValueT>
      _OutIter
      num_put<_CharT, _OutIter>::
      _M_insert_int(_OutIter __s, ios_base& __io, _CharT __fill,
      _ValueT __v) const
      {
 using __gnu_cxx::__add_unsigned;
 typedef typename __add_unsigned<_ValueT>::__type __unsigned_type;
 typedef __numpunct_cache<_CharT> __cache_type;
 __use_cache<__cache_type> __uc;
 const locale& __loc = __io._M_getloc();
 const __cache_type* __lc = __uc(__loc);
 const _CharT* __lit = __lc->_M_atoms_out;
 const ios_base::fmtflags __flags = __io.flags();


 const int __ilen = 5 * sizeof(_ValueT);
 _CharT* __cs = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
            * __ilen));



 const ios_base::fmtflags __basefield = __flags & ios_base::basefield;
 const bool __dec = (__basefield != ios_base::oct
       && __basefield != ios_base::hex);
 const __unsigned_type __u = ((__v > 0 || !__dec)
         ? __unsigned_type(__v)
         : -__unsigned_type(__v));
  int __len = __int_to_char(__cs + __ilen, __u, __lit, __flags, __dec);
 __cs += __ilen - __len;


 if (__lc->_M_use_grouping)
   {


     _CharT* __cs2 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * (__len + 1)
          * 2));
     _M_group_int(__lc->_M_grouping, __lc->_M_grouping_size,
    __lc->_M_thousands_sep, __io, __cs2 + 2, __cs, __len);
     __cs = __cs2 + 2;
   }


 if (__builtin_expect(__dec, true))
   {

     if (__v >= 0)
       {
  if (bool(__flags & ios_base::showpos)
      && __gnu_cxx::__numeric_traits<_ValueT>::__is_signed)
    *--__cs = __lit[__num_base::_S_oplus], ++__len;
       }
     else
       *--__cs = __lit[__num_base::_S_ominus], ++__len;
   }
 else if (bool(__flags & ios_base::showbase) && __v)
   {
     if (__basefield == ios_base::oct)
       *--__cs = __lit[__num_base::_S_odigits], ++__len;
     else
       {

  const bool __uppercase = __flags & ios_base::uppercase;
  *--__cs = __lit[__num_base::_S_ox + __uppercase];

  *--__cs = __lit[__num_base::_S_odigits];
  __len += 2;
       }
   }


 const streamsize __w = __io.width();
 if (__w > static_cast<streamsize>(__len))
   {
     _CharT* __cs3 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * __w));
     _M_pad(__fill, __w, __io, __cs3, __cs, __len);
     __cs = __cs3;
   }
 __io.width(0);



 return std::__write(__s, __cs, __len);
      }

  template<typename _CharT, typename _OutIter>
    void
    num_put<_CharT, _OutIter>::
    _M_group_float(const char* __grouping, size_t __grouping_size,
     _CharT __sep, const _CharT* __p, _CharT* __new,
     _CharT* __cs, int& __len) const
    {



      const int __declen = __p ? __p - __cs : __len;
      _CharT* __p2 = std::__add_grouping(__new, __sep, __grouping,
      __grouping_size,
      __cs, __cs + __declen);


      int __newlen = __p2 - __new;
      if (__p)
 {
   char_traits<_CharT>::copy(__p2, __p, __len - __declen);
   __newlen += __len - __declen;
 }
      __len = __newlen;
    }
# 951 "/usr/include/c++/4.4/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _OutIter>
    template<typename _ValueT>
      _OutIter
      num_put<_CharT, _OutIter>::
      _M_insert_float(_OutIter __s, ios_base& __io, _CharT __fill, char __mod,
         _ValueT __v) const
      {
 typedef __numpunct_cache<_CharT> __cache_type;
 __use_cache<__cache_type> __uc;
 const locale& __loc = __io._M_getloc();
 const __cache_type* __lc = __uc(__loc);


 const streamsize __prec = __io.precision() < 0 ? 6 : __io.precision();

 const int __max_digits =
   __gnu_cxx::__numeric_traits<_ValueT>::__digits10;


 int __len;

 char __fbuf[16];
 __num_base::_S_format_float(__io, __fbuf, __mod);




 int __cs_size = __max_digits * 3;
 char* __cs = static_cast<char*>(__builtin_alloca(__cs_size));
 __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
          __fbuf, __prec, __v);


 if (__len >= __cs_size)
   {
     __cs_size = __len + 1;
     __cs = static_cast<char*>(__builtin_alloca(__cs_size));
     __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
       __fbuf, __prec, __v);
   }
# 1012 "/usr/include/c++/4.4/bits/locale_facets.tcc" 3
 const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

 _CharT* __ws = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
            * __len));
 __ctype.widen(__cs, __cs + __len, __ws);


 _CharT* __wp = 0;
 const char* __p = char_traits<char>::find(__cs, __len, '.');
 if (__p)
   {
     __wp = __ws + (__p - __cs);
     *__wp = __lc->_M_decimal_point;
   }




 if (__lc->_M_use_grouping
     && (__wp || __len < 3 || (__cs[1] <= '9' && __cs[2] <= '9'
          && __cs[1] >= '0' && __cs[2] >= '0')))
   {


     _CharT* __ws2 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * __len * 2));

     streamsize __off = 0;
     if (__cs[0] == '-' || __cs[0] == '+')
       {
  __off = 1;
  __ws2[0] = __ws[0];
  __len -= 1;
       }

     _M_group_float(__lc->_M_grouping, __lc->_M_grouping_size,
      __lc->_M_thousands_sep, __wp, __ws2 + __off,
      __ws + __off, __len);
     __len += __off;

     __ws = __ws2;
   }


 const streamsize __w = __io.width();
 if (__w > static_cast<streamsize>(__len))
   {
     _CharT* __ws3 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * __w));
     _M_pad(__fill, __w, __io, __ws3, __ws, __len);
     __ws = __ws3;
   }
 __io.width(0);



 return std::__write(__s, __ws, __len);
      }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill, bool __v) const
    {
      const ios_base::fmtflags __flags = __io.flags();
      if ((__flags & ios_base::boolalpha) == 0)
        {
          const long __l = __v;
          __s = _M_insert_int(__s, __io, __fill, __l);
        }
      else
        {
   typedef __numpunct_cache<_CharT> __cache_type;
   __use_cache<__cache_type> __uc;
   const locale& __loc = __io._M_getloc();
   const __cache_type* __lc = __uc(__loc);

   const _CharT* __name = __v ? __lc->_M_truename
                              : __lc->_M_falsename;
   int __len = __v ? __lc->_M_truename_size
                   : __lc->_M_falsename_size;

   const streamsize __w = __io.width();
   if (__w > static_cast<streamsize>(__len))
     {
       const streamsize __plen = __w - __len;
       _CharT* __ps
  = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
       * __plen));

       char_traits<_CharT>::assign(__ps, __plen, __fill);
       __io.width(0);

       if ((__flags & ios_base::adjustfield) == ios_base::left)
  {
    __s = std::__write(__s, __name, __len);
    __s = std::__write(__s, __ps, __plen);
  }
       else
  {
    __s = std::__write(__s, __ps, __plen);
    __s = std::__write(__s, __name, __len);
  }
       return __s;
     }
   __io.width(0);
   __s = std::__write(__s, __name, __len);
 }
      return __s;
    }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill, double __v) const
    { return _M_insert_float(__s, __io, __fill, char(), __v); }
# 1137 "/usr/include/c++/4.4/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill,
    long double __v) const
    { return _M_insert_float(__s, __io, __fill, 'L', __v); }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill,
           const void* __v) const
    {
      const ios_base::fmtflags __flags = __io.flags();
      const ios_base::fmtflags __fmt = ~(ios_base::basefield
      | ios_base::uppercase);
      __io.flags((__flags & __fmt) | (ios_base::hex | ios_base::showbase));

      typedef __gnu_cxx::__conditional_type<(sizeof(const void*)
          <= sizeof(unsigned long)),
 unsigned long, unsigned long long>::__type _UIntPtrType;

      __s = _M_insert_int(__s, __io, __fill,
     reinterpret_cast<_UIntPtrType>(__v));
      __io.flags(__flags);
      return __s;
    }


# 1174 "/usr/include/c++/4.4/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _Traits>
    void
    __pad<_CharT, _Traits>::_S_pad(ios_base& __io, _CharT __fill,
       _CharT* __news, const _CharT* __olds,
       streamsize __newlen, streamsize __oldlen)
    {
      const size_t __plen = static_cast<size_t>(__newlen - __oldlen);
      const ios_base::fmtflags __adjust = __io.flags() & ios_base::adjustfield;


      if (__adjust == ios_base::left)
 {
   _Traits::copy(__news, __olds, __oldlen);
   _Traits::assign(__news + __oldlen, __plen, __fill);
   return;
 }

      size_t __mod = 0;
      if (__adjust == ios_base::internal)
 {



          const locale& __loc = __io._M_getloc();
   const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

   if (__ctype.widen('-') == __olds[0]
       || __ctype.widen('+') == __olds[0])
     {
       __news[0] = __olds[0];
       __mod = 1;
       ++__news;
     }
   else if (__ctype.widen('0') == __olds[0]
     && __oldlen > 1
     && (__ctype.widen('x') == __olds[1]
         || __ctype.widen('X') == __olds[1]))
     {
       __news[0] = __olds[0];
       __news[1] = __olds[1];
       __mod = 2;
       __news += 2;
     }

 }
      _Traits::assign(__news, __plen, __fill);
      _Traits::copy(__news + __plen, __olds + __mod, __oldlen - __mod);
    }

  template<typename _CharT>
    _CharT*
    __add_grouping(_CharT* __s, _CharT __sep,
     const char* __gbeg, size_t __gsize,
     const _CharT* __first, const _CharT* __last)
    {
      size_t __idx = 0;
      size_t __ctr = 0;

      while (__last - __first > __gbeg[__idx]
      && static_cast<signed char>(__gbeg[__idx]) > 0
      && __gbeg[__idx] != __gnu_cxx::__numeric_traits<char>::__max)
 {
   __last -= __gbeg[__idx];
   __idx < __gsize - 1 ? ++__idx : ++__ctr;
 }

      while (__first != __last)
 *__s++ = *__first++;

      while (__ctr--)
 {
   *__s++ = __sep;
   for (char __i = __gbeg[__idx]; __i > 0; --__i)
     *__s++ = *__first++;
 }

      while (__idx--)
 {
   *__s++ = __sep;
   for (char __i = __gbeg[__idx]; __i > 0; --__i)
     *__s++ = *__first++;
 }

      return __s;
    }





  extern template class numpunct<char>;
  extern template class numpunct_byname<char>;
  extern template class num_get<char>;
  extern template class num_put<char>;
  extern template class ctype_byname<char>;

  extern template
    const ctype<char>&
    use_facet<ctype<char> >(const locale&);

  extern template
    const numpunct<char>&
    use_facet<numpunct<char> >(const locale&);

  extern template
    const num_put<char>&
    use_facet<num_put<char> >(const locale&);

  extern template
    const num_get<char>&
    use_facet<num_get<char> >(const locale&);

  extern template
    bool
    has_facet<ctype<char> >(const locale&);

  extern template
    bool
    has_facet<numpunct<char> >(const locale&);

  extern template
    bool
    has_facet<num_put<char> >(const locale&);

  extern template
    bool
    has_facet<num_get<char> >(const locale&);


  extern template class numpunct<wchar_t>;
  extern template class numpunct_byname<wchar_t>;
  extern template class num_get<wchar_t>;
  extern template class num_put<wchar_t>;
  extern template class ctype_byname<wchar_t>;

  extern template
    const ctype<wchar_t>&
    use_facet<ctype<wchar_t> >(const locale&);

  extern template
    const numpunct<wchar_t>&
    use_facet<numpunct<wchar_t> >(const locale&);

  extern template
    const num_put<wchar_t>&
    use_facet<num_put<wchar_t> >(const locale&);

  extern template
    const num_get<wchar_t>&
    use_facet<num_get<wchar_t> >(const locale&);

 extern template
    bool
    has_facet<ctype<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<numpunct<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<num_put<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<num_get<wchar_t> >(const locale&);



}
# 2600 "/usr/include/c++/4.4/bits/locale_facets.h" 2 3
# 40 "/usr/include/c++/4.4/bits/basic_ios.h" 2 3


namespace std __attribute__ ((__visibility__ ("default"))) {

  template<typename _Facet>
    inline const _Facet&
    __check_facet(const _Facet* __f)
    {
      if (!__f)
 __throw_bad_cast();
      return *__f;
    }
# 61 "/usr/include/c++/4.4/bits/basic_ios.h" 3
  template<typename _CharT, typename _Traits>
    class basic_ios : public ios_base
    {
    public:






      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;






      typedef ctype<_CharT> __ctype_type;
      typedef num_put<_CharT, ostreambuf_iterator<_CharT, _Traits> >
           __num_put_type;
      typedef num_get<_CharT, istreambuf_iterator<_CharT, _Traits> >
           __num_get_type;



    protected:
      basic_ostream<_CharT, _Traits>* _M_tie;
      mutable char_type _M_fill;
      mutable bool _M_fill_init;
      basic_streambuf<_CharT, _Traits>* _M_streambuf;


      const __ctype_type* _M_ctype;

      const __num_put_type* _M_num_put;

      const __num_get_type* _M_num_get;

    public:







      operator void*() const
      { return this->fail() ? 0 : const_cast<basic_ios*>(this); }

      bool
      operator!() const
      { return this->fail(); }
# 126 "/usr/include/c++/4.4/bits/basic_ios.h" 3
      iostate
      rdstate() const
      { return _M_streambuf_state; }
# 137 "/usr/include/c++/4.4/bits/basic_ios.h" 3
      void
      clear(iostate __state = goodbit);







      void
      setstate(iostate __state)
      { this->clear(this->rdstate() | __state); }




      void
      _M_setstate(iostate __state)
      {


 _M_streambuf_state |= __state;
 if (this->exceptions() & __state)
   throw;
      }







      bool
      good() const
      { return this->rdstate() == 0; }







      bool
      eof() const
      { return (this->rdstate() & eofbit) != 0; }
# 190 "/usr/include/c++/4.4/bits/basic_ios.h" 3
      bool
      fail() const
      { return (this->rdstate() & (badbit | failbit)) != 0; }







      bool
      bad() const
      { return (this->rdstate() & badbit) != 0; }
# 211 "/usr/include/c++/4.4/bits/basic_ios.h" 3
      iostate
      exceptions() const
      { return _M_exception; }
# 246 "/usr/include/c++/4.4/bits/basic_ios.h" 3
      void
      exceptions(iostate __except)
      {
        _M_exception = __except;
        this->clear(_M_streambuf_state);
      }







      explicit
      basic_ios(basic_streambuf<_CharT, _Traits>* __sb)
      : ios_base(), _M_tie(0), _M_fill(), _M_fill_init(false), _M_streambuf(0),
 _M_ctype(0), _M_num_put(0), _M_num_get(0)
      { this->init(__sb); }







      virtual
      ~basic_ios() { }
# 284 "/usr/include/c++/4.4/bits/basic_ios.h" 3
      basic_ostream<_CharT, _Traits>*
      tie() const
      { return _M_tie; }
# 296 "/usr/include/c++/4.4/bits/basic_ios.h" 3
      basic_ostream<_CharT, _Traits>*
      tie(basic_ostream<_CharT, _Traits>* __tiestr)
      {
        basic_ostream<_CharT, _Traits>* __old = _M_tie;
        _M_tie = __tiestr;
        return __old;
      }







      basic_streambuf<_CharT, _Traits>*
      rdbuf() const
      { return _M_streambuf; }
# 336 "/usr/include/c++/4.4/bits/basic_ios.h" 3
      basic_streambuf<_CharT, _Traits>*
      rdbuf(basic_streambuf<_CharT, _Traits>* __sb);
# 350 "/usr/include/c++/4.4/bits/basic_ios.h" 3
      basic_ios&
      copyfmt(const basic_ios& __rhs);







      char_type
      fill() const
      {
 if (!_M_fill_init)
   {
     _M_fill = this->widen(' ');
     _M_fill_init = true;
   }
 return _M_fill;
      }
# 379 "/usr/include/c++/4.4/bits/basic_ios.h" 3
      char_type
      fill(char_type __ch)
      {
 char_type __old = this->fill();
 _M_fill = __ch;
 return __old;
      }
# 399 "/usr/include/c++/4.4/bits/basic_ios.h" 3
      locale
      imbue(const locale& __loc);
# 419 "/usr/include/c++/4.4/bits/basic_ios.h" 3
      char
      narrow(char_type __c, char __dfault) const
      { return __check_facet(_M_ctype).narrow(__c, __dfault); }
# 438 "/usr/include/c++/4.4/bits/basic_ios.h" 3
      char_type
      widen(char __c) const
      { return __check_facet(_M_ctype).widen(__c); }

    protected:







      basic_ios()
      : ios_base(), _M_tie(0), _M_fill(char_type()), _M_fill_init(false),
 _M_streambuf(0), _M_ctype(0), _M_num_put(0), _M_num_get(0)
      { }







      void
      init(basic_streambuf<_CharT, _Traits>* __sb);

      void
      _M_cache_locale(const locale& __loc);
    };

}


# 1 "/usr/include/c++/4.4/bits/basic_ios.tcc" 1 3
# 34 "/usr/include/c++/4.4/bits/basic_ios.tcc" 3
       
# 35 "/usr/include/c++/4.4/bits/basic_ios.tcc" 3

namespace std __attribute__ ((__visibility__ ("default"))) {

  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::clear(iostate __state)
    {
      if (this->rdbuf())
 _M_streambuf_state = __state;
      else
   _M_streambuf_state = __state | badbit;
      if (this->exceptions() & this->rdstate())
 __throw_ios_failure(("basic_ios::clear"));
    }

  template<typename _CharT, typename _Traits>
    basic_streambuf<_CharT, _Traits>*
    basic_ios<_CharT, _Traits>::rdbuf(basic_streambuf<_CharT, _Traits>* __sb)
    {
      basic_streambuf<_CharT, _Traits>* __old = _M_streambuf;
      _M_streambuf = __sb;
      this->clear();
      return __old;
    }

  template<typename _CharT, typename _Traits>
    basic_ios<_CharT, _Traits>&
    basic_ios<_CharT, _Traits>::copyfmt(const basic_ios& __rhs)
    {


      if (this != &__rhs)
 {




   _Words* __words = (__rhs._M_word_size <= _S_local_word_size) ?
                      _M_local_word : new _Words[__rhs._M_word_size];


   _Callback_list* __cb = __rhs._M_callbacks;
   if (__cb)
     __cb->_M_add_reference();
   _M_call_callbacks(erase_event);
   if (_M_word != _M_local_word)
     {
       delete [] _M_word;
       _M_word = 0;
     }
   _M_dispose_callbacks();


   _M_callbacks = __cb;
   for (int __i = 0; __i < __rhs._M_word_size; ++__i)
     __words[__i] = __rhs._M_word[__i];
   _M_word = __words;
   _M_word_size = __rhs._M_word_size;

   this->flags(__rhs.flags());
   this->width(__rhs.width());
   this->precision(__rhs.precision());
   this->tie(__rhs.tie());
   this->fill(__rhs.fill());
   _M_ios_locale = __rhs.getloc();
   _M_cache_locale(_M_ios_locale);

   _M_call_callbacks(copyfmt_event);


   this->exceptions(__rhs.exceptions());
 }
      return *this;
    }


  template<typename _CharT, typename _Traits>
    locale
    basic_ios<_CharT, _Traits>::imbue(const locale& __loc)
    {
      locale __old(this->getloc());
      ios_base::imbue(__loc);
      _M_cache_locale(__loc);
      if (this->rdbuf() != 0)
 this->rdbuf()->pubimbue(__loc);
      return __old;
    }

  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::init(basic_streambuf<_CharT, _Traits>* __sb)
    {

      ios_base::_M_init();


      _M_cache_locale(_M_ios_locale);
# 145 "/usr/include/c++/4.4/bits/basic_ios.tcc" 3
      _M_fill = _CharT();
      _M_fill_init = false;

      _M_tie = 0;
      _M_exception = goodbit;
      _M_streambuf = __sb;
      _M_streambuf_state = __sb ? goodbit : badbit;
    }

  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::_M_cache_locale(const locale& __loc)
    {
      if (__builtin_expect(has_facet<__ctype_type>(__loc), true))
 _M_ctype = &use_facet<__ctype_type>(__loc);
      else
 _M_ctype = 0;

      if (__builtin_expect(has_facet<__num_put_type>(__loc), true))
 _M_num_put = &use_facet<__num_put_type>(__loc);
      else
 _M_num_put = 0;

      if (__builtin_expect(has_facet<__num_get_type>(__loc), true))
 _M_num_get = &use_facet<__num_get_type>(__loc);
      else
 _M_num_get = 0;
    }





  extern template class basic_ios<char>;


  extern template class basic_ios<wchar_t>;



}
# 472 "/usr/include/c++/4.4/bits/basic_ios.h" 2 3
# 46 "/usr/include/c++/4.4/ios" 2 3
# 41 "/usr/include/c++/4.4/ostream" 2 3


namespace std __attribute__ ((__visibility__ ("default"))) {
# 54 "/usr/include/c++/4.4/ostream" 3
  template<typename _CharT, typename _Traits>
    class basic_ostream : virtual public basic_ios<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;


      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef basic_ios<_CharT, _Traits> __ios_type;
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef num_put<_CharT, ostreambuf_iterator<_CharT, _Traits> >
             __num_put_type;
      typedef ctype<_CharT> __ctype_type;
# 81 "/usr/include/c++/4.4/ostream" 3
      explicit
      basic_ostream(__streambuf_type* __sb)
      { this->init(__sb); }






      virtual
      ~basic_ostream() { }


      class sentry;
      friend class sentry;
# 107 "/usr/include/c++/4.4/ostream" 3
      __ostream_type&
      operator<<(__ostream_type& (*__pf)(__ostream_type&))
      {



 return __pf(*this);
      }

      __ostream_type&
      operator<<(__ios_type& (*__pf)(__ios_type&))
      {



 __pf(*this);
 return *this;
      }

      __ostream_type&
      operator<<(ios_base& (*__pf) (ios_base&))
      {



 __pf(*this);
 return *this;
      }
# 164 "/usr/include/c++/4.4/ostream" 3
      __ostream_type&
      operator<<(long __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(unsigned long __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(bool __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(short __n);

      __ostream_type&
      operator<<(unsigned short __n)
      {


 return _M_insert(static_cast<unsigned long>(__n));
      }

      __ostream_type&
      operator<<(int __n);

      __ostream_type&
      operator<<(unsigned int __n)
      {


 return _M_insert(static_cast<unsigned long>(__n));
      }


      __ostream_type&
      operator<<(long long __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(unsigned long long __n)
      { return _M_insert(__n); }


      __ostream_type&
      operator<<(double __f)
      { return _M_insert(__f); }

      __ostream_type&
      operator<<(float __f)
      {


 return _M_insert(static_cast<double>(__f));
      }

      __ostream_type&
      operator<<(long double __f)
      { return _M_insert(__f); }

      __ostream_type&
      operator<<(const void* __p)
      { return _M_insert(__p); }
# 249 "/usr/include/c++/4.4/ostream" 3
      __ostream_type&
      operator<<(__streambuf_type* __sb);
# 282 "/usr/include/c++/4.4/ostream" 3
      __ostream_type&
      put(char_type __c);


      void
      _M_write(const char_type* __s, streamsize __n)
      {
 const streamsize __put = this->rdbuf()->sputn(__s, __n);
 if (__put != __n)
   this->setstate(ios_base::badbit);
      }
# 310 "/usr/include/c++/4.4/ostream" 3
      __ostream_type&
      write(const char_type* __s, streamsize __n);
# 323 "/usr/include/c++/4.4/ostream" 3
      __ostream_type&
      flush();
# 334 "/usr/include/c++/4.4/ostream" 3
      pos_type
      tellp();
# 345 "/usr/include/c++/4.4/ostream" 3
      __ostream_type&
      seekp(pos_type);
# 357 "/usr/include/c++/4.4/ostream" 3
       __ostream_type&
      seekp(off_type, ios_base::seekdir);

    protected:
      basic_ostream()
      { this->init(0); }

      template<typename _ValueT>
        __ostream_type&
        _M_insert(_ValueT __v);
    };
# 376 "/usr/include/c++/4.4/ostream" 3
  template <typename _CharT, typename _Traits>
    class basic_ostream<_CharT, _Traits>::sentry
    {

      bool _M_ok;
      basic_ostream<_CharT, _Traits>& _M_os;

    public:
# 395 "/usr/include/c++/4.4/ostream" 3
      explicit
      sentry(basic_ostream<_CharT, _Traits>& __os);
# 405 "/usr/include/c++/4.4/ostream" 3
      ~sentry()
      {

 if (bool(_M_os.flags() & ios_base::unitbuf) && !uncaught_exception())
   {

     if (_M_os.rdbuf() && _M_os.rdbuf()->pubsync() == -1)
       _M_os.setstate(ios_base::badbit);
   }
      }
# 423 "/usr/include/c++/4.4/ostream" 3
      operator bool() const
      { return _M_ok; }
    };
# 444 "/usr/include/c++/4.4/ostream" 3
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, _CharT __c)
    { return __ostream_insert(__out, &__c, 1); }

  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, char __c)
    { return (__out << __out.widen(__c)); }


  template <class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, char __c)
    { return __ostream_insert(__out, &__c, 1); }


  template<class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, signed char __c)
    { return (__out << static_cast<char>(__c)); }

  template<class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, unsigned char __c)
    { return (__out << static_cast<char>(__c)); }
# 486 "/usr/include/c++/4.4/ostream" 3
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, const _CharT* __s)
    {
      if (!__s)
 __out.setstate(ios_base::badbit);
      else
 __ostream_insert(__out, __s,
    static_cast<streamsize>(_Traits::length(__s)));
      return __out;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits> &
    operator<<(basic_ostream<_CharT, _Traits>& __out, const char* __s);


  template<class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, const char* __s)
    {
      if (!__s)
 __out.setstate(ios_base::badbit);
      else
 __ostream_insert(__out, __s,
    static_cast<streamsize>(_Traits::length(__s)));
      return __out;
    }


  template<class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, const signed char* __s)
    { return (__out << reinterpret_cast<const char*>(__s)); }

  template<class _Traits>
    inline basic_ostream<char, _Traits> &
    operator<<(basic_ostream<char, _Traits>& __out, const unsigned char* __s)
    { return (__out << reinterpret_cast<const char*>(__s)); }
# 536 "/usr/include/c++/4.4/ostream" 3
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    endl(basic_ostream<_CharT, _Traits>& __os)
    { return flush(__os.put(__os.widen('\n'))); }







  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    ends(basic_ostream<_CharT, _Traits>& __os)
    { return __os.put(_CharT()); }






  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    flush(basic_ostream<_CharT, _Traits>& __os)
    { return __os.flush(); }

}


# 1 "/usr/include/c++/4.4/bits/ostream.tcc" 1 3
# 39 "/usr/include/c++/4.4/bits/ostream.tcc" 3
       
# 40 "/usr/include/c++/4.4/bits/ostream.tcc" 3



namespace std __attribute__ ((__visibility__ ("default"))) {

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>::sentry::
    sentry(basic_ostream<_CharT, _Traits>& __os)
    : _M_ok(false), _M_os(__os)
    {

      if (__os.tie() && __os.good())
 __os.tie()->flush();

      if (__os.good())
 _M_ok = true;
      else
 __os.setstate(ios_base::failbit);
    }

  template<typename _CharT, typename _Traits>
    template<typename _ValueT>
      basic_ostream<_CharT, _Traits>&
      basic_ostream<_CharT, _Traits>::
      _M_insert(_ValueT __v)
      {
 sentry __cerb(*this);
 if (__cerb)
   {
     ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
     try
       {
  const __num_put_type& __np = __check_facet(this->_M_num_put);
  if (__np.put(*this, *this, this->fill(), __v).failed())
    __err |= ios_base::badbit;
       }
     catch(__cxxabiv1::__forced_unwind&)
       {
  this->_M_setstate(ios_base::badbit);
  throw;
       }
     catch(...)
       { this->_M_setstate(ios_base::badbit); }
     if (__err)
       this->setstate(__err);
   }
 return *this;
      }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(short __n)
    {


      const ios_base::fmtflags __fmt = this->flags() & ios_base::basefield;
      if (__fmt == ios_base::oct || __fmt == ios_base::hex)
 return _M_insert(static_cast<long>(static_cast<unsigned short>(__n)));
      else
 return _M_insert(static_cast<long>(__n));
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(int __n)
    {


      const ios_base::fmtflags __fmt = this->flags() & ios_base::basefield;
      if (__fmt == ios_base::oct || __fmt == ios_base::hex)
 return _M_insert(static_cast<long>(static_cast<unsigned int>(__n)));
      else
 return _M_insert(static_cast<long>(__n));
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(__streambuf_type* __sbin)
    {
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      sentry __cerb(*this);
      if (__cerb && __sbin)
 {
   try
     {
       if (!__copy_streambufs(__sbin, this->rdbuf()))
  __err |= ios_base::failbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::failbit); }
 }
      else if (!__sbin)
 __err |= ios_base::badbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    put(char_type __c)
    {






      sentry __cerb(*this);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       const int_type __put = this->rdbuf()->sputc(__c);
       if (traits_type::eq_int_type(__put, traits_type::eof()))
  __err |= ios_base::badbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    write(const _CharT* __s, streamsize __n)
    {







      sentry __cerb(*this);
      if (__cerb)
 {
   try
     { _M_write(__s, __n); }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    flush()
    {



      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      try
 {
   if (this->rdbuf() && this->rdbuf()->pubsync() == -1)
     __err |= ios_base::badbit;
 }
      catch(__cxxabiv1::__forced_unwind&)
 {
   this->_M_setstate(ios_base::badbit);
   throw;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    typename basic_ostream<_CharT, _Traits>::pos_type
    basic_ostream<_CharT, _Traits>::
    tellp()
    {
      pos_type __ret = pos_type(-1);
      try
 {
   if (!this->fail())
     __ret = this->rdbuf()->pubseekoff(0, ios_base::cur, ios_base::out);
 }
      catch(__cxxabiv1::__forced_unwind&)
 {
   this->_M_setstate(ios_base::badbit);
   throw;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    seekp(pos_type __pos)
    {
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      try
 {
   if (!this->fail())
     {


       const pos_type __p = this->rdbuf()->pubseekpos(__pos,
            ios_base::out);


       if (__p == pos_type(off_type(-1)))
  __err |= ios_base::failbit;
     }
 }
      catch(__cxxabiv1::__forced_unwind&)
 {
   this->_M_setstate(ios_base::badbit);
   throw;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    seekp(off_type __off, ios_base::seekdir __dir)
    {
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      try
 {
   if (!this->fail())
     {


       const pos_type __p = this->rdbuf()->pubseekoff(__off, __dir,
            ios_base::out);


       if (__p == pos_type(off_type(-1)))
  __err |= ios_base::failbit;
     }
 }
      catch(__cxxabiv1::__forced_unwind&)
 {
   this->_M_setstate(ios_base::badbit);
   throw;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, const char* __s)
    {
      if (!__s)
 __out.setstate(ios_base::badbit);
      else
 {


   const size_t __clen = char_traits<char>::length(__s);
   try
     {
       struct __ptr_guard
       {
  _CharT *__p;
  __ptr_guard (_CharT *__ip): __p(__ip) { }
  ~__ptr_guard() { delete[] __p; }
  _CharT* __get() { return __p; }
       } __pg (new _CharT[__clen]);

       _CharT *__ws = __pg.__get();
       for (size_t __i = 0; __i < __clen; ++__i)
  __ws[__i] = __out.widen(__s[__i]);
       __ostream_insert(__out, __ws, __clen);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __out._M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { __out._M_setstate(ios_base::badbit); }
 }
      return __out;
    }





  extern template class basic_ostream<char>;
  extern template ostream& endl(ostream&);
  extern template ostream& ends(ostream&);
  extern template ostream& flush(ostream&);
  extern template ostream& operator<<(ostream&, char);
  extern template ostream& operator<<(ostream&, unsigned char);
  extern template ostream& operator<<(ostream&, signed char);
  extern template ostream& operator<<(ostream&, const char*);
  extern template ostream& operator<<(ostream&, const unsigned char*);
  extern template ostream& operator<<(ostream&, const signed char*);

  extern template ostream& ostream::_M_insert(long);
  extern template ostream& ostream::_M_insert(unsigned long);
  extern template ostream& ostream::_M_insert(bool);

  extern template ostream& ostream::_M_insert(long long);
  extern template ostream& ostream::_M_insert(unsigned long long);

  extern template ostream& ostream::_M_insert(double);
  extern template ostream& ostream::_M_insert(long double);
  extern template ostream& ostream::_M_insert(const void*);


  extern template class basic_ostream<wchar_t>;
  extern template wostream& endl(wostream&);
  extern template wostream& ends(wostream&);
  extern template wostream& flush(wostream&);
  extern template wostream& operator<<(wostream&, wchar_t);
  extern template wostream& operator<<(wostream&, char);
  extern template wostream& operator<<(wostream&, const wchar_t*);
  extern template wostream& operator<<(wostream&, const char*);

  extern template wostream& wostream::_M_insert(long);
  extern template wostream& wostream::_M_insert(unsigned long);
  extern template wostream& wostream::_M_insert(bool);

  extern template wostream& wostream::_M_insert(long long);
  extern template wostream& wostream::_M_insert(unsigned long long);

  extern template wostream& wostream::_M_insert(double);
  extern template wostream& wostream::_M_insert(long double);
  extern template wostream& wostream::_M_insert(const void*);



}
# 566 "/usr/include/c++/4.4/ostream" 2 3
# 41 "/usr/include/c++/4.4/iostream" 2 3
# 1 "/usr/include/c++/4.4/istream" 1 3
# 38 "/usr/include/c++/4.4/istream" 3
       
# 39 "/usr/include/c++/4.4/istream" 3




namespace std __attribute__ ((__visibility__ ("default"))) {
# 54 "/usr/include/c++/4.4/istream" 3
  template<typename _CharT, typename _Traits>
    class basic_istream : virtual public basic_ios<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;


      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef basic_ios<_CharT, _Traits> __ios_type;
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef num_get<_CharT, istreambuf_iterator<_CharT, _Traits> >
        __num_get_type;
      typedef ctype<_CharT> __ctype_type;

    protected:





      streamsize _M_gcount;

    public:
# 90 "/usr/include/c++/4.4/istream" 3
      explicit
      basic_istream(__streambuf_type* __sb)
      : _M_gcount(streamsize(0))
      { this->init(__sb); }






      virtual
      ~basic_istream()
      { _M_gcount = streamsize(0); }


      class sentry;
      friend class sentry;
# 118 "/usr/include/c++/4.4/istream" 3
      __istream_type&
      operator>>(__istream_type& (*__pf)(__istream_type&))
      { return __pf(*this); }

      __istream_type&
      operator>>(__ios_type& (*__pf)(__ios_type&))
      {
 __pf(*this);
 return *this;
      }

      __istream_type&
      operator>>(ios_base& (*__pf)(ios_base&))
      {
 __pf(*this);
 return *this;
      }
# 165 "/usr/include/c++/4.4/istream" 3
      __istream_type&
      operator>>(bool& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(short& __n);

      __istream_type&
      operator>>(unsigned short& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(int& __n);

      __istream_type&
      operator>>(unsigned int& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(long& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(unsigned long& __n)
      { return _M_extract(__n); }


      __istream_type&
      operator>>(long long& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(unsigned long long& __n)
      { return _M_extract(__n); }


      __istream_type&
      operator>>(float& __f)
      { return _M_extract(__f); }

      __istream_type&
      operator>>(double& __f)
      { return _M_extract(__f); }

      __istream_type&
      operator>>(long double& __f)
      { return _M_extract(__f); }

      __istream_type&
      operator>>(void*& __p)
      { return _M_extract(__p); }
# 237 "/usr/include/c++/4.4/istream" 3
      __istream_type&
      operator>>(__streambuf_type* __sb);
# 247 "/usr/include/c++/4.4/istream" 3
      streamsize
      gcount() const
      { return _M_gcount; }
# 279 "/usr/include/c++/4.4/istream" 3
      int_type
      get();
# 293 "/usr/include/c++/4.4/istream" 3
      __istream_type&
      get(char_type& __c);
# 320 "/usr/include/c++/4.4/istream" 3
      __istream_type&
      get(char_type* __s, streamsize __n, char_type __delim);
# 331 "/usr/include/c++/4.4/istream" 3
      __istream_type&
      get(char_type* __s, streamsize __n)
      { return this->get(__s, __n, this->widen('\n')); }
# 354 "/usr/include/c++/4.4/istream" 3
      __istream_type&
      get(__streambuf_type& __sb, char_type __delim);
# 364 "/usr/include/c++/4.4/istream" 3
      __istream_type&
      get(__streambuf_type& __sb)
      { return this->get(__sb, this->widen('\n')); }
# 393 "/usr/include/c++/4.4/istream" 3
      __istream_type&
      getline(char_type* __s, streamsize __n, char_type __delim);
# 404 "/usr/include/c++/4.4/istream" 3
      __istream_type&
      getline(char_type* __s, streamsize __n)
      { return this->getline(__s, __n, this->widen('\n')); }
# 428 "/usr/include/c++/4.4/istream" 3
      __istream_type&
      ignore();

      __istream_type&
      ignore(streamsize __n);

      __istream_type&
      ignore(streamsize __n, int_type __delim);
# 445 "/usr/include/c++/4.4/istream" 3
      int_type
      peek();
# 463 "/usr/include/c++/4.4/istream" 3
      __istream_type&
      read(char_type* __s, streamsize __n);
# 482 "/usr/include/c++/4.4/istream" 3
      streamsize
      readsome(char_type* __s, streamsize __n);
# 498 "/usr/include/c++/4.4/istream" 3
      __istream_type&
      putback(char_type __c);
# 513 "/usr/include/c++/4.4/istream" 3
      __istream_type&
      unget();
# 531 "/usr/include/c++/4.4/istream" 3
      int
      sync();
# 545 "/usr/include/c++/4.4/istream" 3
      pos_type
      tellg();
# 560 "/usr/include/c++/4.4/istream" 3
      __istream_type&
      seekg(pos_type);
# 576 "/usr/include/c++/4.4/istream" 3
      __istream_type&
      seekg(off_type, ios_base::seekdir);


    protected:
      basic_istream()
      : _M_gcount(streamsize(0))
      { this->init(0); }

      template<typename _ValueT>
        __istream_type&
        _M_extract(_ValueT& __v);
    };


  template<>
    basic_istream<char>&
    basic_istream<char>::
    getline(char_type* __s, streamsize __n, char_type __delim);

  template<>
    basic_istream<char>&
    basic_istream<char>::
    ignore(streamsize __n);

  template<>
    basic_istream<char>&
    basic_istream<char>::
    ignore(streamsize __n, int_type __delim);


  template<>
    basic_istream<wchar_t>&
    basic_istream<wchar_t>::
    getline(char_type* __s, streamsize __n, char_type __delim);

  template<>
    basic_istream<wchar_t>&
    basic_istream<wchar_t>::
    ignore(streamsize __n);

  template<>
    basic_istream<wchar_t>&
    basic_istream<wchar_t>::
    ignore(streamsize __n, int_type __delim);
# 631 "/usr/include/c++/4.4/istream" 3
  template<typename _CharT, typename _Traits>
    class basic_istream<_CharT, _Traits>::sentry
    {
    public:

      typedef _Traits traits_type;
      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::__ctype_type __ctype_type;
      typedef typename _Traits::int_type __int_type;
# 663 "/usr/include/c++/4.4/istream" 3
      explicit
      sentry(basic_istream<_CharT, _Traits>& __is, bool __noskipws = false);
# 673 "/usr/include/c++/4.4/istream" 3
      operator bool() const
      { return _M_ok; }

    private:
      bool _M_ok;
    };
# 693 "/usr/include/c++/4.4/istream" 3
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT& __c);

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, unsigned char& __c)
    { return (__in >> reinterpret_cast<char&>(__c)); }

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, signed char& __c)
    { return (__in >> reinterpret_cast<char&>(__c)); }
# 734 "/usr/include/c++/4.4/istream" 3
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT* __s);


  template<>
    basic_istream<char>&
    operator>>(basic_istream<char>& __in, char* __s);

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, unsigned char* __s)
    { return (__in >> reinterpret_cast<char*>(__s)); }

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, signed char* __s)
    { return (__in >> reinterpret_cast<char*>(__s)); }
# 762 "/usr/include/c++/4.4/istream" 3
  template<typename _CharT, typename _Traits>
    class basic_iostream
    : public basic_istream<_CharT, _Traits>,
      public basic_ostream<_CharT, _Traits>
    {
    public:



      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;


      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_ostream<_CharT, _Traits> __ostream_type;







      explicit
      basic_iostream(basic_streambuf<_CharT, _Traits>* __sb)
      : __istream_type(__sb), __ostream_type(__sb) { }




      virtual
      ~basic_iostream() { }

    protected:
      basic_iostream()
      : __istream_type(), __ostream_type() { }
    };
# 823 "/usr/include/c++/4.4/istream" 3
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    ws(basic_istream<_CharT, _Traits>& __is);

}


# 1 "/usr/include/c++/4.4/bits/istream.tcc" 1 3
# 39 "/usr/include/c++/4.4/bits/istream.tcc" 3
       
# 40 "/usr/include/c++/4.4/bits/istream.tcc" 3



namespace std __attribute__ ((__visibility__ ("default"))) {

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>::sentry::
    sentry(basic_istream<_CharT, _Traits>& __in, bool __noskip) : _M_ok(false)
    {
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      if (__in.good())
 {
   if (__in.tie())
     __in.tie()->flush();
   if (!__noskip && bool(__in.flags() & ios_base::skipws))
     {
       const __int_type __eof = traits_type::eof();
       __streambuf_type* __sb = __in.rdbuf();
       __int_type __c = __sb->sgetc();

       const __ctype_type& __ct = __check_facet(__in._M_ctype);
       while (!traits_type::eq_int_type(__c, __eof)
       && __ct.is(ctype_base::space,
    traits_type::to_char_type(__c)))
  __c = __sb->snextc();




       if (traits_type::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;
     }
 }

      if (__in.good() && __err == ios_base::goodbit)
 _M_ok = true;
      else
 {
   __err |= ios_base::failbit;
   __in.setstate(__err);
 }
    }

  template<typename _CharT, typename _Traits>
    template<typename _ValueT>
      basic_istream<_CharT, _Traits>&
      basic_istream<_CharT, _Traits>::
      _M_extract(_ValueT& __v)
      {
 sentry __cerb(*this, false);
 if (__cerb)
   {
     ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
     try
       {
  const __num_get_type& __ng = __check_facet(this->_M_num_get);
  __ng.get(*this, 0, *this, __err, __v);
       }
     catch(__cxxabiv1::__forced_unwind&)
       {
  this->_M_setstate(ios_base::badbit);
  throw;
       }
     catch(...)
       { this->_M_setstate(ios_base::badbit); }
     if (__err)
       this->setstate(__err);
   }
 return *this;
      }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(short& __n)
    {


      long __l;
      _M_extract(__l);
      if (!this->fail())
 {
   if (__gnu_cxx::__numeric_traits<short>::__min <= __l
       && __l <= __gnu_cxx::__numeric_traits<short>::__max)
     __n = short(__l);
   else
     this->setstate(ios_base::failbit);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(int& __n)
    {


      long __l;
      _M_extract(__l);
      if (!this->fail())
 {
   if (__gnu_cxx::__numeric_traits<int>::__min <= __l
       && __l <= __gnu_cxx::__numeric_traits<int>::__max)
     __n = int(__l);
   else
     this->setstate(ios_base::failbit);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(__streambuf_type* __sbout)
    {
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      sentry __cerb(*this, false);
      if (__cerb && __sbout)
 {
   try
     {
       bool __ineof;
       if (!__copy_streambufs_eof(this->rdbuf(), __sbout, __ineof))
  __err |= ios_base::failbit;
       if (__ineof)
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::failbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::failbit); }
 }
      else if (!__sbout)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::int_type
    basic_istream<_CharT, _Traits>::
    get(void)
    {
      const int_type __eof = traits_type::eof();
      int_type __c = __eof;
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       __c = this->rdbuf()->sbumpc();

       if (!traits_type::eq_int_type(__c, __eof))
  _M_gcount = 1;
       else
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return __c;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(char_type& __c)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       const int_type __cb = this->rdbuf()->sbumpc();

       if (!traits_type::eq_int_type(__cb, traits_type::eof()))
  {
    _M_gcount = 1;
    __c = traits_type::to_char_type(__cb);
  }
       else
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(char_type* __s, streamsize __n, char_type __delim)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       const int_type __idelim = traits_type::to_int_type(__delim);
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();
       int_type __c = __sb->sgetc();

       while (_M_gcount + 1 < __n
       && !traits_type::eq_int_type(__c, __eof)
       && !traits_type::eq_int_type(__c, __idelim))
  {
    *__s++ = traits_type::to_char_type(__c);
    ++_M_gcount;
    __c = __sb->snextc();
  }
       if (traits_type::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }


      if (__n > 0)
 *__s = char_type();
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(__streambuf_type& __sb, char_type __delim)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       const int_type __idelim = traits_type::to_int_type(__delim);
       const int_type __eof = traits_type::eof();
       __streambuf_type* __this_sb = this->rdbuf();
       int_type __c = __this_sb->sgetc();
       char_type __c2 = traits_type::to_char_type(__c);

       while (!traits_type::eq_int_type(__c, __eof)
       && !traits_type::eq_int_type(__c, __idelim)
       && !traits_type::eq_int_type(__sb.sputc(__c2), __eof))
  {
    ++_M_gcount;
    __c = __this_sb->snextc();
    __c2 = traits_type::to_char_type(__c);
  }
       if (traits_type::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    getline(char_type* __s, streamsize __n, char_type __delim)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      sentry __cerb(*this, true);
      if (__cerb)
        {
          try
            {
              const int_type __idelim = traits_type::to_int_type(__delim);
              const int_type __eof = traits_type::eof();
              __streambuf_type* __sb = this->rdbuf();
              int_type __c = __sb->sgetc();

              while (_M_gcount + 1 < __n
                     && !traits_type::eq_int_type(__c, __eof)
                     && !traits_type::eq_int_type(__c, __idelim))
                {
                  *__s++ = traits_type::to_char_type(__c);
                  __c = __sb->snextc();
                  ++_M_gcount;
                }
              if (traits_type::eq_int_type(__c, __eof))
                __err |= ios_base::eofbit;
              else
                {
                  if (traits_type::eq_int_type(__c, __idelim))
                    {
                      __sb->sbumpc();
                      ++_M_gcount;
                    }
                  else
                    __err |= ios_base::failbit;
                }
            }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
          catch(...)
            { this->_M_setstate(ios_base::badbit); }
        }


      if (__n > 0)
 *__s = char_type();
      if (!_M_gcount)
        __err |= ios_base::failbit;
      if (__err)
        this->setstate(__err);
      return *this;
    }




  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    ignore(void)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();

       if (traits_type::eq_int_type(__sb->sbumpc(), __eof))
  __err |= ios_base::eofbit;
       else
  _M_gcount = 1;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    ignore(streamsize __n)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb && __n > 0)
        {
          ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
          try
            {
              const int_type __eof = traits_type::eof();
              __streambuf_type* __sb = this->rdbuf();
              int_type __c = __sb->sgetc();
# 463 "/usr/include/c++/4.4/bits/istream.tcc" 3
       bool __large_ignore = false;
       while (true)
  {
    while (_M_gcount < __n
    && !traits_type::eq_int_type(__c, __eof))
      {
        ++_M_gcount;
        __c = __sb->snextc();
      }
    if (__n == __gnu_cxx::__numeric_traits<streamsize>::__max
        && !traits_type::eq_int_type(__c, __eof))
      {
        _M_gcount =
   __gnu_cxx::__numeric_traits<streamsize>::__min;
        __large_ignore = true;
      }
    else
      break;
  }

       if (__large_ignore)
  _M_gcount = __gnu_cxx::__numeric_traits<streamsize>::__max;

       if (traits_type::eq_int_type(__c, __eof))
                __err |= ios_base::eofbit;
            }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
          catch(...)
            { this->_M_setstate(ios_base::badbit); }
          if (__err)
            this->setstate(__err);
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    ignore(streamsize __n, int_type __delim)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb && __n > 0)
        {
          ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
          try
            {
              const int_type __eof = traits_type::eof();
              __streambuf_type* __sb = this->rdbuf();
              int_type __c = __sb->sgetc();


       bool __large_ignore = false;
       while (true)
  {
    while (_M_gcount < __n
    && !traits_type::eq_int_type(__c, __eof)
    && !traits_type::eq_int_type(__c, __delim))
      {
        ++_M_gcount;
        __c = __sb->snextc();
      }
    if (__n == __gnu_cxx::__numeric_traits<streamsize>::__max
        && !traits_type::eq_int_type(__c, __eof)
        && !traits_type::eq_int_type(__c, __delim))
      {
        _M_gcount =
   __gnu_cxx::__numeric_traits<streamsize>::__min;
        __large_ignore = true;
      }
    else
      break;
  }

       if (__large_ignore)
  _M_gcount = __gnu_cxx::__numeric_traits<streamsize>::__max;

              if (traits_type::eq_int_type(__c, __eof))
                __err |= ios_base::eofbit;
       else if (traits_type::eq_int_type(__c, __delim))
  {
    if (_M_gcount
        < __gnu_cxx::__numeric_traits<streamsize>::__max)
      ++_M_gcount;
    __sb->sbumpc();
  }
            }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
          catch(...)
            { this->_M_setstate(ios_base::badbit); }
          if (__err)
            this->setstate(__err);
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::int_type
    basic_istream<_CharT, _Traits>::
    peek(void)
    {
      int_type __c = traits_type::eof();
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       __c = this->rdbuf()->sgetc();
       if (traits_type::eq_int_type(__c, traits_type::eof()))
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return __c;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    read(char_type* __s, streamsize __n)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       _M_gcount = this->rdbuf()->sgetn(__s, __n);
       if (_M_gcount != __n)
  __err |= (ios_base::eofbit | ios_base::failbit);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    streamsize
    basic_istream<_CharT, _Traits>::
    readsome(char_type* __s, streamsize __n)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {

       const streamsize __num = this->rdbuf()->in_avail();
       if (__num > 0)
  _M_gcount = this->rdbuf()->sgetn(__s, std::min(__num, __n));
       else if (__num == -1)
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return _M_gcount;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    putback(char_type __c)
    {


      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();
       if (!__sb
    || traits_type::eq_int_type(__sb->sputbackc(__c), __eof))
  __err |= ios_base::badbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    unget(void)
    {


      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();
       if (!__sb
    || traits_type::eq_int_type(__sb->sungetc(), __eof))
  __err |= ios_base::badbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    int
    basic_istream<_CharT, _Traits>::
    sync(void)
    {


      int __ret = -1;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       __streambuf_type* __sb = this->rdbuf();
       if (__sb)
  {
    if (__sb->pubsync() == -1)
      __err |= ios_base::badbit;
    else
      __ret = 0;
  }
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::pos_type
    basic_istream<_CharT, _Traits>::
    tellg(void)
    {


      pos_type __ret = pos_type(-1);
      try
 {
   if (!this->fail())
     __ret = this->rdbuf()->pubseekoff(0, ios_base::cur,
           ios_base::in);
 }
      catch(__cxxabiv1::__forced_unwind&)
 {
   this->_M_setstate(ios_base::badbit);
   throw;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    seekg(pos_type __pos)
    {


      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      try
 {
   if (!this->fail())
     {

       const pos_type __p = this->rdbuf()->pubseekpos(__pos,
            ios_base::in);


       if (__p == pos_type(off_type(-1)))
  __err |= ios_base::failbit;
     }
 }
      catch(__cxxabiv1::__forced_unwind&)
 {
   this->_M_setstate(ios_base::badbit);
   throw;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    seekg(off_type __off, ios_base::seekdir __dir)
    {


      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      try
 {
   if (!this->fail())
     {

       const pos_type __p = this->rdbuf()->pubseekoff(__off, __dir,
            ios_base::in);


       if (__p == pos_type(off_type(-1)))
  __err |= ios_base::failbit;
     }
 }
      catch(__cxxabiv1::__forced_unwind&)
 {
   this->_M_setstate(ios_base::badbit);
   throw;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }


  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT& __c)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::int_type __int_type;

      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       const __int_type __cb = __in.rdbuf()->sbumpc();
       if (!_Traits::eq_int_type(__cb, _Traits::eof()))
  __c = _Traits::to_char_type(__cb);
       else
  __err |= (ios_base::eofbit | ios_base::failbit);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __in._M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { __in._M_setstate(ios_base::badbit); }
   if (__err)
     __in.setstate(__err);
 }
      return __in;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT* __s)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef typename _Traits::int_type int_type;
      typedef _CharT char_type;
      typedef ctype<_CharT> __ctype_type;

      streamsize __extracted = 0;
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
 {
   try
     {

       streamsize __num = __in.width();
       if (__num <= 0)
  __num = __gnu_cxx::__numeric_traits<streamsize>::__max;

       const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());

       const int_type __eof = _Traits::eof();
       __streambuf_type* __sb = __in.rdbuf();
       int_type __c = __sb->sgetc();

       while (__extracted < __num - 1
       && !_Traits::eq_int_type(__c, __eof)
       && !__ct.is(ctype_base::space,
     _Traits::to_char_type(__c)))
  {
    *__s++ = _Traits::to_char_type(__c);
    ++__extracted;
    __c = __sb->snextc();
  }
       if (_Traits::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;



       *__s = char_type();
       __in.width(0);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __in._M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { __in._M_setstate(ios_base::badbit); }
 }
      if (!__extracted)
 __err |= ios_base::failbit;
      if (__err)
 __in.setstate(__err);
      return __in;
    }


  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    ws(basic_istream<_CharT, _Traits>& __in)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef typename __istream_type::int_type __int_type;
      typedef ctype<_CharT> __ctype_type;

      const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());
      const __int_type __eof = _Traits::eof();
      __streambuf_type* __sb = __in.rdbuf();
      __int_type __c = __sb->sgetc();

      while (!_Traits::eq_int_type(__c, __eof)
      && __ct.is(ctype_base::space, _Traits::to_char_type(__c)))
 __c = __sb->snextc();

       if (_Traits::eq_int_type(__c, __eof))
  __in.setstate(ios_base::eofbit);
      return __in;
    }





  extern template class basic_istream<char>;
  extern template istream& ws(istream&);
  extern template istream& operator>>(istream&, char&);
  extern template istream& operator>>(istream&, char*);
  extern template istream& operator>>(istream&, unsigned char&);
  extern template istream& operator>>(istream&, signed char&);
  extern template istream& operator>>(istream&, unsigned char*);
  extern template istream& operator>>(istream&, signed char*);

  extern template istream& istream::_M_extract(unsigned short&);
  extern template istream& istream::_M_extract(unsigned int&);
  extern template istream& istream::_M_extract(long&);
  extern template istream& istream::_M_extract(unsigned long&);
  extern template istream& istream::_M_extract(bool&);

  extern template istream& istream::_M_extract(long long&);
  extern template istream& istream::_M_extract(unsigned long long&);

  extern template istream& istream::_M_extract(float&);
  extern template istream& istream::_M_extract(double&);
  extern template istream& istream::_M_extract(long double&);
  extern template istream& istream::_M_extract(void*&);

  extern template class basic_iostream<char>;


  extern template class basic_istream<wchar_t>;
  extern template wistream& ws(wistream&);
  extern template wistream& operator>>(wistream&, wchar_t&);
  extern template wistream& operator>>(wistream&, wchar_t*);

  extern template wistream& wistream::_M_extract(unsigned short&);
  extern template wistream& wistream::_M_extract(unsigned int&);
  extern template wistream& wistream::_M_extract(long&);
  extern template wistream& wistream::_M_extract(unsigned long&);
  extern template wistream& wistream::_M_extract(bool&);

  extern template wistream& wistream::_M_extract(long long&);
  extern template wistream& wistream::_M_extract(unsigned long long&);

  extern template wistream& wistream::_M_extract(float&);
  extern template wistream& wistream::_M_extract(double&);
  extern template wistream& wistream::_M_extract(long double&);
  extern template wistream& wistream::_M_extract(void*&);

  extern template class basic_iostream<wchar_t>;



}
# 831 "/usr/include/c++/4.4/istream" 2 3
# 42 "/usr/include/c++/4.4/iostream" 2 3

namespace std __attribute__ ((__visibility__ ("default"))) {
# 58 "/usr/include/c++/4.4/iostream" 3
  extern istream cin;
  extern ostream cout;
  extern ostream cerr;
  extern ostream clog;


  extern wistream wcin;
  extern wostream wcout;
  extern wostream wcerr;
  extern wostream wclog;




  static ios_base::Init __ioinit;

}
# 18 "/usr/include/wx-2.8/wx/ioswrap.h" 2
# 37 "/usr/include/wx-2.8/wx/textctrl.h" 2
# 47 "/usr/include/wx-2.8/wx/textctrl.h"
class wxTextCtrl;
class wxTextCtrlBase;






typedef long wxTextPos;



typedef long wxTextCoord;





extern const wxChar wxTextCtrlNameStr[];



const wxTextCoord wxOutOfRangeTextCoord = -1;
const wxTextCoord wxInvalidTextCoord = -2;
# 142 "/usr/include/wx-2.8/wx/textctrl.h"
enum wxTextCtrlHitTestResult
{
    wxTE_HT_UNKNOWN = -2,
    wxTE_HT_BEFORE,
    wxTE_HT_ON_TEXT,
    wxTE_HT_BELOW,
    wxTE_HT_BEYOND
};
# 158 "/usr/include/wx-2.8/wx/textctrl.h"
enum wxTextAttrAlignment
{
    wxTEXT_ALIGNMENT_DEFAULT,
    wxTEXT_ALIGNMENT_LEFT,
    wxTEXT_ALIGNMENT_CENTRE,
    wxTEXT_ALIGNMENT_CENTER = wxTEXT_ALIGNMENT_CENTRE,
    wxTEXT_ALIGNMENT_RIGHT,
    wxTEXT_ALIGNMENT_JUSTIFIED
};
# 189 "/usr/include/wx-2.8/wx/textctrl.h"
class wxTextAttr
{
public:

    wxTextAttr() { Init(); }
    wxTextAttr(const wxColour& colText,
               const wxColour& colBack = wxNullColour,
               const wxFont& font = wxNullFont,
               wxTextAttrAlignment alignment = wxTEXT_ALIGNMENT_DEFAULT);


    void Init();





    static wxTextAttr Merge(const wxTextAttr& base, const wxTextAttr& overlay)
    {
        return Combine(overlay, base, __null);
    }


    void Merge(const wxTextAttr& overlay)
    {
        *this = Merge(*this, overlay);
    }



    void operator= (const wxTextAttr& attr);


    void SetTextColour(const wxColour& colText) { m_colText = colText; m_flags |= 0x0001; }
    void SetBackgroundColour(const wxColour& colBack) { m_colBack = colBack; m_flags |= 0x0002; }
    void SetFont(const wxFont& font, long flags = ( 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040 )) { m_font = font; m_flags |= flags; }
    void SetAlignment(wxTextAttrAlignment alignment) { m_textAlignment = alignment; m_flags |= 0x0080; }
    void SetTabs(const wxArrayInt& tabs) { m_tabs = tabs; m_flags |= 0x0400; }
    void SetLeftIndent(int indent, int subIndent = 0) { m_leftIndent = indent; m_leftSubIndent = subIndent; m_flags |= 0x0100; }
    void SetRightIndent(int indent) { m_rightIndent = indent; m_flags |= 0x0200; }
    void SetFlags(long flags) { m_flags = flags; }


    bool HasTextColour() const { return m_colText.Ok() && HasFlag(0x0001) ; }
    bool HasBackgroundColour() const { return m_colBack.Ok() && HasFlag(0x0002) ; }
    bool HasFont() const { return m_font.Ok() && HasFlag(( 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040 )) ; }
    bool HasAlignment() const { return (m_textAlignment != wxTEXT_ALIGNMENT_DEFAULT) && ((m_flags & 0x0080) != 0) ; }
    bool HasTabs() const { return (m_flags & 0x0400) != 0 ; }
    bool HasLeftIndent() const { return (m_flags & 0x0100) != 0 ; }
    bool HasRightIndent() const { return (m_flags & 0x0200) != 0 ; }
    bool HasFlag(long flag) const { return (m_flags & flag) != 0; }

    const wxColour& GetTextColour() const { return m_colText; }
    const wxColour& GetBackgroundColour() const { return m_colBack; }
    const wxFont& GetFont() const { return m_font; }
    wxTextAttrAlignment GetAlignment() const { return m_textAlignment; }
    const wxArrayInt& GetTabs() const { return m_tabs; }
    long GetLeftIndent() const { return m_leftIndent; }
    long GetLeftSubIndent() const { return m_leftSubIndent; }
    long GetRightIndent() const { return m_rightIndent; }
    long GetFlags() const { return m_flags; }


    bool IsDefault() const
    {
        return !HasTextColour() && !HasBackgroundColour() && !HasFont() && !HasAlignment() &&
               !HasTabs() && !HasLeftIndent() && !HasRightIndent() ;
    }




    static wxTextAttr Combine(const wxTextAttr& attr,
                              const wxTextAttr& attrDef,
                              const wxTextCtrlBase *text);

private:
    long m_flags;
    wxColour m_colText,
                        m_colBack;
    wxFont m_font;
    wxTextAttrAlignment m_textAlignment;
    wxArrayInt m_tabs;
    int m_leftIndent;
    int m_leftSubIndent;


    int m_rightIndent;
};






class wxTextCtrlBase : public wxControl

                                 , public std:: streambuf


{
public:



    wxTextCtrlBase(){}
    virtual ~wxTextCtrlBase(){}




    virtual wxString GetValue() const = 0;
    virtual bool IsEmpty() const { return GetValue().empty(); }

    virtual void SetValue(const wxString& value)
        { DoSetValue(value, SetValue_SendEvent); }
    virtual void ChangeValue(const wxString& value)
        { DoSetValue(value); }

    virtual wxString GetRange(long from, long to) const;

    virtual int GetLineLength(long lineNo) const = 0;
    virtual wxString GetLineText(long lineNo) const = 0;
    virtual int GetNumberOfLines() const = 0;

    virtual bool IsModified() const = 0;
    virtual bool IsEditable() const = 0;


    bool IsSingleLine() const { return !HasFlag(0x0020); }
    bool IsMultiLine() const { return !IsSingleLine(); }


    virtual void GetSelection(long* from, long* to) const = 0;

    virtual wxString GetStringSelection() const;





    virtual void Clear() = 0;
    virtual void Replace(long from, long to, const wxString& value) = 0;
    virtual void Remove(long from, long to) = 0;


    bool LoadFile(const wxString& file, int fileType = 0) { return DoLoadFile(file, fileType); }
    bool SaveFile(const wxString& file = wxEmptyString, int fileType = 0);


    virtual bool DoLoadFile(const wxString& file, int fileType);
    virtual bool DoSaveFile(const wxString& file, int fileType);


    virtual void MarkDirty() = 0;
    virtual void DiscardEdits() = 0;
    void SetModified(bool modified)
    {
        if ( modified )
            MarkDirty();
        else
            DiscardEdits();
    }



    virtual void SetMaxLength(unsigned long ) { }



    virtual void WriteText(const wxString& text) = 0;
    virtual void AppendText(const wxString& text) = 0;



    virtual bool EmulateKeyPress(const wxKeyEvent& event);




    virtual bool SetStyle(long start, long end, const wxTextAttr& style);
    virtual bool GetStyle(long position, wxTextAttr& style);
    virtual bool SetDefaultStyle(const wxTextAttr& style);
    virtual const wxTextAttr& GetDefaultStyle() const;




    virtual long XYToPosition(long x, long y) const = 0;
    virtual bool PositionToXY(long pos, long *x, long *y) const = 0;

    virtual void ShowPosition(long pos) = 0;





    virtual wxTextCtrlHitTestResult HitTest(const wxPoint& pt, long *pos) const;
    virtual wxTextCtrlHitTestResult HitTest(const wxPoint& pt,
                                            wxTextCoord *col,
                                            wxTextCoord *row) const;


    virtual void Copy() = 0;
    virtual void Cut() = 0;
    virtual void Paste() = 0;

    virtual bool CanCopy() const;
    virtual bool CanCut() const;
    virtual bool CanPaste() const;


    virtual void Undo() = 0;
    virtual void Redo() = 0;

    virtual bool CanUndo() const = 0;
    virtual bool CanRedo() const = 0;


    virtual void SetInsertionPoint(long pos) = 0;
    virtual void SetInsertionPointEnd() = 0;
    virtual long GetInsertionPoint() const = 0;
    virtual wxTextPos GetLastPosition() const = 0;

    virtual void SetSelection(long from, long to) = 0;
    virtual void SelectAll();
    virtual void SetEditable(bool editable) = 0;



    wxTextCtrl& operator<<(const wxString& s);
    wxTextCtrl& operator<<(int i);
    wxTextCtrl& operator<<(long i);
    wxTextCtrl& operator<<(float f);
    wxTextCtrl& operator<<(double d);
    wxTextCtrl& operator<<(const wxChar c);


    void SendTextUpdatedEvent();


    virtual void DoUpdateWindowUI(wxUpdateUIEvent& event);

    virtual bool ShouldInheritColours() const { return false; }

protected:


    int overflow(int i);




    enum
    {
        SetValue_SendEvent = 1,
        SetValue_SelectionOnly = 2
    };

    virtual void DoSetValue(const wxString& value, int flags = 0) = 0;




    wxString m_filename;


    wxTextAttr m_defaultStyle;

    private: wxTextCtrlBase(const wxTextCtrlBase&); wxTextCtrlBase& operator=(const wxTextCtrlBase&);
    public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const;
};
# 477 "/usr/include/wx-2.8/wx/textctrl.h"
# 1 "/usr/include/wx-2.8/wx/gtk/textctrl.h" 1
# 14 "/usr/include/wx-2.8/wx/gtk/textctrl.h"
typedef struct _GtkTextMark GtkTextMark;





class wxTextCtrl: public wxTextCtrlBase
{
public:
    wxTextCtrl() { Init(); }
    wxTextCtrl(wxWindow *parent,
               wxWindowID id,
               const wxString &value = wxEmptyString,
               const wxPoint &pos = wxDefaultPosition,
               const wxSize &size = wxDefaultSize,
               long style = 0,
               const wxValidator& validator = wxDefaultValidator,
               const wxString &name = wxTextCtrlNameStr);

    virtual ~wxTextCtrl();

    bool Create(wxWindow *parent,
                wxWindowID id,
                const wxString &value = wxEmptyString,
                const wxPoint &pos = wxDefaultPosition,
                const wxSize &size = wxDefaultSize,
                long style = 0,
                const wxValidator& validator = wxDefaultValidator,
                const wxString &name = wxTextCtrlNameStr);




    virtual wxString GetValue() const;
    virtual bool IsEmpty() const;

    virtual int GetLineLength(long lineNo) const;
    virtual wxString GetLineText(long lineNo) const;
    virtual int GetNumberOfLines() const;

    virtual bool IsModified() const;
    virtual bool IsEditable() const;


    virtual void GetSelection(long* from, long* to) const;





    virtual void Clear();
    virtual void Replace(long from, long to, const wxString& value);
    virtual void Remove(long from, long to);


    virtual void MarkDirty();
    virtual void DiscardEdits();

    virtual void SetMaxLength(unsigned long len);



    virtual void WriteText(const wxString& text);
    virtual void AppendText(const wxString& text);



    virtual bool SetStyle(long start, long end, const wxTextAttr& style);




    virtual long XYToPosition(long x, long y) const;
    virtual bool PositionToXY(long pos, long *x, long *y) const;

    virtual void ShowPosition(long pos);

    virtual wxTextCtrlHitTestResult HitTest(const wxPoint& pt, long *pos) const;
    virtual wxTextCtrlHitTestResult HitTest(const wxPoint& pt,
                                            wxTextCoord *col,
                                            wxTextCoord *row) const
    {
        return wxTextCtrlBase::HitTest(pt, col, row);
    }


    virtual void Copy();
    virtual void Cut();
    virtual void Paste();


    virtual void Undo();
    virtual void Redo();

    virtual bool CanUndo() const;
    virtual bool CanRedo() const;


    virtual void SetInsertionPoint(long pos);
    virtual void SetInsertionPointEnd();
    virtual long GetInsertionPoint() const;
    virtual wxTextPos GetLastPosition() const;

    virtual void SetSelection(long from, long to);
    virtual void SetEditable(bool editable);


    virtual void SetWindowStyleFlag( long style );
    virtual bool Enable( bool enable = true );


    void OnDropFiles( wxDropFilesEvent &event );
    void OnChar( wxKeyEvent &event );

    void OnCut(wxCommandEvent& event);
    void OnCopy(wxCommandEvent& event);
    void OnPaste(wxCommandEvent& event);
    void OnUndo(wxCommandEvent& event);
    void OnRedo(wxCommandEvent& event);

    void OnUpdateCut(wxUpdateUIEvent& event);
    void OnUpdateCopy(wxUpdateUIEvent& event);
    void OnUpdatePaste(wxUpdateUIEvent& event);
    void OnUpdateUndo(wxUpdateUIEvent& event);
    void OnUpdateRedo(wxUpdateUIEvent& event);

    bool SetFont(const wxFont& font);
    bool SetForegroundColour(const wxColour& colour);
    bool SetBackgroundColour(const wxColour& colour);

    GtkWidget* GetConnectWidget();

    void SetUpdateFont(bool ) { }



    virtual void Freeze();
    virtual void Thaw();






    virtual void OnParentEnable( bool enable ) ;


    void IgnoreNextTextUpdate(int n = 1) { m_countUpdatesToIgnore = n; }


    bool IgnoreTextUpdate();



    void DontMarkDirtyOnNextChange() { m_dontMarkDirty = true; }


    bool MarkDirtyOnChange();


    virtual bool GTKProcessEvent(wxEvent& event) const;


    static wxVisualAttributes
    GetClassDefaultAttributes(wxWindowVariant variant = wxWINDOW_VARIANT_NORMAL);


    bool IsFrozen() const { return m_freezeCount > 0; }

protected:
    virtual wxSize DoGetBestSize() const;
    virtual void DoApplyWidgetStyle(GtkRcStyle *style);
    virtual GdkWindow *GTKGetWindow(wxArrayGdkWindows& windows) const;


    void Init();



    virtual bool UseGTKStyleBase() const { return true; }

    virtual void DoSetValue(const wxString &value, int flags = 0);




    void GTKSetEditable();
    void GTKSetVisibility();
    void GTKSetWrapMode();
    void GTKSetJustification();

private:

    void ChangeFontGlobally();





    wxFontEncoding GetTextEncoding() const;


    GtkWidget *m_text;

    bool m_modified:1;
    bool m_dontMarkDirty:1;

    int m_countUpdatesToIgnore;



    GtkTextBuffer *m_buffer;


    unsigned m_freezeCount;
    GtkTextMark* m_showPositionOnThaw;


    void OnUrlMouseEvent(wxMouseEvent&);
    GdkCursor *m_gdkHandCursor;
    GdkCursor *m_gdkXTermCursor;

    private: static const wxEventTableEntry sm_eventTableEntries[]; protected: static const wxEventTable sm_eventTable; virtual const wxEventTable* GetEventTable() const; static wxEventHashTable sm_eventHashTable; virtual wxEventHashTable& GetEventHashTable() const;
    public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};
# 478 "/usr/include/wx-2.8/wx/textctrl.h" 2
# 494 "/usr/include/wx-2.8/wx/textctrl.h"

    extern const wxEventType wxEVT_COMMAND_TEXT_UPDATED;
    extern const wxEventType wxEVT_COMMAND_TEXT_ENTER;
    extern const wxEventType wxEVT_COMMAND_TEXT_URL;
    extern const wxEventType wxEVT_COMMAND_TEXT_MAXLEN;




class wxTextUrlEvent : public wxCommandEvent
{
public:
    wxTextUrlEvent(int winid, const wxMouseEvent& evtMouse,
                   long start, long end)
        : wxCommandEvent(wxEVT_COMMAND_TEXT_URL, winid)
        , m_evtMouse(evtMouse), m_start(start), m_end(end)
        { }


    const wxMouseEvent& GetMouseEvent() const { return m_evtMouse; }


    long GetURLStart() const { return m_start; }


    long GetURLEnd() const { return m_end; }

protected:

    wxMouseEvent m_evtMouse;


    long m_start,
         m_end;

private:
    private: wxTextUrlEvent(const wxTextUrlEvent&); wxTextUrlEvent& operator=(const wxTextUrlEvent&); public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();

public:

    wxTextUrlEvent() : m_evtMouse(), m_start(0), m_end(0) { }
};

typedef void (wxEvtHandler::*wxTextUrlEventFunction)(wxTextUrlEvent&);
# 561 "/usr/include/wx-2.8/wx/textctrl.h"
class wxStreamToTextRedirector
{
private:
    void Init(wxTextCtrl *text)
    {
        m_sbufOld = m_ostr.rdbuf();
        m_ostr.rdbuf(text);
    }

public:
    wxStreamToTextRedirector(wxTextCtrl *text)
        : m_ostr(std:: cout)
    {
        Init(text);
    }

    wxStreamToTextRedirector(wxTextCtrl *text, std:: ostream *ostr)
        : m_ostr(*ostr)
    {
        Init(text);
    }

    ~wxStreamToTextRedirector()
    {
        m_ostr.rdbuf(m_sbufOld);
    }

private:

    std:: ostream& m_ostr;


    std:: streambuf *m_sbufOld;
};
# 82 "/usr/include/wx-2.8/wx/wx.h" 2
# 1 "/usr/include/wx-2.8/wx/slider.h" 1
# 48 "/usr/include/wx-2.8/wx/slider.h"
extern const wxChar wxSliderNameStr[];





class wxSliderBase : public wxControl
{
public:
# 68 "/usr/include/wx-2.8/wx/slider.h"
    wxSliderBase() { }


    virtual int GetValue() const = 0;
    virtual void SetValue(int value) = 0;


    virtual void SetRange(int minValue, int maxValue) = 0;
    virtual int GetMin() const = 0;
    virtual int GetMax() const = 0;
    void SetMin( int minValue ) { SetRange( minValue , GetMax() ) ; }
    void SetMax( int maxValue ) { SetRange( GetMin() , maxValue ) ; }




    virtual void SetLineSize(int lineSize) = 0;
    virtual void SetPageSize(int pageSize) = 0;
    virtual int GetLineSize() const = 0;
    virtual int GetPageSize() const = 0;


    virtual void SetThumbLength(int lenPixels) = 0;
    virtual int GetThumbLength() const = 0;




    virtual void SetTickFreq(int , int ) { }
    virtual int GetTickFreq() const { return 0; }
    virtual void ClearTicks() { }
    virtual void SetTick(int ) { }

    virtual void ClearSel() { }
    virtual int GetSelEnd() const { return GetMin(); }
    virtual int GetSelStart() const { return GetMax(); }
    virtual void SetSelection(int , int ) { }

protected:


    virtual int ValueInvertOrNot(int value) const
    {
        if (HasFlag(0x1000))
            return (GetMax() + GetMin()) - value;
        else
            return value;
    }

private:
    private: wxSliderBase(const wxSliderBase&); wxSliderBase& operator=(const wxSliderBase&);
};
# 135 "/usr/include/wx-2.8/wx/slider.h"
# 1 "/usr/include/wx-2.8/wx/gtk/slider.h" 1
# 17 "/usr/include/wx-2.8/wx/gtk/slider.h"
class wxSlider : public wxSliderBase
{
public:
    wxSlider();
    wxSlider(wxWindow *parent,
             wxWindowID id,
             int value, int minValue, int maxValue,
             const wxPoint& pos = wxDefaultPosition,
             const wxSize& size = wxDefaultSize,
             long style = wxHORIZONTAL,
             const wxValidator& validator = wxDefaultValidator,
             const wxString& name = wxSliderNameStr)
    {
        Create( parent, id, value, minValue, maxValue,
                pos, size, style, validator, name );
    }

    bool Create(wxWindow *parent,
                wxWindowID id,
                int value, int minValue, int maxValue,
                const wxPoint& pos = wxDefaultPosition,
                const wxSize& size = wxDefaultSize,
                long style = wxHORIZONTAL,
                const wxValidator& validator = wxDefaultValidator,
                const wxString& name = wxSliderNameStr);


    virtual int GetValue() const;
    virtual void SetValue(int value);

    virtual void SetRange(int minValue, int maxValue);
    virtual int GetMin() const;
    virtual int GetMax() const;

    virtual void SetLineSize(int lineSize);
    virtual void SetPageSize(int pageSize);
    virtual int GetLineSize() const;
    virtual int GetPageSize() const;

    virtual void SetThumbLength(int lenPixels);
    virtual int GetThumbLength() const;

    static wxVisualAttributes
    GetClassDefaultAttributes(wxWindowVariant variant = wxWINDOW_VARIANT_NORMAL);


    double m_pos;
    int m_scrollEventType;
    bool m_needThumbRelease;

protected:
    virtual GdkWindow *GTKGetWindow(wxArrayGdkWindows& windows) const;

private:
    public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};
# 136 "/usr/include/wx-2.8/wx/slider.h" 2
# 83 "/usr/include/wx-2.8/wx/wx.h" 2
# 1 "/usr/include/wx-2.8/wx/gauge.h" 1
# 44 "/usr/include/wx-2.8/wx/gauge.h"
extern const wxChar wxGaugeNameStr[];





class wxGaugeBase : public wxControl
{
public:
    wxGaugeBase() { m_rangeMax = m_gaugePos = 0; }
    virtual ~wxGaugeBase();

    bool Create(wxWindow *parent,
                wxWindowID id,
                int range,
                const wxPoint& pos = wxDefaultPosition,
                const wxSize& size = wxDefaultSize,
                long style = wxHORIZONTAL,
                const wxValidator& validator = wxDefaultValidator,
                const wxString& name = wxGaugeNameStr);




    virtual void SetRange(int range);
    virtual int GetRange() const;

    virtual void SetValue(int pos);
    virtual int GetValue() const;


    virtual void Pulse();


    bool IsVertical() const { return HasFlag(wxVERTICAL); }


    virtual void SetShadowWidth(int w);
    virtual int GetShadowWidth() const;

    virtual void SetBezelFace(int w);
    virtual int GetBezelFace() const;


    virtual bool AcceptsFocus() const { return false; }

protected:

    int m_rangeMax;


    int m_gaugePos;





    private: wxGaugeBase(const wxGaugeBase&); wxGaugeBase& operator=(const wxGaugeBase&);
};
# 112 "/usr/include/wx-2.8/wx/gauge.h"
# 1 "/usr/include/wx-2.8/wx/gtk/gauge.h" 1
# 17 "/usr/include/wx-2.8/wx/gtk/gauge.h"
class wxGauge: public wxControl
{
public:
    wxGauge() { Init(); }

    wxGauge( wxWindow *parent,
             wxWindowID id,
             int range,
             const wxPoint& pos = wxDefaultPosition,
             const wxSize& size = wxDefaultSize,
             long style = wxHORIZONTAL,
             const wxValidator& validator = wxDefaultValidator,
             const wxString& name = wxGaugeNameStr )
    {
        Init();

        Create(parent, id, range, pos, size, style, validator, name);
    }

    bool Create( wxWindow *parent,
                 wxWindowID id, int range,
                 const wxPoint& pos = wxDefaultPosition,
                 const wxSize& size = wxDefaultSize,
                 long style = wxHORIZONTAL,
                 const wxValidator& validator = wxDefaultValidator,
                 const wxString& name = wxGaugeNameStr );

    void SetShadowWidth( int ) { }
    void SetBezelFace( int ) { }
    int GetShadowWidth() const { return 0; };
    int GetBezelFace() const { return 0; };


    void SetRange( int r );
    void SetValue( int pos );

    int GetRange() const;
    int GetValue() const;


    virtual void Pulse();

    bool IsVertical() const { return HasFlag(wxVERTICAL); }

    static wxVisualAttributes
    GetClassDefaultAttributes(wxWindowVariant variant = wxWINDOW_VARIANT_NORMAL);

    virtual wxVisualAttributes GetDefaultAttributes() const;





    int m_rangeMax,
        m_gaugePos;

protected:

    void Init() { m_rangeMax = m_gaugePos = 0; }


    void DoSetGauge();

    virtual wxSize DoGetBestSize() const;

private:
    public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};
# 113 "/usr/include/wx-2.8/wx/gauge.h" 2
# 84 "/usr/include/wx-2.8/wx/wx.h" 2
# 1 "/usr/include/wx-2.8/wx/scrolwin.h" 1
# 17 "/usr/include/wx-2.8/wx/scrolwin.h"
class wxScrollHelperEvtHandler;
class wxTimer;
# 51 "/usr/include/wx-2.8/wx/scrolwin.h"
class wxScrollHelper
{
public:

    wxScrollHelper(wxWindow *winToScroll);
    virtual ~wxScrollHelper();


    virtual void SetScrollbars(int pixelsPerUnitX, int pixelsPerUnitY,
                               int noUnitsX, int noUnitsY,
                               int xPos = 0, int yPos = 0,
                               bool noRefresh = false );


    virtual void Scroll(int x, int y);


    int GetScrollPageSize(int orient) const;
    void SetScrollPageSize(int orient, int pageSize);



    int GetScrollLines( int orient ) const;


    void SetScrollRate( int xstep, int ystep );


    virtual void GetScrollPixelsPerUnit(int *pixelsPerUnitX,
                                        int *pixelsPerUnitY) const;






    virtual void EnableScrolling(bool x_scrolling, bool y_scrolling);


    virtual void GetViewStart(int *x, int *y) const;


    void SetScale(double xs, double ys) { m_scaleX = xs; m_scaleY = ys; }
    double GetScaleX() const { return m_scaleX; }
    double GetScaleY() const { return m_scaleY; }


    void CalcScrolledPosition(int x, int y, int *xx, int *yy) const
        { DoCalcScrolledPosition(x, y, xx, yy); }
    wxPoint CalcScrolledPosition(const wxPoint& pt) const
    {
        wxPoint p2;
        DoCalcScrolledPosition(pt.x, pt.y, &p2.x, &p2.y);
        return p2;
    }

    void CalcUnscrolledPosition(int x, int y, int *xx, int *yy) const
        { DoCalcUnscrolledPosition(x, y, xx, yy); }
    wxPoint CalcUnscrolledPosition(const wxPoint& pt) const
    {
        wxPoint p2;
        DoCalcUnscrolledPosition(pt.x, pt.y, &p2.x, &p2.y);
        return p2;
    }

    virtual void DoCalcScrolledPosition(int x, int y, int *xx, int *yy) const;
    virtual void DoCalcUnscrolledPosition(int x, int y, int *xx, int *yy) const;


    virtual void AdjustScrollbars(void);


    virtual int CalcScrollInc(wxScrollWinEvent& event);





    virtual void SetTargetWindow(wxWindow *target);
    virtual wxWindow *GetTargetWindow() const;

    void SetTargetRect(const wxRect& rect) { m_rectToScroll = rect; }
    wxRect GetTargetRect() const { return m_rectToScroll; }


    virtual void OnDraw(wxDC& ) { }


    virtual void DoPrepareDC(wxDC& dc);


    bool IsAutoScrolling() const { return m_timerAutoScroll != __null; }


    void StopAutoScrolling();







    virtual bool SendAutoScrollEvents(wxScrollWinEvent& event) const;


    void HandleOnScroll(wxScrollWinEvent& event);
    void HandleOnSize(wxSizeEvent& event);
    void HandleOnPaint(wxPaintEvent& event);
    void HandleOnChar(wxKeyEvent& event);
    void HandleOnMouseEnter(wxMouseEvent& event);
    void HandleOnMouseLeave(wxMouseEvent& event);

    void HandleOnMouseWheel(wxMouseEvent& event);



    void HandleOnChildFocus(wxChildFocusEvent& event);




    void OnScroll(wxScrollWinEvent& event) { HandleOnScroll(event); }

protected:

    const wxRect *GetScrollRect() const
    {
        return m_rectToScroll.width != 0 ? &m_rectToScroll : __null;
    }


    wxSize GetTargetSize() const
    {
        return m_rectToScroll.width != 0 ? m_rectToScroll.GetSize()
                                         : m_targetWindow->GetClientSize();
    }

    void GetTargetSize(int *w, int *h) const
    {
        wxSize size = GetTargetSize();
        if ( w )
            *w = size.x;
        if ( h )
            *h = size.y;
    }



    bool ScrollLayout();
    void ScrollDoSetVirtualSize(int x, int y);
    wxSize ScrollGetBestVirtualSize() const;
    wxSize ScrollGetWindowSizeForVirtualSize(const wxSize& size) const;



    void DoSetTargetWindow(wxWindow *target);


    void DeleteEvtHandler();


    double m_scaleX;
    double m_scaleY;

    wxWindow *m_win,
                         *m_targetWindow;

    wxRect m_rectToScroll;

    wxTimer *m_timerAutoScroll;

    int m_xScrollPixelsPerLine;
    int m_yScrollPixelsPerLine;
    int m_xScrollPosition;
    int m_yScrollPosition;
    int m_xScrollLines;
    int m_yScrollLines;
    int m_xScrollLinesPerPage;
    int m_yScrollLinesPerPage;

    bool m_xScrollingEnabled;
    bool m_yScrollingEnabled;


    int m_wheelRotation;


    wxScrollHelperEvtHandler *m_handler;

    private: wxScrollHelper(const wxScrollHelper&); wxScrollHelper& operator=(const wxScrollHelper&);
};
# 259 "/usr/include/wx-2.8/wx/scrolwin.h"
# 1 "/usr/include/wx-2.8/wx/gtk/scrolwin.h" 1
# 19 "/usr/include/wx-2.8/wx/gtk/scrolwin.h"
class wxScrollHelperNative : public wxScrollHelper
{
public:

    wxScrollHelperNative(wxWindow *win) : wxScrollHelper(win) { }

    virtual void SetScrollbars(int pixelsPerUnitX, int pixelsPerUnitY,
                               int noUnitsX, int noUnitsY,
                               int xPos = 0, int yPos = 0,
                               bool noRefresh = false);
    virtual void AdjustScrollbars();
    virtual void Scroll(int x, int y);

protected:

    void DoAdjustScrollbar(GtkRange* range,
                           int pixelsPerLine,
                           int winSize,
                           int virtSize,
                           int *pos,
                           int *lines,
                           int *linesPerPage);

    void DoAdjustHScrollbar(int winSize, int virtSize)
    {
        DoAdjustScrollbar
        (
            m_win->m_scrollBar[wxWindow::ScrollDir_Horz],
            m_xScrollPixelsPerLine, winSize, virtSize,
            &m_xScrollPosition, &m_xScrollLines, &m_xScrollLinesPerPage
        );
    }

    void DoAdjustVScrollbar(int winSize, int virtSize)
    {
        DoAdjustScrollbar
        (
            m_win->m_scrollBar[wxWindow::ScrollDir_Vert],
            m_yScrollPixelsPerLine, winSize, virtSize,
            &m_yScrollPosition, &m_yScrollLines, &m_yScrollLinesPerPage
        );
    }


    void DoScroll(int orient,
                  int pos,
                  int pixelsPerLine,
                  int *posOld);

private:
    private: wxScrollHelperNative(const wxScrollHelperNative&); wxScrollHelperNative& operator=(const wxScrollHelperNative&);
};
# 260 "/usr/include/wx-2.8/wx/scrolwin.h" 2
# 270 "/usr/include/wx-2.8/wx/scrolwin.h"
class wxScrolledWindow : public wxPanel,
                                     public wxScrollHelperNative
{
public:
    wxScrolledWindow() : wxScrollHelperNative(this) { }
    wxScrolledWindow(wxWindow *parent,
                     wxWindowID winid = wxID_ANY,
                     const wxPoint& pos = wxDefaultPosition,
                     const wxSize& size = wxDefaultSize,
                     long style = (0x40000000 | 0x80000000),
                     const wxString& name = wxPanelNameStr)
        : wxScrollHelperNative(this)
    {
        Create(parent, winid, pos, size, style, name);
    }

    virtual ~wxScrolledWindow();

    bool Create(wxWindow *parent,
                wxWindowID winid,
                const wxPoint& pos = wxDefaultPosition,
                const wxSize& size = wxDefaultSize,
                long style = (0x40000000 | 0x80000000),
                const wxString& name = wxPanelNameStr);







    public: virtual void PrepareDC(wxDC& dc) { DoPrepareDC(dc); } virtual bool Layout() { return ScrollLayout(); } virtual void DoSetVirtualSize(int x, int y) { ScrollDoSetVirtualSize(x, y); } virtual wxSize GetBestVirtualSize() const { return ScrollGetBestVirtualSize(); } protected: virtual wxSize GetWindowSizeForVirtualSize(const wxSize& size) const { return ScrollGetWindowSizeForVirtualSize(size); }

protected:


    void OnPaint(wxPaintEvent& event);

private:
    private: wxScrolledWindow(const wxScrolledWindow&); wxScrolledWindow& operator=(const wxScrolledWindow&); public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
    private: static const wxEventTableEntry sm_eventTableEntries[]; protected: static const wxEventTable sm_eventTable; virtual const wxEventTable* GetEventTable() const; static wxEventHashTable sm_eventHashTable; virtual wxEventHashTable& GetEventHashTable() const;
};
# 85 "/usr/include/wx-2.8/wx/wx.h" 2
# 1 "/usr/include/wx-2.8/wx/dirdlg.h" 1
# 23 "/usr/include/wx-2.8/wx/dirdlg.h"
extern const wxChar wxDirDialogNameStr[];
extern const wxChar wxDirDialogDefaultFolderStr[];
extern const wxChar wxDirSelectorPromptStr[];
# 43 "/usr/include/wx-2.8/wx/dirdlg.h"
class wxDirDialogBase : public wxDialog
{
public:
    wxDirDialogBase() {}
    wxDirDialogBase(wxWindow *parent,
                    const wxString& title = wxDirSelectorPromptStr,
                    const wxString& defaultPath = wxEmptyString,
                    long style = ((0x20000000 | 0x0800 | 0x1000)|0x0040),
                    const wxPoint& pos = wxDefaultPosition,
                    const wxSize& sz = wxDefaultSize,
                    const wxString& name = wxDirDialogNameStr)
    {
        Create(parent, title, defaultPath, style, pos, sz, name);
    }

    virtual ~wxDirDialogBase() {}


    bool Create(wxWindow *parent,
                const wxString& title = wxDirSelectorPromptStr,
                const wxString& defaultPath = wxEmptyString,
                long style = ((0x20000000 | 0x0800 | 0x1000)|0x0040),
                const wxPoint& pos = wxDefaultPosition,
                const wxSize& sz = wxDefaultSize,
                const wxString& name = wxDirDialogNameStr)
    {
        if (!wxDialog::Create(parent, wxID_ANY, title, pos, sz, style, name))
            return false;
        m_path = defaultPath;
        m_message = title;
        return true;
    }



    long GetStyle() const __attribute__ ((deprecated));
    void SetStyle(long style) __attribute__ ((deprecated));



    virtual void SetMessage(const wxString& message) { m_message = message; }
    virtual void SetPath(const wxString& path) { m_path = path; }

    virtual wxString GetMessage() const { return m_message; }
    virtual wxString GetPath() const { return m_path; }

protected:
    wxString m_message;
    wxString m_path;
};
# 110 "/usr/include/wx-2.8/wx/dirdlg.h"
# 1 "/usr/include/wx-2.8/wx/gtk/dirdlg.h" 1
# 13 "/usr/include/wx-2.8/wx/gtk/dirdlg.h"
# 1 "/usr/include/wx-2.8/wx/generic/dirdlgg.h" 1
# 18 "/usr/include/wx-2.8/wx/generic/dirdlgg.h"
class wxGenericDirCtrl;
class wxTextCtrl;
class wxTreeEvent;


extern const wxChar wxDirDialogNameStr[];
extern const wxChar wxDirSelectorPromptStr[];
# 40 "/usr/include/wx-2.8/wx/generic/dirdlgg.h"
class wxGenericDirDialog : public wxDirDialogBase
{
public:
    wxGenericDirDialog() : wxDirDialogBase() { }

    wxGenericDirDialog(wxWindow* parent,
                       const wxString& title = wxDirSelectorPromptStr,
                       const wxString& defaultPath = wxEmptyString,
                       long style = ((0x20000000 | 0x0800 | 0x1000)|0x0040),
                       const wxPoint& pos = wxDefaultPosition,
                       const wxSize& sz = wxDefaultSize,
                       const wxString& name = wxDirDialogNameStr);

    bool Create(wxWindow* parent,
                const wxString& title = wxDirSelectorPromptStr,
                const wxString& defaultPath = wxEmptyString,
                long style = ((0x20000000 | 0x0800 | 0x1000)|0x0040),
                const wxPoint& pos = wxDefaultPosition,
                const wxSize& sz = wxDefaultSize,
                       const wxString& name = wxDirDialogNameStr);


    void SetPath(const wxString& path);
    wxString GetPath() const;


    virtual int ShowModal();
    virtual void EndModal(int retCode);


    wxTextCtrl* GetInputCtrl() const { return m_input; }

protected:

    void OnCloseWindow(wxCloseEvent& event);
    void OnOK(wxCommandEvent& event);
    void OnTreeSelected(wxTreeEvent &event);
    void OnTreeKeyDown(wxTreeEvent &event);
    void OnNew(wxCommandEvent& event);
    void OnGoHome(wxCommandEvent& event);
    void OnShowHidden(wxCommandEvent& event);

    wxGenericDirCtrl* m_dirCtrl;
    wxTextCtrl* m_input;

    private: static const wxEventTableEntry sm_eventTableEntries[]; protected: static const wxEventTable sm_eventTable; virtual const wxEventTable* GetEventTable() const; static wxEventHashTable sm_eventHashTable; virtual wxEventHashTable& GetEventHashTable() const;
    public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};
# 14 "/usr/include/wx-2.8/wx/gtk/dirdlg.h" 2





class wxDirDialog : public wxGenericDirDialog
{
public:
    wxDirDialog() { }

    wxDirDialog(wxWindow *parent,
                const wxString& message = wxDirSelectorPromptStr,
                const wxString& defaultPath = wxEmptyString,
                long style = ((0x20000000 | 0x0800 | 0x1000)|0x0040),
                const wxPoint& pos = wxDefaultPosition,
                const wxSize& size = wxDefaultSize,
                const wxString& name = wxDirDialogNameStr);

    virtual ~wxDirDialog() { }


public:

    wxString GetPath() const;
    void SetPath(const wxString& path);

    virtual int ShowModal();
    virtual bool Show( bool show = true );


protected:


    virtual void DoSetSize(int x, int y,
                           int width, int height,
                           int sizeFlags = (0x0001|0x0002));


private:
    public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
    private: static const wxEventTableEntry sm_eventTableEntries[]; protected: static const wxEventTable sm_eventTable; virtual const wxEventTable* GetEventTable() const; static wxEventHashTable sm_eventHashTable; virtual wxEventHashTable& GetEventHashTable() const;
    void OnFakeOk( wxCommandEvent &event );
};
# 111 "/usr/include/wx-2.8/wx/dirdlg.h" 2
# 131 "/usr/include/wx-2.8/wx/dirdlg.h"
 wxString
wxDirSelector(const wxString& message = wxDirSelectorPromptStr,
              const wxString& defaultPath = wxEmptyString,
              long style = ((0x20000000 | 0x0800 | 0x1000)|0x0040),
              const wxPoint& pos = wxDefaultPosition,
              wxWindow *parent = __null);
# 86 "/usr/include/wx-2.8/wx/wx.h" 2
# 1 "/usr/include/wx-2.8/wx/toolbar.h" 1
# 21 "/usr/include/wx-2.8/wx/toolbar.h"
enum
{

    wxTB_HORIZONTAL = wxHORIZONTAL,
    wxTB_TOP = wxTB_HORIZONTAL,


    wxTB_VERTICAL = wxVERTICAL,
    wxTB_LEFT = wxTB_VERTICAL,


    wxTB_3DBUTTONS = 0x0010,


    wxTB_FLAT = 0x0020,


    wxTB_DOCKABLE = 0x0040,


    wxTB_NOICONS = 0x0080,


    wxTB_TEXT = 0x0100,


    wxTB_NODIVIDER = 0x0200,


    wxTB_NOALIGN = 0x0400,


    wxTB_HORZ_LAYOUT = 0x0800,
    wxTB_HORZ_TEXT = wxTB_HORZ_LAYOUT | wxTB_TEXT,


    wxTB_NO_TOOLTIPS = 0x1000,


    wxTB_BOTTOM = 0x2000,


    wxTB_RIGHT = 0x4000
};


# 1 "/usr/include/wx-2.8/wx/tbarbase.h" 1
# 27 "/usr/include/wx-2.8/wx/tbarbase.h"
class wxToolBarBase;
class wxToolBarToolBase;
class wxImage;





extern const wxChar wxToolBarNameStr[];
extern const wxSize wxDefaultSize;
extern const wxPoint wxDefaultPosition;

enum wxToolBarToolStyle
{
    wxTOOL_STYLE_BUTTON = 1,
    wxTOOL_STYLE_SEPARATOR = 2,
    wxTOOL_STYLE_CONTROL
};
# 57 "/usr/include/wx-2.8/wx/tbarbase.h"
class wxToolBarToolBase : public wxObject
{
public:



    wxToolBarToolBase(wxToolBarBase *tbar = (wxToolBarBase *)__null,
                      int toolid = wxID_SEPARATOR,
                      const wxString& label = wxEmptyString,
                      const wxBitmap& bmpNormal = wxNullBitmap,
                      const wxBitmap& bmpDisabled = wxNullBitmap,
                      wxItemKind kind = wxITEM_NORMAL,
                      wxObject *clientData = (wxObject *) __null,
                      const wxString& shortHelpString = wxEmptyString,
                      const wxString& longHelpString = wxEmptyString)
        : m_label(label),
          m_shortHelpString(shortHelpString),
          m_longHelpString(longHelpString)
    {
        m_tbar = tbar;
        m_id = toolid;
        if (m_id == wxID_ANY)
            m_id = wxNewId();
        m_clientData = clientData;

        m_bmpNormal = bmpNormal;
        m_bmpDisabled = bmpDisabled;

        m_kind = kind;

        m_enabled = true;
        m_toggled = false;

        m_toolStyle = toolid == wxID_SEPARATOR ? wxTOOL_STYLE_SEPARATOR
                                           : wxTOOL_STYLE_BUTTON;
    }

    wxToolBarToolBase(wxToolBarBase *tbar, wxControl *control)
    {
        m_tbar = tbar;
        m_control = control;
        m_id = control->GetId();

        m_kind = wxITEM_MAX;

        m_enabled = true;
        m_toggled = false;

        m_toolStyle = wxTOOL_STYLE_CONTROL;
    }

    virtual ~wxToolBarToolBase(){}





    int GetId() const { return m_id; }

    wxControl *GetControl() const
    {
        ;

        return m_control;
    }

    wxToolBarBase *GetToolBar() const { return m_tbar; }


    bool IsButton() const { return m_toolStyle == wxTOOL_STYLE_BUTTON; }
    bool IsControl() const { return m_toolStyle == wxTOOL_STYLE_CONTROL; }
    bool IsSeparator() const { return m_toolStyle == wxTOOL_STYLE_SEPARATOR; }
    int GetStyle() const { return m_toolStyle; }
    wxItemKind GetKind() const
    {
        ;

        return m_kind;
    }


    bool IsEnabled() const { return m_enabled; }
    bool IsToggled() const { return m_toggled; }
    bool CanBeToggled() const
        { return m_kind == wxITEM_CHECK || m_kind == wxITEM_RADIO; }


    const wxBitmap& GetNormalBitmap() const { return m_bmpNormal; }
    const wxBitmap& GetDisabledBitmap() const { return m_bmpDisabled; }

    const wxBitmap& GetBitmap() const
        { return IsEnabled() ? GetNormalBitmap() : GetDisabledBitmap(); }

    const wxString& GetLabel() const { return m_label; }

    const wxString& GetShortHelp() const { return m_shortHelpString; }
    const wxString& GetLongHelp() const { return m_longHelpString; }

    wxObject *GetClientData() const
    {
        if ( m_toolStyle == wxTOOL_STYLE_CONTROL )
        {
            return (wxObject*)m_control->GetClientData();
        }
        else
        {
            return m_clientData;
        }
    }


    bool Enable(bool enable);
    bool Toggle(bool toggle);
    bool SetToggle(bool toggle);
    bool SetShortHelp(const wxString& help);
    bool SetLongHelp(const wxString& help);

    void Toggle() { Toggle(!IsToggled()); }

    void SetNormalBitmap(const wxBitmap& bmp) { m_bmpNormal = bmp; }
    void SetDisabledBitmap(const wxBitmap& bmp) { m_bmpDisabled = bmp; }

    virtual void SetLabel(const wxString& label) { m_label = label; }

    void SetClientData(wxObject *clientData)
    {
        if ( m_toolStyle == wxTOOL_STYLE_CONTROL )
        {
            m_control->SetClientData(clientData);
        }
        else
        {
            m_clientData = clientData;
        }
    }


    virtual void Detach() { m_tbar = (wxToolBarBase *)__null; }
    virtual void Attach(wxToolBarBase *tbar) { m_tbar = tbar; }

protected:
    wxToolBarBase *m_tbar;


    int m_toolStyle;
    int m_id;
    wxItemKind m_kind;


    union
    {
        wxObject *m_clientData;
        wxControl *m_control;
    };


    bool m_toggled;
    bool m_enabled;


    wxBitmap m_bmpNormal;
    wxBitmap m_bmpDisabled;


    wxString m_label;


    wxString m_shortHelpString;
    wxString m_longHelpString;

    private: wxToolBarToolBase(const wxToolBarToolBase&); wxToolBarToolBase& operator=(const wxToolBarToolBase&); public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};


typedef wxToolBarToolBase _WX_LIST_ITEM_TYPE_wxToolBarToolsList; typedef int (*wxSortFuncFor_wxToolBarToolsList)(const wxToolBarToolBase **, const wxToolBarToolBase **); class wxwxToolBarToolsListNode : public wxNodeBase { public: wxwxToolBarToolsListNode(wxListBase *list = (wxListBase *)__null, wxwxToolBarToolsListNode *previous = (wxwxToolBarToolsListNode *)__null, wxwxToolBarToolsListNode *next = (wxwxToolBarToolsListNode *)__null, wxToolBarToolBase *data = (wxToolBarToolBase *)__null, const wxListKey& key = wxDefaultListKey) : wxNodeBase(list, previous, next, data, key) { } wxwxToolBarToolsListNode *GetNext() const { return (wxwxToolBarToolsListNode *)wxNodeBase::GetNext(); } wxwxToolBarToolsListNode *GetPrevious() const { return (wxwxToolBarToolsListNode *)wxNodeBase::GetPrevious(); } wxToolBarToolBase *GetData() const { return (wxToolBarToolBase *)wxNodeBase::GetData(); } void SetData(wxToolBarToolBase *data) { wxNodeBase::SetData(data); } protected: virtual void DeleteData(); private: wxwxToolBarToolsListNode(const wxwxToolBarToolsListNode&); wxwxToolBarToolsListNode& operator=(const wxwxToolBarToolsListNode&); }; class wxToolBarToolsList : public wxListBase { public: typedef wxwxToolBarToolsListNode Node; class compatibility_iterator { public: compatibility_iterator(Node *ptr = __null) : m_ptr(ptr) { } Node *operator->() const { return m_ptr; } operator Node *() const { return m_ptr; } private: Node *m_ptr; }; wxToolBarToolsList(wxKeyType keyType = wxKEY_NONE) : wxListBase(keyType) { } wxToolBarToolsList(const wxToolBarToolsList& list) : wxListBase(list.GetKeyType()) { Assign(list); } wxToolBarToolsList(size_t count, wxToolBarToolBase *elements[]) : wxListBase(count, (void **)elements) { } wxToolBarToolsList& operator=(const wxToolBarToolsList& list) { Assign(list); return *this; } wxwxToolBarToolsListNode *GetFirst() const { return (wxwxToolBarToolsListNode *)wxListBase::GetFirst(); } wxwxToolBarToolsListNode *GetLast() const { return (wxwxToolBarToolsListNode *)wxListBase::GetLast(); } wxwxToolBarToolsListNode *Item(size_t index) const { return (wxwxToolBarToolsListNode *)wxListBase::Item(index); } wxToolBarToolBase *operator[](size_t index) const { wxwxToolBarToolsListNode *node = Item(index); return node ? (wxToolBarToolBase*)(node->GetData()) : (wxToolBarToolBase*)__null; } wxwxToolBarToolsListNode *Append(wxToolBarToolBase *object) { return (wxwxToolBarToolsListNode *)wxListBase::Append(object); } wxwxToolBarToolsListNode *Insert(wxToolBarToolBase *object) { return (wxwxToolBarToolsListNode *)Insert((wxwxToolBarToolsListNode*)__null, object); } wxwxToolBarToolsListNode *Insert(size_t pos, wxToolBarToolBase *object) { return (wxwxToolBarToolsListNode *)wxListBase::Insert(pos, object); } wxwxToolBarToolsListNode *Insert(wxwxToolBarToolsListNode *prev, wxToolBarToolBase *object) { return (wxwxToolBarToolsListNode *)wxListBase::Insert(prev, object); } wxwxToolBarToolsListNode *Append(long key, void *object) { return (wxwxToolBarToolsListNode *)wxListBase::Append(key, object); } wxwxToolBarToolsListNode *Append(const wxChar *key, void *object) { return (wxwxToolBarToolsListNode *)wxListBase::Append(key, object); } wxwxToolBarToolsListNode *DetachNode(wxwxToolBarToolsListNode *node) { return (wxwxToolBarToolsListNode *)wxListBase::DetachNode(node); } bool DeleteNode(wxwxToolBarToolsListNode *node) { return wxListBase::DeleteNode(node); } bool DeleteObject(wxToolBarToolBase *object) { return wxListBase::DeleteObject(object); } void Erase(wxwxToolBarToolsListNode *it) { DeleteNode(it); } wxwxToolBarToolsListNode *Find(const wxToolBarToolBase *object) const { return (wxwxToolBarToolsListNode *)wxListBase::Find(object); } virtual wxwxToolBarToolsListNode *Find(const wxListKey& key) const { return (wxwxToolBarToolsListNode *)wxListBase::Find(key); } int IndexOf(wxToolBarToolBase *object) const { return wxListBase::IndexOf(object); } void Sort(wxSortCompareFunction func) { wxListBase::Sort(func); } void Sort(wxSortFuncFor_wxToolBarToolsList func) { Sort((wxSortCompareFunction)func); } protected: virtual wxNodeBase *CreateNode(wxNodeBase *prev, wxNodeBase *next, void *data, const wxListKey& key = wxDefaultListKey) { return new wxwxToolBarToolsListNode(this, (wxwxToolBarToolsListNode *)prev, (wxwxToolBarToolsListNode *)next, (wxToolBarToolBase *)data, key); } public: typedef size_t size_type; typedef int difference_type; typedef wxToolBarToolBase* value_type; typedef wxToolBarToolBase* base_value_type; typedef value_type& reference; typedef const value_type& const_reference; typedef base_value_type& base_reference; typedef const base_value_type& const_base_reference; class iterator { typedef wxToolBarToolsList list; public: typedef wxwxToolBarToolsListNode Node; typedef iterator itor; typedef wxToolBarToolBase* value_type; typedef value_type* ptr_type; typedef value_type& reference; Node* m_node; Node* m_init; public: typedef reference reference_type; typedef ptr_type pointer_type; iterator(Node* node, Node* init) : m_node(node), m_init(init) {} iterator() : m_node(__null), m_init(__null) { } reference_type operator*() const { return *(pointer_type)m_node->GetDataPtr(); } itor& operator++() { m_node = m_node->GetNext(); return *this; } const itor operator++(int) { itor tmp = *this; m_node = m_node->GetNext(); return tmp; } itor& operator--() { m_node = m_node ? m_node->GetPrevious() : m_init; return *this; } const itor operator--(int) { itor tmp = *this; m_node = m_node ? m_node->GetPrevious() : m_init; return tmp; } bool operator!=(const itor& it) const { return it.m_node != m_node; } bool operator==(const itor& it) const { return it.m_node == m_node; } }; class const_iterator { typedef wxToolBarToolsList list; public: typedef wxwxToolBarToolsListNode Node; typedef wxToolBarToolBase* value_type; typedef const value_type& const_reference; typedef const_iterator itor; typedef value_type* ptr_type; Node* m_node; Node* m_init; public: typedef const_reference reference_type; typedef const ptr_type pointer_type; const_iterator(Node* node, Node* init) : m_node(node), m_init(init) { } const_iterator() : m_node(__null), m_init(__null) { } const_iterator(const iterator& it) : m_node(it.m_node), m_init(it.m_init) { } reference_type operator*() const { return *(pointer_type)m_node->GetDataPtr(); } itor& operator++() { m_node = m_node->GetNext(); return *this; } const itor operator++(int) { itor tmp = *this; m_node = m_node->GetNext(); return tmp; } itor& operator--() { m_node = m_node ? m_node->GetPrevious() : m_init; return *this; } const itor operator--(int) { itor tmp = *this; m_node = m_node ? m_node->GetPrevious() : m_init; return tmp; } bool operator!=(const itor& it) const { return it.m_node != m_node; } bool operator==(const itor& it) const { return it.m_node == m_node; } }; class reverse_iterator { typedef wxToolBarToolsList list; public: typedef wxwxToolBarToolsListNode Node; typedef wxToolBarToolBase* value_type; typedef reverse_iterator itor; typedef value_type* ptr_type; typedef value_type& reference; Node* m_node; Node* m_init; public: typedef reference reference_type; typedef ptr_type pointer_type; reverse_iterator(Node* node, Node* init) : m_node(node), m_init(init) { } reverse_iterator() : m_node(__null), m_init(__null) { } reference_type operator*() const { return *(pointer_type)m_node->GetDataPtr(); } itor& operator++() { m_node = m_node->GetPrevious(); return *this; } const itor operator++(int) { itor tmp = *this; m_node = m_node->GetPrevious(); return tmp; } itor& operator--() { m_node = m_node ? m_node->GetNext() : m_init; return *this; } const itor operator--(int) { itor tmp = *this; m_node = m_node ? m_node->GetNext() : m_init; return tmp; } bool operator!=(const itor& it) const { return it.m_node != m_node; } bool operator==(const itor& it) const { return it.m_node == m_node; } }; class const_reverse_iterator { typedef wxToolBarToolsList list; public: typedef wxwxToolBarToolsListNode Node; typedef wxToolBarToolBase* value_type; typedef const_reverse_iterator itor; typedef value_type* ptr_type; typedef const value_type& const_reference; Node* m_node; Node* m_init; public: typedef const_reference reference_type; typedef const ptr_type pointer_type; const_reverse_iterator(Node* node, Node* init) : m_node(node), m_init(init) { } const_reverse_iterator() : m_node(__null), m_init(__null) { } const_reverse_iterator(const reverse_iterator& it) : m_node(it.m_node), m_init(it.m_init) { } reference_type operator*() const { return *(pointer_type)m_node->GetDataPtr(); } itor& operator++() { m_node = m_node->GetPrevious(); return *this; } const itor operator++(int) { itor tmp = *this; m_node = m_node->GetPrevious(); return tmp; } itor& operator--() { m_node = m_node ? m_node->GetNext() : m_init; return *this;} const itor operator--(int) { itor tmp = *this; m_node = m_node ? m_node->GetNext() : m_init; return tmp; } bool operator!=(const itor& it) const { return it.m_node != m_node; } bool operator==(const itor& it) const { return it.m_node == m_node; } }; explicit wxToolBarToolsList(size_type n, const_reference v = value_type()) { assign(n, v); } wxToolBarToolsList(const const_iterator& first, const const_iterator& last) { assign(first, last); } iterator begin() { return iterator(GetFirst(), GetLast()); } const_iterator begin() const { return const_iterator(GetFirst(), GetLast()); } iterator end() { return iterator(__null, GetLast()); } const_iterator end() const { return const_iterator(__null, GetLast()); } reverse_iterator rbegin() { return reverse_iterator(GetLast(), GetFirst()); } const_reverse_iterator rbegin() const { return const_reverse_iterator(GetLast(), GetFirst()); } reverse_iterator rend() { return reverse_iterator(__null, GetFirst()); } const_reverse_iterator rend() const { return const_reverse_iterator(__null, GetFirst()); } void resize(size_type n, value_type v = value_type()) { while (n < size()) pop_back(); while (n > size()) push_back(v); } size_type size() const { return GetCount(); } size_type max_size() const { return 2147483647; } bool empty() const { return IsEmpty(); } reference front() { return *begin(); } const_reference front() const { return *begin(); } reference back() { iterator tmp = end(); return *--tmp; } const_reference back() const { const_iterator tmp = end(); return *--tmp; } void push_front(const_reference v = value_type()) { Insert(GetFirst(), (const_base_reference)v); } void pop_front() { DeleteNode(GetFirst()); } void push_back(const_reference v = value_type()) { Append((const_base_reference)v); } void pop_back() { DeleteNode(GetLast()); } void assign(const_iterator first, const const_iterator& last) { clear(); for(; first != last; ++first) Append((const_base_reference)*first); } void assign(size_type n, const_reference v = value_type()) { clear(); for(size_type i = 0; i < n; ++i) Append((const_base_reference)v); } iterator insert(const iterator& it, const_reference v = value_type()) { if ( it == end() ) Append((const_base_reference)v); else Insert(it.m_node, (const_base_reference)v); iterator itprev(it); return itprev--; } void insert(const iterator& it, size_type n, const_reference v = value_type()) { for(size_type i = 0; i < n; ++i) insert(it, v); } void insert(const iterator& it, const_iterator first, const const_iterator& last) { for(; first != last; ++first) insert(it, *first); } iterator erase(const iterator& it) { iterator next = iterator(it.m_node->GetNext(), GetLast()); DeleteNode(it.m_node); return next; } iterator erase(const iterator& first, const iterator& last) { iterator next = last; if ( next != end() ) ++next; DeleteNodes(first.m_node, last.m_node); return next; } void clear() { Clear(); } void splice(const iterator& it, wxToolBarToolsList& l, const iterator& first, const iterator& last) { insert(it, first, last); l.erase(first, last); } void splice(const iterator& it, wxToolBarToolsList& l) { splice(it, l, l.begin(), l.end() ); } void splice(const iterator& it, wxToolBarToolsList& l, const iterator& first) { if ( it != first ) { insert(it, *first); l.erase(first); } } void remove(const_reference v) { DeleteObject((const_base_reference)v); } void reverse() { Reverse(); } };





class wxToolBarBase : public wxControl
{
public:
    wxToolBarBase();
    virtual ~wxToolBarBase();
# 250 "/usr/include/wx-2.8/wx/tbarbase.h"
    wxToolBarToolBase *AddTool(int toolid,
                               const wxString& label,
                               const wxBitmap& bitmap,
                               const wxBitmap& bmpDisabled,
                               wxItemKind kind = wxITEM_NORMAL,
                               const wxString& shortHelp = wxEmptyString,
                               const wxString& longHelp = wxEmptyString,
                               wxObject *data = __null)
    {
        return DoAddTool(toolid, label, bitmap, bmpDisabled, kind,
                         shortHelp, longHelp, data);
    }


    wxToolBarToolBase *AddTool(int toolid,
                               const wxString& label,
                               const wxBitmap& bitmap,
                               const wxString& shortHelp = wxEmptyString,
                               wxItemKind kind = wxITEM_NORMAL)
    {
        return AddTool(toolid, label, bitmap, wxNullBitmap, kind, shortHelp);
    }


    wxToolBarToolBase *AddCheckTool(int toolid,
                                    const wxString& label,
                                    const wxBitmap& bitmap,
                                    const wxBitmap& bmpDisabled = wxNullBitmap,
                                    const wxString& shortHelp = wxEmptyString,
                                    const wxString& longHelp = wxEmptyString,
                                    wxObject *data = __null)
    {
        return AddTool(toolid, label, bitmap, bmpDisabled, wxITEM_CHECK,
                       shortHelp, longHelp, data);
    }



    wxToolBarToolBase *AddRadioTool(int toolid,
                                    const wxString& label,
                                    const wxBitmap& bitmap,
                                    const wxBitmap& bmpDisabled = wxNullBitmap,
                                    const wxString& shortHelp = wxEmptyString,
                                    const wxString& longHelp = wxEmptyString,
                                    wxObject *data = __null)
    {
        return AddTool(toolid, label, bitmap, bmpDisabled, wxITEM_RADIO,
                       shortHelp, longHelp, data);
    }




    virtual wxToolBarToolBase *InsertTool
                               (
                                    size_t pos,
                                    int toolid,
                                    const wxString& label,
                                    const wxBitmap& bitmap,
                                    const wxBitmap& bmpDisabled = wxNullBitmap,
                                    wxItemKind kind = wxITEM_NORMAL,
                                    const wxString& shortHelp = wxEmptyString,
                                    const wxString& longHelp = wxEmptyString,
                                    wxObject *clientData = __null
                               );

    virtual wxToolBarToolBase *AddTool (wxToolBarToolBase *tool);
    virtual wxToolBarToolBase *InsertTool (size_t pos, wxToolBarToolBase *tool);






    virtual wxToolBarToolBase *AddControl(wxControl *control);
    virtual wxToolBarToolBase *InsertControl(size_t pos, wxControl *control);


    virtual wxControl *FindControl( int toolid );


    virtual wxToolBarToolBase *AddSeparator();
    virtual wxToolBarToolBase *InsertSeparator(size_t pos);



    virtual wxToolBarToolBase *RemoveTool(int toolid);


    virtual bool DeleteToolByPos(size_t pos);
    virtual bool DeleteTool(int toolid);


    virtual void ClearTools();



    virtual bool Realize();




    virtual void EnableTool(int toolid, bool enable);
    virtual void ToggleTool(int toolid, bool toggle);


    virtual void SetToggle(int toolid, bool toggle);


    virtual wxObject *GetToolClientData(int toolid) const;
    virtual void SetToolClientData(int toolid, wxObject *clientData);


    virtual int GetToolPos(int id) const;


    virtual bool GetToolState(int toolid) const;

    virtual bool GetToolEnabled(int toolid) const;

    virtual void SetToolShortHelp(int toolid, const wxString& helpString);
    virtual wxString GetToolShortHelp(int toolid) const;
    virtual void SetToolLongHelp(int toolid, const wxString& helpString);
    virtual wxString GetToolLongHelp(int toolid) const;




    virtual void SetMargins(int x, int y);
    void SetMargins(const wxSize& size)
        { SetMargins((int) size.x, (int) size.y); }
    virtual void SetToolPacking(int packing)
        { m_toolPacking = packing; }
    virtual void SetToolSeparation(int separation)
        { m_toolSeparation = separation; }

    virtual wxSize GetToolMargins() const { return wxSize(m_xMargin, m_yMargin); }
    virtual int GetToolPacking() const { return m_toolPacking; }
    virtual int GetToolSeparation() const { return m_toolSeparation; }





    virtual void SetRows(int nRows);


    void SetMaxRowsCols(int rows, int cols)
        { m_maxRows = rows; m_maxCols = cols; }
    int GetMaxRows() const { return m_maxRows; }
    int GetMaxCols() const { return m_maxCols; }



    virtual void SetToolBitmapSize(const wxSize& size)
        { m_defaultWidth = size.x; m_defaultHeight = size.y; }
    virtual wxSize GetToolBitmapSize() const
        { return wxSize(m_defaultWidth, m_defaultHeight); }



    virtual wxSize GetToolSize() const
        { return GetToolBitmapSize(); }



    virtual wxToolBarToolBase *FindToolForPosition(wxCoord x,
                                                   wxCoord y) const = 0;


    wxToolBarToolBase *FindById(int toolid) const;


    bool IsVertical() const { return HasFlag(wxTB_LEFT | wxTB_RIGHT); }






    wxToolBarToolBase *AddTool(int toolid,
                               const wxBitmap& bitmap,
                               const wxBitmap& bmpDisabled,
                               bool toggle = false,
                               wxObject *clientData = __null,
                               const wxString& shortHelpString = wxEmptyString,
                               const wxString& longHelpString = wxEmptyString)
    {
        return AddTool(toolid, wxEmptyString,
                       bitmap, bmpDisabled,
                       toggle ? wxITEM_CHECK : wxITEM_NORMAL,
                       shortHelpString, longHelpString, clientData);
    }

    wxToolBarToolBase *AddTool(int toolid,
                               const wxBitmap& bitmap,
                               const wxString& shortHelpString = wxEmptyString,
                               const wxString& longHelpString = wxEmptyString)
    {
        return AddTool(toolid, wxEmptyString,
                       bitmap, wxNullBitmap, wxITEM_NORMAL,
                       shortHelpString, longHelpString, __null);
    }

    wxToolBarToolBase *AddTool(int toolid,
                               const wxBitmap& bitmap,
                               const wxBitmap& bmpDisabled,
                               bool toggle,
                               wxCoord xPos,
                               wxCoord yPos = wxDefaultCoord,
                               wxObject *clientData = __null,
                               const wxString& shortHelp = wxEmptyString,
                               const wxString& longHelp = wxEmptyString)
    {
        return DoAddTool(toolid, wxEmptyString, bitmap, bmpDisabled,
                         toggle ? wxITEM_CHECK : wxITEM_NORMAL,
                         shortHelp, longHelp, clientData, xPos, yPos);
    }

    wxToolBarToolBase *InsertTool(size_t pos,
                                  int toolid,
                                  const wxBitmap& bitmap,
                                  const wxBitmap& bmpDisabled = wxNullBitmap,
                                  bool toggle = false,
                                  wxObject *clientData = __null,
                                  const wxString& shortHelp = wxEmptyString,
                                  const wxString& longHelp = wxEmptyString)
    {
        return InsertTool(pos, toolid, wxEmptyString, bitmap, bmpDisabled,
                          toggle ? wxITEM_CHECK : wxITEM_NORMAL,
                          shortHelp, longHelp, clientData);
    }







    virtual bool OnLeftClick(int toolid, bool toggleDown);


    virtual void OnRightClick(int toolid, long x, long y);



    virtual void OnMouseEnter(int toolid);





    wxSize GetMargins() const { return GetToolMargins(); }




    size_t GetToolsCount() const { return m_tools.GetCount(); }


    virtual void UpdateWindowUI(long flags = wxUPDATE_UI_NONE) ;


    virtual bool AcceptsFocus() const { return false; }

protected:





    virtual wxToolBarToolBase *DoAddTool
                               (
                                   int toolid,
                                   const wxString& label,
                                   const wxBitmap& bitmap,
                                   const wxBitmap& bmpDisabled,
                                   wxItemKind kind,
                                   const wxString& shortHelp = wxEmptyString,
                                   const wxString& longHelp = wxEmptyString,
                                   wxObject *clientData = __null,
                                   wxCoord xPos = wxDefaultCoord,
                                   wxCoord yPos = wxDefaultCoord
                               );



    virtual bool DoInsertTool(size_t pos, wxToolBarToolBase *tool) = 0;



    virtual bool DoDeleteTool(size_t pos, wxToolBarToolBase *tool) = 0;


    virtual void DoEnableTool(wxToolBarToolBase *tool, bool enable) = 0;


    virtual void DoToggleTool(wxToolBarToolBase *tool, bool toggle) = 0;


    virtual void DoSetToggle(wxToolBarToolBase *tool, bool toggle) = 0;


    virtual wxToolBarToolBase *CreateTool(int toolid,
                                          const wxString& label,
                                          const wxBitmap& bmpNormal,
                                          const wxBitmap& bmpDisabled,
                                          wxItemKind kind,
                                          wxObject *clientData,
                                          const wxString& shortHelp,
                                          const wxString& longHelp) = 0;

    virtual wxToolBarToolBase *CreateTool(wxControl *control) = 0;
# 572 "/usr/include/wx-2.8/wx/tbarbase.h"
    void FixupStyle();


    void UnToggleRadioGroup(wxToolBarToolBase *tool);


    wxToolBarToolsList m_tools;


    int m_xMargin;
    int m_yMargin;


    int m_maxRows;
    int m_maxCols;


    int m_toolPacking,
        m_toolSeparation;


    wxCoord m_defaultWidth, m_defaultHeight;

private:
    private: static const wxEventTableEntry sm_eventTableEntries[]; protected: static const wxEventTable sm_eventTable; virtual const wxEventTable* GetEventTable() const; static wxEventHashTable sm_eventHashTable; virtual wxEventHashTable& GetEventHashTable() const;
    private: wxToolBarBase(const wxToolBarBase&); wxToolBarBase& operator=(const wxToolBarBase&);
};


bool wxCreateGreyedImage(const wxImage& in, wxImage& out) ;
# 68 "/usr/include/wx-2.8/wx/toolbar.h" 2
# 80 "/usr/include/wx-2.8/wx/toolbar.h"
# 1 "/usr/include/wx-2.8/wx/gtk/tbargtk.h" 1
# 19 "/usr/include/wx-2.8/wx/gtk/tbargtk.h"
class wxToolBar : public wxToolBarBase
{
public:

    wxToolBar() { Init(); }
    wxToolBar( wxWindow *parent,
               wxWindowID id,
               const wxPoint& pos = wxDefaultPosition,
               const wxSize& size = wxDefaultSize,
               long style = wxTB_HORIZONTAL,
               const wxString& name = wxToolBarNameStr )
    {
        Init();

        Create(parent, id, pos, size, style, name);
    }

    bool Create( wxWindow *parent,
                 wxWindowID id,
                 const wxPoint& pos = wxDefaultPosition,
                 const wxSize& size = wxDefaultSize,
                 long style = 0,
                 const wxString& name = wxToolBarNameStr );

    virtual ~wxToolBar();


    virtual void SetMargins(int x, int y);
    virtual void SetToolSeparation(int separation);

    virtual wxToolBarToolBase *FindToolForPosition(wxCoord x, wxCoord y) const;

    virtual void SetToolShortHelp(int id, const wxString& helpString);

    virtual void SetWindowStyleFlag( long style );



    void SetToolNormalBitmap(int id, const wxBitmap& bitmap);
    void SetToolDisabledBitmap(int id, const wxBitmap& bitmap);


    static wxVisualAttributes
    GetClassDefaultAttributes(wxWindowVariant variant = wxWINDOW_VARIANT_NORMAL);




    GtkToolbar *m_toolbar;

    bool m_blockEvent;

    void OnInternalIdle();

protected:

    void Init();


    void GtkSetStyle();

    virtual GdkWindow *GTKGetWindow(wxArrayGdkWindows& windows) const;


    virtual bool DoInsertTool(size_t pos, wxToolBarToolBase *tool);
    virtual bool DoDeleteTool(size_t pos, wxToolBarToolBase *tool);

    virtual void DoEnableTool(wxToolBarToolBase *tool, bool enable);
    virtual void DoToggleTool(wxToolBarToolBase *tool, bool toggle);
    virtual void DoSetToggle(wxToolBarToolBase *tool, bool toggle);

    virtual wxToolBarToolBase *CreateTool(int id,
                                          const wxString& label,
                                          const wxBitmap& bitmap1,
                                          const wxBitmap& bitmap2,
                                          wxItemKind kind,
                                          wxObject *clientData,
                                          const wxString& shortHelpString,
                                          const wxString& longHelpString);
    virtual wxToolBarToolBase *CreateTool(wxControl *control);

private:
    public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};
# 81 "/usr/include/wx-2.8/wx/toolbar.h" 2
# 87 "/usr/include/wx-2.8/wx/wx.h" 2
# 1 "/usr/include/wx-2.8/wx/combobox.h" 1
# 19 "/usr/include/wx-2.8/wx/combobox.h"
extern const wxChar wxComboBoxNameStr[];
# 28 "/usr/include/wx-2.8/wx/combobox.h"
class wxComboBoxBase : public wxItemContainer
{
public:

    virtual wxString GetValue() const = 0;
    virtual void SetValue(const wxString& value) = 0;

    virtual void Copy() = 0;
    virtual void Cut() = 0;
    virtual void Paste() = 0;
    virtual void SetInsertionPoint(long pos) = 0;
    virtual long GetInsertionPoint() const = 0;
    virtual wxTextPos GetLastPosition() const = 0;
    virtual void Replace(long from, long to, const wxString& value) = 0;
    virtual void SetSelection(long from, long to) = 0;
    virtual void SetEditable(bool editable) = 0;

    virtual void SetInsertionPointEnd()
        { SetInsertionPoint(GetLastPosition()); }
    virtual void Remove(long from, long to)
        { Replace(from, to, wxEmptyString); }

    virtual bool IsEditable() const = 0;

    virtual void Undo() = 0;
    virtual void Redo() = 0;
    virtual void SelectAll() = 0;

    virtual bool CanCopy() const = 0;
    virtual bool CanCut() const = 0;
    virtual bool CanPaste() const = 0;
    virtual bool CanUndo() const = 0;
    virtual bool CanRedo() const = 0;




    virtual int GetCurrentSelection() const { return GetSelection(); }



    virtual void SetSelection(int n) = 0;
};
# 83 "/usr/include/wx-2.8/wx/combobox.h"
# 1 "/usr/include/wx-2.8/wx/gtk/combobox.h" 1
# 18 "/usr/include/wx-2.8/wx/gtk/combobox.h"
class wxComboBox : public wxControl, public wxComboBoxBase
{
public:
    inline wxComboBox() {}
    inline wxComboBox(wxWindow *parent, wxWindowID id,
           const wxString& value = wxEmptyString,
           const wxPoint& pos = wxDefaultPosition,
           const wxSize& size = wxDefaultSize,
           int n = 0, const wxString choices[] = (const wxString *) __null,
           long style = 0,
           const wxValidator& validator = wxDefaultValidator,
           const wxString& name = wxComboBoxNameStr)
    {
        Create(parent, id, value, pos, size, n, choices, style, validator, name);
    }
    inline wxComboBox(wxWindow *parent, wxWindowID id,
           const wxString& value,
           const wxPoint& pos,
           const wxSize& size,
           const wxArrayString& choices,
           long style = 0,
           const wxValidator& validator = wxDefaultValidator,
           const wxString& name = wxComboBoxNameStr)
    {
        Create(parent, id, value, pos, size, choices, style, validator, name);
    }

    virtual ~wxComboBox();

    bool Create(wxWindow *parent, wxWindowID id,
           const wxString& value = wxEmptyString,
           const wxPoint& pos = wxDefaultPosition,
           const wxSize& size = wxDefaultSize,
           int n = 0, const wxString choices[] = (const wxString *) __null,
           long style = 0,
           const wxValidator& validator = wxDefaultValidator,
           const wxString& name = wxComboBoxNameStr);
    bool Create(wxWindow *parent, wxWindowID id,
           const wxString& value,
           const wxPoint& pos,
           const wxSize& size,
           const wxArrayString& choices,
           long style = 0,
           const wxValidator& validator = wxDefaultValidator,
           const wxString& name = wxComboBoxNameStr);


    virtual unsigned int GetCount() const;
    virtual wxString GetString(unsigned int n) const;
    virtual void SetString(unsigned int n, const wxString &text);
    virtual int FindString(const wxString& s, bool bCase = false) const;
    virtual void SetSelection(int n);
    virtual int GetSelection() const;
    wxString GetStringSelection() const;


    virtual void Clear();
    virtual void Delete(unsigned int n);


    virtual wxString GetValue() const;
    virtual void SetValue(const wxString& value);
    virtual void Copy();
    virtual void Cut();
    virtual void Paste();
    virtual void SetInsertionPoint( long pos );
    virtual long GetInsertionPoint() const;
    virtual wxTextPos GetLastPosition() const;
    virtual void Replace( long from, long to, const wxString& value );
    virtual void SetSelection( long from, long to );
    virtual void SetEditable( bool editable );
    virtual void SetInsertionPointEnd() { SetInsertionPoint( -1 ); }
    virtual void Remove(long from, long to) { Replace(from, to, wxEmptyString); }
    virtual bool IsEditable() const;
    virtual void Undo();
    virtual void Redo();
    virtual void SelectAll();
    virtual bool CanCopy() const;
    virtual bool CanCut() const;
    virtual bool CanPaste() const;
    virtual bool CanUndo() const;
    virtual bool CanRedo() const;


    bool HasSelection() const;
    void GetSelection( long* from, long* to ) const;
    int GetCurrentSelection() const;

    virtual void SetFocus();

    void OnSize( wxSizeEvent &event );
    void OnChar( wxKeyEvent &event );


    void OnCut(wxCommandEvent& event);
    void OnCopy(wxCommandEvent& event);
    void OnPaste(wxCommandEvent& event);
    void OnUndo(wxCommandEvent& event);
    void OnRedo(wxCommandEvent& event);
    void OnDelete(wxCommandEvent& event);
    void OnSelectAll(wxCommandEvent& event);

    void OnUpdateCut(wxUpdateUIEvent& event);
    void OnUpdateCopy(wxUpdateUIEvent& event);
    void OnUpdatePaste(wxUpdateUIEvent& event);
    void OnUpdateUndo(wxUpdateUIEvent& event);
    void OnUpdateRedo(wxUpdateUIEvent& event);
    void OnUpdateDelete(wxUpdateUIEvent& event);
    void OnUpdateSelectAll(wxUpdateUIEvent& event);

    bool m_ignoreNextUpdate:1;
    wxList m_clientDataList;
    wxList m_clientObjectList;
    int m_prevSelection;

    void DisableEvents();
    void EnableEvents();
    GtkWidget* GetConnectWidget();

    void SetClientData(void *data) { wxEvtHandler::SetClientData(data); } void *GetClientData() const { return wxEvtHandler::GetClientData(); } void SetClientObject(wxClientData *data) { wxEvtHandler::SetClientObject(data); } wxClientData *GetClientObject() const { return wxEvtHandler::GetClientObject(); } void SetClientData(unsigned int n, void* clientData) { wxItemContainer::SetClientData(n, clientData); } void* GetClientData(unsigned int n) const { return wxItemContainer::GetClientData(n); } void SetClientObject(unsigned int n, wxClientData* clientData) { wxItemContainer::SetClientObject(n, clientData); } wxClientData* GetClientObject(unsigned int n) const { return wxItemContainer::GetClientObject(n); }

    static wxVisualAttributes
    GetClassDefaultAttributes(wxWindowVariant variant = wxWINDOW_VARIANT_NORMAL);

protected:

    virtual void DoApplyWidgetStyle(GtkRcStyle *style);
    virtual GdkWindow *GTKGetWindow(wxArrayGdkWindows& windows) const;


    virtual int DoAppend(const wxString& item);
    virtual int DoInsert(const wxString& item, unsigned int pos);

    virtual void DoSetItemClientData(unsigned int n, void* clientData);
    virtual void* DoGetItemClientData(unsigned int n) const;
    virtual void DoSetItemClientObject(unsigned int n, wxClientData* clientData);
    virtual wxClientData* DoGetItemClientObject(unsigned int n) const;


    virtual wxSize DoGetBestSize() const;



    virtual bool UseGTKStyleBase() const { return true; }

private:
    private: wxComboBox(const wxComboBox&); wxComboBox& operator=(const wxComboBox&); public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
    private: static const wxEventTableEntry sm_eventTableEntries[]; protected: static const wxEventTable sm_eventTable; virtual const wxEventTable* GetEventTable() const; static wxEventHashTable sm_eventHashTable; virtual wxEventHashTable& GetEventHashTable() const;
};
# 84 "/usr/include/wx-2.8/wx/combobox.h" 2
# 88 "/usr/include/wx-2.8/wx/wx.h" 2
# 1 "/usr/include/wx-2.8/wx/layout.h" 1
# 35 "/usr/include/wx-2.8/wx/layout.h"
class wxWindowBase;
class wxLayoutConstraints;







enum wxEdge
{
    wxLeft, wxTop, wxRight, wxBottom, wxWidth, wxHeight,
    wxCentre, wxCenter = wxCentre, wxCentreX, wxCentreY
};

enum wxRelationship
{
    wxUnconstrained = 0,
    wxAsIs,
    wxPercentOf,
    wxAbove,
    wxBelow,
    wxLeftOf,
    wxRightOf,
    wxSameAs,
    wxAbsolute
};





class wxIndividualLayoutConstraint : public wxObject
{
public:
    wxIndividualLayoutConstraint();



    virtual ~wxIndividualLayoutConstraint(){}

    void Set(wxRelationship rel, wxWindowBase *otherW, wxEdge otherE, int val = 0, int marg = 0);




    void LeftOf(wxWindowBase *sibling, int marg = 0);
    void RightOf(wxWindowBase *sibling, int marg = 0);
    void Above(wxWindowBase *sibling, int marg = 0);
    void Below(wxWindowBase *sibling, int marg = 0);




    void SameAs(wxWindowBase *otherW, wxEdge edge, int marg = 0);


    void PercentOf(wxWindowBase *otherW, wxEdge wh, int per);




    void Absolute(int val);




    void Unconstrained() { relationship = wxUnconstrained; }




    void AsIs() { relationship = wxAsIs; }




    wxWindowBase *GetOtherWindow() { return otherWin; }
    wxEdge GetMyEdge() const { return myEdge; }
    void SetEdge(wxEdge which) { myEdge = which; }
    void SetValue(int v) { value = v; }
    int GetMargin() { return margin; }
    void SetMargin(int m) { margin = m; }
    int GetValue() const { return value; }
    int GetPercent() const { return percent; }
    int GetOtherEdge() const { return otherEdge; }
    bool GetDone() const { return done; }
    void SetDone(bool d) { done = d; }
    wxRelationship GetRelationship() { return relationship; }
    void SetRelationship(wxRelationship r) { relationship = r; }


    bool ResetIfWin(wxWindowBase *otherW);


    bool SatisfyConstraint(wxLayoutConstraints *constraints, wxWindowBase *win);



    int GetEdge(wxEdge which, wxWindowBase *thisWin, wxWindowBase *other) const;

protected:

    friend class wxIndividualLayoutConstraint_Serialize;


    wxWindowBase *otherWin;

    wxEdge myEdge;
    wxRelationship relationship;
    int margin;
    int value;
    int percent;
    wxEdge otherEdge;
    bool done;

    public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};





class wxLayoutConstraints : public wxObject
{
public:

    wxIndividualLayoutConstraint left;
    wxIndividualLayoutConstraint top;
    wxIndividualLayoutConstraint right;
    wxIndividualLayoutConstraint bottom;

    wxIndividualLayoutConstraint width;
    wxIndividualLayoutConstraint height;

    wxIndividualLayoutConstraint centreX;
    wxIndividualLayoutConstraint centreY;

    wxLayoutConstraints();



    virtual ~wxLayoutConstraints(){}

    bool SatisfyConstraints(wxWindowBase *win, int *noChanges);
    bool AreSatisfied() const
    {
        return left.GetDone() && top.GetDone() &&
               width.GetDone() && height.GetDone();
    }

    public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};
# 89 "/usr/include/wx-2.8/wx/wx.h" 2
# 1 "/usr/include/wx-2.8/wx/sizer.h" 1
# 23 "/usr/include/wx-2.8/wx/sizer.h"
class wxButton;
class wxBoxSizer;
class wxSizerItem;
class wxSizer;
class wxFlexGridSizer;
class wxGridBagSizer;
# 43 "/usr/include/wx-2.8/wx/sizer.h"
class wxSizerFlags
{
public:


    wxSizerFlags(int proportion = 0) : m_proportion(proportion)
    {
        m_flags = 0;
        m_borderInPixels = 0;
    }




    wxSizerFlags& Proportion(int proportion)
    {
        m_proportion = proportion;
        return *this;
    }

    wxSizerFlags& Align(int alignment)
    {
        m_flags &= ~wxALIGN_MASK;
        m_flags |= alignment;

        return *this;
    }

    wxSizerFlags& Expand()
    {
        m_flags |= wxEXPAND;
        return *this;
    }


    wxSizerFlags& Centre() { return Align(wxCENTRE); }
    wxSizerFlags& Center() { return Centre(); }
    wxSizerFlags& Left() { return Align(wxALIGN_LEFT); }
    wxSizerFlags& Right() { return Align(wxALIGN_RIGHT); }


    wxSizerFlags& Top() { return Align(wxALIGN_TOP); }
    wxSizerFlags& Bottom() { return Align(wxALIGN_BOTTOM); }



    static int GetDefaultBorder()
    {



        return 5;



    }


    wxSizerFlags& Border(int direction, int borderInPixels)
    {
        m_flags &= ~wxALL;
        m_flags |= direction;

        m_borderInPixels = borderInPixels;

        return *this;
    }

    wxSizerFlags& Border(int direction = wxALL)
    {

        return Border(direction, GetDefaultBorder());






    }

    wxSizerFlags& DoubleBorder(int direction = wxALL)
    {

        return Border(direction, 2*GetDefaultBorder());





    }

    wxSizerFlags& TripleBorder(int direction = wxALL)
    {

        return Border(direction, 3*GetDefaultBorder());





    }

    wxSizerFlags& HorzBorder()
    {

        return Border(wxLEFT | wxRIGHT, GetDefaultBorder());



    }

    wxSizerFlags& DoubleHorzBorder()
    {

        return Border(wxLEFT | wxRIGHT, 2*GetDefaultBorder());



    }



    wxSizerFlags& Shaped()
    {
        m_flags |= wxSHAPED;

        return *this;
    }

    wxSizerFlags& FixedMinSize()
    {
        m_flags |= wxFIXED_MINSIZE;

        return *this;
    }




    wxSizerFlags& ReserveSpaceEvenIfHidden();



    int GetProportion() const { return m_proportion; }
    int GetFlags() const { return m_flags; }
    int GetBorderInPixels() const { return m_borderInPixels; }

private:
    int m_proportion;
    int m_flags;
    int m_borderInPixels;
};






class wxSizerSpacer
{
public:
    wxSizerSpacer(const wxSize& size) : m_size(size), m_isShown(true) { }

    void SetSize(const wxSize& size) { m_size = size; }
    const wxSize& GetSize() const { return m_size; }

    void Show(bool show) { m_isShown = show; }
    bool IsShown() const { return m_isShown; }

private:

    wxSize m_size;


    bool m_isShown;
};





class wxSizerItem : public wxObject
{
public:

    wxSizerItem( wxWindow *window,
                 int proportion,
                 int flag,
                 int border,
                 wxObject* userData );


    wxSizerItem(wxWindow *window, const wxSizerFlags& flags)
    {
        Init(flags);

        SetWindow(window);
    }


    wxSizerItem( wxSizer *sizer,
                 int proportion,
                 int flag,
                 int border,
                 wxObject* userData );


    wxSizerItem(wxSizer *sizer, const wxSizerFlags& flags)
    {
        Init(flags);

        SetSizer(sizer);
    }


    wxSizerItem( int width,
                 int height,
                 int proportion,
                 int flag,
                 int border,
                 wxObject* userData);


    wxSizerItem(int width, int height, const wxSizerFlags& flags)
    {
        Init(flags);

        SetSpacer(width, height);
    }

    wxSizerItem();
    virtual ~wxSizerItem();

    virtual void DeleteWindows();


    void DetachSizer() { m_sizer = __null; }

    virtual wxSize GetSize() const;
    virtual wxSize CalcMin();
    virtual void SetDimension( const wxPoint& pos, const wxSize& size );

    wxSize GetMinSize() const
        { return m_minSize; }
    wxSize GetMinSizeWithBorder() const;

    void SetMinSize(const wxSize& size)
    {
        if ( IsWindow() )
            m_window->SetMinSize(size);
        m_minSize = size;
    }
    void SetMinSize( int x, int y )
        { SetMinSize(wxSize(x, y)); }
    void SetInitSize( int x, int y )
        { SetMinSize(wxSize(x, y)); }



    void SetRatio(int width, int height)
        { m_ratio = (width && height) ? ((float) width / (float) height) : 1; }
    void SetRatio(const wxSize& size)
        { SetRatio(size.x, size.y); }
    void SetRatio(float ratio)
        { m_ratio = ratio; }
    float GetRatio() const
        { return m_ratio; }

    virtual wxRect GetRect() { return m_rect; }

    bool IsWindow() const { return m_kind == Item_Window; }
    bool IsSizer() const { return m_kind == Item_Sizer; }
    bool IsSpacer() const { return m_kind == Item_Spacer; }



    void SetOption( int option ) __attribute__ ((deprecated));
    int GetOption() const __attribute__ ((deprecated));


    void SetProportion( int proportion )
        { m_proportion = proportion; }
    int GetProportion() const
        { return m_proportion; }
    void SetFlag( int flag )
        { m_flag = flag; }
    int GetFlag() const
        { return m_flag; }
    void SetBorder( int border )
        { m_border = border; }
    int GetBorder() const
        { return m_border; }

    wxWindow *GetWindow() const
        { return m_kind == Item_Window ? m_window : __null; }
    wxSizer *GetSizer() const
        { return m_kind == Item_Sizer ? m_sizer : __null; }
    wxSize GetSpacer() const;




    bool IsShown() const;
    void Show(bool show);

    void SetUserData(wxObject* userData)
        { delete m_userData; m_userData = userData; }
    wxObject* GetUserData() const
        { return m_userData; }
    wxPoint GetPosition() const
        { return m_pos; }



    void SetWindow(wxWindow *window);
    void SetSizer(wxSizer *sizer);
    void SetSpacer(const wxSize& size);
    void SetSpacer(int width, int height) { SetSpacer(wxSize(width, height)); }

protected:

    void Init() { m_userData = __null; }


    void Init(const wxSizerFlags& flags);



    enum
    {
        Item_None,
        Item_Window,
        Item_Sizer,
        Item_Spacer,
        Item_Max
    } m_kind;
    union
    {
        wxWindow *m_window;
        wxSizer *m_sizer;
        wxSizerSpacer *m_spacer;
    };

    wxPoint m_pos;
    wxSize m_minSize;
    int m_proportion;
    int m_border;
    int m_flag;


    wxRect m_rect;




    float m_ratio;

    wxObject *m_userData;

private:

    bool ShouldAccountFor() const;

    public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
    private: wxSizerItem(const wxSizerItem&); wxSizerItem& operator=(const wxSizerItem&);

    friend class wxBoxSizer;
    friend class wxFlexGridSizer;
    friend class wxGridBagSizer;
};

typedef wxSizerItem _WX_LIST_ITEM_TYPE_wxSizerItemList; typedef int (*wxSortFuncFor_wxSizerItemList)(const wxSizerItem **, const wxSizerItem **); class wxwxSizerItemListNode : public wxNodeBase { public: wxwxSizerItemListNode(wxListBase *list = (wxListBase *)__null, wxwxSizerItemListNode *previous = (wxwxSizerItemListNode *)__null, wxwxSizerItemListNode *next = (wxwxSizerItemListNode *)__null, wxSizerItem *data = (wxSizerItem *)__null, const wxListKey& key = wxDefaultListKey) : wxNodeBase(list, previous, next, data, key) { } wxwxSizerItemListNode *GetNext() const { return (wxwxSizerItemListNode *)wxNodeBase::GetNext(); } wxwxSizerItemListNode *GetPrevious() const { return (wxwxSizerItemListNode *)wxNodeBase::GetPrevious(); } wxSizerItem *GetData() const { return (wxSizerItem *)wxNodeBase::GetData(); } void SetData(wxSizerItem *data) { wxNodeBase::SetData(data); } protected: virtual void DeleteData(); private: wxwxSizerItemListNode(const wxwxSizerItemListNode&); wxwxSizerItemListNode& operator=(const wxwxSizerItemListNode&); }; class wxSizerItemList : public wxListBase { public: typedef wxwxSizerItemListNode Node; class compatibility_iterator { public: compatibility_iterator(Node *ptr = __null) : m_ptr(ptr) { } Node *operator->() const { return m_ptr; } operator Node *() const { return m_ptr; } private: Node *m_ptr; }; wxSizerItemList(wxKeyType keyType = wxKEY_NONE) : wxListBase(keyType) { } wxSizerItemList(const wxSizerItemList& list) : wxListBase(list.GetKeyType()) { Assign(list); } wxSizerItemList(size_t count, wxSizerItem *elements[]) : wxListBase(count, (void **)elements) { } wxSizerItemList& operator=(const wxSizerItemList& list) { Assign(list); return *this; } wxwxSizerItemListNode *GetFirst() const { return (wxwxSizerItemListNode *)wxListBase::GetFirst(); } wxwxSizerItemListNode *GetLast() const { return (wxwxSizerItemListNode *)wxListBase::GetLast(); } wxwxSizerItemListNode *Item(size_t index) const { return (wxwxSizerItemListNode *)wxListBase::Item(index); } wxSizerItem *operator[](size_t index) const { wxwxSizerItemListNode *node = Item(index); return node ? (wxSizerItem*)(node->GetData()) : (wxSizerItem*)__null; } wxwxSizerItemListNode *Append(wxSizerItem *object) { return (wxwxSizerItemListNode *)wxListBase::Append(object); } wxwxSizerItemListNode *Insert(wxSizerItem *object) { return (wxwxSizerItemListNode *)Insert((wxwxSizerItemListNode*)__null, object); } wxwxSizerItemListNode *Insert(size_t pos, wxSizerItem *object) { return (wxwxSizerItemListNode *)wxListBase::Insert(pos, object); } wxwxSizerItemListNode *Insert(wxwxSizerItemListNode *prev, wxSizerItem *object) { return (wxwxSizerItemListNode *)wxListBase::Insert(prev, object); } wxwxSizerItemListNode *Append(long key, void *object) { return (wxwxSizerItemListNode *)wxListBase::Append(key, object); } wxwxSizerItemListNode *Append(const wxChar *key, void *object) { return (wxwxSizerItemListNode *)wxListBase::Append(key, object); } wxwxSizerItemListNode *DetachNode(wxwxSizerItemListNode *node) { return (wxwxSizerItemListNode *)wxListBase::DetachNode(node); } bool DeleteNode(wxwxSizerItemListNode *node) { return wxListBase::DeleteNode(node); } bool DeleteObject(wxSizerItem *object) { return wxListBase::DeleteObject(object); } void Erase(wxwxSizerItemListNode *it) { DeleteNode(it); } wxwxSizerItemListNode *Find(const wxSizerItem *object) const { return (wxwxSizerItemListNode *)wxListBase::Find(object); } virtual wxwxSizerItemListNode *Find(const wxListKey& key) const { return (wxwxSizerItemListNode *)wxListBase::Find(key); } int IndexOf(wxSizerItem *object) const { return wxListBase::IndexOf(object); } void Sort(wxSortCompareFunction func) { wxListBase::Sort(func); } void Sort(wxSortFuncFor_wxSizerItemList func) { Sort((wxSortCompareFunction)func); } protected: virtual wxNodeBase *CreateNode(wxNodeBase *prev, wxNodeBase *next, void *data, const wxListKey& key = wxDefaultListKey) { return new wxwxSizerItemListNode(this, (wxwxSizerItemListNode *)prev, (wxwxSizerItemListNode *)next, (wxSizerItem *)data, key); } public: typedef size_t size_type; typedef int difference_type; typedef wxSizerItem* value_type; typedef wxSizerItem* base_value_type; typedef value_type& reference; typedef const value_type& const_reference; typedef base_value_type& base_reference; typedef const base_value_type& const_base_reference; class iterator { typedef wxSizerItemList list; public: typedef wxwxSizerItemListNode Node; typedef iterator itor; typedef wxSizerItem* value_type; typedef value_type* ptr_type; typedef value_type& reference; Node* m_node; Node* m_init; public: typedef reference reference_type; typedef ptr_type pointer_type; iterator(Node* node, Node* init) : m_node(node), m_init(init) {} iterator() : m_node(__null), m_init(__null) { } reference_type operator*() const { return *(pointer_type)m_node->GetDataPtr(); } itor& operator++() { m_node = m_node->GetNext(); return *this; } const itor operator++(int) { itor tmp = *this; m_node = m_node->GetNext(); return tmp; } itor& operator--() { m_node = m_node ? m_node->GetPrevious() : m_init; return *this; } const itor operator--(int) { itor tmp = *this; m_node = m_node ? m_node->GetPrevious() : m_init; return tmp; } bool operator!=(const itor& it) const { return it.m_node != m_node; } bool operator==(const itor& it) const { return it.m_node == m_node; } }; class const_iterator { typedef wxSizerItemList list; public: typedef wxwxSizerItemListNode Node; typedef wxSizerItem* value_type; typedef const value_type& const_reference; typedef const_iterator itor; typedef value_type* ptr_type; Node* m_node; Node* m_init; public: typedef const_reference reference_type; typedef const ptr_type pointer_type; const_iterator(Node* node, Node* init) : m_node(node), m_init(init) { } const_iterator() : m_node(__null), m_init(__null) { } const_iterator(const iterator& it) : m_node(it.m_node), m_init(it.m_init) { } reference_type operator*() const { return *(pointer_type)m_node->GetDataPtr(); } itor& operator++() { m_node = m_node->GetNext(); return *this; } const itor operator++(int) { itor tmp = *this; m_node = m_node->GetNext(); return tmp; } itor& operator--() { m_node = m_node ? m_node->GetPrevious() : m_init; return *this; } const itor operator--(int) { itor tmp = *this; m_node = m_node ? m_node->GetPrevious() : m_init; return tmp; } bool operator!=(const itor& it) const { return it.m_node != m_node; } bool operator==(const itor& it) const { return it.m_node == m_node; } }; class reverse_iterator { typedef wxSizerItemList list; public: typedef wxwxSizerItemListNode Node; typedef wxSizerItem* value_type; typedef reverse_iterator itor; typedef value_type* ptr_type; typedef value_type& reference; Node* m_node; Node* m_init; public: typedef reference reference_type; typedef ptr_type pointer_type; reverse_iterator(Node* node, Node* init) : m_node(node), m_init(init) { } reverse_iterator() : m_node(__null), m_init(__null) { } reference_type operator*() const { return *(pointer_type)m_node->GetDataPtr(); } itor& operator++() { m_node = m_node->GetPrevious(); return *this; } const itor operator++(int) { itor tmp = *this; m_node = m_node->GetPrevious(); return tmp; } itor& operator--() { m_node = m_node ? m_node->GetNext() : m_init; return *this; } const itor operator--(int) { itor tmp = *this; m_node = m_node ? m_node->GetNext() : m_init; return tmp; } bool operator!=(const itor& it) const { return it.m_node != m_node; } bool operator==(const itor& it) const { return it.m_node == m_node; } }; class const_reverse_iterator { typedef wxSizerItemList list; public: typedef wxwxSizerItemListNode Node; typedef wxSizerItem* value_type; typedef const_reverse_iterator itor; typedef value_type* ptr_type; typedef const value_type& const_reference; Node* m_node; Node* m_init; public: typedef const_reference reference_type; typedef const ptr_type pointer_type; const_reverse_iterator(Node* node, Node* init) : m_node(node), m_init(init) { } const_reverse_iterator() : m_node(__null), m_init(__null) { } const_reverse_iterator(const reverse_iterator& it) : m_node(it.m_node), m_init(it.m_init) { } reference_type operator*() const { return *(pointer_type)m_node->GetDataPtr(); } itor& operator++() { m_node = m_node->GetPrevious(); return *this; } const itor operator++(int) { itor tmp = *this; m_node = m_node->GetPrevious(); return tmp; } itor& operator--() { m_node = m_node ? m_node->GetNext() : m_init; return *this;} const itor operator--(int) { itor tmp = *this; m_node = m_node ? m_node->GetNext() : m_init; return tmp; } bool operator!=(const itor& it) const { return it.m_node != m_node; } bool operator==(const itor& it) const { return it.m_node == m_node; } }; explicit wxSizerItemList(size_type n, const_reference v = value_type()) { assign(n, v); } wxSizerItemList(const const_iterator& first, const const_iterator& last) { assign(first, last); } iterator begin() { return iterator(GetFirst(), GetLast()); } const_iterator begin() const { return const_iterator(GetFirst(), GetLast()); } iterator end() { return iterator(__null, GetLast()); } const_iterator end() const { return const_iterator(__null, GetLast()); } reverse_iterator rbegin() { return reverse_iterator(GetLast(), GetFirst()); } const_reverse_iterator rbegin() const { return const_reverse_iterator(GetLast(), GetFirst()); } reverse_iterator rend() { return reverse_iterator(__null, GetFirst()); } const_reverse_iterator rend() const { return const_reverse_iterator(__null, GetFirst()); } void resize(size_type n, value_type v = value_type()) { while (n < size()) pop_back(); while (n > size()) push_back(v); } size_type size() const { return GetCount(); } size_type max_size() const { return 2147483647; } bool empty() const { return IsEmpty(); } reference front() { return *begin(); } const_reference front() const { return *begin(); } reference back() { iterator tmp = end(); return *--tmp; } const_reference back() const { const_iterator tmp = end(); return *--tmp; } void push_front(const_reference v = value_type()) { Insert(GetFirst(), (const_base_reference)v); } void pop_front() { DeleteNode(GetFirst()); } void push_back(const_reference v = value_type()) { Append((const_base_reference)v); } void pop_back() { DeleteNode(GetLast()); } void assign(const_iterator first, const const_iterator& last) { clear(); for(; first != last; ++first) Append((const_base_reference)*first); } void assign(size_type n, const_reference v = value_type()) { clear(); for(size_type i = 0; i < n; ++i) Append((const_base_reference)v); } iterator insert(const iterator& it, const_reference v = value_type()) { if ( it == end() ) Append((const_base_reference)v); else Insert(it.m_node, (const_base_reference)v); iterator itprev(it); return itprev--; } void insert(const iterator& it, size_type n, const_reference v = value_type()) { for(size_type i = 0; i < n; ++i) insert(it, v); } void insert(const iterator& it, const_iterator first, const const_iterator& last) { for(; first != last; ++first) insert(it, *first); } iterator erase(const iterator& it) { iterator next = iterator(it.m_node->GetNext(), GetLast()); DeleteNode(it.m_node); return next; } iterator erase(const iterator& first, const iterator& last) { iterator next = last; if ( next != end() ) ++next; DeleteNodes(first.m_node, last.m_node); return next; } void clear() { Clear(); } void splice(const iterator& it, wxSizerItemList& l, const iterator& first, const iterator& last) { insert(it, first, last); l.erase(first, last); } void splice(const iterator& it, wxSizerItemList& l) { splice(it, l, l.begin(), l.end() ); } void splice(const iterator& it, wxSizerItemList& l, const iterator& first) { if ( it != first ) { insert(it, *first); l.erase(first); } } void remove(const_reference v) { DeleteObject((const_base_reference)v); } void reverse() { Reverse(); } };






class wxSizer: public wxObject, public wxClientDataContainer
{
public:
    wxSizer() { m_containingWindow = __null; }
    virtual ~wxSizer();



    wxSizerItem* Add(wxWindow *window,
                     int proportion = 0,
                     int flag = 0,
                     int border = 0,
                     wxObject* userData = __null);
    wxSizerItem* Add(wxSizer *sizer,
                     int proportion = 0,
                     int flag = 0,
                     int border = 0,
                     wxObject* userData = __null);
    wxSizerItem* Add(int width,
                     int height,
                     int proportion = 0,
                     int flag = 0,
                     int border = 0,
                     wxObject* userData = __null);
    wxSizerItem* Add( wxWindow *window, const wxSizerFlags& flags);
    wxSizerItem* Add( wxSizer *sizer, const wxSizerFlags& flags);
    wxSizerItem* Add( wxSizerItem *item);

    wxSizerItem* AddSpacer(int size);
    wxSizerItem* AddStretchSpacer(int prop = 1);

    wxSizerItem* Insert(size_t index,
                        wxWindow *window,
                        int proportion = 0,
                        int flag = 0,
                        int border = 0,
                        wxObject* userData = __null);
    wxSizerItem* Insert(size_t index,
                        wxSizer *sizer,
                        int proportion = 0,
                        int flag = 0,
                        int border = 0,
                        wxObject* userData = __null);
    wxSizerItem* Insert(size_t index,
                        int width,
                        int height,
                        int proportion = 0,
                        int flag = 0,
                        int border = 0,
                        wxObject* userData = __null);
    wxSizerItem* Insert(size_t index,
                        wxWindow *window,
                        const wxSizerFlags& flags);
    wxSizerItem* Insert(size_t index,
                        wxSizer *sizer,
                        const wxSizerFlags& flags);
    virtual wxSizerItem* Insert( size_t index, wxSizerItem *item);

    wxSizerItem* InsertSpacer(size_t index, int size);
    wxSizerItem* InsertStretchSpacer(size_t index, int prop = 1);

    wxSizerItem* Prepend(wxWindow *window,
                         int proportion = 0,
                         int flag = 0,
                         int border = 0,
                         wxObject* userData = __null);
    wxSizerItem* Prepend(wxSizer *sizer,
                         int proportion = 0,
                         int flag = 0,
                         int border = 0,
                         wxObject* userData = __null);
    wxSizerItem* Prepend(int width,
                         int height,
                         int proportion = 0,
                         int flag = 0,
                         int border = 0,
                         wxObject* userData = __null);
    wxSizerItem* Prepend(wxWindow *window, const wxSizerFlags& flags);
    wxSizerItem* Prepend(wxSizer *sizer, const wxSizerFlags& flags);
    wxSizerItem* Prepend(wxSizerItem *item);

    wxSizerItem* PrependSpacer(int size);
    wxSizerItem* PrependStretchSpacer(int prop = 1);



    void SetContainingWindow(wxWindow *window);
    wxWindow *GetContainingWindow() const { return m_containingWindow; }




    virtual bool Remove( wxWindow *window ) __attribute__ ((deprecated));


    virtual bool Remove( wxSizer *sizer );
    virtual bool Remove( int index );

    virtual bool Detach( wxWindow *window );
    virtual bool Detach( wxSizer *sizer );
    virtual bool Detach( int index );

    virtual bool Replace( wxWindow *oldwin, wxWindow *newwin, bool recursive = false );
    virtual bool Replace( wxSizer *oldsz, wxSizer *newsz, bool recursive = false );
    virtual bool Replace( size_t index, wxSizerItem *newitem );

    virtual void Clear( bool delete_windows = false );
    virtual void DeleteWindows();

    void SetMinSize( int width, int height )
        { DoSetMinSize( width, height ); }
    void SetMinSize( const wxSize& size )
        { DoSetMinSize( size.x, size.y ); }


    bool SetItemMinSize( wxWindow *window, int width, int height )
        { return DoSetItemMinSize( window, width, height ); }
    bool SetItemMinSize( wxWindow *window, const wxSize& size )
        { return DoSetItemMinSize( window, size.x, size.y ); }


    bool SetItemMinSize( wxSizer *sizer, int width, int height )
        { return DoSetItemMinSize( sizer, width, height ); }
    bool SetItemMinSize( wxSizer *sizer, const wxSize& size )
        { return DoSetItemMinSize( sizer, size.x, size.y ); }

    bool SetItemMinSize( size_t index, int width, int height )
        { return DoSetItemMinSize( index, width, height ); }
    bool SetItemMinSize( size_t index, const wxSize& size )
        { return DoSetItemMinSize( index, size.x, size.y ); }

    wxSize GetSize() const
        { return m_size; }
    wxPoint GetPosition() const
        { return m_position; }


    wxSize GetMinSize();

    virtual void RecalcSizes() = 0;
    virtual wxSize CalcMin() = 0;

    virtual void Layout();


    wxSize ComputeFittingClientSize(wxWindow *window);
    wxSize ComputeFittingWindowSize(wxWindow *window);


    wxSize Fit( wxWindow *window );
    void FitInside( wxWindow *window );
    void SetSizeHints( wxWindow *window );
    void SetVirtualSizeHints( wxWindow *window );

    wxSizerItemList& GetChildren()
        { return m_children; }

    void SetDimension( int x, int y, int width, int height );

    wxSizerItem* GetItem( wxWindow *window, bool recursive = false );
    wxSizerItem* GetItem( wxSizer *sizer, bool recursive = false );
    wxSizerItem* GetItem( size_t index );



    bool Show( wxWindow *window, bool show = true, bool recursive = false );
    bool Show( wxSizer *sizer, bool show = true, bool recursive = false );
    bool Show( size_t index, bool show = true );

    bool Hide( wxSizer *sizer, bool recursive = false )
        { return Show( sizer, false, recursive ); }
    bool Hide( wxWindow *window, bool recursive = false )
        { return Show( window, false, recursive ); }
    bool Hide( size_t index )
        { return Show( index, false ); }

    bool IsShown( wxWindow *window ) const;
    bool IsShown( wxSizer *sizer ) const;
    bool IsShown( size_t index ) const;


    virtual void ShowItems (bool show);

    void Show(bool show) { ShowItems(show); }

protected:
    wxSize m_size;
    wxSize m_minSize;
    wxPoint m_position;
    wxSizerItemList m_children;


    wxWindow *m_containingWindow;

    wxSize GetMaxWindowSize( wxWindow *window ) const;
    wxSize GetMinWindowSize( wxWindow *window );
    wxSize GetMaxClientSize( wxWindow *window ) const;
    wxSize GetMinClientSize( wxWindow *window );
    wxSize VirtualFitSize( wxWindow *window );

    virtual void DoSetMinSize( int width, int height );
    virtual bool DoSetItemMinSize( wxWindow *window, int width, int height );
    virtual bool DoSetItemMinSize( wxSizer *sizer, int width, int height );
    virtual bool DoSetItemMinSize( size_t index, int width, int height );

private:
    public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};





class wxGridSizer: public wxSizer
{
public:
    wxGridSizer( int rows, int cols, int vgap, int hgap );
    wxGridSizer( int cols, int vgap = 0, int hgap = 0 );

    virtual void RecalcSizes();
    virtual wxSize CalcMin();

    void SetCols( int cols ) { m_cols = cols; }
    void SetRows( int rows ) { m_rows = rows; }
    void SetVGap( int gap ) { m_vgap = gap; }
    void SetHGap( int gap ) { m_hgap = gap; }
    int GetCols() const { return m_cols; }
    int GetRows() const { return m_rows; }
    int GetVGap() const { return m_vgap; }
    int GetHGap() const { return m_hgap; }

protected:
    int m_rows;
    int m_cols;
    int m_vgap;
    int m_hgap;


    int CalcRowsCols(int& rows, int& cols) const;

    void SetItemBounds( wxSizerItem *item, int x, int y, int w, int h );

private:
    public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};







enum wxFlexSizerGrowMode
{

    wxFLEX_GROWMODE_NONE,


    wxFLEX_GROWMODE_SPECIFIED,


    wxFLEX_GROWMODE_ALL
};

class wxFlexGridSizer: public wxGridSizer
{
public:

    wxFlexGridSizer( int rows, int cols, int vgap, int hgap );
    wxFlexGridSizer( int cols, int vgap = 0, int hgap = 0 );
    virtual ~wxFlexGridSizer();




    void AddGrowableRow( size_t idx, int proportion = 0 );
    void RemoveGrowableRow( size_t idx );
    void AddGrowableCol( size_t idx, int proportion = 0 );
    void RemoveGrowableCol( size_t idx );






    void SetFlexibleDirection(int direction) { m_flexDirection = direction; }
    int GetFlexibleDirection() const { return m_flexDirection; }



    void SetNonFlexibleGrowMode(wxFlexSizerGrowMode mode) { m_growMode = mode; }
    wxFlexSizerGrowMode GetNonFlexibleGrowMode() const { return m_growMode; }


    const wxArrayInt& GetRowHeights() const { return m_rowHeights; }
    const wxArrayInt& GetColWidths() const { return m_colWidths; }


    virtual void RecalcSizes();
    virtual wxSize CalcMin();

protected:
    void AdjustForFlexDirection();
    void AdjustForGrowables(const wxSize& sz, const wxSize& minsz,
                            int nrows, int ncols);


    wxArrayInt m_rowHeights,
                m_colWidths;


    wxArrayInt m_growableRows,
                m_growableCols;


    wxArrayInt m_growableRowsProportions,
                m_growableColsProportions;



    int m_flexDirection;
    wxFlexSizerGrowMode m_growMode;


    wxSize m_calculatedMinSize;

private:
    public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
    private: wxFlexGridSizer(const wxFlexGridSizer&); wxFlexGridSizer& operator=(const wxFlexGridSizer&);
};





class wxBoxSizer: public wxSizer
{
public:
    wxBoxSizer( int orient );

    void RecalcSizes();
    wxSize CalcMin();

    int GetOrientation() const
        { return m_orient; }

    void SetOrientation(int orient)
        { m_orient = orient; }

protected:
    int m_orient;
    int m_stretchable;
    int m_minWidth;
    int m_minHeight;
    int m_fixedWidth;
    int m_fixedHeight;

private:
    public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};







class wxStaticBox;

class wxStaticBoxSizer: public wxBoxSizer
{
public:
    wxStaticBoxSizer(wxStaticBox *box, int orient);
    wxStaticBoxSizer(int orient, wxWindow *win, const wxString& label = wxEmptyString);
    virtual ~wxStaticBoxSizer();

    void RecalcSizes();
    wxSize CalcMin();

    wxStaticBox *GetStaticBox() const
        { return m_staticBox; }


    virtual void ShowItems (bool show);

    virtual bool Detach( wxWindow *window );
    virtual bool Detach( wxSizer *sizer ) { return wxBoxSizer::Detach(sizer); }
    virtual bool Detach( int index ) { return wxBoxSizer::Detach(index); }

protected:
    wxStaticBox *m_staticBox;

private:
    public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
    private: wxStaticBoxSizer(const wxStaticBoxSizer&); wxStaticBoxSizer& operator=(const wxStaticBoxSizer&);
};





class wxStdDialogButtonSizer: public wxBoxSizer
{
public:



    wxStdDialogButtonSizer();



    void AddButton(wxButton *button);


    void SetAffirmativeButton( wxButton *button );
    void SetNegativeButton( wxButton *button );
    void SetCancelButton( wxButton *button );
# 846 "/usr/include/wx-2.8/wx/sizer.h"
    void Realize();

    wxButton *GetAffirmativeButton() const { return m_buttonAffirmative; }
    wxButton *GetApplyButton() const { return m_buttonApply; }
    wxButton *GetNegativeButton() const { return m_buttonNegative; }
    wxButton *GetCancelButton() const { return m_buttonCancel; }
    wxButton *GetHelpButton() const { return m_buttonHelp; }

protected:
    wxButton *m_buttonAffirmative;
    wxButton *m_buttonApply;
    wxButton *m_buttonNegative;
    wxButton *m_buttonCancel;
    wxButton *m_buttonHelp;

private:
    public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
    private: wxStdDialogButtonSizer(const wxStdDialogButtonSizer&); wxStdDialogButtonSizer& operator=(const wxStdDialogButtonSizer&);
};
# 937 "/usr/include/wx-2.8/wx/sizer.h"
inline wxSizerItem*
wxSizer::Add( wxSizerItem *item )
{
    return Insert( m_children.GetCount(), item );
}

inline wxSizerItem*
wxSizer::Add( wxWindow *window, int proportion, int flag, int border, wxObject* userData )
{
    return Add( new wxSizerItem( window, proportion, flag, border, userData ) );
}

inline wxSizerItem*
wxSizer::Add( wxSizer *sizer, int proportion, int flag, int border, wxObject* userData )
{
    return Add( new wxSizerItem( sizer, proportion, flag, border, userData ) );
}

inline wxSizerItem*
wxSizer::Add( int width, int height, int proportion, int flag, int border, wxObject* userData )
{
    return Add( new wxSizerItem( width, height, proportion, flag, border, userData ) );
}

inline wxSizerItem*
wxSizer::Add( wxWindow *window, const wxSizerFlags& flags )
{
    return Add( new wxSizerItem(window, flags) );
}

inline wxSizerItem*
wxSizer::Add( wxSizer *sizer, const wxSizerFlags& flags )
{
    return Add( new wxSizerItem(sizer, flags) );
}

inline wxSizerItem*
wxSizer::AddSpacer(int size)
{
    return Add(size, size);
}

inline wxSizerItem*
wxSizer::AddStretchSpacer(int prop)
{
    return Add(0, 0, prop);
}

inline wxSizerItem*
wxSizer::Prepend( wxSizerItem *item )
{
    return Insert( 0, item );
}

inline wxSizerItem*
wxSizer::Prepend( wxWindow *window, int proportion, int flag, int border, wxObject* userData )
{
    return Prepend( new wxSizerItem( window, proportion, flag, border, userData ) );
}

inline wxSizerItem*
wxSizer::Prepend( wxSizer *sizer, int proportion, int flag, int border, wxObject* userData )
{
    return Prepend( new wxSizerItem( sizer, proportion, flag, border, userData ) );
}

inline wxSizerItem*
wxSizer::Prepend( int width, int height, int proportion, int flag, int border, wxObject* userData )
{
    return Prepend( new wxSizerItem( width, height, proportion, flag, border, userData ) );
}

inline wxSizerItem*
wxSizer::PrependSpacer(int size)
{
    return Prepend(size, size);
}

inline wxSizerItem*
wxSizer::PrependStretchSpacer(int prop)
{
    return Prepend(0, 0, prop);
}

inline wxSizerItem*
wxSizer::Prepend( wxWindow *window, const wxSizerFlags& flags )
{
    return Prepend( new wxSizerItem(window, flags) );
}

inline wxSizerItem*
wxSizer::Prepend( wxSizer *sizer, const wxSizerFlags& flags )
{
    return Prepend( new wxSizerItem(sizer, flags) );
}

inline wxSizerItem*
wxSizer::Insert( size_t index,
                 wxWindow *window,
                 int proportion,
                 int flag,
                 int border,
                 wxObject* userData )
{
    return Insert( index, new wxSizerItem( window, proportion, flag, border, userData ) );
}

inline wxSizerItem*
wxSizer::Insert( size_t index,
                 wxSizer *sizer,
                 int proportion,
                 int flag,
                 int border,
                 wxObject* userData )
{
    return Insert( index, new wxSizerItem( sizer, proportion, flag, border, userData ) );
}

inline wxSizerItem*
wxSizer::Insert( size_t index,
                 int width,
                 int height,
                 int proportion,
                 int flag,
                 int border,
                 wxObject* userData )
{
    return Insert( index, new wxSizerItem( width, height, proportion, flag, border, userData ) );
}

inline wxSizerItem*
wxSizer::Insert( size_t index, wxWindow *window, const wxSizerFlags& flags )
{
    return Insert( index, new wxSizerItem(window, flags) );
}

inline wxSizerItem*
wxSizer::Insert( size_t index, wxSizer *sizer, const wxSizerFlags& flags )
{
    return Insert( index, new wxSizerItem(sizer, flags) );
}

inline wxSizerItem*
wxSizer::InsertSpacer(size_t index, int size)
{
    return Insert(index, size, size);
}

inline wxSizerItem*
wxSizer::InsertStretchSpacer(size_t index, int prop)
{
    return Insert(index, 0, 0, prop);
}
# 90 "/usr/include/wx-2.8/wx/wx.h" 2
# 1 "/usr/include/wx-2.8/wx/mdi.h" 1
# 26 "/usr/include/wx-2.8/wx/mdi.h"
# 1 "/usr/include/wx-2.8/wx/gtk/mdi.h" 1
# 19 "/usr/include/wx-2.8/wx/gtk/mdi.h"
class wxMDIParentFrame: public wxFrame
{
public:
    wxMDIParentFrame() { Init(); }
    wxMDIParentFrame(wxWindow *parent,
                     wxWindowID id,
                     const wxString& title,
                     const wxPoint& pos = wxDefaultPosition,
                     const wxSize& size = wxDefaultSize,
                     long style = (0x0800 | 0x0040 | 0x0400 | 0x0200 | 0x1000 | 0x20000000 | 0x00400000) | 0x80000000 | 0x40000000,
                     const wxString& name = wxFrameNameStr)
    {
        Init();

        (void)Create(parent, id, title, pos, size, style, name);
    }

    virtual ~wxMDIParentFrame();
    bool Create( wxWindow *parent,
                 wxWindowID id,
                 const wxString& title,
                 const wxPoint& pos = wxDefaultPosition,
                 const wxSize& size = wxDefaultSize,
                 long style = (0x0800 | 0x0040 | 0x0400 | 0x0200 | 0x1000 | 0x20000000 | 0x00400000) | 0x80000000 | 0x40000000,
                 const wxString& name = wxFrameNameStr );

    wxMDIChildFrame *GetActiveChild() const;

    wxMDIClientWindow *GetClientWindow() const;
    virtual wxMDIClientWindow *OnCreateClient();

    virtual void Cascade() {}
    virtual void Tile(wxOrientation = wxHORIZONTAL) {}
    virtual void ArrangeIcons() {}
    virtual void ActivateNext();
    virtual void ActivatePrevious();



    wxMDIClientWindow *m_clientWindow;
    bool m_justInserted;

    virtual void GtkOnSize();
    virtual void OnInternalIdle();

protected:
    void Init();

private:
    friend class wxMDIChildFrame;

    public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};





class wxMDIChildFrame: public wxFrame
{
public:
    wxMDIChildFrame();
    wxMDIChildFrame( wxMDIParentFrame *parent,
                     wxWindowID id,
                     const wxString& title,
                     const wxPoint& pos = wxDefaultPosition,
                     const wxSize& size = wxDefaultSize,
                     long style = (0x0800 | 0x0040 | 0x0400 | 0x0200 | 0x1000 | 0x20000000 | 0x00400000),
                     const wxString& name = wxFrameNameStr );

    virtual ~wxMDIChildFrame();
    bool Create( wxMDIParentFrame *parent,
                 wxWindowID id,
                 const wxString& title,
                 const wxPoint& pos = wxDefaultPosition,
                 const wxSize& size = wxDefaultSize,
                 long style = (0x0800 | 0x0040 | 0x0400 | 0x0200 | 0x1000 | 0x20000000 | 0x00400000),
                 const wxString& name = wxFrameNameStr );

    virtual void SetMenuBar( wxMenuBar *menu_bar );
    virtual wxMenuBar *GetMenuBar() const;

    virtual void AddChild( wxWindowBase *child );

    virtual void Activate();



    virtual wxStatusBar* CreateStatusBar( int = 1,
                                        long = 1,
                                        wxWindowID = 1,
                                        const wxString& = wxEmptyString)
      { return (wxStatusBar*)__null; }

    virtual wxStatusBar *GetStatusBar() const { return (wxStatusBar*)__null; }
    virtual void SetStatusText( const wxString &, int =0 ) {}
    virtual void SetStatusWidths( int , const int [] ) {}



    virtual void DoSetSizeHints( int ,
                                 int ,
                                 int = wxDefaultCoord,
                                 int = wxDefaultCoord,
                                 int = wxDefaultCoord,
                                 int = wxDefaultCoord) {}



    virtual wxToolBar* CreateToolBar( long ,
                                       wxWindowID ,
                                       const wxString& )
        { return (wxToolBar*)__null; }
    virtual wxToolBar *GetToolBar() const { return (wxToolBar*)__null; }



    virtual void SetIcon(const wxIcon& icon)
        { wxTopLevelWindowBase::SetIcon(icon); }
    virtual void SetIcons(const wxIconBundle& icons )
        { wxTopLevelWindowBase::SetIcons(icons); }


    virtual void SetTitle( const wxString &title );


    virtual void Maximize( bool = true ) { }
    virtual bool IsMaximized() const { return true; }
    virtual void Iconize(bool = true) { }
    virtual bool IsIconized() const { return false; }
    virtual void Restore() {}

    virtual bool IsTopLevel() const { return false; }

    virtual bool Destroy();

    void OnActivate( wxActivateEvent& event );
    void OnMenuHighlight( wxMenuEvent& event );



    wxMenuBar *m_menuBar;
    GtkNotebookPage *m_page;
    bool m_justInserted;

protected:

    virtual void DoSetSize(int x, int y,
                           int width, int height,
                           int sizeFlags = (0x0001|0x0002));
    virtual void DoSetClientSize(int width, int height);
    virtual void DoGetClientSize( int *width, int *height ) const;

private:
    private: static const wxEventTableEntry sm_eventTableEntries[]; protected: static const wxEventTable sm_eventTable; virtual const wxEventTable* GetEventTable() const; static wxEventHashTable sm_eventHashTable; virtual wxEventHashTable& GetEventHashTable() const;
    public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};





class wxMDIClientWindow: public wxWindow
{
public:
    wxMDIClientWindow();
    wxMDIClientWindow( wxMDIParentFrame *parent, long style = 0 );
    virtual ~wxMDIClientWindow();
    virtual bool CreateClient( wxMDIParentFrame *parent, long style = 0x80000000 | 0x40000000 );

private:
    public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};
# 27 "/usr/include/wx-2.8/wx/mdi.h" 2
# 91 "/usr/include/wx-2.8/wx/wx.h" 2
# 1 "/usr/include/wx-2.8/wx/statusbr.h" 1
# 23 "/usr/include/wx-2.8/wx/statusbr.h"
extern const wxChar wxStatusBarNameStr[];

typedef wxString _WX_LIST_ITEM_TYPE_wxListString; typedef int (*wxSortFuncFor_wxListString)(const wxString **, const wxString **); class wxwxListStringNode : public wxNodeBase { public: wxwxListStringNode(wxListBase *list = (wxListBase *)__null, wxwxListStringNode *previous = (wxwxListStringNode *)__null, wxwxListStringNode *next = (wxwxListStringNode *)__null, wxString *data = (wxString *)__null, const wxListKey& key = wxDefaultListKey) : wxNodeBase(list, previous, next, data, key) { } wxwxListStringNode *GetNext() const { return (wxwxListStringNode *)wxNodeBase::GetNext(); } wxwxListStringNode *GetPrevious() const { return (wxwxListStringNode *)wxNodeBase::GetPrevious(); } wxString *GetData() const { return (wxString *)wxNodeBase::GetData(); } void SetData(wxString *data) { wxNodeBase::SetData(data); } protected: virtual void DeleteData(); private: wxwxListStringNode(const wxwxListStringNode&); wxwxListStringNode& operator=(const wxwxListStringNode&); }; class wxListString : public wxListBase { public: typedef wxwxListStringNode Node; class compatibility_iterator { public: compatibility_iterator(Node *ptr = __null) : m_ptr(ptr) { } Node *operator->() const { return m_ptr; } operator Node *() const { return m_ptr; } private: Node *m_ptr; }; wxListString(wxKeyType keyType = wxKEY_NONE) : wxListBase(keyType) { } wxListString(const wxListString& list) : wxListBase(list.GetKeyType()) { Assign(list); } wxListString(size_t count, wxString *elements[]) : wxListBase(count, (void **)elements) { } wxListString& operator=(const wxListString& list) { Assign(list); return *this; } wxwxListStringNode *GetFirst() const { return (wxwxListStringNode *)wxListBase::GetFirst(); } wxwxListStringNode *GetLast() const { return (wxwxListStringNode *)wxListBase::GetLast(); } wxwxListStringNode *Item(size_t index) const { return (wxwxListStringNode *)wxListBase::Item(index); } wxString *operator[](size_t index) const { wxwxListStringNode *node = Item(index); return node ? (wxString*)(node->GetData()) : (wxString*)__null; } wxwxListStringNode *Append(wxString *object) { return (wxwxListStringNode *)wxListBase::Append(object); } wxwxListStringNode *Insert(wxString *object) { return (wxwxListStringNode *)Insert((wxwxListStringNode*)__null, object); } wxwxListStringNode *Insert(size_t pos, wxString *object) { return (wxwxListStringNode *)wxListBase::Insert(pos, object); } wxwxListStringNode *Insert(wxwxListStringNode *prev, wxString *object) { return (wxwxListStringNode *)wxListBase::Insert(prev, object); } wxwxListStringNode *Append(long key, void *object) { return (wxwxListStringNode *)wxListBase::Append(key, object); } wxwxListStringNode *Append(const wxChar *key, void *object) { return (wxwxListStringNode *)wxListBase::Append(key, object); } wxwxListStringNode *DetachNode(wxwxListStringNode *node) { return (wxwxListStringNode *)wxListBase::DetachNode(node); } bool DeleteNode(wxwxListStringNode *node) { return wxListBase::DeleteNode(node); } bool DeleteObject(wxString *object) { return wxListBase::DeleteObject(object); } void Erase(wxwxListStringNode *it) { DeleteNode(it); } wxwxListStringNode *Find(const wxString *object) const { return (wxwxListStringNode *)wxListBase::Find(object); } virtual wxwxListStringNode *Find(const wxListKey& key) const { return (wxwxListStringNode *)wxListBase::Find(key); } int IndexOf(wxString *object) const { return wxListBase::IndexOf(object); } void Sort(wxSortCompareFunction func) { wxListBase::Sort(func); } void Sort(wxSortFuncFor_wxListString func) { Sort((wxSortCompareFunction)func); } protected: virtual wxNodeBase *CreateNode(wxNodeBase *prev, wxNodeBase *next, void *data, const wxListKey& key = wxDefaultListKey) { return new wxwxListStringNode(this, (wxwxListStringNode *)prev, (wxwxListStringNode *)next, (wxString *)data, key); } public: typedef size_t size_type; typedef int difference_type; typedef wxString* value_type; typedef wxString* base_value_type; typedef value_type& reference; typedef const value_type& const_reference; typedef base_value_type& base_reference; typedef const base_value_type& const_base_reference; class iterator { typedef wxListString list; public: typedef wxwxListStringNode Node; typedef iterator itor; typedef wxString* value_type; typedef value_type* ptr_type; typedef value_type& reference; Node* m_node; Node* m_init; public: typedef reference reference_type; typedef ptr_type pointer_type; iterator(Node* node, Node* init) : m_node(node), m_init(init) {} iterator() : m_node(__null), m_init(__null) { } reference_type operator*() const { return *(pointer_type)m_node->GetDataPtr(); } itor& operator++() { m_node = m_node->GetNext(); return *this; } const itor operator++(int) { itor tmp = *this; m_node = m_node->GetNext(); return tmp; } itor& operator--() { m_node = m_node ? m_node->GetPrevious() : m_init; return *this; } const itor operator--(int) { itor tmp = *this; m_node = m_node ? m_node->GetPrevious() : m_init; return tmp; } bool operator!=(const itor& it) const { return it.m_node != m_node; } bool operator==(const itor& it) const { return it.m_node == m_node; } }; class const_iterator { typedef wxListString list; public: typedef wxwxListStringNode Node; typedef wxString* value_type; typedef const value_type& const_reference; typedef const_iterator itor; typedef value_type* ptr_type; Node* m_node; Node* m_init; public: typedef const_reference reference_type; typedef const ptr_type pointer_type; const_iterator(Node* node, Node* init) : m_node(node), m_init(init) { } const_iterator() : m_node(__null), m_init(__null) { } const_iterator(const iterator& it) : m_node(it.m_node), m_init(it.m_init) { } reference_type operator*() const { return *(pointer_type)m_node->GetDataPtr(); } itor& operator++() { m_node = m_node->GetNext(); return *this; } const itor operator++(int) { itor tmp = *this; m_node = m_node->GetNext(); return tmp; } itor& operator--() { m_node = m_node ? m_node->GetPrevious() : m_init; return *this; } const itor operator--(int) { itor tmp = *this; m_node = m_node ? m_node->GetPrevious() : m_init; return tmp; } bool operator!=(const itor& it) const { return it.m_node != m_node; } bool operator==(const itor& it) const { return it.m_node == m_node; } }; class reverse_iterator { typedef wxListString list; public: typedef wxwxListStringNode Node; typedef wxString* value_type; typedef reverse_iterator itor; typedef value_type* ptr_type; typedef value_type& reference; Node* m_node; Node* m_init; public: typedef reference reference_type; typedef ptr_type pointer_type; reverse_iterator(Node* node, Node* init) : m_node(node), m_init(init) { } reverse_iterator() : m_node(__null), m_init(__null) { } reference_type operator*() const { return *(pointer_type)m_node->GetDataPtr(); } itor& operator++() { m_node = m_node->GetPrevious(); return *this; } const itor operator++(int) { itor tmp = *this; m_node = m_node->GetPrevious(); return tmp; } itor& operator--() { m_node = m_node ? m_node->GetNext() : m_init; return *this; } const itor operator--(int) { itor tmp = *this; m_node = m_node ? m_node->GetNext() : m_init; return tmp; } bool operator!=(const itor& it) const { return it.m_node != m_node; } bool operator==(const itor& it) const { return it.m_node == m_node; } }; class const_reverse_iterator { typedef wxListString list; public: typedef wxwxListStringNode Node; typedef wxString* value_type; typedef const_reverse_iterator itor; typedef value_type* ptr_type; typedef const value_type& const_reference; Node* m_node; Node* m_init; public: typedef const_reference reference_type; typedef const ptr_type pointer_type; const_reverse_iterator(Node* node, Node* init) : m_node(node), m_init(init) { } const_reverse_iterator() : m_node(__null), m_init(__null) { } const_reverse_iterator(const reverse_iterator& it) : m_node(it.m_node), m_init(it.m_init) { } reference_type operator*() const { return *(pointer_type)m_node->GetDataPtr(); } itor& operator++() { m_node = m_node->GetPrevious(); return *this; } const itor operator++(int) { itor tmp = *this; m_node = m_node->GetPrevious(); return tmp; } itor& operator--() { m_node = m_node ? m_node->GetNext() : m_init; return *this;} const itor operator--(int) { itor tmp = *this; m_node = m_node ? m_node->GetNext() : m_init; return tmp; } bool operator!=(const itor& it) const { return it.m_node != m_node; } bool operator==(const itor& it) const { return it.m_node == m_node; } }; explicit wxListString(size_type n, const_reference v = value_type()) { assign(n, v); } wxListString(const const_iterator& first, const const_iterator& last) { assign(first, last); } iterator begin() { return iterator(GetFirst(), GetLast()); } const_iterator begin() const { return const_iterator(GetFirst(), GetLast()); } iterator end() { return iterator(__null, GetLast()); } const_iterator end() const { return const_iterator(__null, GetLast()); } reverse_iterator rbegin() { return reverse_iterator(GetLast(), GetFirst()); } const_reverse_iterator rbegin() const { return const_reverse_iterator(GetLast(), GetFirst()); } reverse_iterator rend() { return reverse_iterator(__null, GetFirst()); } const_reverse_iterator rend() const { return const_reverse_iterator(__null, GetFirst()); } void resize(size_type n, value_type v = value_type()) { while (n < size()) pop_back(); while (n > size()) push_back(v); } size_type size() const { return GetCount(); } size_type max_size() const { return 2147483647; } bool empty() const { return IsEmpty(); } reference front() { return *begin(); } const_reference front() const { return *begin(); } reference back() { iterator tmp = end(); return *--tmp; } const_reference back() const { const_iterator tmp = end(); return *--tmp; } void push_front(const_reference v = value_type()) { Insert(GetFirst(), (const_base_reference)v); } void pop_front() { DeleteNode(GetFirst()); } void push_back(const_reference v = value_type()) { Append((const_base_reference)v); } void pop_back() { DeleteNode(GetLast()); } void assign(const_iterator first, const const_iterator& last) { clear(); for(; first != last; ++first) Append((const_base_reference)*first); } void assign(size_type n, const_reference v = value_type()) { clear(); for(size_type i = 0; i < n; ++i) Append((const_base_reference)v); } iterator insert(const iterator& it, const_reference v = value_type()) { if ( it == end() ) Append((const_base_reference)v); else Insert(it.m_node, (const_base_reference)v); iterator itprev(it); return itprev--; } void insert(const iterator& it, size_type n, const_reference v = value_type()) { for(size_type i = 0; i < n; ++i) insert(it, v); } void insert(const iterator& it, const_iterator first, const const_iterator& last) { for(; first != last; ++first) insert(it, *first); } iterator erase(const iterator& it) { iterator next = iterator(it.m_node->GetNext(), GetLast()); DeleteNode(it.m_node); return next; } iterator erase(const iterator& first, const iterator& last) { iterator next = last; if ( next != end() ) ++next; DeleteNodes(first.m_node, last.m_node); return next; } void clear() { Clear(); } void splice(const iterator& it, wxListString& l, const iterator& first, const iterator& last) { insert(it, first, last); l.erase(first, last); } void splice(const iterator& it, wxListString& l) { splice(it, l, l.begin(), l.end() ); } void splice(const iterator& it, wxListString& l, const iterator& first) { if ( it != first ) { insert(it, *first); l.erase(first); } } void remove(const_reference v) { DeleteObject((const_base_reference)v); } void reverse() { Reverse(); } };
# 40 "/usr/include/wx-2.8/wx/statusbr.h"
class wxStatusBarBase : public wxWindow
{
public:
    wxStatusBarBase();

    virtual ~wxStatusBarBase();






    virtual void SetFieldsCount(int number = 1, const int *widths = __null);
    int GetFieldsCount() const { return m_nFields; }




    virtual void SetStatusText(const wxString& text, int number = 0) = 0;
    virtual wxString GetStatusText(int number = 0) const = 0;

    void PushStatusText(const wxString& text, int number = 0);
    void PopStatusText(int number = 0);
# 73 "/usr/include/wx-2.8/wx/statusbr.h"
    virtual void SetStatusWidths(int n, const int widths[]);
# 82 "/usr/include/wx-2.8/wx/statusbr.h"
    virtual void SetStatusStyles(int n, const int styles[]);





    virtual bool GetFieldRect(int i, wxRect& rect) const = 0;


    virtual void SetMinHeight(int height) = 0;


    virtual int GetBorderX() const = 0;
    virtual int GetBorderY() const = 0;


    virtual bool AcceptsFocus() const { return false; }

protected:

    void InitWidths();


    void FreeWidths();


    void ReinitWidths() { FreeWidths(); InitWidths(); }


    void InitStyles();
    void FreeStyles();
    void ReinitStyles() { FreeStyles(); InitStyles(); }


    void InitStacks();
    void FreeStacks();
    void ReinitStacks() { FreeStacks(); InitStacks(); }


    wxArrayInt CalculateAbsWidths(wxCoord widthTotal) const;


    wxListString *GetStatusStack(int i) const;
    wxListString *GetOrCreateStatusStack(int i);


    int m_nFields;



    int *m_statusWidths;


    int *m_statusStyles;



    wxListString **m_statusTextStacks;

    private: wxStatusBarBase(const wxStatusBarBase&); wxStatusBarBase& operator=(const wxStatusBarBase&);
};
# 168 "/usr/include/wx-2.8/wx/statusbr.h"
# 1 "/usr/include/wx-2.8/wx/generic/statusbr.h" 1
# 22 "/usr/include/wx-2.8/wx/generic/statusbr.h"
class wxStatusBar : public wxStatusBarBase
{
public:
    wxStatusBar() { Init(); }
    wxStatusBar(wxWindow *parent,
                       wxWindowID winid = wxID_ANY,
                       long style = 0x0010,
                       const wxString& name = wxStatusBarNameStr)
    {
        Init();

        Create(parent, winid, style, name);
    }

    virtual ~wxStatusBar();

    bool Create(wxWindow *parent, wxWindowID winid = wxID_ANY,
                long style = 0x0010,
                const wxString& name = wxStatusBarNameStr);


    virtual void SetFieldsCount(int number = 1,
                                const int *widths = (const int *) __null);


    virtual void SetStatusText(const wxString& text, int number = 0);
    virtual wxString GetStatusText(int number = 0) const;


    virtual void SetStatusWidths(int n, const int widths_field[]);


    virtual bool GetFieldRect(int i, wxRect& rect) const;


    virtual void SetMinHeight(int height);

    virtual int GetBorderX() const { return m_borderX; }
    virtual int GetBorderY() const { return m_borderY; }




    virtual void DrawFieldText(wxDC& dc, int i);
    virtual void DrawField(wxDC& dc, int i);

    void SetBorderX(int x);
    void SetBorderY(int y);

    void OnPaint(wxPaintEvent& event);

    void OnLeftDown(wxMouseEvent& event);
    void OnRightDown(wxMouseEvent& event);

    virtual void InitColours();


    void OnSysColourChanged(wxSysColourChangedEvent& event);

protected:

    void Init();

    wxArrayString m_statusStrings;


    int m_lastClientWidth;

    wxArrayInt m_widthsAbs;

    int m_borderX;
    int m_borderY;
    wxPen m_mediumShadowPen;
    wxPen m_hilightPen;

    virtual wxSize DoGetBestSize() const;

private:
    private: static const wxEventTableEntry sm_eventTableEntries[]; protected: static const wxEventTable sm_eventTable; virtual const wxEventTable* GetEventTable() const; static wxEventHashTable sm_eventHashTable; virtual wxEventHashTable& GetEventHashTable() const;
    private: wxStatusBar(const wxStatusBar&); wxStatusBar& operator=(const wxStatusBar&); public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};
# 169 "/usr/include/wx-2.8/wx/statusbr.h" 2
# 92 "/usr/include/wx-2.8/wx/wx.h" 2
# 1 "/usr/include/wx-2.8/wx/choicdlg.h" 1
# 17 "/usr/include/wx-2.8/wx/choicdlg.h"
# 1 "/usr/include/wx-2.8/wx/generic/choicdgg.h" 1
# 18 "/usr/include/wx-2.8/wx/generic/choicdgg.h"
class wxListBoxBase;
# 39 "/usr/include/wx-2.8/wx/generic/choicdgg.h"
class wxAnyChoiceDialog : public wxDialog
{
public:
    wxAnyChoiceDialog() { }

    wxAnyChoiceDialog(wxWindow *parent,
                      const wxString& message,
                      const wxString& caption,
                      int n, const wxString *choices,
                      long styleDlg = ((0x20000000 | 0x0800 | 0x1000) | 0x0040 | 0x00000004 | 0x00000010 | wxCENTRE),
                      const wxPoint& pos = wxDefaultPosition,
                      long styleLbox = 0x0400)
    {
        (void)Create(parent, message, caption, n, choices,
                     styleDlg, pos, styleLbox);
    }
    wxAnyChoiceDialog(wxWindow *parent,
                      const wxString& message,
                      const wxString& caption,
                      const wxArrayString& choices,
                      long styleDlg = ((0x20000000 | 0x0800 | 0x1000) | 0x0040 | 0x00000004 | 0x00000010 | wxCENTRE),
                      const wxPoint& pos = wxDefaultPosition,
                      long styleLbox = 0x0400)
    {
        (void)Create(parent, message, caption, choices,
                     styleDlg, pos, styleLbox);
    }

    bool Create(wxWindow *parent,
                const wxString& message,
                const wxString& caption,
                int n, const wxString *choices,
                long styleDlg = ((0x20000000 | 0x0800 | 0x1000) | 0x0040 | 0x00000004 | 0x00000010 | wxCENTRE),
                const wxPoint& pos = wxDefaultPosition,
                long styleLbox = 0x0400);
    bool Create(wxWindow *parent,
                const wxString& message,
                const wxString& caption,
                const wxArrayString& choices,
                long styleDlg = ((0x20000000 | 0x0800 | 0x1000) | 0x0040 | 0x00000004 | 0x00000010 | wxCENTRE),
                const wxPoint& pos = wxDefaultPosition,
                long styleLbox = 0x0400);

protected:
    wxListBoxBase *m_listbox;

    virtual wxListBoxBase *CreateList(int n,
                                      const wxString *choices,
                                      long styleLbox);

    private: wxAnyChoiceDialog(const wxAnyChoiceDialog&); wxAnyChoiceDialog& operator=(const wxAnyChoiceDialog&);
};





class wxSingleChoiceDialog : public wxAnyChoiceDialog
{
public:
    wxSingleChoiceDialog()
    {
        m_selection = -1;
    }

    wxSingleChoiceDialog(wxWindow *parent,
                         const wxString& message,
                         const wxString& caption,
                         int n,
                         const wxString *choices,
                         char **clientData = (char **)__null,
                         long style = ((0x20000000 | 0x0800 | 0x1000) | 0x0040 | 0x00000004 | 0x00000010 | wxCENTRE),
                         const wxPoint& pos = wxDefaultPosition);
    wxSingleChoiceDialog(wxWindow *parent,
                         const wxString& message,
                         const wxString& caption,
                         const wxArrayString& choices,
                         char **clientData = (char **)__null,
                         long style = ((0x20000000 | 0x0800 | 0x1000) | 0x0040 | 0x00000004 | 0x00000010 | wxCENTRE),
                         const wxPoint& pos = wxDefaultPosition);

    bool Create(wxWindow *parent,
                const wxString& message,
                const wxString& caption,
                int n,
                const wxString *choices,
                char **clientData = (char **)__null,
                long style = ((0x20000000 | 0x0800 | 0x1000) | 0x0040 | 0x00000004 | 0x00000010 | wxCENTRE),
                const wxPoint& pos = wxDefaultPosition);
    bool Create(wxWindow *parent,
                const wxString& message,
                const wxString& caption,
                const wxArrayString& choices,
                char **clientData = (char **)__null,
                long style = ((0x20000000 | 0x0800 | 0x1000) | 0x0040 | 0x00000004 | 0x00000010 | wxCENTRE),
                const wxPoint& pos = wxDefaultPosition);

    void SetSelection(int sel);
    int GetSelection() const { return m_selection; }
    wxString GetStringSelection() const { return m_stringSelection; }


    char *GetSelectionClientData() const { return (char *)m_clientData; }


    void OnOK(wxCommandEvent& event);

    void OnListBoxDClick(wxCommandEvent& event);





protected:
    int m_selection;
    wxString m_stringSelection;

    void DoChoice();

private:
    private: wxSingleChoiceDialog(const wxSingleChoiceDialog&); wxSingleChoiceDialog& operator=(const wxSingleChoiceDialog&); public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
    private: static const wxEventTableEntry sm_eventTableEntries[]; protected: static const wxEventTable sm_eventTable; virtual const wxEventTable* GetEventTable() const; static wxEventHashTable sm_eventHashTable; virtual wxEventHashTable& GetEventHashTable() const;
};





class wxMultiChoiceDialog : public wxAnyChoiceDialog
{
public:
    wxMultiChoiceDialog() { }

    wxMultiChoiceDialog(wxWindow *parent,
                        const wxString& message,
                        const wxString& caption,
                        int n,
                        const wxString *choices,
                        long style = ((0x20000000 | 0x0800 | 0x1000) | 0x0040 | 0x00000004 | 0x00000010 | wxCENTRE),
                        const wxPoint& pos = wxDefaultPosition)
    {
        (void)Create(parent, message, caption, n, choices, style, pos);
    }
    wxMultiChoiceDialog(wxWindow *parent,
                        const wxString& message,
                        const wxString& caption,
                        const wxArrayString& choices,
                        long style = ((0x20000000 | 0x0800 | 0x1000) | 0x0040 | 0x00000004 | 0x00000010 | wxCENTRE),
                        const wxPoint& pos = wxDefaultPosition)
    {
        (void)Create(parent, message, caption, choices, style, pos);
    }

    bool Create(wxWindow *parent,
                const wxString& message,
                const wxString& caption,
                int n,
                const wxString *choices,
                long style = ((0x20000000 | 0x0800 | 0x1000) | 0x0040 | 0x00000004 | 0x00000010 | wxCENTRE),
                const wxPoint& pos = wxDefaultPosition);
    bool Create(wxWindow *parent,
                const wxString& message,
                const wxString& caption,
                const wxArrayString& choices,
                long style = ((0x20000000 | 0x0800 | 0x1000) | 0x0040 | 0x00000004 | 0x00000010 | wxCENTRE),
                const wxPoint& pos = wxDefaultPosition);

    void SetSelections(const wxArrayInt& selections);
    wxArrayInt GetSelections() const { return m_selections; }


    virtual bool TransferDataFromWindow();

protected:

    virtual wxListBoxBase *CreateList(int n,
                                      const wxString *choices,
                                      long styleLbox);


    wxArrayInt m_selections;

private:
    private: wxMultiChoiceDialog(const wxMultiChoiceDialog&); wxMultiChoiceDialog& operator=(const wxMultiChoiceDialog&); public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};






 wxString wxGetSingleChoice(const wxString& message,
                                       const wxString& caption,
                                       const wxArrayString& choices,
                                       wxWindow *parent = __null,
                                       int x = wxDefaultCoord,
                                       int y = wxDefaultCoord,
                                       bool centre = true,
                                       int width = 200,
                                       int height = 150);

 wxString wxGetSingleChoice(const wxString& message,
                                       const wxString& caption,
                                       int n, const wxString *choices,
                                       wxWindow *parent = __null,
                                       int x = wxDefaultCoord,
                                       int y = wxDefaultCoord,
                                       bool centre = true,
                                       int width = 200,
                                       int height = 150);



 int wxGetSingleChoiceIndex(const wxString& message,
                                       const wxString& caption,
                                       const wxArrayString& choices,
                                       wxWindow *parent = __null,
                                       int x = wxDefaultCoord,
                                       int y = wxDefaultCoord,
                                       bool centre = true,
                                       int width = 200,
                                       int height = 150);

 int wxGetSingleChoiceIndex(const wxString& message,
                                       const wxString& caption,
                                       int n, const wxString *choices,
                                       wxWindow *parent = __null,
                                       int x = wxDefaultCoord,
                                       int y = wxDefaultCoord,
                                       bool centre = true,
                                       int width = 200,
                                       int height = 150);


 void* wxGetSingleChoiceData(const wxString& message,
                                        const wxString& caption,
                                        const wxArrayString& choices,
                                        void **client_data,
                                        wxWindow *parent = __null,
                                        int x = wxDefaultCoord,
                                        int y = wxDefaultCoord,
                                        bool centre = true,
                                        int width = 200,
                                        int height = 150);

 void* wxGetSingleChoiceData(const wxString& message,
                                        const wxString& caption,
                                        int n, const wxString *choices,
                                        void **client_data,
                                        wxWindow *parent = __null,
                                        int x = wxDefaultCoord,
                                        int y = wxDefaultCoord,
                                        bool centre = true,
                                        int width = 200,
                                        int height = 150);




 size_t wxGetMultipleChoices(wxArrayInt& selections,
                                        const wxString& message,
                                        const wxString& caption,
                                        int n, const wxString *choices,
                                        wxWindow *parent = __null,
                                        int x = wxDefaultCoord,
                                        int y = wxDefaultCoord,
                                        bool centre = true,
                                        int width = 200,
                                        int height = 150);

 size_t wxGetMultipleChoices(wxArrayInt& selections,
                                        const wxString& message,
                                        const wxString& caption,
                                        const wxArrayString& choices,
                                        wxWindow *parent = __null,
                                        int x = wxDefaultCoord,
                                        int y = wxDefaultCoord,
                                        bool centre = true,
                                        int width = 200,
                                        int height = 150);
# 18 "/usr/include/wx-2.8/wx/choicdlg.h" 2
# 93 "/usr/include/wx-2.8/wx/wx.h" 2
# 1 "/usr/include/wx-2.8/wx/textdlg.h" 1
# 15 "/usr/include/wx-2.8/wx/textdlg.h"
# 1 "/usr/include/wx-2.8/wx/generic/textdlgg.h" 1
# 22 "/usr/include/wx-2.8/wx/generic/textdlgg.h"
# 1 "/usr/include/wx-2.8/wx/valtext.h" 1
# 32 "/usr/include/wx-2.8/wx/valtext.h"
class wxTextValidator: public wxValidator
{
public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
public:

    wxTextValidator(long style = 0x0000, wxString *val = 0);
    wxTextValidator(const wxTextValidator& val);

    virtual ~wxTextValidator(){}





    virtual wxObject *Clone() const { return new wxTextValidator(*this); }
    bool Copy(const wxTextValidator& val);



    virtual bool Validate(wxWindow *parent);


    virtual bool TransferToWindow();


    virtual bool TransferFromWindow();


    inline long GetStyle() const { return m_validatorStyle; }
    inline void SetStyle(long style) { m_validatorStyle = style; }
# 74 "/usr/include/wx-2.8/wx/valtext.h"
    void SetIncludes(const wxArrayString& includes) { m_includes = includes; }
    inline wxArrayString& GetIncludes() { return m_includes; }

    void SetExcludes(const wxArrayString& excludes) { m_excludes = excludes; }
    inline wxArrayString& GetExcludes() { return m_excludes; }

    bool IsInCharIncludes(const wxString& val);
    bool IsNotInCharExcludes(const wxString& val);


    void OnChar(wxKeyEvent& event);


private: static const wxEventTableEntry sm_eventTableEntries[]; protected: static const wxEventTable sm_eventTable; virtual const wxEventTable* GetEventTable() const; static wxEventHashTable sm_eventHashTable; virtual wxEventHashTable& GetEventHashTable() const;

protected:
    long m_validatorStyle;
    wxString * m_stringValue;




    wxArrayString m_includes;
    wxArrayString m_excludes;

    bool CheckValidator() const
    {
        if ( m_validatorWindow ) ; else { ; return false; } typedef int wxDummyCheckInt;

        if ( m_validatorWindow->IsKindOf((&wxTextCtrl::ms_classInfo)) ) ; else { ; return false; } typedef int wxDummyCheckInt;


        return true;
    }

private:





    wxTextValidator& operator=(const wxTextValidator&);
};
# 23 "/usr/include/wx-2.8/wx/generic/textdlgg.h" 2


class wxTextCtrl;

extern const wxChar wxGetTextFromUserPromptStr[];
extern const wxChar wxGetPasswordFromUserPromptStr[];







class wxTextEntryDialog : public wxDialog
{
public:
    wxTextEntryDialog(wxWindow *parent,
                      const wxString& message,
                      const wxString& caption = wxGetTextFromUserPromptStr,
                      const wxString& value = wxEmptyString,
                      long style = (0x00000004 | 0x00000010 | wxCENTRE | 0x00000001),
                      const wxPoint& pos = wxDefaultPosition);

    void SetValue(const wxString& val);
    wxString GetValue() const { return m_value; }


    void SetTextValidator( const wxTextValidator& validator );
    void SetTextValidator( long style = 0x0000 );
    wxTextValidator* GetTextValidator() { return (wxTextValidator*)m_textctrl->GetValidator(); }




    void OnOK(wxCommandEvent& event);

protected:
    wxTextCtrl *m_textctrl;
    wxString m_value;
    long m_dialogStyle;

private:
    private: static const wxEventTableEntry sm_eventTableEntries[]; protected: static const wxEventTable sm_eventTable; virtual const wxEventTable* GetEventTable() const; static wxEventHashTable sm_eventHashTable; virtual wxEventHashTable& GetEventHashTable() const;
    public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
    private: wxTextEntryDialog(const wxTextEntryDialog&); wxTextEntryDialog& operator=(const wxTextEntryDialog&);
};





class wxPasswordEntryDialog : public wxTextEntryDialog
{
public:
    wxPasswordEntryDialog(wxWindow *parent,
                      const wxString& message,
                      const wxString& caption = wxGetPasswordFromUserPromptStr,
                      const wxString& value = wxEmptyString,
                      long style = (0x00000004 | 0x00000010 | wxCENTRE | 0x00000001),
                      const wxPoint& pos = wxDefaultPosition);
private:
    public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
    private: wxPasswordEntryDialog(const wxPasswordEntryDialog&); wxPasswordEntryDialog& operator=(const wxPasswordEntryDialog&);
};





wxString
wxGetTextFromUser(const wxString& message,
                  const wxString& caption = wxGetTextFromUserPromptStr,
                  const wxString& default_value = wxEmptyString,
                  wxWindow *parent = (wxWindow *) __null,
                  wxCoord x = wxDefaultCoord,
                  wxCoord y = wxDefaultCoord,
                  bool centre = true);

wxString
wxGetPasswordFromUser(const wxString& message,
                      const wxString& caption = wxGetPasswordFromUserPromptStr,
                      const wxString& default_value = wxEmptyString,
                      wxWindow *parent = (wxWindow *) __null,
                      wxCoord x = wxDefaultCoord,
                      wxCoord y = wxDefaultCoord,
                      bool centre = true);
# 16 "/usr/include/wx-2.8/wx/textdlg.h" 2
# 94 "/usr/include/wx-2.8/wx/wx.h" 2
# 1 "/usr/include/wx-2.8/wx/filedlg.h" 1
# 36 "/usr/include/wx-2.8/wx/filedlg.h"
enum
{
    wxFD_OPEN = 0x0001,
    wxFD_SAVE = 0x0002,
    wxFD_OVERWRITE_PROMPT = 0x0004,
    wxFD_FILE_MUST_EXIST = 0x0010,
    wxFD_MULTIPLE = 0x0020,
    wxFD_CHANGE_DIR = 0x0080,
    wxFD_PREVIEW = 0x0100
};


enum
{
    wxOPEN = wxFD_OPEN,
    wxSAVE = wxFD_SAVE,
    wxOVERWRITE_PROMPT = wxFD_OVERWRITE_PROMPT,



    wxFILE_MUST_EXIST = wxFD_FILE_MUST_EXIST,
    wxMULTIPLE = wxFD_MULTIPLE,
    wxCHANGE_DIR = wxFD_CHANGE_DIR
};




extern const wxChar wxFileDialogNameStr[];
extern const wxChar wxFileSelectorPromptStr[];
extern const wxChar wxFileSelectorDefaultWildcardStr[];





class wxFileDialogBase: public wxDialog
{
public:
    wxFileDialogBase () { Init(); }

    wxFileDialogBase(wxWindow *parent,
                     const wxString& message = wxFileSelectorPromptStr,
                     const wxString& defaultDir = wxEmptyString,
                     const wxString& defaultFile = wxEmptyString,
                     const wxString& wildCard = wxFileSelectorDefaultWildcardStr,
                     long style = wxFD_OPEN,
                     const wxPoint& pos = wxDefaultPosition,
                     const wxSize& sz = wxDefaultSize,
                     const wxString& name = wxFileDialogNameStr)
    {
        Init();
        Create(parent, message, defaultDir, defaultFile, wildCard, style, pos, sz, name);
    }

    bool Create(wxWindow *parent,
                const wxString& message = wxFileSelectorPromptStr,
                const wxString& defaultDir = wxEmptyString,
                const wxString& defaultFile = wxEmptyString,
                const wxString& wildCard = wxFileSelectorDefaultWildcardStr,
                long style = wxFD_OPEN,
                const wxPoint& pos = wxDefaultPosition,
                const wxSize& sz = wxDefaultSize,
                const wxString& name = wxFileDialogNameStr);

    bool HasFdFlag(int flag) const { return HasFlag(flag); }

    virtual void SetMessage(const wxString& message) { m_message = message; }
    virtual void SetPath(const wxString& path) { m_path = path; }
    virtual void SetDirectory(const wxString& dir) { m_dir = dir; }
    virtual void SetFilename(const wxString& name) { m_fileName = name; }
    virtual void SetWildcard(const wxString& wildCard) { m_wildCard = wildCard; }
    virtual void SetFilterIndex(int filterIndex) { m_filterIndex = filterIndex; }

    virtual wxString GetMessage() const { return m_message; }
    virtual wxString GetPath() const { return m_path; }
    virtual void GetPaths(wxArrayString& paths) const { paths.Empty(); paths.Add(m_path); }
    virtual wxString GetDirectory() const { return m_dir; }
    virtual wxString GetFilename() const { return m_fileName; }
    virtual void GetFilenames(wxArrayString& files) const { files.Empty(); files.Add(m_fileName); }
    virtual wxString GetWildcard() const { return m_wildCard; }
    virtual int GetFilterIndex() const { return m_filterIndex; }
# 134 "/usr/include/wx-2.8/wx/filedlg.h"
    long GetStyle() const __attribute__ ((deprecated));
    void SetStyle(long style) __attribute__ ((deprecated));
# 144 "/usr/include/wx-2.8/wx/filedlg.h"
    static wxString AppendExtension(const wxString &filePath,
                                    const wxString &extensionList);

protected:
    wxString m_message;
    wxString m_dir;
    wxString m_path;
    wxString m_fileName;
    wxString m_wildCard;
    int m_filterIndex;

private:
    void Init();
    public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
    private: wxFileDialogBase(const wxFileDialogBase&); wxFileDialogBase& operator=(const wxFileDialogBase&);
};






 wxString
wxFileSelector(const wxChar *message = wxFileSelectorPromptStr,
               const wxChar *default_path = __null,
               const wxChar *default_filename = __null,
               const wxChar *default_extension = __null,
               const wxChar *wildcard = wxFileSelectorDefaultWildcardStr,
               int flags = 0,
               wxWindow *parent = __null,
               int x = wxDefaultCoord, int y = wxDefaultCoord);


 wxString
wxFileSelectorEx(const wxChar *message = wxFileSelectorPromptStr,
                 const wxChar *default_path = __null,
                 const wxChar *default_filename = __null,
                 int *indexDefaultExtension = __null,
                 const wxChar *wildcard = wxFileSelectorDefaultWildcardStr,
                 int flags = 0,
                 wxWindow *parent = __null,
                 int x = wxDefaultCoord, int y = wxDefaultCoord);


 wxString
wxLoadFileSelector(const wxChar *what,
                   const wxChar *extension,
                   const wxChar *default_name = (const wxChar *)__null,
                   wxWindow *parent = (wxWindow *) __null);


 wxString
wxSaveFileSelector(const wxChar *what,
                   const wxChar *extension,
                   const wxChar *default_name = (const wxChar *) __null,
                   wxWindow *parent = (wxWindow *) __null);
# 210 "/usr/include/wx-2.8/wx/filedlg.h"
# 1 "/usr/include/wx-2.8/wx/gtk/filedlg.h" 1
# 13 "/usr/include/wx-2.8/wx/gtk/filedlg.h"
# 1 "/usr/include/wx-2.8/wx/generic/filedlgg.h" 1
# 15 "/usr/include/wx-2.8/wx/generic/filedlgg.h"
# 1 "/usr/include/wx-2.8/wx/listctrl.h" 1
# 19 "/usr/include/wx-2.8/wx/listctrl.h"
# 1 "/usr/include/wx-2.8/wx/listbase.h" 1
# 25 "/usr/include/wx-2.8/wx/listbase.h"
typedef int ( *wxListCtrlCompare)(long item1, long item2, long sortData);
# 106 "/usr/include/wx-2.8/wx/listbase.h"
enum
{
    wxLIST_NEXT_ABOVE,
    wxLIST_NEXT_ALL,
    wxLIST_NEXT_BELOW,
    wxLIST_NEXT_LEFT,
    wxLIST_NEXT_RIGHT
};


enum
{
    wxLIST_ALIGN_DEFAULT,
    wxLIST_ALIGN_LEFT,
    wxLIST_ALIGN_TOP,
    wxLIST_ALIGN_SNAP_TO_GRID
};


enum wxListColumnFormat
{
    wxLIST_FORMAT_LEFT,
    wxLIST_FORMAT_RIGHT,
    wxLIST_FORMAT_CENTRE,
    wxLIST_FORMAT_CENTER = wxLIST_FORMAT_CENTRE
};


enum
{
    wxLIST_AUTOSIZE = -1,
    wxLIST_AUTOSIZE_USEHEADER = -2
};


enum
{
    wxLIST_RECT_BOUNDS,
    wxLIST_RECT_ICON,
    wxLIST_RECT_LABEL
};


enum
{
    wxLIST_FIND_UP,
    wxLIST_FIND_DOWN,
    wxLIST_FIND_LEFT,
    wxLIST_FIND_RIGHT
};
# 164 "/usr/include/wx-2.8/wx/listbase.h"
class wxListItemAttr
{
public:

    wxListItemAttr() { }
    wxListItemAttr(const wxColour& colText,
                   const wxColour& colBack,
                   const wxFont& font)
        : m_colText(colText), m_colBack(colBack), m_font(font)
    {
    }





    void SetTextColour(const wxColour& colText) { m_colText = colText; }
    void SetBackgroundColour(const wxColour& colBack) { m_colBack = colBack; }
    void SetFont(const wxFont& font) { m_font = font; }


    bool HasTextColour() const { return m_colText.Ok(); }
    bool HasBackgroundColour() const { return m_colBack.Ok(); }
    bool HasFont() const { return m_font.Ok(); }

    const wxColour& GetTextColour() const { return m_colText; }
    const wxColour& GetBackgroundColour() const { return m_colBack; }
    const wxFont& GetFont() const { return m_font; }




    void AssignFrom(const wxListItemAttr& source)
    {
        if ( source.HasTextColour() )
            SetTextColour(source.GetTextColour());
        if ( source.HasBackgroundColour() )
            SetBackgroundColour(source.GetBackgroundColour());
        if ( source.HasFont() )
            SetFont(source.GetFont());
    }

private:
    wxColour m_colText,
             m_colBack;
    wxFont m_font;
};





class wxListItem : public wxObject
{
public:
    wxListItem() { Init(); m_attr = __null; }
    wxListItem(const wxListItem& item)
        : wxObject(),
          m_mask(item.m_mask),
          m_itemId(item.m_itemId),
          m_col(item.m_col),
          m_state(item.m_state),
          m_stateMask(item.m_stateMask),
          m_text(item.m_text),
          m_image(item.m_image),
          m_data(item.m_data),
          m_format(item.m_format),
          m_width(item.m_width),
          m_attr(__null)
    {

        if ( item.HasAttributes() )
            m_attr = new wxListItemAttr(*item.GetAttributes());
    }
    virtual ~wxListItem() { delete m_attr; }


    void Clear() { Init(); m_text.clear(); ClearAttributes(); }
    void ClearAttributes() { if ( m_attr ) { delete m_attr; m_attr = __null; } }


    void SetMask(long mask)
        { m_mask = mask; }
    void SetId(long id)
        { m_itemId = id; }
    void SetColumn(int col)
        { m_col = col; }
    void SetState(long state)
        { m_mask |= 0x0001; m_state = state; m_stateMask |= state; }
    void SetStateMask(long stateMask)
        { m_stateMask = stateMask; }
    void SetText(const wxString& text)
        { m_mask |= 0x0002; m_text = text; }
    void SetImage(int image)
        { m_mask |= 0x0004; m_image = image; }
    void SetData(long data)
        { m_mask |= 0x0008; m_data = data; }
    void SetData(void *data)
        { m_mask |= 0x0008; m_data = wxPtrToUInt(data); }

    void SetWidth(int width)
        { m_mask |= 0x0020; m_width = width; }
    void SetAlign(wxListColumnFormat align)
        { m_mask |= 0x0040; m_format = align; }

    void SetTextColour(const wxColour& colText)
        { Attributes().SetTextColour(colText); }
    void SetBackgroundColour(const wxColour& colBack)
        { Attributes().SetBackgroundColour(colBack); }
    void SetFont(const wxFont& font)
        { Attributes().SetFont(font); }


    long GetMask() const { return m_mask; }
    long GetId() const { return m_itemId; }
    int GetColumn() const { return m_col; }
    long GetState() const { return m_state & m_stateMask; }
    const wxString& GetText() const { return m_text; }
    int GetImage() const { return m_image; }
    wxUIntPtr GetData() const { return m_data; }

    int GetWidth() const { return m_width; }
    wxListColumnFormat GetAlign() const { return (wxListColumnFormat)m_format; }

    wxListItemAttr *GetAttributes() const { return m_attr; }
    bool HasAttributes() const { return m_attr != __null; }

    wxColour GetTextColour() const
        { return HasAttributes() ? m_attr->GetTextColour() : wxNullColour; }
    wxColour GetBackgroundColour() const
        { return HasAttributes() ? m_attr->GetBackgroundColour()
                                 : wxNullColour; }
    wxFont GetFont() const
        { return HasAttributes() ? m_attr->GetFont() : wxNullFont; }



    operator long() const { return m_itemId; }



    long m_mask;
    long m_itemId;
    int m_col;
    long m_state;
    long m_stateMask;
    wxString m_text;
    int m_image;
    wxUIntPtr m_data;


    int m_format;
    int m_width;





protected:

    wxListItemAttr& Attributes()
    {
        if ( !m_attr )
            m_attr = new wxListItemAttr;

        return *m_attr;
    }

    void Init()
    {
        m_mask = 0;
        m_itemId = 0;
        m_col = 0;
        m_state = 0;
        m_stateMask = 0;
        m_image = -1;
        m_data = 0;

        m_format = wxLIST_FORMAT_CENTRE;
        m_width = 0;
    }

    wxListItemAttr *m_attr;

private:

    wxListItem& operator=(const wxListItem& item);

    public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};





class wxListEvent : public wxNotifyEvent
{
public:
    wxListEvent(wxEventType commandType = wxEVT_NULL, int winid = 0)
        : wxNotifyEvent(commandType, winid)
        , m_code(0)
        , m_oldItemIndex(0)
        , m_itemIndex(0)
        , m_col(0)
        , m_pointDrag()
        , m_item()
        , m_editCancelled(false)
        { }

    wxListEvent(const wxListEvent& event)
        : wxNotifyEvent(event)
        , m_code(event.m_code)
        , m_oldItemIndex(event.m_oldItemIndex)
        , m_itemIndex(event.m_itemIndex)
        , m_col(event.m_col)
        , m_pointDrag(event.m_pointDrag)
        , m_item(event.m_item)
        , m_editCancelled(event.m_editCancelled)
        { }

    int GetKeyCode() const { return m_code; }
    long GetIndex() const { return m_itemIndex; }
    int GetColumn() const { return m_col; }
    wxPoint GetPoint() const { return m_pointDrag; }
    const wxString& GetLabel() const { return m_item.m_text; }
    const wxString& GetText() const { return m_item.m_text; }
    int GetImage() const { return m_item.m_image; }
    long GetData() const { return static_cast<long>(m_item.m_data); }
    long GetMask() const { return m_item.m_mask; }
    const wxListItem& GetItem() const { return m_item; }


    long GetCacheFrom() const { return m_oldItemIndex; }
    long GetCacheTo() const { return m_itemIndex; }


    bool IsEditCancelled() const { return m_editCancelled; }
    void SetEditCanceled(bool editCancelled) { m_editCancelled = editCancelled; }

    virtual wxEvent *Clone() const { return new wxListEvent(*this); }


    int m_code;
    long m_oldItemIndex;
    long m_itemIndex;
    int m_col;
    wxPoint m_pointDrag;

    wxListItem m_item;

protected:
    bool m_editCancelled;

private:
    private: wxListEvent& operator=(const wxListEvent&); public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};






    extern const wxEventType wxEVT_COMMAND_LIST_BEGIN_DRAG;
    extern const wxEventType wxEVT_COMMAND_LIST_BEGIN_RDRAG;
    extern const wxEventType wxEVT_COMMAND_LIST_BEGIN_LABEL_EDIT;
    extern const wxEventType wxEVT_COMMAND_LIST_END_LABEL_EDIT;
    extern const wxEventType wxEVT_COMMAND_LIST_DELETE_ITEM;
    extern const wxEventType wxEVT_COMMAND_LIST_DELETE_ALL_ITEMS;




    extern const wxEventType wxEVT_COMMAND_LIST_ITEM_SELECTED;
    extern const wxEventType wxEVT_COMMAND_LIST_ITEM_DESELECTED;
    extern const wxEventType wxEVT_COMMAND_LIST_KEY_DOWN;
    extern const wxEventType wxEVT_COMMAND_LIST_INSERT_ITEM;
    extern const wxEventType wxEVT_COMMAND_LIST_COL_CLICK;
    extern const wxEventType wxEVT_COMMAND_LIST_ITEM_RIGHT_CLICK;
    extern const wxEventType wxEVT_COMMAND_LIST_ITEM_MIDDLE_CLICK;
    extern const wxEventType wxEVT_COMMAND_LIST_ITEM_ACTIVATED;
    extern const wxEventType wxEVT_COMMAND_LIST_CACHE_HINT;
    extern const wxEventType wxEVT_COMMAND_LIST_COL_RIGHT_CLICK;
    extern const wxEventType wxEVT_COMMAND_LIST_COL_BEGIN_DRAG;
    extern const wxEventType wxEVT_COMMAND_LIST_COL_DRAGGING;
    extern const wxEventType wxEVT_COMMAND_LIST_COL_END_DRAG;
    extern const wxEventType wxEVT_COMMAND_LIST_ITEM_FOCUSED;


typedef void (wxEvtHandler::*wxListEventFunction)(wxListEvent&);
# 20 "/usr/include/wx-2.8/wx/listctrl.h" 2





extern const wxChar wxListCtrlNameStr[];
# 36 "/usr/include/wx-2.8/wx/listctrl.h"
# 1 "/usr/include/wx-2.8/wx/generic/listctrl.h" 1
# 16 "/usr/include/wx-2.8/wx/generic/listctrl.h"
class wxImageList;


class wxDropTarget;
# 31 "/usr/include/wx-2.8/wx/generic/listctrl.h"
class wxListHeaderWindow;
class wxListMainWindow;





class wxGenericListCtrl: public wxControl
{
public:

    wxGenericListCtrl();
    wxGenericListCtrl( wxWindow *parent,
                wxWindowID winid = wxID_ANY,
                const wxPoint &pos = wxDefaultPosition,
                const wxSize &size = wxDefaultSize,
                long style = 0x0004,
                const wxValidator& validator = wxDefaultValidator,
                const wxString &name = wxListCtrlNameStr)
    {
        Create(parent, winid, pos, size, style, validator, name);
    }
    virtual ~wxGenericListCtrl();

    bool Create( wxWindow *parent,
                 wxWindowID winid = wxID_ANY,
                 const wxPoint &pos = wxDefaultPosition,
                 const wxSize &size = wxDefaultSize,
                 long style = 0x0004,
                 const wxValidator& validator = wxDefaultValidator,
                 const wxString &name = wxListCtrlNameStr);

    bool GetColumn( int col, wxListItem& item ) const;
    bool SetColumn( int col, wxListItem& item );
    int GetColumnWidth( int col ) const;
    bool SetColumnWidth( int col, int width);
    int GetCountPerPage() const;
    wxRect GetViewRect() const;

    bool GetItem( wxListItem& info ) const;
    bool SetItem( wxListItem& info ) ;
    long SetItem( long index, int col, const wxString& label, int imageId = -1 );
    int GetItemState( long item, long stateMask ) const;
    bool SetItemState( long item, long state, long stateMask);
    bool SetItemImage( long item, int image, int selImage = -1 );
    bool SetItemColumnImage( long item, long column, int image );
    wxString GetItemText( long item ) const;
    void SetItemText( long item, const wxString& str );
    wxUIntPtr GetItemData( long item ) const;

    bool SetItemPtrData(long item, wxUIntPtr data);

    bool SetItemData(long item, long data);
    bool GetItemRect( long item, wxRect& rect, int code = wxLIST_RECT_BOUNDS ) const;
    bool GetItemPosition( long item, wxPoint& pos ) const;
    bool SetItemPosition( long item, const wxPoint& pos );
    int GetItemCount() const;
    int GetColumnCount() const;
    void SetItemSpacing( int spacing, bool isSmall = false );
    wxSize GetItemSpacing() const;
    void SetItemTextColour( long item, const wxColour& col);
    wxColour GetItemTextColour( long item ) const;
    void SetItemBackgroundColour( long item, const wxColour &col);
    wxColour GetItemBackgroundColour( long item ) const;
    void SetItemFont( long item, const wxFont &f);
    wxFont GetItemFont( long item ) const;
    int GetSelectedItemCount() const;
    wxColour GetTextColour() const;
    void SetTextColour(const wxColour& col);
    long GetTopItem() const;

    void SetSingleStyle( long style, bool add = true ) ;
    void SetWindowStyleFlag( long style );
    void RecreateWindow() {}
    long GetNextItem( long item, int geometry = wxLIST_NEXT_ALL, int state = 0x0000 ) const;
    wxImageList *GetImageList( int which ) const;
    void SetImageList( wxImageList *imageList, int which );
    void AssignImageList( wxImageList *imageList, int which );
    bool Arrange( int flag = wxLIST_ALIGN_DEFAULT );

    void ClearAll();
    bool DeleteItem( long item );
    bool DeleteAllItems();
    bool DeleteAllColumns();
    bool DeleteColumn( int col );

    void SetItemCount(long count);

    wxTextCtrl *EditLabel(long item,
                          wxClassInfo* textControlClass = (&wxTextCtrl::ms_classInfo));
    wxTextCtrl* GetEditControl() const;
    void Edit( long item ) { EditLabel(item); }

    bool EnsureVisible( long item );
    long FindItem( long start, const wxString& str, bool partial = false );
    long FindItem( long start, wxUIntPtr data );
    long FindItem( long start, const wxPoint& pt, int direction );
    long HitTest( const wxPoint& point, int& flags, long *pSubItem = __null ) const;
    long InsertItem(wxListItem& info);
    long InsertItem( long index, const wxString& label );
    long InsertItem( long index, int imageIndex );
    long InsertItem( long index, const wxString& label, int imageIndex );
    long InsertColumn( long col, wxListItem& info );
    long InsertColumn( long col, const wxString& heading,
                       int format = wxLIST_FORMAT_LEFT, int width = -1 );
    bool ScrollList( int dx, int dy );
    bool SortItems( wxListCtrlCompare fn, long data );
    bool Update( long item );
    virtual void Update();


    bool InReportView() const { return HasFlag(0x0020); }


    bool IsVirtual() const { return HasFlag(0x0200); }


    bool HasHeader() const
        { return InReportView() && !HasFlag(0x0800); }


    void RefreshItem(long item);
    void RefreshItems(long itemFrom, long itemTo);



    int GetItemSpacing( bool isSmall ) const __attribute__ ((deprecated));


    virtual wxVisualAttributes GetDefaultAttributes() const
    {
        return GetClassDefaultAttributes(GetWindowVariant());
    }

    static wxVisualAttributes
    GetClassDefaultAttributes(wxWindowVariant variant = wxWINDOW_VARIANT_NORMAL);




    void OnInternalIdle( );
    void OnSize( wxSizeEvent &event );


    virtual void Refresh(bool eraseBackground = true,
                         const wxRect *rect = __null);

    virtual void Freeze();
    virtual void Thaw();

    virtual bool SetBackgroundColour( const wxColour &colour );
    virtual bool SetForegroundColour( const wxColour &colour );
    virtual wxColour GetBackgroundColour() const;
    virtual wxColour GetForegroundColour() const;
    virtual bool SetFont( const wxFont &font );
    virtual bool SetCursor( const wxCursor &cursor );

    virtual int GetScrollPos(int orient) const;
    virtual void SetScrollPos(int orient, int pos, bool refresh = true);


    virtual void SetDropTarget( wxDropTarget *dropTarget );
    virtual wxDropTarget *GetDropTarget() const;


    virtual bool ShouldInheritColours() const { return false; }
    virtual void SetFocus();




    wxImageList *m_imageListNormal;
    wxImageList *m_imageListSmall;
    wxImageList *m_imageListState;
    bool m_ownsImageListNormal,
                         m_ownsImageListSmall,
                         m_ownsImageListState;
    wxListHeaderWindow *m_headerWin;
    wxListMainWindow *m_mainWin;
    wxCoord m_headerHeight;

protected:
    virtual bool DoPopupMenu( wxMenu *menu, int x, int y );



    virtual void DoClientToScreen( int *x, int *y ) const;
    virtual void DoScreenToClient( int *x, int *y ) const;

    virtual wxSize DoGetBestSize() const;


    virtual wxString OnGetItemText(long item, long column) const;




    virtual int OnGetItemImage(long item) const;


    virtual int OnGetItemColumnImage(long item, long column) const;


    virtual wxListItemAttr *OnGetItemAttr(long item) const;


    friend class wxListMainWindow;

private:

    void CreateHeaderWindow();


    void CalculateAndSetHeaderHeight();



    void ResizeReportView(bool showHeader);

    private: static const wxEventTableEntry sm_eventTableEntries[]; protected: static const wxEventTable sm_eventTable; virtual const wxEventTable* GetEventTable() const; static wxEventHashTable sm_eventHashTable; virtual wxEventHashTable& GetEventHashTable() const;
    public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};







class wxListCtrl: public wxGenericListCtrl
{
    public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();

public:
    wxListCtrl() {}

    wxListCtrl(wxWindow *parent, wxWindowID winid = wxID_ANY,
               const wxPoint& pos = wxDefaultPosition,
               const wxSize& size = wxDefaultSize,
               long style = 0x0004,
               const wxValidator &validator = wxDefaultValidator,
               const wxString &name = wxListCtrlNameStr)
    : wxGenericListCtrl(parent, winid, pos, size, style, validator, name)
    {
    }

};
# 37 "/usr/include/wx-2.8/wx/listctrl.h" 2






class wxListView : public wxListCtrl
{
public:
    wxListView() { }
    wxListView( wxWindow *parent,
                wxWindowID winid = wxID_ANY,
                const wxPoint& pos = wxDefaultPosition,
                const wxSize& size = wxDefaultSize,
                long style = 0x0020,
                const wxValidator& validator = wxDefaultValidator,
                const wxString &name = wxListCtrlNameStr)
    {
        Create(parent, winid, pos, size, style, validator, name);
    }





    void Select(long n, bool on = true)
    {
        SetItemState(n, on ? 0x0004 : 0, 0x0004);
    }


    void Focus(long index)
    {
        SetItemState(index, 0x0002, 0x0002);
        EnsureVisible(index);
    }


    long GetFocusedItem() const
    {
        return GetNextItem(-1, wxLIST_NEXT_ALL, 0x0002);
    }


    long GetNextSelected(long item) const
        { return GetNextItem(item, wxLIST_NEXT_ALL, 0x0004); }
    long GetFirstSelected() const
        { return GetNextSelected(-1); }


    bool IsSelected(long index) const
        { return GetItemState(index, 0x0004) != 0; }




    void SetColumnImage(int col, int image)
    {
        wxListItem item;
        item.SetMask(0x0004);
        item.SetImage(image);
        SetColumn(col, item);
    }

    void ClearColumnImage(int col) { SetColumnImage(col, -1); }

private:
    private: wxListView(const wxListView&); wxListView& operator=(const wxListView&); public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};
# 16 "/usr/include/wx-2.8/wx/generic/filedlgg.h" 2


# 1 "/usr/include/wx-2.8/wx/filedlg.h" 1
# 19 "/usr/include/wx-2.8/wx/generic/filedlgg.h" 2





class wxBitmapButton;
class wxCheckBox;
class wxChoice;
class wxFileData;
class wxFileCtrl;
class wxGenericFileDialog;
class wxListEvent;
class wxListItem;
class wxStaticText;
class wxTextCtrl;





class wxGenericFileDialog: public wxFileDialogBase
{
public:
    wxGenericFileDialog() : wxFileDialogBase() { Init(); }

    wxGenericFileDialog(wxWindow *parent,
                        const wxString& message = wxFileSelectorPromptStr,
                        const wxString& defaultDir = wxEmptyString,
                        const wxString& defaultFile = wxEmptyString,
                        const wxString& wildCard = wxFileSelectorDefaultWildcardStr,
                        long style = wxFD_OPEN,
                        const wxPoint& pos = wxDefaultPosition,
                        const wxSize& sz = wxDefaultSize,
                        const wxString& name = wxFileDialogNameStr,
                        bool bypassGenericImpl = false );

    bool Create( wxWindow *parent,
                 const wxString& message = wxFileSelectorPromptStr,
                 const wxString& defaultDir = wxEmptyString,
                 const wxString& defaultFile = wxEmptyString,
                 const wxString& wildCard = wxFileSelectorDefaultWildcardStr,
                 long style = wxFD_OPEN,
                 const wxPoint& pos = wxDefaultPosition,
                 const wxSize& sz = wxDefaultSize,
                 const wxString& name = wxFileDialogNameStr,
                 bool bypassGenericImpl = false );

    virtual ~wxGenericFileDialog();

    virtual void SetMessage(const wxString& message) { SetTitle(message); }
    virtual void SetPath(const wxString& path);
    virtual void SetFilterIndex(int filterIndex);
    virtual void SetWildcard(const wxString& wildCard);


    virtual void GetPaths(wxArrayString& paths) const;
    virtual void GetFilenames(wxArrayString& files) const;




    virtual int ShowModal();
    virtual bool Show( bool show = true );

    void OnSelected( wxListEvent &event );
    void OnActivated( wxListEvent &event );
    void OnList( wxCommandEvent &event );
    void OnReport( wxCommandEvent &event );
    void OnUp( wxCommandEvent &event );
    void OnHome( wxCommandEvent &event );
    void OnListOk( wxCommandEvent &event );
    void OnNew( wxCommandEvent &event );
    void OnChoiceFilter( wxCommandEvent &event );
    void OnTextEnter( wxCommandEvent &event );
    void OnTextChange( wxCommandEvent &event );
    void OnCheck( wxCommandEvent &event );

    virtual void HandleAction( const wxString &fn );

    virtual void UpdateControls();

private:

    bool m_bypassGenericImpl;

protected:

    void DoSetFilterIndex(int filterindex);

    wxString m_filterExtension;
    wxChoice *m_choice;
    wxTextCtrl *m_text;
    wxFileCtrl *m_list;
    wxCheckBox *m_check;
    wxStaticText *m_static;
    wxBitmapButton *m_upDirButton;
    wxBitmapButton *m_newDirButton;

private:
    void Init();
    public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
    private: static const wxEventTableEntry sm_eventTableEntries[]; protected: static const wxEventTable sm_eventTable; virtual const wxEventTable* GetEventTable() const; static wxEventHashTable sm_eventHashTable; virtual wxEventHashTable& GetEventHashTable() const;


    static long ms_lastViewStyle;
    static bool ms_lastShowHidden;
};
# 155 "/usr/include/wx-2.8/wx/generic/filedlgg.h"
class wxFileData
{
public:
    enum fileType
    {
        is_file = 0x0000,
        is_dir = 0x0001,
        is_link = 0x0002,
        is_exe = 0x0004,
        is_drive = 0x0008
    };

    wxFileData() { Init(); }

    wxFileData( const wxFileData& fileData ) { Copy(fileData); }

    wxFileData( const wxString &filePath, const wxString &fileName,
                fileType type, int image_id );


    void Copy( const wxFileData &other );


    void ReadData();


    wxString GetFileName() const { return m_fileName; }

    wxString GetFilePath() const { return m_filePath; }

    void SetNewName( const wxString &filePath, const wxString &fileName );


    wxFileOffset GetSize() const { return m_size; }

    wxString GetFileType() const;

    wxDateTime GetDateTime() const { return m_dateTime; }

    wxString GetModificationTime() const;

    wxString GetPermissions() const { return m_permissions; }

    int GetImageId() const { return m_image; }

    bool IsFile() const { return !IsDir() && !IsLink() && !IsDrive(); }
    bool IsDir() const { return (m_type & is_dir ) != 0; }
    bool IsLink() const { return (m_type & is_link ) != 0; }
    bool IsExe() const { return (m_type & is_exe ) != 0; }
    bool IsDrive() const { return (m_type & is_drive) != 0; }


    int GetType() const { return m_type; }


    enum fileListFieldType
    {
        FileList_Name,
        FileList_Size,
        FileList_Type,
        FileList_Time,

        FileList_Perm,

        FileList_Max
    };


    wxString GetEntry( fileListFieldType num ) const;


    wxString GetHint() const;

    void MakeItem( wxListItem &item );


    wxFileData& operator = (const wxFileData& fd) { Copy(fd); return *this; }

protected:
    wxString m_fileName;
    wxString m_filePath;
    wxFileOffset m_size;
    wxDateTime m_dateTime;
    wxString m_permissions;
    int m_type;
    int m_image;

private:
    void Init();
};





class wxFileCtrl : public wxListCtrl
{
public:
    wxFileCtrl();
    wxFileCtrl( wxWindow *win,
                wxWindowID id,
                const wxString &wild,
                bool showHidden,
                const wxPoint &pos = wxDefaultPosition,
                const wxSize &size = wxDefaultSize,
                long style = 0x0010,
                const wxValidator &validator = wxDefaultValidator,
                const wxString &name = L"filelist" );
    virtual ~wxFileCtrl();

    virtual void ChangeToListMode();
    virtual void ChangeToReportMode();
    virtual void ChangeToSmallIconMode();
    virtual void ShowHidden( bool show = true );
    bool GetShowHidden() const { return m_showHidden; }

    virtual long Add( wxFileData *fd, wxListItem &item );
    virtual void UpdateItem(const wxListItem &item);
    virtual void UpdateFiles();
    virtual void MakeDir();
    virtual void GoToParentDir();
    virtual void GoToHomeDir();
    virtual void GoToDir( const wxString &dir );
    virtual void SetWild( const wxString &wild );
    wxString GetWild() const { return m_wild; }
    wxString GetDir() const { return m_dirName; }

    void OnListDeleteItem( wxListEvent &event );
    void OnListDeleteAllItems( wxListEvent &event );
    void OnListEndLabelEdit( wxListEvent &event );
    void OnListColClick( wxListEvent &event );

    virtual void SortItems(wxFileData::fileListFieldType field, bool foward);
    bool GetSortDirection() const { return m_sort_foward; }
    wxFileData::fileListFieldType GetSortField() const { return m_sort_field; }

protected:
    void FreeItemData(wxListItem& item);
    void FreeAllItemsData();

    wxString m_dirName;
    bool m_showHidden;
    wxString m_wild;

    bool m_sort_foward;
    wxFileData::fileListFieldType m_sort_field;

private:
    public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
    private: static const wxEventTableEntry sm_eventTableEntries[]; protected: static const wxEventTable sm_eventTable; virtual const wxEventTable* GetEventTable() const; static wxEventHashTable sm_eventHashTable; virtual wxEventHashTable& GetEventHashTable() const;
};
# 14 "/usr/include/wx-2.8/wx/gtk/filedlg.h" 2





class wxFileDialog: public wxGenericFileDialog
{
public:
    wxFileDialog() { }

    wxFileDialog(wxWindow *parent,
                 const wxString& message = wxFileSelectorPromptStr,
                 const wxString& defaultDir = wxEmptyString,
                 const wxString& defaultFile = wxEmptyString,
                 const wxString& wildCard = wxFileSelectorDefaultWildcardStr,
                 long style = wxFD_OPEN,
                 const wxPoint& pos = wxDefaultPosition,
                 const wxSize& sz = wxDefaultSize,
                 const wxString& name = wxFileDialogNameStr);

    virtual ~wxFileDialog() {}

    virtual wxString GetPath() const;
    virtual void GetPaths(wxArrayString& paths) const;
    virtual wxString GetDirectory() const;
    virtual wxString GetFilename() const;
    virtual void GetFilenames(wxArrayString& files) const;
    virtual int GetFilterIndex() const;

    virtual void SetMessage(const wxString& message);
    virtual void SetPath(const wxString& path);
    virtual void SetDirectory(const wxString& dir);
    virtual void SetFilename(const wxString& name);
    virtual void SetWildcard(const wxString& wildCard);
    virtual void SetFilterIndex(int filterIndex);

    virtual int ShowModal();
    virtual bool Show( bool show = true );



protected:


    virtual void DoSetSize(int x, int y,
                           int width, int height,
                           int sizeFlags = (0x0001|0x0002));


private:
    public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
    private: static const wxEventTableEntry sm_eventTableEntries[]; protected: static const wxEventTable sm_eventTable; virtual const wxEventTable* GetEventTable() const; static wxEventHashTable sm_eventHashTable; virtual wxEventHashTable& GetEventHashTable() const;
    void OnFakeOk( wxCommandEvent &event );
};
# 211 "/usr/include/wx-2.8/wx/filedlg.h" 2
# 95 "/usr/include/wx-2.8/wx/wx.h" 2
# 4 "/home/jankup/SourceCpp/DatabaseExplorer/src/column.h" 2
# 1 "controls/include/wx/dblayer/DatabaseResultSet.h" 1




# 1 "/usr/include/wx-2.8/wx/wxprec.h" 1
# 6 "controls/include/wx/dblayer/DatabaseResultSet.h" 2
# 16 "controls/include/wx/dblayer/DatabaseResultSet.h"
# 1 "/usr/include/wx-2.8/wx/hashset.h" 1
# 17 "controls/include/wx/dblayer/DatabaseResultSet.h" 2


# 1 "controls/include/wx/dblayer/DatabaseLayerDef.h" 1
# 20 "controls/include/wx/dblayer/DatabaseResultSet.h" 2
# 1 "controls/include/wx/dblayer/DatabaseErrorReporter.h" 1




# 1 "/usr/include/wx-2.8/wx/wxprec.h" 1
# 6 "controls/include/wx/dblayer/DatabaseErrorReporter.h" 2
# 17 "controls/include/wx/dblayer/DatabaseErrorReporter.h"
class DatabaseErrorReporter
{
public:

  DatabaseErrorReporter();


  virtual ~DatabaseErrorReporter();

  const wxString& GetErrorMessage();
  int GetErrorCode();

  void ResetErrorCodes();

protected:
  void SetErrorMessage(const wxString& strErrorMessage);
  void SetErrorCode(int nErrorCode);

  void ThrowDatabaseException();

private:
  wxString m_strErrorMessage;
  int m_nErrorCode;
};
# 21 "controls/include/wx/dblayer/DatabaseResultSet.h" 2
# 1 "controls/include/wx/dblayer/DatabaseStringConverter.h" 1




# 1 "/usr/include/wx-2.8/wx/wxprec.h" 1
# 6 "controls/include/wx/dblayer/DatabaseStringConverter.h" 2
# 17 "controls/include/wx/dblayer/DatabaseStringConverter.h"
class DatabaseStringConverter
{
public:

  DatabaseStringConverter();
  DatabaseStringConverter(const wxChar* charset);


  virtual ~DatabaseStringConverter() { }

  void SetEncoding(wxFontEncoding encoding);
  void SetEncoding(const wxCSConv* conv);
  const wxCSConv* GetEncoding() { return &m_Encoding; }

  virtual const wxCharBuffer ConvertToUnicodeStream(const wxString& inputString);
  virtual size_t GetEncodedStreamLength(const wxString& inputString);
  virtual wxString ConvertFromUnicodeStream(const char* inputBuffer);

  static const wxCharBuffer ConvertToUnicodeStream(const wxString& inputString, const char* encoding);
  static wxString ConvertFromUnicodeStream(const char* inputBuffer, const char* encoding);
  static size_t GetEncodedStreamLength(const wxString& inputString, const char* encoding);

private:
  wxCSConv m_Encoding;
};
# 22 "controls/include/wx/dblayer/DatabaseResultSet.h" 2
# 1 "controls/include/wx/dblayer/ResultSetMetaData.h" 1




# 1 "/usr/include/wx-2.8/wx/wxprec.h" 1
# 6 "controls/include/wx/dblayer/ResultSetMetaData.h" 2
# 18 "controls/include/wx/dblayer/ResultSetMetaData.h"
class ResultSetMetaData : public DatabaseStringConverter
{
public:

  virtual int GetColumnType(int i) = 0;

  virtual int GetColumnSize(int i) = 0;

  virtual wxString GetColumnName(int i) = 0;

  virtual int GetColumnCount() = 0;

  enum {
    COLUMN_UNKNOWN = 0,
    COLUMN_NULL,
    COLUMN_INTEGER,
    COLUMN_STRING,
    COLUMN_DOUBLE,
    COLUMN_BOOL,
    COLUMN_BLOB,
    COLUMN_DATE,
  };
};
# 23 "controls/include/wx/dblayer/DatabaseResultSet.h" 2

class StringToIntMap_wxImplementation_Pair { public: typedef wxString t1; typedef int t2; typedef const wxString const_t1; typedef const int const_t2; StringToIntMap_wxImplementation_Pair( const const_t1& f, const const_t2& s ):first(t1(f)),second(t2(s)) {} t1 first; t2 second; }; class StringToIntMap_wxImplementation_KeyEx { typedef wxString key_type; typedef StringToIntMap_wxImplementation_Pair pair_type; typedef const key_type const_key_type; typedef const pair_type const_pair_type; typedef const_key_type& const_key_reference; typedef const_pair_type& const_pair_reference; public: StringToIntMap_wxImplementation_KeyEx() { } const_key_reference operator()( const_pair_reference pair ) const { return pair.first; } StringToIntMap_wxImplementation_KeyEx& operator=(const StringToIntMap_wxImplementation_KeyEx&) { return *this; } }; class StringToIntMap_wxImplementation_HashTable : protected _wxHashTableBase2 { public: typedef wxString key_type; typedef StringToIntMap_wxImplementation_Pair value_type; typedef wxStringHash hasher; typedef wxStringEqual key_equal; typedef size_t size_type; typedef ptrdiff_t difference_type; typedef value_type* pointer; typedef const value_type* const_pointer; typedef value_type& reference; typedef const value_type& const_reference; typedef const wxString const_key_type; typedef const StringToIntMap_wxImplementation_Pair const_mapped_type; public: struct Node; typedef StringToIntMap_wxImplementation_KeyEx key_extractor; typedef StringToIntMap_wxImplementation_HashTable Self; protected: Node** m_table; size_t m_tableBuckets; size_t m_items; hasher m_hasher; key_equal m_equals; key_extractor m_getKey; public: struct Node:public _wxHashTable_NodeBase { public: Node( const value_type& value ) : m_value( value ) {} Node* m_next() { return (Node*)this->m_nxt; } value_type m_value; }; class Iterator; friend class Iterator; protected: static void DeleteNode( _wxHashTable_NodeBase* node ) { delete (Node*)node; } public: class Iterator { public: Node* m_node; Self* m_ht; Iterator() : m_node(0), m_ht(0) {} Iterator( Node* node, const Self* ht ) : m_node(node), m_ht((Self*)ht) {} bool operator ==( const Iterator& it ) const { return m_node == it.m_node; } bool operator !=( const Iterator& it ) const { return m_node != it.m_node; } protected: Node* GetNextNode() { size_type bucket = GetBucketForNode(m_ht,m_node); for( size_type i = bucket + 1; i < m_ht->m_tableBuckets; ++i ) { if( m_ht->m_table[i] ) return m_ht->m_table[i]; } return 0; } void PlusPlus() { Node* next = m_node->m_next(); m_node = next ? next : GetNextNode(); } }; public: class iterator : public Iterator { public: iterator() : Iterator() {} iterator( Node* node, Self* ht ) : Iterator( node, ht ) {} iterator& operator++() { PlusPlus(); return *this; } iterator operator++(int) { iterator it=*this;PlusPlus();return it; } reference operator *() const { return m_node->m_value; } pointer operator ->() const { return &(m_node->m_value); } }; class const_iterator : public Iterator { public: const_iterator() : Iterator() {} const_iterator(iterator i) : Iterator(i) {} const_iterator( Node* node, const Self* ht ) : Iterator( node, (Self*)ht ) {} const_iterator& operator++() { PlusPlus();return *this; } const_iterator operator++(int) { const_iterator it=*this;PlusPlus();return it; } const_reference operator *() const { return m_node->m_value; } const_pointer operator ->() const { return &(m_node->m_value); } }; StringToIntMap_wxImplementation_HashTable( size_type sz = 10, const hasher& hfun = hasher(), const key_equal& k_eq = key_equal(), const key_extractor& k_ex = key_extractor() ) : m_tableBuckets( GetNextPrime( (unsigned long) sz ) ), m_items( 0 ), m_hasher( hfun ), m_equals( k_eq ), m_getKey( k_ex ) { m_table = (Node**)AllocTable( m_tableBuckets ); } StringToIntMap_wxImplementation_HashTable( const Self& ht ) : m_table( 0 ), m_tableBuckets( 0 ), m_items( ht.m_items ), m_hasher( ht.m_hasher ), m_equals( ht.m_equals ), m_getKey( ht.m_getKey ) { HashCopy( ht ); } const Self& operator=( const Self& ht ) { clear(); m_hasher = ht.m_hasher; m_equals = ht.m_equals; m_getKey = ht.m_getKey; m_items = ht.m_items; HashCopy( ht ); return *this; } ~StringToIntMap_wxImplementation_HashTable() { clear(); FreeTable(m_table); } hasher hash_funct() { return m_hasher; } key_equal key_eq() { return m_equals; } void clear() { DeleteNodes( m_tableBuckets, (_wxHashTable_NodeBase**)m_table, DeleteNode ); m_items = 0; } size_type size() const { return m_items; } size_type max_size() const { return size_type(-1); } bool empty() const { return size() == 0; } const_iterator end() const { return const_iterator( 0, this ); } iterator end() { return iterator( 0, this ); } const_iterator begin() const { return const_iterator( (Node*)GetFirstNode( m_tableBuckets, (_wxHashTable_NodeBase**)m_table ), this ); } iterator begin() { return iterator( (Node*)GetFirstNode( m_tableBuckets, (_wxHashTable_NodeBase**)m_table ), this ); } size_type erase( const const_key_type& key ) { Node** node = GetNodePtr( key ); if( !node ) return 0; --m_items; Node* temp = (*node)->m_next(); delete *node; (*node) = temp; if( never_shrink( m_tableBuckets, m_items ) ) ResizeTable( GetPreviousPrime( (unsigned long) m_tableBuckets ) - 1 ); return 1; } protected: static size_type GetBucketForNode( Self* ht, Node* node ) { return ht->m_hasher( ht->m_getKey( node->m_value ) ) % ht->m_tableBuckets; } static Node* CopyNode( Node* node ) { return new Node( *node ); } Node* GetOrCreateNode( const value_type& value, bool& created ) { const const_key_type& key = m_getKey( value ); size_t bucket = m_hasher( key ) % m_tableBuckets; Node* node = m_table[bucket]; while( node ) { if( m_equals( m_getKey( node->m_value ), key ) ) { created = false; return node; } node = node->m_next(); } created = true; return CreateNode( value, bucket); } Node * CreateNode( const value_type& value, size_t bucket ) { Node* node = new Node( value ); node->m_nxt = m_table[bucket]; m_table[bucket] = node; ++m_items; if( grow_lf70( m_tableBuckets, m_items ) ) ResizeTable( m_tableBuckets ); return node; } void CreateNode( const value_type& value ) { CreateNode(value, m_hasher( m_getKey(value) ) % m_tableBuckets ); } Node** GetNodePtr( const const_key_type& key ) const { size_t bucket = m_hasher( key ) % m_tableBuckets; Node** node = &m_table[bucket]; while( *node ) { if( m_equals( m_getKey( (*node)->m_value ), key ) ) return node; node = (Node**)&(*node)->m_nxt; } return __null; } Node* GetNode( const const_key_type& key ) const { size_t bucket = m_hasher( key ) % m_tableBuckets; Node* node = m_table[bucket]; while( node ) { if( m_equals( m_getKey( node->m_value ), key ) ) return node; node = node->m_next(); } return 0; } void ResizeTable( size_t newSize ) { newSize = GetNextPrime( (unsigned long)newSize ); Node** srcTable = m_table; size_t srcBuckets = m_tableBuckets; m_table = (Node**)AllocTable( newSize ); m_tableBuckets = newSize; CopyHashTable( (_wxHashTable_NodeBase**)srcTable, srcBuckets, this, (_wxHashTable_NodeBase**)m_table, (BucketFromNode)GetBucketForNode, (ProcessNode)&DummyProcessNode ); FreeTable(srcTable); } void HashCopy( const Self& ht ) { ResizeTable( ht.size() ); CopyHashTable( (_wxHashTable_NodeBase**)ht.m_table, ht.m_tableBuckets, (_wxHashTableBase2*)this, (_wxHashTable_NodeBase**)m_table, (BucketFromNode)GetBucketForNode, (ProcessNode)CopyNode ); } }; class StringToIntMap:public StringToIntMap_wxImplementation_HashTable { public: typedef int mapped_type; class Insert_Result { public: typedef iterator t1; typedef bool t2; typedef const iterator const_t1; typedef const bool const_t2; Insert_Result( const const_t1& f, const const_t2& s ):first(t1(f)),second(t2(s)) {} t1 first; t2 second; }; explicit StringToIntMap( size_type hint = 100, hasher hf = hasher(), key_equal eq = key_equal() ) : StringToIntMap_wxImplementation_HashTable( hint, hf, eq, StringToIntMap_wxImplementation_KeyEx() ) {} mapped_type& operator[]( const const_key_type& key ) { bool created; return GetOrCreateNode( StringToIntMap_wxImplementation_Pair( key, mapped_type() ), created)->m_value.second; } const_iterator find( const const_key_type& key ) const { return const_iterator( GetNode( key ), this ); } iterator find( const const_key_type& key ) { return iterator( GetNode( key ), this ); } Insert_Result insert( const value_type& v ) { bool created; Node *node = GetOrCreateNode( StringToIntMap_wxImplementation_Pair( v.first, v.second ), created); return Insert_Result(iterator(node, this), created); } size_type erase( const key_type& k ) { return StringToIntMap_wxImplementation_HashTable::erase( k ); } void erase( const iterator& it ) { erase( it->first ); } void erase( const const_iterator& it ) { erase( it->first ); } size_type count( const const_key_type& key ) { return (size_type)(GetNode( key ) ? 1 : 0); } };
class MetaDataHashSet_wxImplementation_KeyEx { typedef ResultSetMetaData* key_type; typedef const key_type const_key_type; typedef const_key_type& const_key_reference; public: MetaDataHashSet_wxImplementation_KeyEx() { } const_key_reference operator()( const_key_reference key ) const { return key; } MetaDataHashSet_wxImplementation_KeyEx& operator=(const MetaDataHashSet_wxImplementation_KeyEx&) { return *this; } }; class MetaDataHashSet_wxImplementation_HashTable : protected _wxHashTableBase2 { public: typedef ResultSetMetaData* key_type; typedef ResultSetMetaData* value_type; typedef wxPointerHash hasher; typedef wxPointerEqual key_equal; typedef size_t size_type; typedef ptrdiff_t difference_type; typedef value_type* pointer; typedef const value_type* const_pointer; typedef value_type& reference; typedef const value_type& const_reference; typedef const ResultSetMetaData* const_key_type; typedef const ResultSetMetaData* const_mapped_type; public: struct Node; typedef MetaDataHashSet_wxImplementation_KeyEx key_extractor; typedef MetaDataHashSet_wxImplementation_HashTable Self; protected: Node** m_table; size_t m_tableBuckets; size_t m_items; hasher m_hasher; key_equal m_equals; key_extractor m_getKey; public: struct Node:public _wxHashTable_NodeBase { public: Node( const value_type& value ) : m_value( value ) {} Node* m_next() { return (Node*)this->m_nxt; } value_type m_value; }; class Iterator; friend class Iterator; protected: static void DeleteNode( _wxHashTable_NodeBase* node ) { delete (Node*)node; } public: class Iterator { public: Node* m_node; Self* m_ht; Iterator() : m_node(0), m_ht(0) {} Iterator( Node* node, const Self* ht ) : m_node(node), m_ht((Self*)ht) {} bool operator ==( const Iterator& it ) const { return m_node == it.m_node; } bool operator !=( const Iterator& it ) const { return m_node != it.m_node; } protected: Node* GetNextNode() { size_type bucket = GetBucketForNode(m_ht,m_node); for( size_type i = bucket + 1; i < m_ht->m_tableBuckets; ++i ) { if( m_ht->m_table[i] ) return m_ht->m_table[i]; } return 0; } void PlusPlus() { Node* next = m_node->m_next(); m_node = next ? next : GetNextNode(); } }; public: class iterator : public Iterator { public: iterator() : Iterator() {} iterator( Node* node, Self* ht ) : Iterator( node, ht ) {} iterator& operator++() { PlusPlus(); return *this; } iterator operator++(int) { iterator it=*this;PlusPlus();return it; } reference operator *() const { return m_node->m_value; } pointer operator ->() const { return &(m_node->m_value); } }; class const_iterator : public Iterator { public: const_iterator() : Iterator() {} const_iterator(iterator i) : Iterator(i) {} const_iterator( Node* node, const Self* ht ) : Iterator( node, (Self*)ht ) {} const_iterator& operator++() { PlusPlus();return *this; } const_iterator operator++(int) { const_iterator it=*this;PlusPlus();return it; } const_reference operator *() const { return m_node->m_value; } const_pointer operator ->() const { return &(m_node->m_value); } }; MetaDataHashSet_wxImplementation_HashTable( size_type sz = 10, const hasher& hfun = hasher(), const key_equal& k_eq = key_equal(), const key_extractor& k_ex = key_extractor() ) : m_tableBuckets( GetNextPrime( (unsigned long) sz ) ), m_items( 0 ), m_hasher( hfun ), m_equals( k_eq ), m_getKey( k_ex ) { m_table = (Node**)AllocTable( m_tableBuckets ); } MetaDataHashSet_wxImplementation_HashTable( const Self& ht ) : m_table( 0 ), m_tableBuckets( 0 ), m_items( ht.m_items ), m_hasher( ht.m_hasher ), m_equals( ht.m_equals ), m_getKey( ht.m_getKey ) { HashCopy( ht ); } const Self& operator=( const Self& ht ) { clear(); m_hasher = ht.m_hasher; m_equals = ht.m_equals; m_getKey = ht.m_getKey; m_items = ht.m_items; HashCopy( ht ); return *this; } ~MetaDataHashSet_wxImplementation_HashTable() { clear(); FreeTable(m_table); } hasher hash_funct() { return m_hasher; } key_equal key_eq() { return m_equals; } void clear() { DeleteNodes( m_tableBuckets, (_wxHashTable_NodeBase**)m_table, DeleteNode ); m_items = 0; } size_type size() const { return m_items; } size_type max_size() const { return size_type(-1); } bool empty() const { return size() == 0; } const_iterator end() const { return const_iterator( 0, this ); } iterator end() { return iterator( 0, this ); } const_iterator begin() const { return const_iterator( (Node*)GetFirstNode( m_tableBuckets, (_wxHashTable_NodeBase**)m_table ), this ); } iterator begin() { return iterator( (Node*)GetFirstNode( m_tableBuckets, (_wxHashTable_NodeBase**)m_table ), this ); } size_type erase( const const_key_type& key ) { Node** node = GetNodePtr( key ); if( !node ) return 0; --m_items; Node* temp = (*node)->m_next(); delete *node; (*node) = temp; if( never_shrink( m_tableBuckets, m_items ) ) ResizeTable( GetPreviousPrime( (unsigned long) m_tableBuckets ) - 1 ); return 1; } protected: static size_type GetBucketForNode( Self* ht, Node* node ) { return ht->m_hasher( ht->m_getKey( node->m_value ) ) % ht->m_tableBuckets; } static Node* CopyNode( Node* node ) { return new Node( *node ); } Node* GetOrCreateNode( const value_type& value, bool& created ) { const const_key_type& key = m_getKey( value ); size_t bucket = m_hasher( key ) % m_tableBuckets; Node* node = m_table[bucket]; while( node ) { if( m_equals( m_getKey( node->m_value ), key ) ) { created = false; return node; } node = node->m_next(); } created = true; return CreateNode( value, bucket); } Node * CreateNode( const value_type& value, size_t bucket ) { Node* node = new Node( value ); node->m_nxt = m_table[bucket]; m_table[bucket] = node; ++m_items; if( grow_lf70( m_tableBuckets, m_items ) ) ResizeTable( m_tableBuckets ); return node; } void CreateNode( const value_type& value ) { CreateNode(value, m_hasher( m_getKey(value) ) % m_tableBuckets ); } Node** GetNodePtr( const const_key_type& key ) const { size_t bucket = m_hasher( key ) % m_tableBuckets; Node** node = &m_table[bucket]; while( *node ) { if( m_equals( m_getKey( (*node)->m_value ), key ) ) return node; node = (Node**)&(*node)->m_nxt; } return __null; } Node* GetNode( const const_key_type& key ) const { size_t bucket = m_hasher( key ) % m_tableBuckets; Node* node = m_table[bucket]; while( node ) { if( m_equals( m_getKey( node->m_value ), key ) ) return node; node = node->m_next(); } return 0; } void ResizeTable( size_t newSize ) { newSize = GetNextPrime( (unsigned long)newSize ); Node** srcTable = m_table; size_t srcBuckets = m_tableBuckets; m_table = (Node**)AllocTable( newSize ); m_tableBuckets = newSize; CopyHashTable( (_wxHashTable_NodeBase**)srcTable, srcBuckets, this, (_wxHashTable_NodeBase**)m_table, (BucketFromNode)GetBucketForNode, (ProcessNode)&DummyProcessNode ); FreeTable(srcTable); } void HashCopy( const Self& ht ) { ResizeTable( ht.size() ); CopyHashTable( (_wxHashTable_NodeBase**)ht.m_table, ht.m_tableBuckets, (_wxHashTableBase2*)this, (_wxHashTable_NodeBase**)m_table, (BucketFromNode)GetBucketForNode, (ProcessNode)CopyNode ); } }; class MetaDataHashSet:public MetaDataHashSet_wxImplementation_HashTable { public: class Insert_Result { public: typedef iterator t1; typedef bool t2; typedef const iterator const_t1; typedef const bool const_t2; Insert_Result( const const_t1& f, const const_t2& s ):first(t1(f)),second(t2(s)) {} t1 first; t2 second; }; explicit MetaDataHashSet( size_type hint = 100, hasher hf = hasher(), key_equal eq = key_equal() ) : MetaDataHashSet_wxImplementation_HashTable( hint, hf, eq, MetaDataHashSet_wxImplementation_KeyEx() ) {} Insert_Result insert( const key_type& key ) { bool created; Node *node = GetOrCreateNode( key, created ); return Insert_Result( iterator( node, this ), created ); } const_iterator find( const const_key_type& key ) const { return const_iterator( GetNode( key ), this ); } iterator find( const const_key_type& key ) { return iterator( GetNode( key ), this ); } size_type erase( const key_type& k ) { return MetaDataHashSet_wxImplementation_HashTable::erase( k ); } void erase( const iterator& it ) { erase( *it ); } void erase( const const_iterator& it ) { erase( *it ); } size_type count( const const_key_type& key ) { return GetNode( key ) ? 1 : 0; } };

class DatabaseResultSet : public DatabaseErrorReporter, public DatabaseStringConverter
{
public:

  DatabaseResultSet();


  virtual ~DatabaseResultSet();


  virtual bool Next() = 0;

  virtual void Close() = 0;

  virtual int LookupField(const wxString& strField) = 0;



  virtual int GetResultInt(int nField) = 0;

  virtual wxString GetResultString(int nField) = 0;

  virtual long GetResultLong(int nField) = 0;

  virtual bool GetResultBool(int nField) = 0;

  virtual wxDateTime GetResultDate(int nField) = 0;

  virtual void* GetResultBlob(int nField, wxMemoryBuffer& Buffer) = 0;

  virtual double GetResultDouble(int nField) = 0;

  virtual bool IsFieldNull(int nField) = 0;


  virtual int GetResultInt(const wxString& strField);

  virtual wxString GetResultString(const wxString& strField);

  virtual long GetResultLong(const wxString& strField);

  virtual bool GetResultBool(const wxString& strField);

  virtual wxDateTime GetResultDate(const wxString& strField);

  virtual void* GetResultBlob(const wxString& strField, wxMemoryBuffer& Buffer);

  virtual double GetResultDouble(const wxString& strField);

  virtual bool IsFieldNull(const wxString& strField);



  virtual ResultSetMetaData* GetMetaData() = 0;

  virtual bool CloseMetaData(ResultSetMetaData* pMetaData);

protected:

  void CloseMetaData();

  void LogMetaDataForCleanup(ResultSetMetaData* pMetaData) { m_MetaData.insert(pMetaData); }

private:
  MetaDataHashSet m_MetaData;
};
# 5 "/home/jankup/SourceCpp/DatabaseExplorer/src/column.h" 2
# 1 "/home/jankup/SourceCpp/DatabaseExplorer/src/IDbAdapter.h" 1



# 1 "controls/include/wx/dblayer/DatabaseLayer.h" 1




# 1 "/usr/include/wx-2.8/wx/wxprec.h" 1
# 6 "controls/include/wx/dblayer/DatabaseLayer.h" 2
# 22 "controls/include/wx/dblayer/DatabaseLayer.h"
# 1 "controls/include/wx/dblayer/DatabaseResultSet.h" 1
# 23 "controls/include/wx/dblayer/DatabaseLayer.h" 2
# 1 "controls/include/wx/dblayer/PreparedStatement.h" 1




# 1 "/usr/include/wx-2.8/wx/wxprec.h" 1
# 6 "controls/include/wx/dblayer/PreparedStatement.h" 2
# 21 "controls/include/wx/dblayer/PreparedStatement.h"
# 1 "controls/include/wx/dblayer/DatabaseQueryParser.h" 1




# 1 "/usr/include/wx-2.8/wx/wxprec.h" 1
# 6 "controls/include/wx/dblayer/DatabaseQueryParser.h" 2
# 15 "controls/include/wx/dblayer/DatabaseQueryParser.h"
wxArrayString ParseQueries(const wxString& strQuery);
# 22 "controls/include/wx/dblayer/PreparedStatement.h" 2

class StatementResultSetHashSet_wxImplementation_KeyEx { typedef DatabaseResultSet* key_type; typedef const key_type const_key_type; typedef const_key_type& const_key_reference; public: StatementResultSetHashSet_wxImplementation_KeyEx() { } const_key_reference operator()( const_key_reference key ) const { return key; } StatementResultSetHashSet_wxImplementation_KeyEx& operator=(const StatementResultSetHashSet_wxImplementation_KeyEx&) { return *this; } }; class StatementResultSetHashSet_wxImplementation_HashTable : protected _wxHashTableBase2 { public: typedef DatabaseResultSet* key_type; typedef DatabaseResultSet* value_type; typedef wxPointerHash hasher; typedef wxPointerEqual key_equal; typedef size_t size_type; typedef ptrdiff_t difference_type; typedef value_type* pointer; typedef const value_type* const_pointer; typedef value_type& reference; typedef const value_type& const_reference; typedef const DatabaseResultSet* const_key_type; typedef const DatabaseResultSet* const_mapped_type; public: struct Node; typedef StatementResultSetHashSet_wxImplementation_KeyEx key_extractor; typedef StatementResultSetHashSet_wxImplementation_HashTable Self; protected: Node** m_table; size_t m_tableBuckets; size_t m_items; hasher m_hasher; key_equal m_equals; key_extractor m_getKey; public: struct Node:public _wxHashTable_NodeBase { public: Node( const value_type& value ) : m_value( value ) {} Node* m_next() { return (Node*)this->m_nxt; } value_type m_value; }; class Iterator; friend class Iterator; protected: static void DeleteNode( _wxHashTable_NodeBase* node ) { delete (Node*)node; } public: class Iterator { public: Node* m_node; Self* m_ht; Iterator() : m_node(0), m_ht(0) {} Iterator( Node* node, const Self* ht ) : m_node(node), m_ht((Self*)ht) {} bool operator ==( const Iterator& it ) const { return m_node == it.m_node; } bool operator !=( const Iterator& it ) const { return m_node != it.m_node; } protected: Node* GetNextNode() { size_type bucket = GetBucketForNode(m_ht,m_node); for( size_type i = bucket + 1; i < m_ht->m_tableBuckets; ++i ) { if( m_ht->m_table[i] ) return m_ht->m_table[i]; } return 0; } void PlusPlus() { Node* next = m_node->m_next(); m_node = next ? next : GetNextNode(); } }; public: class iterator : public Iterator { public: iterator() : Iterator() {} iterator( Node* node, Self* ht ) : Iterator( node, ht ) {} iterator& operator++() { PlusPlus(); return *this; } iterator operator++(int) { iterator it=*this;PlusPlus();return it; } reference operator *() const { return m_node->m_value; } pointer operator ->() const { return &(m_node->m_value); } }; class const_iterator : public Iterator { public: const_iterator() : Iterator() {} const_iterator(iterator i) : Iterator(i) {} const_iterator( Node* node, const Self* ht ) : Iterator( node, (Self*)ht ) {} const_iterator& operator++() { PlusPlus();return *this; } const_iterator operator++(int) { const_iterator it=*this;PlusPlus();return it; } const_reference operator *() const { return m_node->m_value; } const_pointer operator ->() const { return &(m_node->m_value); } }; StatementResultSetHashSet_wxImplementation_HashTable( size_type sz = 10, const hasher& hfun = hasher(), const key_equal& k_eq = key_equal(), const key_extractor& k_ex = key_extractor() ) : m_tableBuckets( GetNextPrime( (unsigned long) sz ) ), m_items( 0 ), m_hasher( hfun ), m_equals( k_eq ), m_getKey( k_ex ) { m_table = (Node**)AllocTable( m_tableBuckets ); } StatementResultSetHashSet_wxImplementation_HashTable( const Self& ht ) : m_table( 0 ), m_tableBuckets( 0 ), m_items( ht.m_items ), m_hasher( ht.m_hasher ), m_equals( ht.m_equals ), m_getKey( ht.m_getKey ) { HashCopy( ht ); } const Self& operator=( const Self& ht ) { clear(); m_hasher = ht.m_hasher; m_equals = ht.m_equals; m_getKey = ht.m_getKey; m_items = ht.m_items; HashCopy( ht ); return *this; } ~StatementResultSetHashSet_wxImplementation_HashTable() { clear(); FreeTable(m_table); } hasher hash_funct() { return m_hasher; } key_equal key_eq() { return m_equals; } void clear() { DeleteNodes( m_tableBuckets, (_wxHashTable_NodeBase**)m_table, DeleteNode ); m_items = 0; } size_type size() const { return m_items; } size_type max_size() const { return size_type(-1); } bool empty() const { return size() == 0; } const_iterator end() const { return const_iterator( 0, this ); } iterator end() { return iterator( 0, this ); } const_iterator begin() const { return const_iterator( (Node*)GetFirstNode( m_tableBuckets, (_wxHashTable_NodeBase**)m_table ), this ); } iterator begin() { return iterator( (Node*)GetFirstNode( m_tableBuckets, (_wxHashTable_NodeBase**)m_table ), this ); } size_type erase( const const_key_type& key ) { Node** node = GetNodePtr( key ); if( !node ) return 0; --m_items; Node* temp = (*node)->m_next(); delete *node; (*node) = temp; if( never_shrink( m_tableBuckets, m_items ) ) ResizeTable( GetPreviousPrime( (unsigned long) m_tableBuckets ) - 1 ); return 1; } protected: static size_type GetBucketForNode( Self* ht, Node* node ) { return ht->m_hasher( ht->m_getKey( node->m_value ) ) % ht->m_tableBuckets; } static Node* CopyNode( Node* node ) { return new Node( *node ); } Node* GetOrCreateNode( const value_type& value, bool& created ) { const const_key_type& key = m_getKey( value ); size_t bucket = m_hasher( key ) % m_tableBuckets; Node* node = m_table[bucket]; while( node ) { if( m_equals( m_getKey( node->m_value ), key ) ) { created = false; return node; } node = node->m_next(); } created = true; return CreateNode( value, bucket); } Node * CreateNode( const value_type& value, size_t bucket ) { Node* node = new Node( value ); node->m_nxt = m_table[bucket]; m_table[bucket] = node; ++m_items; if( grow_lf70( m_tableBuckets, m_items ) ) ResizeTable( m_tableBuckets ); return node; } void CreateNode( const value_type& value ) { CreateNode(value, m_hasher( m_getKey(value) ) % m_tableBuckets ); } Node** GetNodePtr( const const_key_type& key ) const { size_t bucket = m_hasher( key ) % m_tableBuckets; Node** node = &m_table[bucket]; while( *node ) { if( m_equals( m_getKey( (*node)->m_value ), key ) ) return node; node = (Node**)&(*node)->m_nxt; } return __null; } Node* GetNode( const const_key_type& key ) const { size_t bucket = m_hasher( key ) % m_tableBuckets; Node* node = m_table[bucket]; while( node ) { if( m_equals( m_getKey( node->m_value ), key ) ) return node; node = node->m_next(); } return 0; } void ResizeTable( size_t newSize ) { newSize = GetNextPrime( (unsigned long)newSize ); Node** srcTable = m_table; size_t srcBuckets = m_tableBuckets; m_table = (Node**)AllocTable( newSize ); m_tableBuckets = newSize; CopyHashTable( (_wxHashTable_NodeBase**)srcTable, srcBuckets, this, (_wxHashTable_NodeBase**)m_table, (BucketFromNode)GetBucketForNode, (ProcessNode)&DummyProcessNode ); FreeTable(srcTable); } void HashCopy( const Self& ht ) { ResizeTable( ht.size() ); CopyHashTable( (_wxHashTable_NodeBase**)ht.m_table, ht.m_tableBuckets, (_wxHashTableBase2*)this, (_wxHashTable_NodeBase**)m_table, (BucketFromNode)GetBucketForNode, (ProcessNode)CopyNode ); } }; class StatementResultSetHashSet:public StatementResultSetHashSet_wxImplementation_HashTable { public: class Insert_Result { public: typedef iterator t1; typedef bool t2; typedef const iterator const_t1; typedef const bool const_t2; Insert_Result( const const_t1& f, const const_t2& s ):first(t1(f)),second(t2(s)) {} t1 first; t2 second; }; explicit StatementResultSetHashSet( size_type hint = 100, hasher hf = hasher(), key_equal eq = key_equal() ) : StatementResultSetHashSet_wxImplementation_HashTable( hint, hf, eq, StatementResultSetHashSet_wxImplementation_KeyEx() ) {} Insert_Result insert( const key_type& key ) { bool created; Node *node = GetOrCreateNode( key, created ); return Insert_Result( iterator( node, this ), created ); } const_iterator find( const const_key_type& key ) const { return const_iterator( GetNode( key ), this ); } iterator find( const const_key_type& key ) { return iterator( GetNode( key ), this ); } size_type erase( const key_type& k ) { return StatementResultSetHashSet_wxImplementation_HashTable::erase( k ); } void erase( const iterator& it ) { erase( *it ); } void erase( const const_iterator& it ) { erase( *it ); } size_type count( const const_key_type& key ) { return GetNode( key ) ? 1 : 0; } };

class PreparedStatement : public DatabaseErrorReporter, public DatabaseStringConverter
{
public:

  PreparedStatement();


  virtual ~PreparedStatement();


  virtual void Close() = 0;



  virtual void SetParamInt(int nPosition, int nValue) = 0;

  virtual void SetParamDouble(int nPosition, double dblValue) = 0;

  virtual void SetParamString(int nPosition, const wxString& strValue) = 0;

  virtual void SetParamNull(int nPosition) = 0;

  virtual void SetParamBlob(int nPosition, const wxMemoryBuffer& buffer);

  virtual void SetParamBlob(int nPosition, const void* pData, long nDataLength) = 0;

  virtual void SetParamDate(int nPosition, const wxDateTime& dateValue) = 0;

  virtual void SetParamBool(int nPosition, bool bValue) = 0;
  virtual int GetParameterCount() = 0;


  virtual int RunQuery() = 0;

  virtual DatabaseResultSet* RunQueryWithResults() = 0;




  int ExecuteUpdate() { return RunQuery(); }

  DatabaseResultSet* ExecuteQuery() { return RunQueryWithResults(); }


  virtual bool CloseResultSet(DatabaseResultSet* pResultSet);

protected:

  void CloseResultSets();

  void LogResultSetForCleanup(DatabaseResultSet* pResultSet) { m_ResultSets.insert(pResultSet); }

private:
  StatementResultSetHashSet m_ResultSets;
};
# 24 "controls/include/wx/dblayer/DatabaseLayer.h" 2

class DatabaseResultSetHashSet_wxImplementation_KeyEx { typedef DatabaseResultSet* key_type; typedef const key_type const_key_type; typedef const_key_type& const_key_reference; public: DatabaseResultSetHashSet_wxImplementation_KeyEx() { } const_key_reference operator()( const_key_reference key ) const { return key; } DatabaseResultSetHashSet_wxImplementation_KeyEx& operator=(const DatabaseResultSetHashSet_wxImplementation_KeyEx&) { return *this; } }; class DatabaseResultSetHashSet_wxImplementation_HashTable : protected _wxHashTableBase2 { public: typedef DatabaseResultSet* key_type; typedef DatabaseResultSet* value_type; typedef wxPointerHash hasher; typedef wxPointerEqual key_equal; typedef size_t size_type; typedef ptrdiff_t difference_type; typedef value_type* pointer; typedef const value_type* const_pointer; typedef value_type& reference; typedef const value_type& const_reference; typedef const DatabaseResultSet* const_key_type; typedef const DatabaseResultSet* const_mapped_type; public: struct Node; typedef DatabaseResultSetHashSet_wxImplementation_KeyEx key_extractor; typedef DatabaseResultSetHashSet_wxImplementation_HashTable Self; protected: Node** m_table; size_t m_tableBuckets; size_t m_items; hasher m_hasher; key_equal m_equals; key_extractor m_getKey; public: struct Node:public _wxHashTable_NodeBase { public: Node( const value_type& value ) : m_value( value ) {} Node* m_next() { return (Node*)this->m_nxt; } value_type m_value; }; class Iterator; friend class Iterator; protected: static void DeleteNode( _wxHashTable_NodeBase* node ) { delete (Node*)node; } public: class Iterator { public: Node* m_node; Self* m_ht; Iterator() : m_node(0), m_ht(0) {} Iterator( Node* node, const Self* ht ) : m_node(node), m_ht((Self*)ht) {} bool operator ==( const Iterator& it ) const { return m_node == it.m_node; } bool operator !=( const Iterator& it ) const { return m_node != it.m_node; } protected: Node* GetNextNode() { size_type bucket = GetBucketForNode(m_ht,m_node); for( size_type i = bucket + 1; i < m_ht->m_tableBuckets; ++i ) { if( m_ht->m_table[i] ) return m_ht->m_table[i]; } return 0; } void PlusPlus() { Node* next = m_node->m_next(); m_node = next ? next : GetNextNode(); } }; public: class iterator : public Iterator { public: iterator() : Iterator() {} iterator( Node* node, Self* ht ) : Iterator( node, ht ) {} iterator& operator++() { PlusPlus(); return *this; } iterator operator++(int) { iterator it=*this;PlusPlus();return it; } reference operator *() const { return m_node->m_value; } pointer operator ->() const { return &(m_node->m_value); } }; class const_iterator : public Iterator { public: const_iterator() : Iterator() {} const_iterator(iterator i) : Iterator(i) {} const_iterator( Node* node, const Self* ht ) : Iterator( node, (Self*)ht ) {} const_iterator& operator++() { PlusPlus();return *this; } const_iterator operator++(int) { const_iterator it=*this;PlusPlus();return it; } const_reference operator *() const { return m_node->m_value; } const_pointer operator ->() const { return &(m_node->m_value); } }; DatabaseResultSetHashSet_wxImplementation_HashTable( size_type sz = 10, const hasher& hfun = hasher(), const key_equal& k_eq = key_equal(), const key_extractor& k_ex = key_extractor() ) : m_tableBuckets( GetNextPrime( (unsigned long) sz ) ), m_items( 0 ), m_hasher( hfun ), m_equals( k_eq ), m_getKey( k_ex ) { m_table = (Node**)AllocTable( m_tableBuckets ); } DatabaseResultSetHashSet_wxImplementation_HashTable( const Self& ht ) : m_table( 0 ), m_tableBuckets( 0 ), m_items( ht.m_items ), m_hasher( ht.m_hasher ), m_equals( ht.m_equals ), m_getKey( ht.m_getKey ) { HashCopy( ht ); } const Self& operator=( const Self& ht ) { clear(); m_hasher = ht.m_hasher; m_equals = ht.m_equals; m_getKey = ht.m_getKey; m_items = ht.m_items; HashCopy( ht ); return *this; } ~DatabaseResultSetHashSet_wxImplementation_HashTable() { clear(); FreeTable(m_table); } hasher hash_funct() { return m_hasher; } key_equal key_eq() { return m_equals; } void clear() { DeleteNodes( m_tableBuckets, (_wxHashTable_NodeBase**)m_table, DeleteNode ); m_items = 0; } size_type size() const { return m_items; } size_type max_size() const { return size_type(-1); } bool empty() const { return size() == 0; } const_iterator end() const { return const_iterator( 0, this ); } iterator end() { return iterator( 0, this ); } const_iterator begin() const { return const_iterator( (Node*)GetFirstNode( m_tableBuckets, (_wxHashTable_NodeBase**)m_table ), this ); } iterator begin() { return iterator( (Node*)GetFirstNode( m_tableBuckets, (_wxHashTable_NodeBase**)m_table ), this ); } size_type erase( const const_key_type& key ) { Node** node = GetNodePtr( key ); if( !node ) return 0; --m_items; Node* temp = (*node)->m_next(); delete *node; (*node) = temp; if( never_shrink( m_tableBuckets, m_items ) ) ResizeTable( GetPreviousPrime( (unsigned long) m_tableBuckets ) - 1 ); return 1; } protected: static size_type GetBucketForNode( Self* ht, Node* node ) { return ht->m_hasher( ht->m_getKey( node->m_value ) ) % ht->m_tableBuckets; } static Node* CopyNode( Node* node ) { return new Node( *node ); } Node* GetOrCreateNode( const value_type& value, bool& created ) { const const_key_type& key = m_getKey( value ); size_t bucket = m_hasher( key ) % m_tableBuckets; Node* node = m_table[bucket]; while( node ) { if( m_equals( m_getKey( node->m_value ), key ) ) { created = false; return node; } node = node->m_next(); } created = true; return CreateNode( value, bucket); } Node * CreateNode( const value_type& value, size_t bucket ) { Node* node = new Node( value ); node->m_nxt = m_table[bucket]; m_table[bucket] = node; ++m_items; if( grow_lf70( m_tableBuckets, m_items ) ) ResizeTable( m_tableBuckets ); return node; } void CreateNode( const value_type& value ) { CreateNode(value, m_hasher( m_getKey(value) ) % m_tableBuckets ); } Node** GetNodePtr( const const_key_type& key ) const { size_t bucket = m_hasher( key ) % m_tableBuckets; Node** node = &m_table[bucket]; while( *node ) { if( m_equals( m_getKey( (*node)->m_value ), key ) ) return node; node = (Node**)&(*node)->m_nxt; } return __null; } Node* GetNode( const const_key_type& key ) const { size_t bucket = m_hasher( key ) % m_tableBuckets; Node* node = m_table[bucket]; while( node ) { if( m_equals( m_getKey( node->m_value ), key ) ) return node; node = node->m_next(); } return 0; } void ResizeTable( size_t newSize ) { newSize = GetNextPrime( (unsigned long)newSize ); Node** srcTable = m_table; size_t srcBuckets = m_tableBuckets; m_table = (Node**)AllocTable( newSize ); m_tableBuckets = newSize; CopyHashTable( (_wxHashTable_NodeBase**)srcTable, srcBuckets, this, (_wxHashTable_NodeBase**)m_table, (BucketFromNode)GetBucketForNode, (ProcessNode)&DummyProcessNode ); FreeTable(srcTable); } void HashCopy( const Self& ht ) { ResizeTable( ht.size() ); CopyHashTable( (_wxHashTable_NodeBase**)ht.m_table, ht.m_tableBuckets, (_wxHashTableBase2*)this, (_wxHashTable_NodeBase**)m_table, (BucketFromNode)GetBucketForNode, (ProcessNode)CopyNode ); } }; class DatabaseResultSetHashSet:public DatabaseResultSetHashSet_wxImplementation_HashTable { public: class Insert_Result { public: typedef iterator t1; typedef bool t2; typedef const iterator const_t1; typedef const bool const_t2; Insert_Result( const const_t1& f, const const_t2& s ):first(t1(f)),second(t2(s)) {} t1 first; t2 second; }; explicit DatabaseResultSetHashSet( size_type hint = 100, hasher hf = hasher(), key_equal eq = key_equal() ) : DatabaseResultSetHashSet_wxImplementation_HashTable( hint, hf, eq, DatabaseResultSetHashSet_wxImplementation_KeyEx() ) {} Insert_Result insert( const key_type& key ) { bool created; Node *node = GetOrCreateNode( key, created ); return Insert_Result( iterator( node, this ), created ); } const_iterator find( const const_key_type& key ) const { return const_iterator( GetNode( key ), this ); } iterator find( const const_key_type& key ) { return iterator( GetNode( key ), this ); } size_type erase( const key_type& k ) { return DatabaseResultSetHashSet_wxImplementation_HashTable::erase( k ); } void erase( const iterator& it ) { erase( *it ); } void erase( const const_iterator& it ) { erase( *it ); } size_type count( const const_key_type& key ) { return GetNode( key ) ? 1 : 0; } };
class DatabaseStatementHashSet_wxImplementation_KeyEx { typedef PreparedStatement* key_type; typedef const key_type const_key_type; typedef const_key_type& const_key_reference; public: DatabaseStatementHashSet_wxImplementation_KeyEx() { } const_key_reference operator()( const_key_reference key ) const { return key; } DatabaseStatementHashSet_wxImplementation_KeyEx& operator=(const DatabaseStatementHashSet_wxImplementation_KeyEx&) { return *this; } }; class DatabaseStatementHashSet_wxImplementation_HashTable : protected _wxHashTableBase2 { public: typedef PreparedStatement* key_type; typedef PreparedStatement* value_type; typedef wxPointerHash hasher; typedef wxPointerEqual key_equal; typedef size_t size_type; typedef ptrdiff_t difference_type; typedef value_type* pointer; typedef const value_type* const_pointer; typedef value_type& reference; typedef const value_type& const_reference; typedef const PreparedStatement* const_key_type; typedef const PreparedStatement* const_mapped_type; public: struct Node; typedef DatabaseStatementHashSet_wxImplementation_KeyEx key_extractor; typedef DatabaseStatementHashSet_wxImplementation_HashTable Self; protected: Node** m_table; size_t m_tableBuckets; size_t m_items; hasher m_hasher; key_equal m_equals; key_extractor m_getKey; public: struct Node:public _wxHashTable_NodeBase { public: Node( const value_type& value ) : m_value( value ) {} Node* m_next() { return (Node*)this->m_nxt; } value_type m_value; }; class Iterator; friend class Iterator; protected: static void DeleteNode( _wxHashTable_NodeBase* node ) { delete (Node*)node; } public: class Iterator { public: Node* m_node; Self* m_ht; Iterator() : m_node(0), m_ht(0) {} Iterator( Node* node, const Self* ht ) : m_node(node), m_ht((Self*)ht) {} bool operator ==( const Iterator& it ) const { return m_node == it.m_node; } bool operator !=( const Iterator& it ) const { return m_node != it.m_node; } protected: Node* GetNextNode() { size_type bucket = GetBucketForNode(m_ht,m_node); for( size_type i = bucket + 1; i < m_ht->m_tableBuckets; ++i ) { if( m_ht->m_table[i] ) return m_ht->m_table[i]; } return 0; } void PlusPlus() { Node* next = m_node->m_next(); m_node = next ? next : GetNextNode(); } }; public: class iterator : public Iterator { public: iterator() : Iterator() {} iterator( Node* node, Self* ht ) : Iterator( node, ht ) {} iterator& operator++() { PlusPlus(); return *this; } iterator operator++(int) { iterator it=*this;PlusPlus();return it; } reference operator *() const { return m_node->m_value; } pointer operator ->() const { return &(m_node->m_value); } }; class const_iterator : public Iterator { public: const_iterator() : Iterator() {} const_iterator(iterator i) : Iterator(i) {} const_iterator( Node* node, const Self* ht ) : Iterator( node, (Self*)ht ) {} const_iterator& operator++() { PlusPlus();return *this; } const_iterator operator++(int) { const_iterator it=*this;PlusPlus();return it; } const_reference operator *() const { return m_node->m_value; } const_pointer operator ->() const { return &(m_node->m_value); } }; DatabaseStatementHashSet_wxImplementation_HashTable( size_type sz = 10, const hasher& hfun = hasher(), const key_equal& k_eq = key_equal(), const key_extractor& k_ex = key_extractor() ) : m_tableBuckets( GetNextPrime( (unsigned long) sz ) ), m_items( 0 ), m_hasher( hfun ), m_equals( k_eq ), m_getKey( k_ex ) { m_table = (Node**)AllocTable( m_tableBuckets ); } DatabaseStatementHashSet_wxImplementation_HashTable( const Self& ht ) : m_table( 0 ), m_tableBuckets( 0 ), m_items( ht.m_items ), m_hasher( ht.m_hasher ), m_equals( ht.m_equals ), m_getKey( ht.m_getKey ) { HashCopy( ht ); } const Self& operator=( const Self& ht ) { clear(); m_hasher = ht.m_hasher; m_equals = ht.m_equals; m_getKey = ht.m_getKey; m_items = ht.m_items; HashCopy( ht ); return *this; } ~DatabaseStatementHashSet_wxImplementation_HashTable() { clear(); FreeTable(m_table); } hasher hash_funct() { return m_hasher; } key_equal key_eq() { return m_equals; } void clear() { DeleteNodes( m_tableBuckets, (_wxHashTable_NodeBase**)m_table, DeleteNode ); m_items = 0; } size_type size() const { return m_items; } size_type max_size() const { return size_type(-1); } bool empty() const { return size() == 0; } const_iterator end() const { return const_iterator( 0, this ); } iterator end() { return iterator( 0, this ); } const_iterator begin() const { return const_iterator( (Node*)GetFirstNode( m_tableBuckets, (_wxHashTable_NodeBase**)m_table ), this ); } iterator begin() { return iterator( (Node*)GetFirstNode( m_tableBuckets, (_wxHashTable_NodeBase**)m_table ), this ); } size_type erase( const const_key_type& key ) { Node** node = GetNodePtr( key ); if( !node ) return 0; --m_items; Node* temp = (*node)->m_next(); delete *node; (*node) = temp; if( never_shrink( m_tableBuckets, m_items ) ) ResizeTable( GetPreviousPrime( (unsigned long) m_tableBuckets ) - 1 ); return 1; } protected: static size_type GetBucketForNode( Self* ht, Node* node ) { return ht->m_hasher( ht->m_getKey( node->m_value ) ) % ht->m_tableBuckets; } static Node* CopyNode( Node* node ) { return new Node( *node ); } Node* GetOrCreateNode( const value_type& value, bool& created ) { const const_key_type& key = m_getKey( value ); size_t bucket = m_hasher( key ) % m_tableBuckets; Node* node = m_table[bucket]; while( node ) { if( m_equals( m_getKey( node->m_value ), key ) ) { created = false; return node; } node = node->m_next(); } created = true; return CreateNode( value, bucket); } Node * CreateNode( const value_type& value, size_t bucket ) { Node* node = new Node( value ); node->m_nxt = m_table[bucket]; m_table[bucket] = node; ++m_items; if( grow_lf70( m_tableBuckets, m_items ) ) ResizeTable( m_tableBuckets ); return node; } void CreateNode( const value_type& value ) { CreateNode(value, m_hasher( m_getKey(value) ) % m_tableBuckets ); } Node** GetNodePtr( const const_key_type& key ) const { size_t bucket = m_hasher( key ) % m_tableBuckets; Node** node = &m_table[bucket]; while( *node ) { if( m_equals( m_getKey( (*node)->m_value ), key ) ) return node; node = (Node**)&(*node)->m_nxt; } return __null; } Node* GetNode( const const_key_type& key ) const { size_t bucket = m_hasher( key ) % m_tableBuckets; Node* node = m_table[bucket]; while( node ) { if( m_equals( m_getKey( node->m_value ), key ) ) return node; node = node->m_next(); } return 0; } void ResizeTable( size_t newSize ) { newSize = GetNextPrime( (unsigned long)newSize ); Node** srcTable = m_table; size_t srcBuckets = m_tableBuckets; m_table = (Node**)AllocTable( newSize ); m_tableBuckets = newSize; CopyHashTable( (_wxHashTable_NodeBase**)srcTable, srcBuckets, this, (_wxHashTable_NodeBase**)m_table, (BucketFromNode)GetBucketForNode, (ProcessNode)&DummyProcessNode ); FreeTable(srcTable); } void HashCopy( const Self& ht ) { ResizeTable( ht.size() ); CopyHashTable( (_wxHashTable_NodeBase**)ht.m_table, ht.m_tableBuckets, (_wxHashTableBase2*)this, (_wxHashTable_NodeBase**)m_table, (BucketFromNode)GetBucketForNode, (ProcessNode)CopyNode ); } }; class DatabaseStatementHashSet:public DatabaseStatementHashSet_wxImplementation_HashTable { public: class Insert_Result { public: typedef iterator t1; typedef bool t2; typedef const iterator const_t1; typedef const bool const_t2; Insert_Result( const const_t1& f, const const_t2& s ):first(t1(f)),second(t2(s)) {} t1 first; t2 second; }; explicit DatabaseStatementHashSet( size_type hint = 100, hasher hf = hasher(), key_equal eq = key_equal() ) : DatabaseStatementHashSet_wxImplementation_HashTable( hint, hf, eq, DatabaseStatementHashSet_wxImplementation_KeyEx() ) {} Insert_Result insert( const key_type& key ) { bool created; Node *node = GetOrCreateNode( key, created ); return Insert_Result( iterator( node, this ), created ); } const_iterator find( const const_key_type& key ) const { return const_iterator( GetNode( key ), this ); } iterator find( const const_key_type& key ) { return iterator( GetNode( key ), this ); } size_type erase( const key_type& k ) { return DatabaseStatementHashSet_wxImplementation_HashTable::erase( k ); } void erase( const iterator& it ) { erase( *it ); } void erase( const const_iterator& it ) { erase( *it ); } size_type count( const const_key_type& key ) { return GetNode( key ) ? 1 : 0; } };

class DatabaseLayer : public DatabaseErrorReporter, public DatabaseStringConverter
{
public:

  DatabaseLayer();


  virtual ~DatabaseLayer();


  virtual bool Open(const wxString& strDatabase) = 0;


  virtual bool Close() = 0;


  virtual bool IsOpen() = 0;



  virtual void BeginTransaction() = 0;

  virtual void Commit() = 0;

  virtual void RollBack() = 0;



  virtual int RunQuery(const wxString& strQuery);

  virtual int RunQuery(const wxString& strQuery, bool bParseQueries) = 0;

  virtual DatabaseResultSet* RunQueryWithResults(const wxString& strQuery) = 0;


  virtual bool CloseResultSet(DatabaseResultSet* pResultSet);



  virtual PreparedStatement* PrepareStatement(const wxString& strQuery) = 0;

  virtual bool CloseStatement(PreparedStatement* pStatement);




  int ExecuteUpdate(const wxString& strQuery) { return RunQuery(strQuery); }

  DatabaseResultSet* ExecuteQuery(const wxString& strQuery) { return RunQueryWithResults(strQuery); }



  virtual bool TableExists(const wxString& table) = 0;

  virtual bool ViewExists(const wxString& view) = 0;

  virtual wxArrayString GetTables() = 0;

  virtual wxArrayString GetViews() = 0;

  virtual wxArrayString GetColumns(const wxString& table) = 0;
# 98 "controls/include/wx/dblayer/DatabaseLayer.h"
  virtual int GetSingleResultInt(const wxString& strSQL, int nField, bool bRequireUniqueResult = true);
  virtual int GetSingleResultInt(const wxString& strSQL, const wxString& strField, bool bRequireUniqueResult = true);




  virtual wxString GetSingleResultString(const wxString& strSQL, int nField, bool bRequireUniqueResult = true);
  virtual wxString GetSingleResultString(const wxString& strSQL, const wxString& strField, bool bRequireUniqueResult = true);




  virtual long GetSingleResultLong(const wxString& strSQL, int nField, bool bRequireUniqueResult = true);
  virtual long GetSingleResultLong(const wxString& strSQL, const wxString& strField, bool bRequireUniqueResult = true);




  virtual bool GetSingleResultBool(const wxString& strSQL, int nField, bool bRequireUniqueResult = true);
  virtual bool GetSingleResultBool(const wxString& strSQL, const wxString& strField, bool bRequireUniqueResult = true);




  virtual wxDateTime GetSingleResultDate(const wxString& strSQL, int nField, bool bRequireUniqueResult = true);
  virtual wxDateTime GetSingleResultDate(const wxString& strSQL, const wxString& strField, bool bRequireUniqueResult = true);




  virtual void* GetSingleResultBlob(const wxString& strSQL, int nField, wxMemoryBuffer& Buffer, bool bRequireUniqueResult = true);
  virtual void* GetSingleResultBlob(const wxString& strSQL, const wxString& strField, wxMemoryBuffer& Buffer, bool bRequireUniqueResult = true);




  virtual double GetSingleResultDouble(const wxString& strSQL, int nField, bool bRequireUniqueResult = true);
  virtual double GetSingleResultDouble(const wxString& strSQL, const wxString& strField, bool bRequireUniqueResult = true);


  virtual wxArrayInt GetResultsArrayInt(const wxString& strSQL, int nField);
  virtual wxArrayInt GetResultsArrayInt(const wxString& strSQL, const wxString& Field);

  virtual wxArrayString GetResultsArrayString(const wxString& strSQL, int nField);
  virtual wxArrayString GetResultsArrayString(const wxString& strSQL, const wxString& Field);

  virtual wxArrayLong GetResultsArrayLong(const wxString& strSQL, int nField);
  virtual wxArrayLong GetResultsArrayLong(const wxString& strSQL, const wxString& Field);

  virtual wxArrayDouble GetResultsArrayDouble(const wxString& strSQL, int nField);
  virtual wxArrayDouble GetResultsArrayDouble(const wxString& strSQL, const wxString& Field);



  void CloseResultSets();

  void CloseStatements();

protected:

  void LogResultSetForCleanup(DatabaseResultSet* pResultSet) { m_ResultSets.insert(pResultSet); }

  void LogStatementForCleanup(PreparedStatement* pStatement) { m_Statements.insert(pStatement); }

private:
  int GetSingleResultInt(const wxString& strSQL, const wxVariant* field, bool bRequireUniqueResult = true);
  wxString GetSingleResultString(const wxString& strSQL, const wxVariant* field, bool bRequireUniqueResult = true);
  long GetSingleResultLong(const wxString& strSQL, const wxVariant* field, bool bRequireUniqueResult = true);
  bool GetSingleResultBool(const wxString& strSQL, const wxVariant* field, bool bRequireUniqueResult = true);
  wxDateTime GetSingleResultDate(const wxString& strSQL, const wxVariant* field, bool bRequireUniqueResult = true);
  void* GetSingleResultBlob(const wxString& strSQL, const wxVariant* field, wxMemoryBuffer& Buffer, bool bRequireUniqueResult = true);
  double GetSingleResultDouble(const wxString& strSQL, const wxVariant* field, bool bRequireUniqueResult = true);
  wxArrayInt GetResultsArrayInt(const wxString& strSQL, const wxVariant* field);
  wxArrayString GetResultsArrayString(const wxString& strSQL, const wxVariant* field);
  wxArrayLong GetResultsArrayLong(const wxString& strSQL, const wxVariant* field);

  wxArrayDouble GetResultsArrayDouble(const wxString& strSQL, const wxVariant* field);


  DatabaseResultSetHashSet m_ResultSets;
  DatabaseStatementHashSet m_Statements;
};
# 5 "/home/jankup/SourceCpp/DatabaseExplorer/src/IDbAdapter.h" 2




class ColumnCol;
class DatabaseCol;
class TableCol;


class IDbAdapter {

public:
 virtual DatabaseLayer* GetDatabaseLayer() = 0;
 virtual bool IsConnected() = 0;

 virtual ColumnCol* GetColumns(const wxString& tableName) = 0;
 virtual TableCol* GetTables(const wxString& dbName) = 0;
 virtual DatabaseCol* GetDatabases() = 0;

 virtual void CloseConnection() = 0;

};
# 6 "/home/jankup/SourceCpp/DatabaseExplorer/src/column.h" 2




class Column {
protected:
 wxString m_name;
 wxString m_parentName;
 wxString m_type;
 bool m_notNull;
 bool m_primaryKey;

 bool m_isSaved;

public:



 Column(wxString& name,
   wxString& parentName,
   wxString& type,
   bool notNull,
   bool primaryKey);
 ~Column();



 wxString getName() { return this->m_name; }

 wxString getParentName() { return this->m_parentName; }

 wxString getType() { return this->m_type; }

 bool NotNull() { return this->m_notNull; }

 bool PrimaryKey() { return this->m_primaryKey; }

 bool IsSaved() { return this->m_isSaved; }


 void Edit(wxString& name,
   wxString& parentName,
   wxString& type,
   bool notNull,
   bool primaryKey);

};
# 2 "/home/jankup/SourceCpp/DatabaseExplorer/src/column.cpp" 2
Column::~Column()
{
}



Column::Column(wxString& name,
   wxString& parentName,
   wxString& type,
   bool notNull,
   bool primaryKey)
{
  this->m_name = name;
  this->m_parentName = parentName;
  this->m_type = type;
  this->m_notNull = notNull;
  this->m_primaryKey = primaryKey,
  this->m_isSaved = true;
  }

void Column::Edit(wxString& name,
   wxString& parentName,
   wxString& type,
   bool notNull,
   bool primaryKey)
{
  this->m_name = name;
  this->m_parentName = parentName;
  this->m_type = type;
  this->m_notNull = notNull;
  this->m_primaryKey = primaryKey;
  this->m_isSaved = false;
}
